// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq, Clone, Default)]
pub struct NetworkEnvelope {
    // message fields
    pub message_version: i32,
    // message oneof groups
    pub message: ::std::option::Option<NetworkEnvelope_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkEnvelope {
    fn default() -> &'a NetworkEnvelope {
        <NetworkEnvelope as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum NetworkEnvelope_oneof_message {
    preliminary_get_data_request(PreliminaryGetDataRequest),
    get_data_response(GetDataResponse),
    get_updated_data_request(GetUpdatedDataRequest),
    get_peers_request(GetPeersRequest),
    get_peers_response(GetPeersResponse),
    ping(Ping),
    pong(Pong),
    offer_availability_request(OfferAvailabilityRequest),
    offer_availability_response(OfferAvailabilityResponse),
    refresh_offer_message(RefreshOfferMessage),
    add_data_message(AddDataMessage),
    remove_data_message(RemoveDataMessage),
    remove_mailbox_data_message(RemoveMailboxDataMessage),
    close_connection_message(CloseConnectionMessage),
    prefixed_sealed_and_signed_message(PrefixedSealedAndSignedMessage),
    inputs_for_deposit_tx_request(InputsForDepositTxRequest),
    inputs_for_deposit_tx_response(InputsForDepositTxResponse),
    deposit_tx_message(DepositTxMessage),
    counter_currency_transfer_started_message(CounterCurrencyTransferStartedMessage),
    payout_tx_published_message(PayoutTxPublishedMessage),
    open_new_dispute_message(OpenNewDisputeMessage),
    peer_opened_dispute_message(PeerOpenedDisputeMessage),
    chat_message(ChatMessage),
    dispute_result_message(DisputeResultMessage),
    peer_published_dispute_payout_tx_message(PeerPublishedDisputePayoutTxMessage),
    private_notification_message(PrivateNotificationMessage),
    get_blocks_request(GetBlocksRequest),
    get_blocks_response(GetBlocksResponse),
    new_block_broadcast_message(NewBlockBroadcastMessage),
    add_persistable_network_payload_message(AddPersistableNetworkPayloadMessage),
    ack_message(AckMessage),
    republish_governance_data_request(RepublishGovernanceDataRequest),
    new_dao_state_hash_message(NewDaoStateHashMessage),
    get_dao_state_hashes_request(GetDaoStateHashesRequest),
    get_dao_state_hashes_response(GetDaoStateHashesResponse),
    new_proposal_state_hash_message(NewProposalStateHashMessage),
    get_proposal_state_hashes_request(GetProposalStateHashesRequest),
    get_proposal_state_hashes_response(GetProposalStateHashesResponse),
    new_blind_vote_state_hash_message(NewBlindVoteStateHashMessage),
    get_blind_vote_state_hashes_request(GetBlindVoteStateHashesRequest),
    get_blind_vote_state_hashes_response(GetBlindVoteStateHashesResponse),
    bundle_of_envelopes(BundleOfEnvelopes),
    mediated_payout_tx_signature_message(MediatedPayoutTxSignatureMessage),
    mediated_payout_tx_published_message(MediatedPayoutTxPublishedMessage),
    delayed_payout_tx_signature_request(DelayedPayoutTxSignatureRequest),
    delayed_payout_tx_signature_response(DelayedPayoutTxSignatureResponse),
    deposit_tx_and_delayed_payout_tx_message(DepositTxAndDelayedPayoutTxMessage),
    peer_published_delayed_payout_tx_message(PeerPublishedDelayedPayoutTxMessage),
}

impl NetworkEnvelope {
    pub fn new() -> NetworkEnvelope {
        ::std::default::Default::default()
    }

    // int32 message_version = 1;

    pub fn get_message_version(&self) -> i32 {
        self.message_version
    }
    pub fn clear_message_version(&mut self) {
        self.message_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_message_version(&mut self, v: i32) {
        self.message_version = v;
    }

    // .io.bisq.protobuffer.PreliminaryGetDataRequest preliminary_get_data_request = 2;

    pub fn get_preliminary_get_data_request(&self) -> &PreliminaryGetDataRequest {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::preliminary_get_data_request(ref v),
            ) => v,
            _ => PreliminaryGetDataRequest::default_instance(),
        }
    }
    pub fn clear_preliminary_get_data_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_preliminary_get_data_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::preliminary_get_data_request(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_preliminary_get_data_request(&mut self, v: PreliminaryGetDataRequest) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::preliminary_get_data_request(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_preliminary_get_data_request(&mut self) -> &mut PreliminaryGetDataRequest {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::preliminary_get_data_request(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::preliminary_get_data_request(
                    PreliminaryGetDataRequest::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::preliminary_get_data_request(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_preliminary_get_data_request(&mut self) -> PreliminaryGetDataRequest {
        if self.has_preliminary_get_data_request() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::preliminary_get_data_request(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            PreliminaryGetDataRequest::new()
        }
    }

    // .io.bisq.protobuffer.GetDataResponse get_data_response = 3;

    pub fn get_get_data_response(&self) -> &GetDataResponse {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_data_response(
                ref v,
            )) => v,
            _ => GetDataResponse::default_instance(),
        }
    }
    pub fn clear_get_data_response(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_data_response(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_data_response(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_data_response(&mut self, v: GetDataResponse) {
        self.message =
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_data_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_data_response(&mut self) -> &mut GetDataResponse {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_data_response(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_data_response(GetDataResponse::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_data_response(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_data_response(&mut self) -> GetDataResponse {
        if self.has_get_data_response() {
            match self.message.take() {
                ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_data_response(
                    v,
                )) => v,
                _ => panic!(),
            }
        } else {
            GetDataResponse::new()
        }
    }

    // .io.bisq.protobuffer.GetUpdatedDataRequest get_updated_data_request = 4;

    pub fn get_get_updated_data_request(&self) -> &GetUpdatedDataRequest {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_updated_data_request(ref v),
            ) => v,
            _ => GetUpdatedDataRequest::default_instance(),
        }
    }
    pub fn clear_get_updated_data_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_updated_data_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_updated_data_request(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_updated_data_request(&mut self, v: GetUpdatedDataRequest) {
        self.message =
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_updated_data_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_updated_data_request(&mut self) -> &mut GetUpdatedDataRequest {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::get_updated_data_request(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_updated_data_request(
                    GetUpdatedDataRequest::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_updated_data_request(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_updated_data_request(&mut self) -> GetUpdatedDataRequest {
        if self.has_get_updated_data_request() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::get_updated_data_request(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            GetUpdatedDataRequest::new()
        }
    }

    // .io.bisq.protobuffer.GetPeersRequest get_peers_request = 5;

    pub fn get_get_peers_request(&self) -> &GetPeersRequest {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_peers_request(
                ref v,
            )) => v,
            _ => GetPeersRequest::default_instance(),
        }
    }
    pub fn clear_get_peers_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_peers_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_peers_request(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_peers_request(&mut self, v: GetPeersRequest) {
        self.message =
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_peers_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_peers_request(&mut self) -> &mut GetPeersRequest {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_peers_request(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_peers_request(GetPeersRequest::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_peers_request(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_peers_request(&mut self) -> GetPeersRequest {
        if self.has_get_peers_request() {
            match self.message.take() {
                ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_peers_request(
                    v,
                )) => v,
                _ => panic!(),
            }
        } else {
            GetPeersRequest::new()
        }
    }

    // .io.bisq.protobuffer.GetPeersResponse get_peers_response = 6;

    pub fn get_get_peers_response(&self) -> &GetPeersResponse {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_peers_response(
                ref v,
            )) => v,
            _ => GetPeersResponse::default_instance(),
        }
    }
    pub fn clear_get_peers_response(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_peers_response(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_peers_response(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_peers_response(&mut self, v: GetPeersResponse) {
        self.message =
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_peers_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_peers_response(&mut self) -> &mut GetPeersResponse {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_peers_response(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_peers_response(GetPeersResponse::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_peers_response(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_peers_response(&mut self) -> GetPeersResponse {
        if self.has_get_peers_response() {
            match self.message.take() {
                ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_peers_response(
                    v,
                )) => v,
                _ => panic!(),
            }
        } else {
            GetPeersResponse::new()
        }
    }

    // .io.bisq.protobuffer.Ping ping = 7;

    pub fn get_ping(&self) -> &Ping {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::ping(ref v)) => v,
            _ => Ping::default_instance(),
        }
    }
    pub fn clear_ping(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::ping(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: Ping) {
        self.message = ::std::option::Option::Some(NetworkEnvelope_oneof_message::ping(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ping(&mut self) -> &mut Ping {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::ping(_)) = self.message {
        } else {
            self.message =
                ::std::option::Option::Some(NetworkEnvelope_oneof_message::ping(Ping::new()));
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::ping(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ping(&mut self) -> Ping {
        if self.has_ping() {
            match self.message.take() {
                ::std::option::Option::Some(NetworkEnvelope_oneof_message::ping(v)) => v,
                _ => panic!(),
            }
        } else {
            Ping::new()
        }
    }

    // .io.bisq.protobuffer.Pong pong = 8;

    pub fn get_pong(&self) -> &Pong {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::pong(ref v)) => v,
            _ => Pong::default_instance(),
        }
    }
    pub fn clear_pong(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_pong(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::pong(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pong(&mut self, v: Pong) {
        self.message = ::std::option::Option::Some(NetworkEnvelope_oneof_message::pong(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pong(&mut self) -> &mut Pong {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::pong(_)) = self.message {
        } else {
            self.message =
                ::std::option::Option::Some(NetworkEnvelope_oneof_message::pong(Pong::new()));
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::pong(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pong(&mut self) -> Pong {
        if self.has_pong() {
            match self.message.take() {
                ::std::option::Option::Some(NetworkEnvelope_oneof_message::pong(v)) => v,
                _ => panic!(),
            }
        } else {
            Pong::new()
        }
    }

    // .io.bisq.protobuffer.OfferAvailabilityRequest offer_availability_request = 9;

    pub fn get_offer_availability_request(&self) -> &OfferAvailabilityRequest {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::offer_availability_request(ref v),
            ) => v,
            _ => OfferAvailabilityRequest::default_instance(),
        }
    }
    pub fn clear_offer_availability_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_offer_availability_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::offer_availability_request(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_offer_availability_request(&mut self, v: OfferAvailabilityRequest) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::offer_availability_request(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_offer_availability_request(&mut self) -> &mut OfferAvailabilityRequest {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::offer_availability_request(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::offer_availability_request(
                    OfferAvailabilityRequest::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::offer_availability_request(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_offer_availability_request(&mut self) -> OfferAvailabilityRequest {
        if self.has_offer_availability_request() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::offer_availability_request(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            OfferAvailabilityRequest::new()
        }
    }

    // .io.bisq.protobuffer.OfferAvailabilityResponse offer_availability_response = 10;

    pub fn get_offer_availability_response(&self) -> &OfferAvailabilityResponse {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::offer_availability_response(ref v),
            ) => v,
            _ => OfferAvailabilityResponse::default_instance(),
        }
    }
    pub fn clear_offer_availability_response(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_offer_availability_response(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::offer_availability_response(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_offer_availability_response(&mut self, v: OfferAvailabilityResponse) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::offer_availability_response(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_offer_availability_response(&mut self) -> &mut OfferAvailabilityResponse {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::offer_availability_response(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::offer_availability_response(
                    OfferAvailabilityResponse::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::offer_availability_response(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_offer_availability_response(&mut self) -> OfferAvailabilityResponse {
        if self.has_offer_availability_response() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::offer_availability_response(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            OfferAvailabilityResponse::new()
        }
    }

    // .io.bisq.protobuffer.RefreshOfferMessage refresh_offer_message = 11;

    pub fn get_refresh_offer_message(&self) -> &RefreshOfferMessage {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::refresh_offer_message(
                ref v,
            )) => v,
            _ => RefreshOfferMessage::default_instance(),
        }
    }
    pub fn clear_refresh_offer_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_refresh_offer_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::refresh_offer_message(
                ..,
            )) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_refresh_offer_message(&mut self, v: RefreshOfferMessage) {
        self.message =
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::refresh_offer_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_refresh_offer_message(&mut self) -> &mut RefreshOfferMessage {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::refresh_offer_message(
            _,
        )) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::refresh_offer_message(RefreshOfferMessage::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::refresh_offer_message(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_refresh_offer_message(&mut self) -> RefreshOfferMessage {
        if self.has_refresh_offer_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::refresh_offer_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            RefreshOfferMessage::new()
        }
    }

    // .io.bisq.protobuffer.AddDataMessage add_data_message = 12;

    pub fn get_add_data_message(&self) -> &AddDataMessage {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::add_data_message(ref v)) => {
                v
            }
            _ => AddDataMessage::default_instance(),
        }
    }
    pub fn clear_add_data_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_add_data_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::add_data_message(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_add_data_message(&mut self, v: AddDataMessage) {
        self.message =
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::add_data_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_add_data_message(&mut self) -> &mut AddDataMessage {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::add_data_message(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::add_data_message(AddDataMessage::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::add_data_message(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_add_data_message(&mut self) -> AddDataMessage {
        if self.has_add_data_message() {
            match self.message.take() {
                ::std::option::Option::Some(NetworkEnvelope_oneof_message::add_data_message(v)) => {
                    v
                }
                _ => panic!(),
            }
        } else {
            AddDataMessage::new()
        }
    }

    // .io.bisq.protobuffer.RemoveDataMessage remove_data_message = 13;

    pub fn get_remove_data_message(&self) -> &RemoveDataMessage {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::remove_data_message(
                ref v,
            )) => v,
            _ => RemoveDataMessage::default_instance(),
        }
    }
    pub fn clear_remove_data_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_remove_data_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::remove_data_message(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_data_message(&mut self, v: RemoveDataMessage) {
        self.message =
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::remove_data_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_data_message(&mut self) -> &mut RemoveDataMessage {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::remove_data_message(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::remove_data_message(RemoveDataMessage::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::remove_data_message(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_data_message(&mut self) -> RemoveDataMessage {
        if self.has_remove_data_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::remove_data_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            RemoveDataMessage::new()
        }
    }

    // .io.bisq.protobuffer.RemoveMailboxDataMessage remove_mailbox_data_message = 14;

    pub fn get_remove_mailbox_data_message(&self) -> &RemoveMailboxDataMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::remove_mailbox_data_message(ref v),
            ) => v,
            _ => RemoveMailboxDataMessage::default_instance(),
        }
    }
    pub fn clear_remove_mailbox_data_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_remove_mailbox_data_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::remove_mailbox_data_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_mailbox_data_message(&mut self, v: RemoveMailboxDataMessage) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::remove_mailbox_data_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_remove_mailbox_data_message(&mut self) -> &mut RemoveMailboxDataMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::remove_mailbox_data_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::remove_mailbox_data_message(
                    RemoveMailboxDataMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::remove_mailbox_data_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_mailbox_data_message(&mut self) -> RemoveMailboxDataMessage {
        if self.has_remove_mailbox_data_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::remove_mailbox_data_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            RemoveMailboxDataMessage::new()
        }
    }

    // .io.bisq.protobuffer.CloseConnectionMessage close_connection_message = 15;

    pub fn get_close_connection_message(&self) -> &CloseConnectionMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::close_connection_message(ref v),
            ) => v,
            _ => CloseConnectionMessage::default_instance(),
        }
    }
    pub fn clear_close_connection_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_close_connection_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::close_connection_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_close_connection_message(&mut self, v: CloseConnectionMessage) {
        self.message =
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::close_connection_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_close_connection_message(&mut self) -> &mut CloseConnectionMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::close_connection_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::close_connection_message(
                    CloseConnectionMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::close_connection_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_close_connection_message(&mut self) -> CloseConnectionMessage {
        if self.has_close_connection_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::close_connection_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            CloseConnectionMessage::new()
        }
    }

    // .io.bisq.protobuffer.PrefixedSealedAndSignedMessage prefixed_sealed_and_signed_message = 16;

    pub fn get_prefixed_sealed_and_signed_message(&self) -> &PrefixedSealedAndSignedMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::prefixed_sealed_and_signed_message(ref v),
            ) => v,
            _ => PrefixedSealedAndSignedMessage::default_instance(),
        }
    }
    pub fn clear_prefixed_sealed_and_signed_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_prefixed_sealed_and_signed_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::prefixed_sealed_and_signed_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prefixed_sealed_and_signed_message(&mut self, v: PrefixedSealedAndSignedMessage) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::prefixed_sealed_and_signed_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_prefixed_sealed_and_signed_message(
        &mut self,
    ) -> &mut PrefixedSealedAndSignedMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::prefixed_sealed_and_signed_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::prefixed_sealed_and_signed_message(
                    PrefixedSealedAndSignedMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::prefixed_sealed_and_signed_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prefixed_sealed_and_signed_message(&mut self) -> PrefixedSealedAndSignedMessage {
        if self.has_prefixed_sealed_and_signed_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::prefixed_sealed_and_signed_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            PrefixedSealedAndSignedMessage::new()
        }
    }

    // .io.bisq.protobuffer.InputsForDepositTxRequest inputs_for_deposit_tx_request = 17;

    pub fn get_inputs_for_deposit_tx_request(&self) -> &InputsForDepositTxRequest {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::inputs_for_deposit_tx_request(ref v),
            ) => v,
            _ => InputsForDepositTxRequest::default_instance(),
        }
    }
    pub fn clear_inputs_for_deposit_tx_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_inputs_for_deposit_tx_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::inputs_for_deposit_tx_request(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_inputs_for_deposit_tx_request(&mut self, v: InputsForDepositTxRequest) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::inputs_for_deposit_tx_request(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_inputs_for_deposit_tx_request(&mut self) -> &mut InputsForDepositTxRequest {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::inputs_for_deposit_tx_request(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::inputs_for_deposit_tx_request(
                    InputsForDepositTxRequest::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::inputs_for_deposit_tx_request(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_inputs_for_deposit_tx_request(&mut self) -> InputsForDepositTxRequest {
        if self.has_inputs_for_deposit_tx_request() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::inputs_for_deposit_tx_request(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            InputsForDepositTxRequest::new()
        }
    }

    // .io.bisq.protobuffer.InputsForDepositTxResponse inputs_for_deposit_tx_response = 18;

    pub fn get_inputs_for_deposit_tx_response(&self) -> &InputsForDepositTxResponse {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::inputs_for_deposit_tx_response(ref v),
            ) => v,
            _ => InputsForDepositTxResponse::default_instance(),
        }
    }
    pub fn clear_inputs_for_deposit_tx_response(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_inputs_for_deposit_tx_response(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::inputs_for_deposit_tx_response(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_inputs_for_deposit_tx_response(&mut self, v: InputsForDepositTxResponse) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::inputs_for_deposit_tx_response(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_inputs_for_deposit_tx_response(&mut self) -> &mut InputsForDepositTxResponse {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::inputs_for_deposit_tx_response(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::inputs_for_deposit_tx_response(
                    InputsForDepositTxResponse::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::inputs_for_deposit_tx_response(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_inputs_for_deposit_tx_response(&mut self) -> InputsForDepositTxResponse {
        if self.has_inputs_for_deposit_tx_response() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::inputs_for_deposit_tx_response(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            InputsForDepositTxResponse::new()
        }
    }

    // .io.bisq.protobuffer.DepositTxMessage deposit_tx_message = 19;

    pub fn get_deposit_tx_message(&self) -> &DepositTxMessage {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::deposit_tx_message(
                ref v,
            )) => v,
            _ => DepositTxMessage::default_instance(),
        }
    }
    pub fn clear_deposit_tx_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_deposit_tx_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::deposit_tx_message(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_deposit_tx_message(&mut self, v: DepositTxMessage) {
        self.message =
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::deposit_tx_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_deposit_tx_message(&mut self) -> &mut DepositTxMessage {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::deposit_tx_message(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::deposit_tx_message(DepositTxMessage::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::deposit_tx_message(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_deposit_tx_message(&mut self) -> DepositTxMessage {
        if self.has_deposit_tx_message() {
            match self.message.take() {
                ::std::option::Option::Some(NetworkEnvelope_oneof_message::deposit_tx_message(
                    v,
                )) => v,
                _ => panic!(),
            }
        } else {
            DepositTxMessage::new()
        }
    }

    // .io.bisq.protobuffer.CounterCurrencyTransferStartedMessage counter_currency_transfer_started_message = 20;

    pub fn get_counter_currency_transfer_started_message(
        &self,
    ) -> &CounterCurrencyTransferStartedMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::counter_currency_transfer_started_message(ref v),
            ) => v,
            _ => CounterCurrencyTransferStartedMessage::default_instance(),
        }
    }
    pub fn clear_counter_currency_transfer_started_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_counter_currency_transfer_started_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::counter_currency_transfer_started_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_counter_currency_transfer_started_message(
        &mut self,
        v: CounterCurrencyTransferStartedMessage,
    ) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::counter_currency_transfer_started_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_counter_currency_transfer_started_message(
        &mut self,
    ) -> &mut CounterCurrencyTransferStartedMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::counter_currency_transfer_started_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::counter_currency_transfer_started_message(
                    CounterCurrencyTransferStartedMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::counter_currency_transfer_started_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_counter_currency_transfer_started_message(
        &mut self,
    ) -> CounterCurrencyTransferStartedMessage {
        if self.has_counter_currency_transfer_started_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::counter_currency_transfer_started_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            CounterCurrencyTransferStartedMessage::new()
        }
    }

    // .io.bisq.protobuffer.PayoutTxPublishedMessage payout_tx_published_message = 21;

    pub fn get_payout_tx_published_message(&self) -> &PayoutTxPublishedMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::payout_tx_published_message(ref v),
            ) => v,
            _ => PayoutTxPublishedMessage::default_instance(),
        }
    }
    pub fn clear_payout_tx_published_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_payout_tx_published_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::payout_tx_published_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_payout_tx_published_message(&mut self, v: PayoutTxPublishedMessage) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::payout_tx_published_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_payout_tx_published_message(&mut self) -> &mut PayoutTxPublishedMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::payout_tx_published_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::payout_tx_published_message(
                    PayoutTxPublishedMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::payout_tx_published_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_payout_tx_published_message(&mut self) -> PayoutTxPublishedMessage {
        if self.has_payout_tx_published_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::payout_tx_published_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            PayoutTxPublishedMessage::new()
        }
    }

    // .io.bisq.protobuffer.OpenNewDisputeMessage open_new_dispute_message = 22;

    pub fn get_open_new_dispute_message(&self) -> &OpenNewDisputeMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::open_new_dispute_message(ref v),
            ) => v,
            _ => OpenNewDisputeMessage::default_instance(),
        }
    }
    pub fn clear_open_new_dispute_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_open_new_dispute_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::open_new_dispute_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_open_new_dispute_message(&mut self, v: OpenNewDisputeMessage) {
        self.message =
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::open_new_dispute_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_open_new_dispute_message(&mut self) -> &mut OpenNewDisputeMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::open_new_dispute_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::open_new_dispute_message(
                    OpenNewDisputeMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::open_new_dispute_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_open_new_dispute_message(&mut self) -> OpenNewDisputeMessage {
        if self.has_open_new_dispute_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::open_new_dispute_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            OpenNewDisputeMessage::new()
        }
    }

    // .io.bisq.protobuffer.PeerOpenedDisputeMessage peer_opened_dispute_message = 23;

    pub fn get_peer_opened_dispute_message(&self) -> &PeerOpenedDisputeMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::peer_opened_dispute_message(ref v),
            ) => v,
            _ => PeerOpenedDisputeMessage::default_instance(),
        }
    }
    pub fn clear_peer_opened_dispute_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_peer_opened_dispute_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::peer_opened_dispute_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_peer_opened_dispute_message(&mut self, v: PeerOpenedDisputeMessage) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::peer_opened_dispute_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_peer_opened_dispute_message(&mut self) -> &mut PeerOpenedDisputeMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::peer_opened_dispute_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::peer_opened_dispute_message(
                    PeerOpenedDisputeMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::peer_opened_dispute_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_peer_opened_dispute_message(&mut self) -> PeerOpenedDisputeMessage {
        if self.has_peer_opened_dispute_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::peer_opened_dispute_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            PeerOpenedDisputeMessage::new()
        }
    }

    // .io.bisq.protobuffer.ChatMessage chat_message = 24;

    pub fn get_chat_message(&self) -> &ChatMessage {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::chat_message(ref v)) => v,
            _ => ChatMessage::default_instance(),
        }
    }
    pub fn clear_chat_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_chat_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::chat_message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chat_message(&mut self, v: ChatMessage) {
        self.message = ::std::option::Option::Some(NetworkEnvelope_oneof_message::chat_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chat_message(&mut self) -> &mut ChatMessage {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::chat_message(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::chat_message(ChatMessage::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::chat_message(ref mut v)) => {
                v
            }
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chat_message(&mut self) -> ChatMessage {
        if self.has_chat_message() {
            match self.message.take() {
                ::std::option::Option::Some(NetworkEnvelope_oneof_message::chat_message(v)) => v,
                _ => panic!(),
            }
        } else {
            ChatMessage::new()
        }
    }

    // .io.bisq.protobuffer.DisputeResultMessage dispute_result_message = 25;

    pub fn get_dispute_result_message(&self) -> &DisputeResultMessage {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::dispute_result_message(
                ref v,
            )) => v,
            _ => DisputeResultMessage::default_instance(),
        }
    }
    pub fn clear_dispute_result_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_dispute_result_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::dispute_result_message(
                ..,
            )) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dispute_result_message(&mut self, v: DisputeResultMessage) {
        self.message =
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::dispute_result_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dispute_result_message(&mut self) -> &mut DisputeResultMessage {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::dispute_result_message(
            _,
        )) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::dispute_result_message(DisputeResultMessage::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::dispute_result_message(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dispute_result_message(&mut self) -> DisputeResultMessage {
        if self.has_dispute_result_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::dispute_result_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            DisputeResultMessage::new()
        }
    }

    // .io.bisq.protobuffer.PeerPublishedDisputePayoutTxMessage peer_published_dispute_payout_tx_message = 26;

    pub fn get_peer_published_dispute_payout_tx_message(
        &self,
    ) -> &PeerPublishedDisputePayoutTxMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::peer_published_dispute_payout_tx_message(ref v),
            ) => v,
            _ => PeerPublishedDisputePayoutTxMessage::default_instance(),
        }
    }
    pub fn clear_peer_published_dispute_payout_tx_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_peer_published_dispute_payout_tx_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::peer_published_dispute_payout_tx_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_peer_published_dispute_payout_tx_message(
        &mut self,
        v: PeerPublishedDisputePayoutTxMessage,
    ) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::peer_published_dispute_payout_tx_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_peer_published_dispute_payout_tx_message(
        &mut self,
    ) -> &mut PeerPublishedDisputePayoutTxMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::peer_published_dispute_payout_tx_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::peer_published_dispute_payout_tx_message(
                    PeerPublishedDisputePayoutTxMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::peer_published_dispute_payout_tx_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_peer_published_dispute_payout_tx_message(
        &mut self,
    ) -> PeerPublishedDisputePayoutTxMessage {
        if self.has_peer_published_dispute_payout_tx_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::peer_published_dispute_payout_tx_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            PeerPublishedDisputePayoutTxMessage::new()
        }
    }

    // .io.bisq.protobuffer.PrivateNotificationMessage private_notification_message = 27;

    pub fn get_private_notification_message(&self) -> &PrivateNotificationMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::private_notification_message(ref v),
            ) => v,
            _ => PrivateNotificationMessage::default_instance(),
        }
    }
    pub fn clear_private_notification_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_private_notification_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::private_notification_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_private_notification_message(&mut self, v: PrivateNotificationMessage) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::private_notification_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_private_notification_message(&mut self) -> &mut PrivateNotificationMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::private_notification_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::private_notification_message(
                    PrivateNotificationMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::private_notification_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_private_notification_message(&mut self) -> PrivateNotificationMessage {
        if self.has_private_notification_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::private_notification_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            PrivateNotificationMessage::new()
        }
    }

    // .io.bisq.protobuffer.GetBlocksRequest get_blocks_request = 28;

    pub fn get_get_blocks_request(&self) -> &GetBlocksRequest {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_blocks_request(
                ref v,
            )) => v,
            _ => GetBlocksRequest::default_instance(),
        }
    }
    pub fn clear_get_blocks_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_blocks_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_blocks_request(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_blocks_request(&mut self, v: GetBlocksRequest) {
        self.message =
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_blocks_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_blocks_request(&mut self) -> &mut GetBlocksRequest {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_blocks_request(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_blocks_request(GetBlocksRequest::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_blocks_request(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_blocks_request(&mut self) -> GetBlocksRequest {
        if self.has_get_blocks_request() {
            match self.message.take() {
                ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_blocks_request(
                    v,
                )) => v,
                _ => panic!(),
            }
        } else {
            GetBlocksRequest::new()
        }
    }

    // .io.bisq.protobuffer.GetBlocksResponse get_blocks_response = 29;

    pub fn get_get_blocks_response(&self) -> &GetBlocksResponse {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_blocks_response(
                ref v,
            )) => v,
            _ => GetBlocksResponse::default_instance(),
        }
    }
    pub fn clear_get_blocks_response(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_blocks_response(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_blocks_response(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_blocks_response(&mut self, v: GetBlocksResponse) {
        self.message =
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_blocks_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_blocks_response(&mut self) -> &mut GetBlocksResponse {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_blocks_response(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_blocks_response(GetBlocksResponse::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::get_blocks_response(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_blocks_response(&mut self) -> GetBlocksResponse {
        if self.has_get_blocks_response() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::get_blocks_response(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            GetBlocksResponse::new()
        }
    }

    // .io.bisq.protobuffer.NewBlockBroadcastMessage new_block_broadcast_message = 30;

    pub fn get_new_block_broadcast_message(&self) -> &NewBlockBroadcastMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_block_broadcast_message(ref v),
            ) => v,
            _ => NewBlockBroadcastMessage::default_instance(),
        }
    }
    pub fn clear_new_block_broadcast_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_new_block_broadcast_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_block_broadcast_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_new_block_broadcast_message(&mut self, v: NewBlockBroadcastMessage) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::new_block_broadcast_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_new_block_broadcast_message(&mut self) -> &mut NewBlockBroadcastMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::new_block_broadcast_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_block_broadcast_message(
                    NewBlockBroadcastMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_block_broadcast_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_new_block_broadcast_message(&mut self) -> NewBlockBroadcastMessage {
        if self.has_new_block_broadcast_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::new_block_broadcast_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            NewBlockBroadcastMessage::new()
        }
    }

    // .io.bisq.protobuffer.AddPersistableNetworkPayloadMessage add_persistable_network_payload_message = 31;

    pub fn get_add_persistable_network_payload_message(
        &self,
    ) -> &AddPersistableNetworkPayloadMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::add_persistable_network_payload_message(ref v),
            ) => v,
            _ => AddPersistableNetworkPayloadMessage::default_instance(),
        }
    }
    pub fn clear_add_persistable_network_payload_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_add_persistable_network_payload_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::add_persistable_network_payload_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_add_persistable_network_payload_message(
        &mut self,
        v: AddPersistableNetworkPayloadMessage,
    ) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::add_persistable_network_payload_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_add_persistable_network_payload_message(
        &mut self,
    ) -> &mut AddPersistableNetworkPayloadMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::add_persistable_network_payload_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::add_persistable_network_payload_message(
                    AddPersistableNetworkPayloadMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::add_persistable_network_payload_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_add_persistable_network_payload_message(
        &mut self,
    ) -> AddPersistableNetworkPayloadMessage {
        if self.has_add_persistable_network_payload_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::add_persistable_network_payload_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            AddPersistableNetworkPayloadMessage::new()
        }
    }

    // .io.bisq.protobuffer.AckMessage ack_message = 32;

    pub fn get_ack_message(&self) -> &AckMessage {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::ack_message(ref v)) => v,
            _ => AckMessage::default_instance(),
        }
    }
    pub fn clear_ack_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_ack_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::ack_message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ack_message(&mut self, v: AckMessage) {
        self.message = ::std::option::Option::Some(NetworkEnvelope_oneof_message::ack_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ack_message(&mut self) -> &mut AckMessage {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::ack_message(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(NetworkEnvelope_oneof_message::ack_message(
                AckMessage::new(),
            ));
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::ack_message(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ack_message(&mut self) -> AckMessage {
        if self.has_ack_message() {
            match self.message.take() {
                ::std::option::Option::Some(NetworkEnvelope_oneof_message::ack_message(v)) => v,
                _ => panic!(),
            }
        } else {
            AckMessage::new()
        }
    }

    // .io.bisq.protobuffer.RepublishGovernanceDataRequest republish_governance_data_request = 33;

    pub fn get_republish_governance_data_request(&self) -> &RepublishGovernanceDataRequest {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::republish_governance_data_request(ref v),
            ) => v,
            _ => RepublishGovernanceDataRequest::default_instance(),
        }
    }
    pub fn clear_republish_governance_data_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_republish_governance_data_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::republish_governance_data_request(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_republish_governance_data_request(&mut self, v: RepublishGovernanceDataRequest) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::republish_governance_data_request(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_republish_governance_data_request(&mut self) -> &mut RepublishGovernanceDataRequest {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::republish_governance_data_request(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::republish_governance_data_request(
                    RepublishGovernanceDataRequest::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::republish_governance_data_request(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_republish_governance_data_request(&mut self) -> RepublishGovernanceDataRequest {
        if self.has_republish_governance_data_request() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::republish_governance_data_request(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            RepublishGovernanceDataRequest::new()
        }
    }

    // .io.bisq.protobuffer.NewDaoStateHashMessage new_dao_state_hash_message = 34;

    pub fn get_new_dao_state_hash_message(&self) -> &NewDaoStateHashMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_dao_state_hash_message(ref v),
            ) => v,
            _ => NewDaoStateHashMessage::default_instance(),
        }
    }
    pub fn clear_new_dao_state_hash_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_new_dao_state_hash_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_dao_state_hash_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_new_dao_state_hash_message(&mut self, v: NewDaoStateHashMessage) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::new_dao_state_hash_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_new_dao_state_hash_message(&mut self) -> &mut NewDaoStateHashMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::new_dao_state_hash_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_dao_state_hash_message(
                    NewDaoStateHashMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_dao_state_hash_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_new_dao_state_hash_message(&mut self) -> NewDaoStateHashMessage {
        if self.has_new_dao_state_hash_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::new_dao_state_hash_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            NewDaoStateHashMessage::new()
        }
    }

    // .io.bisq.protobuffer.GetDaoStateHashesRequest get_dao_state_hashes_request = 35;

    pub fn get_get_dao_state_hashes_request(&self) -> &GetDaoStateHashesRequest {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_dao_state_hashes_request(ref v),
            ) => v,
            _ => GetDaoStateHashesRequest::default_instance(),
        }
    }
    pub fn clear_get_dao_state_hashes_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_dao_state_hashes_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_dao_state_hashes_request(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_dao_state_hashes_request(&mut self, v: GetDaoStateHashesRequest) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::get_dao_state_hashes_request(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_get_dao_state_hashes_request(&mut self) -> &mut GetDaoStateHashesRequest {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::get_dao_state_hashes_request(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_dao_state_hashes_request(
                    GetDaoStateHashesRequest::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_dao_state_hashes_request(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_dao_state_hashes_request(&mut self) -> GetDaoStateHashesRequest {
        if self.has_get_dao_state_hashes_request() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::get_dao_state_hashes_request(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            GetDaoStateHashesRequest::new()
        }
    }

    // .io.bisq.protobuffer.GetDaoStateHashesResponse get_dao_state_hashes_response = 36;

    pub fn get_get_dao_state_hashes_response(&self) -> &GetDaoStateHashesResponse {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_dao_state_hashes_response(ref v),
            ) => v,
            _ => GetDaoStateHashesResponse::default_instance(),
        }
    }
    pub fn clear_get_dao_state_hashes_response(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_dao_state_hashes_response(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_dao_state_hashes_response(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_dao_state_hashes_response(&mut self, v: GetDaoStateHashesResponse) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::get_dao_state_hashes_response(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_get_dao_state_hashes_response(&mut self) -> &mut GetDaoStateHashesResponse {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::get_dao_state_hashes_response(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_dao_state_hashes_response(
                    GetDaoStateHashesResponse::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_dao_state_hashes_response(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_dao_state_hashes_response(&mut self) -> GetDaoStateHashesResponse {
        if self.has_get_dao_state_hashes_response() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::get_dao_state_hashes_response(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            GetDaoStateHashesResponse::new()
        }
    }

    // .io.bisq.protobuffer.NewProposalStateHashMessage new_proposal_state_hash_message = 37;

    pub fn get_new_proposal_state_hash_message(&self) -> &NewProposalStateHashMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_proposal_state_hash_message(ref v),
            ) => v,
            _ => NewProposalStateHashMessage::default_instance(),
        }
    }
    pub fn clear_new_proposal_state_hash_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_new_proposal_state_hash_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_proposal_state_hash_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_new_proposal_state_hash_message(&mut self, v: NewProposalStateHashMessage) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::new_proposal_state_hash_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_new_proposal_state_hash_message(&mut self) -> &mut NewProposalStateHashMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::new_proposal_state_hash_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_proposal_state_hash_message(
                    NewProposalStateHashMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_proposal_state_hash_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_new_proposal_state_hash_message(&mut self) -> NewProposalStateHashMessage {
        if self.has_new_proposal_state_hash_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::new_proposal_state_hash_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            NewProposalStateHashMessage::new()
        }
    }

    // .io.bisq.protobuffer.GetProposalStateHashesRequest get_proposal_state_hashes_request = 38;

    pub fn get_get_proposal_state_hashes_request(&self) -> &GetProposalStateHashesRequest {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_proposal_state_hashes_request(ref v),
            ) => v,
            _ => GetProposalStateHashesRequest::default_instance(),
        }
    }
    pub fn clear_get_proposal_state_hashes_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_proposal_state_hashes_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_proposal_state_hashes_request(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_proposal_state_hashes_request(&mut self, v: GetProposalStateHashesRequest) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::get_proposal_state_hashes_request(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_get_proposal_state_hashes_request(&mut self) -> &mut GetProposalStateHashesRequest {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::get_proposal_state_hashes_request(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_proposal_state_hashes_request(
                    GetProposalStateHashesRequest::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_proposal_state_hashes_request(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_proposal_state_hashes_request(&mut self) -> GetProposalStateHashesRequest {
        if self.has_get_proposal_state_hashes_request() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::get_proposal_state_hashes_request(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            GetProposalStateHashesRequest::new()
        }
    }

    // .io.bisq.protobuffer.GetProposalStateHashesResponse get_proposal_state_hashes_response = 39;

    pub fn get_get_proposal_state_hashes_response(&self) -> &GetProposalStateHashesResponse {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_proposal_state_hashes_response(ref v),
            ) => v,
            _ => GetProposalStateHashesResponse::default_instance(),
        }
    }
    pub fn clear_get_proposal_state_hashes_response(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_proposal_state_hashes_response(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_proposal_state_hashes_response(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_proposal_state_hashes_response(&mut self, v: GetProposalStateHashesResponse) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::get_proposal_state_hashes_response(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_get_proposal_state_hashes_response(
        &mut self,
    ) -> &mut GetProposalStateHashesResponse {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::get_proposal_state_hashes_response(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_proposal_state_hashes_response(
                    GetProposalStateHashesResponse::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_proposal_state_hashes_response(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_proposal_state_hashes_response(&mut self) -> GetProposalStateHashesResponse {
        if self.has_get_proposal_state_hashes_response() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::get_proposal_state_hashes_response(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            GetProposalStateHashesResponse::new()
        }
    }

    // .io.bisq.protobuffer.NewBlindVoteStateHashMessage new_blind_vote_state_hash_message = 40;

    pub fn get_new_blind_vote_state_hash_message(&self) -> &NewBlindVoteStateHashMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_blind_vote_state_hash_message(ref v),
            ) => v,
            _ => NewBlindVoteStateHashMessage::default_instance(),
        }
    }
    pub fn clear_new_blind_vote_state_hash_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_new_blind_vote_state_hash_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_blind_vote_state_hash_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_new_blind_vote_state_hash_message(&mut self, v: NewBlindVoteStateHashMessage) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::new_blind_vote_state_hash_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_new_blind_vote_state_hash_message(&mut self) -> &mut NewBlindVoteStateHashMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::new_blind_vote_state_hash_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_blind_vote_state_hash_message(
                    NewBlindVoteStateHashMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::new_blind_vote_state_hash_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_new_blind_vote_state_hash_message(&mut self) -> NewBlindVoteStateHashMessage {
        if self.has_new_blind_vote_state_hash_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::new_blind_vote_state_hash_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            NewBlindVoteStateHashMessage::new()
        }
    }

    // .io.bisq.protobuffer.GetBlindVoteStateHashesRequest get_blind_vote_state_hashes_request = 41;

    pub fn get_get_blind_vote_state_hashes_request(&self) -> &GetBlindVoteStateHashesRequest {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_request(ref v),
            ) => v,
            _ => GetBlindVoteStateHashesRequest::default_instance(),
        }
    }
    pub fn clear_get_blind_vote_state_hashes_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_blind_vote_state_hashes_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_request(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_blind_vote_state_hashes_request(&mut self, v: GetBlindVoteStateHashesRequest) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_request(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_get_blind_vote_state_hashes_request(
        &mut self,
    ) -> &mut GetBlindVoteStateHashesRequest {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_request(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_request(
                    GetBlindVoteStateHashesRequest::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_request(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_blind_vote_state_hashes_request(&mut self) -> GetBlindVoteStateHashesRequest {
        if self.has_get_blind_vote_state_hashes_request() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_request(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            GetBlindVoteStateHashesRequest::new()
        }
    }

    // .io.bisq.protobuffer.GetBlindVoteStateHashesResponse get_blind_vote_state_hashes_response = 42;

    pub fn get_get_blind_vote_state_hashes_response(&self) -> &GetBlindVoteStateHashesResponse {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_response(ref v),
            ) => v,
            _ => GetBlindVoteStateHashesResponse::default_instance(),
        }
    }
    pub fn clear_get_blind_vote_state_hashes_response(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_blind_vote_state_hashes_response(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_response(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_blind_vote_state_hashes_response(&mut self, v: GetBlindVoteStateHashesResponse) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_response(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_get_blind_vote_state_hashes_response(
        &mut self,
    ) -> &mut GetBlindVoteStateHashesResponse {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_response(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_response(
                    GetBlindVoteStateHashesResponse::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_response(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_blind_vote_state_hashes_response(&mut self) -> GetBlindVoteStateHashesResponse {
        if self.has_get_blind_vote_state_hashes_response() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_response(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            GetBlindVoteStateHashesResponse::new()
        }
    }

    // .io.bisq.protobuffer.BundleOfEnvelopes bundle_of_envelopes = 43;

    pub fn get_bundle_of_envelopes(&self) -> &BundleOfEnvelopes {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::bundle_of_envelopes(
                ref v,
            )) => v,
            _ => BundleOfEnvelopes::default_instance(),
        }
    }
    pub fn clear_bundle_of_envelopes(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_bundle_of_envelopes(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::bundle_of_envelopes(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bundle_of_envelopes(&mut self, v: BundleOfEnvelopes) {
        self.message =
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::bundle_of_envelopes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bundle_of_envelopes(&mut self) -> &mut BundleOfEnvelopes {
        if let ::std::option::Option::Some(NetworkEnvelope_oneof_message::bundle_of_envelopes(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::bundle_of_envelopes(BundleOfEnvelopes::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(NetworkEnvelope_oneof_message::bundle_of_envelopes(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bundle_of_envelopes(&mut self) -> BundleOfEnvelopes {
        if self.has_bundle_of_envelopes() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::bundle_of_envelopes(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            BundleOfEnvelopes::new()
        }
    }

    // .io.bisq.protobuffer.MediatedPayoutTxSignatureMessage mediated_payout_tx_signature_message = 44;

    pub fn get_mediated_payout_tx_signature_message(&self) -> &MediatedPayoutTxSignatureMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::mediated_payout_tx_signature_message(ref v),
            ) => v,
            _ => MediatedPayoutTxSignatureMessage::default_instance(),
        }
    }
    pub fn clear_mediated_payout_tx_signature_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_mediated_payout_tx_signature_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::mediated_payout_tx_signature_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mediated_payout_tx_signature_message(
        &mut self,
        v: MediatedPayoutTxSignatureMessage,
    ) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::mediated_payout_tx_signature_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_mediated_payout_tx_signature_message(
        &mut self,
    ) -> &mut MediatedPayoutTxSignatureMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::mediated_payout_tx_signature_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::mediated_payout_tx_signature_message(
                    MediatedPayoutTxSignatureMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::mediated_payout_tx_signature_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mediated_payout_tx_signature_message(
        &mut self,
    ) -> MediatedPayoutTxSignatureMessage {
        if self.has_mediated_payout_tx_signature_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::mediated_payout_tx_signature_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            MediatedPayoutTxSignatureMessage::new()
        }
    }

    // .io.bisq.protobuffer.MediatedPayoutTxPublishedMessage mediated_payout_tx_published_message = 45;

    pub fn get_mediated_payout_tx_published_message(&self) -> &MediatedPayoutTxPublishedMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::mediated_payout_tx_published_message(ref v),
            ) => v,
            _ => MediatedPayoutTxPublishedMessage::default_instance(),
        }
    }
    pub fn clear_mediated_payout_tx_published_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_mediated_payout_tx_published_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::mediated_payout_tx_published_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mediated_payout_tx_published_message(
        &mut self,
        v: MediatedPayoutTxPublishedMessage,
    ) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::mediated_payout_tx_published_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_mediated_payout_tx_published_message(
        &mut self,
    ) -> &mut MediatedPayoutTxPublishedMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::mediated_payout_tx_published_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::mediated_payout_tx_published_message(
                    MediatedPayoutTxPublishedMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::mediated_payout_tx_published_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mediated_payout_tx_published_message(
        &mut self,
    ) -> MediatedPayoutTxPublishedMessage {
        if self.has_mediated_payout_tx_published_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::mediated_payout_tx_published_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            MediatedPayoutTxPublishedMessage::new()
        }
    }

    // .io.bisq.protobuffer.DelayedPayoutTxSignatureRequest delayed_payout_tx_signature_request = 46;

    pub fn get_delayed_payout_tx_signature_request(&self) -> &DelayedPayoutTxSignatureRequest {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::delayed_payout_tx_signature_request(ref v),
            ) => v,
            _ => DelayedPayoutTxSignatureRequest::default_instance(),
        }
    }
    pub fn clear_delayed_payout_tx_signature_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_delayed_payout_tx_signature_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::delayed_payout_tx_signature_request(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delayed_payout_tx_signature_request(&mut self, v: DelayedPayoutTxSignatureRequest) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::delayed_payout_tx_signature_request(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_delayed_payout_tx_signature_request(
        &mut self,
    ) -> &mut DelayedPayoutTxSignatureRequest {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::delayed_payout_tx_signature_request(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::delayed_payout_tx_signature_request(
                    DelayedPayoutTxSignatureRequest::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::delayed_payout_tx_signature_request(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delayed_payout_tx_signature_request(&mut self) -> DelayedPayoutTxSignatureRequest {
        if self.has_delayed_payout_tx_signature_request() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::delayed_payout_tx_signature_request(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            DelayedPayoutTxSignatureRequest::new()
        }
    }

    // .io.bisq.protobuffer.DelayedPayoutTxSignatureResponse delayed_payout_tx_signature_response = 47;

    pub fn get_delayed_payout_tx_signature_response(&self) -> &DelayedPayoutTxSignatureResponse {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::delayed_payout_tx_signature_response(ref v),
            ) => v,
            _ => DelayedPayoutTxSignatureResponse::default_instance(),
        }
    }
    pub fn clear_delayed_payout_tx_signature_response(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_delayed_payout_tx_signature_response(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::delayed_payout_tx_signature_response(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delayed_payout_tx_signature_response(
        &mut self,
        v: DelayedPayoutTxSignatureResponse,
    ) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::delayed_payout_tx_signature_response(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_delayed_payout_tx_signature_response(
        &mut self,
    ) -> &mut DelayedPayoutTxSignatureResponse {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::delayed_payout_tx_signature_response(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::delayed_payout_tx_signature_response(
                    DelayedPayoutTxSignatureResponse::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::delayed_payout_tx_signature_response(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delayed_payout_tx_signature_response(
        &mut self,
    ) -> DelayedPayoutTxSignatureResponse {
        if self.has_delayed_payout_tx_signature_response() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::delayed_payout_tx_signature_response(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            DelayedPayoutTxSignatureResponse::new()
        }
    }

    // .io.bisq.protobuffer.DepositTxAndDelayedPayoutTxMessage deposit_tx_and_delayed_payout_tx_message = 48;

    pub fn get_deposit_tx_and_delayed_payout_tx_message(
        &self,
    ) -> &DepositTxAndDelayedPayoutTxMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::deposit_tx_and_delayed_payout_tx_message(ref v),
            ) => v,
            _ => DepositTxAndDelayedPayoutTxMessage::default_instance(),
        }
    }
    pub fn clear_deposit_tx_and_delayed_payout_tx_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_deposit_tx_and_delayed_payout_tx_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::deposit_tx_and_delayed_payout_tx_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_deposit_tx_and_delayed_payout_tx_message(
        &mut self,
        v: DepositTxAndDelayedPayoutTxMessage,
    ) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::deposit_tx_and_delayed_payout_tx_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_deposit_tx_and_delayed_payout_tx_message(
        &mut self,
    ) -> &mut DepositTxAndDelayedPayoutTxMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::deposit_tx_and_delayed_payout_tx_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::deposit_tx_and_delayed_payout_tx_message(
                    DepositTxAndDelayedPayoutTxMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::deposit_tx_and_delayed_payout_tx_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_deposit_tx_and_delayed_payout_tx_message(
        &mut self,
    ) -> DepositTxAndDelayedPayoutTxMessage {
        if self.has_deposit_tx_and_delayed_payout_tx_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::deposit_tx_and_delayed_payout_tx_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            DepositTxAndDelayedPayoutTxMessage::new()
        }
    }

    // .io.bisq.protobuffer.PeerPublishedDelayedPayoutTxMessage peer_published_delayed_payout_tx_message = 49;

    pub fn get_peer_published_delayed_payout_tx_message(
        &self,
    ) -> &PeerPublishedDelayedPayoutTxMessage {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::peer_published_delayed_payout_tx_message(ref v),
            ) => v,
            _ => PeerPublishedDelayedPayoutTxMessage::default_instance(),
        }
    }
    pub fn clear_peer_published_delayed_payout_tx_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_peer_published_delayed_payout_tx_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::peer_published_delayed_payout_tx_message(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_peer_published_delayed_payout_tx_message(
        &mut self,
        v: PeerPublishedDelayedPayoutTxMessage,
    ) {
        self.message = ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::peer_published_delayed_payout_tx_message(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_peer_published_delayed_payout_tx_message(
        &mut self,
    ) -> &mut PeerPublishedDelayedPayoutTxMessage {
        if let ::std::option::Option::Some(
            NetworkEnvelope_oneof_message::peer_published_delayed_payout_tx_message(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::peer_published_delayed_payout_tx_message(
                    PeerPublishedDelayedPayoutTxMessage::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                NetworkEnvelope_oneof_message::peer_published_delayed_payout_tx_message(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_peer_published_delayed_payout_tx_message(
        &mut self,
    ) -> PeerPublishedDelayedPayoutTxMessage {
        if self.has_peer_published_delayed_payout_tx_message() {
            match self.message.take() {
                ::std::option::Option::Some(
                    NetworkEnvelope_oneof_message::peer_published_delayed_payout_tx_message(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            PeerPublishedDelayedPayoutTxMessage::new()
        }
    }
}

impl ::protobuf::Message for NetworkEnvelope {
    fn is_initialized(&self) -> bool {
        if let Some(NetworkEnvelope_oneof_message::preliminary_get_data_request(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::get_data_response(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::get_updated_data_request(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::get_peers_request(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::get_peers_response(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::ping(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::pong(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::offer_availability_request(ref v)) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::offer_availability_response(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::refresh_offer_message(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::add_data_message(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::remove_data_message(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::remove_mailbox_data_message(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::close_connection_message(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::prefixed_sealed_and_signed_message(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::inputs_for_deposit_tx_request(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::inputs_for_deposit_tx_response(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::deposit_tx_message(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::counter_currency_transfer_started_message(
            ref v,
        )) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::payout_tx_published_message(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::open_new_dispute_message(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::peer_opened_dispute_message(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::chat_message(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::dispute_result_message(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::peer_published_dispute_payout_tx_message(
            ref v,
        )) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::private_notification_message(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::get_blocks_request(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::get_blocks_response(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::new_block_broadcast_message(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::add_persistable_network_payload_message(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::ack_message(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::republish_governance_data_request(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::new_dao_state_hash_message(ref v)) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::get_dao_state_hashes_request(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::get_dao_state_hashes_response(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::new_proposal_state_hash_message(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::get_proposal_state_hashes_request(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::get_proposal_state_hashes_response(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::new_blind_vote_state_hash_message(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_request(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_response(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::bundle_of_envelopes(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::mediated_payout_tx_signature_message(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::mediated_payout_tx_published_message(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::delayed_payout_tx_signature_request(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::delayed_payout_tx_signature_response(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::deposit_tx_and_delayed_payout_tx_message(
            ref v,
        )) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NetworkEnvelope_oneof_message::peer_published_delayed_payout_tx_message(
            ref v,
        )) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.message_version = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::preliminary_get_data_request(
                            is.read_message()?,
                        ),
                    );
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::get_data_response(is.read_message()?),
                    );
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::get_updated_data_request(is.read_message()?),
                    );
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::get_peers_request(is.read_message()?),
                    );
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::get_peers_response(is.read_message()?),
                    );
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::ping(is.read_message()?),
                    );
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::pong(is.read_message()?),
                    );
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::offer_availability_request(
                            is.read_message()?,
                        ),
                    );
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::offer_availability_response(
                            is.read_message()?,
                        ),
                    );
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::refresh_offer_message(is.read_message()?),
                    );
                }
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::add_data_message(is.read_message()?),
                    );
                }
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::remove_data_message(is.read_message()?),
                    );
                }
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::remove_mailbox_data_message(
                            is.read_message()?,
                        ),
                    );
                }
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::close_connection_message(is.read_message()?),
                    );
                }
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::prefixed_sealed_and_signed_message(
                            is.read_message()?,
                        ),
                    );
                }
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::inputs_for_deposit_tx_request(
                            is.read_message()?,
                        ),
                    );
                }
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::inputs_for_deposit_tx_response(
                            is.read_message()?,
                        ),
                    );
                }
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::deposit_tx_message(is.read_message()?),
                    );
                }
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::counter_currency_transfer_started_message(
                            is.read_message()?,
                        ),
                    );
                }
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::payout_tx_published_message(
                            is.read_message()?,
                        ),
                    );
                }
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::open_new_dispute_message(is.read_message()?),
                    );
                }
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::peer_opened_dispute_message(
                            is.read_message()?,
                        ),
                    );
                }
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::chat_message(is.read_message()?),
                    );
                }
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::dispute_result_message(is.read_message()?),
                    );
                }
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::peer_published_dispute_payout_tx_message(
                            is.read_message()?,
                        ),
                    );
                }
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::private_notification_message(
                            is.read_message()?,
                        ),
                    );
                }
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::get_blocks_request(is.read_message()?),
                    );
                }
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::get_blocks_response(is.read_message()?),
                    );
                }
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::new_block_broadcast_message(
                            is.read_message()?,
                        ),
                    );
                }
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::add_persistable_network_payload_message(
                            is.read_message()?,
                        ),
                    );
                }
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::ack_message(is.read_message()?),
                    );
                }
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::republish_governance_data_request(
                            is.read_message()?,
                        ),
                    );
                }
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::new_dao_state_hash_message(
                            is.read_message()?,
                        ),
                    );
                }
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::get_dao_state_hashes_request(
                            is.read_message()?,
                        ),
                    );
                }
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::get_dao_state_hashes_response(
                            is.read_message()?,
                        ),
                    );
                }
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::new_proposal_state_hash_message(
                            is.read_message()?,
                        ),
                    );
                }
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::get_proposal_state_hashes_request(
                            is.read_message()?,
                        ),
                    );
                }
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::get_proposal_state_hashes_response(
                            is.read_message()?,
                        ),
                    );
                }
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::new_blind_vote_state_hash_message(
                            is.read_message()?,
                        ),
                    );
                }
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_request(
                            is.read_message()?,
                        ),
                    );
                }
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_response(
                            is.read_message()?,
                        ),
                    );
                }
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::bundle_of_envelopes(is.read_message()?),
                    );
                }
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::mediated_payout_tx_signature_message(
                            is.read_message()?,
                        ),
                    );
                }
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::mediated_payout_tx_published_message(
                            is.read_message()?,
                        ),
                    );
                }
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::delayed_payout_tx_signature_request(
                            is.read_message()?,
                        ),
                    );
                }
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::delayed_payout_tx_signature_response(
                            is.read_message()?,
                        ),
                    );
                }
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::deposit_tx_and_delayed_payout_tx_message(
                            is.read_message()?,
                        ),
                    );
                }
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        NetworkEnvelope_oneof_message::peer_published_delayed_payout_tx_message(
                            is.read_message()?,
                        ),
                    );
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.message_version != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.message_version,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &NetworkEnvelope_oneof_message::preliminary_get_data_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::get_data_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::get_updated_data_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::get_peers_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::get_peers_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::ping(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::pong(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::offer_availability_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::offer_availability_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::refresh_offer_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::add_data_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::remove_data_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::remove_mailbox_data_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::close_connection_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::prefixed_sealed_and_signed_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::inputs_for_deposit_tx_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::inputs_for_deposit_tx_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::deposit_tx_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::counter_currency_transfer_started_message(
                    ref v,
                ) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::payout_tx_published_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::open_new_dispute_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::peer_opened_dispute_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::chat_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::dispute_result_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::peer_published_dispute_payout_tx_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::private_notification_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::get_blocks_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::get_blocks_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::new_block_broadcast_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::add_persistable_network_payload_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::ack_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::republish_governance_data_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::new_dao_state_hash_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::get_dao_state_hashes_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::get_dao_state_hashes_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::new_proposal_state_hash_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::get_proposal_state_hashes_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::get_proposal_state_hashes_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::new_blind_vote_state_hash_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::bundle_of_envelopes(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::mediated_payout_tx_signature_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::mediated_payout_tx_published_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::delayed_payout_tx_signature_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::delayed_payout_tx_signature_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::deposit_tx_and_delayed_payout_tx_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &NetworkEnvelope_oneof_message::peer_published_delayed_payout_tx_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.message_version != 0 {
            os.write_int32(1, self.message_version)?;
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &NetworkEnvelope_oneof_message::preliminary_get_data_request(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::get_data_response(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::get_updated_data_request(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::get_peers_request(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::get_peers_response(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::ping(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::pong(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::offer_availability_request(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::offer_availability_response(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::refresh_offer_message(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::add_data_message(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::remove_data_message(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::remove_mailbox_data_message(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::close_connection_message(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::prefixed_sealed_and_signed_message(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::inputs_for_deposit_tx_request(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::inputs_for_deposit_tx_response(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::deposit_tx_message(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::counter_currency_transfer_started_message(
                    ref v,
                ) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::payout_tx_published_message(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::open_new_dispute_message(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::peer_opened_dispute_message(ref v) => {
                    os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::chat_message(ref v) => {
                    os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::dispute_result_message(ref v) => {
                    os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::peer_published_dispute_payout_tx_message(ref v) => {
                    os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::private_notification_message(ref v) => {
                    os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::get_blocks_request(ref v) => {
                    os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::get_blocks_response(ref v) => {
                    os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::new_block_broadcast_message(ref v) => {
                    os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::add_persistable_network_payload_message(ref v) => {
                    os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::ack_message(ref v) => {
                    os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::republish_governance_data_request(ref v) => {
                    os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::new_dao_state_hash_message(ref v) => {
                    os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::get_dao_state_hashes_request(ref v) => {
                    os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::get_dao_state_hashes_response(ref v) => {
                    os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::new_proposal_state_hash_message(ref v) => {
                    os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::get_proposal_state_hashes_request(ref v) => {
                    os.write_tag(38, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::get_proposal_state_hashes_response(ref v) => {
                    os.write_tag(39, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::new_blind_vote_state_hash_message(ref v) => {
                    os.write_tag(40, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_request(ref v) => {
                    os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::get_blind_vote_state_hashes_response(ref v) => {
                    os.write_tag(42, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::bundle_of_envelopes(ref v) => {
                    os.write_tag(43, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::mediated_payout_tx_signature_message(ref v) => {
                    os.write_tag(44, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::mediated_payout_tx_published_message(ref v) => {
                    os.write_tag(45, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::delayed_payout_tx_signature_request(ref v) => {
                    os.write_tag(46, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::delayed_payout_tx_signature_response(ref v) => {
                    os.write_tag(47, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::deposit_tx_and_delayed_payout_tx_message(ref v) => {
                    os.write_tag(48, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &NetworkEnvelope_oneof_message::peer_published_delayed_payout_tx_message(ref v) => {
                    os.write_tag(49, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkEnvelope {
        NetworkEnvelope::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "message_version",
                    |m: &NetworkEnvelope| &m.message_version,
                    |m: &mut NetworkEnvelope| &mut m.message_version,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        PreliminaryGetDataRequest,
                    >(
                        "preliminary_get_data_request",
                        NetworkEnvelope::has_preliminary_get_data_request,
                        NetworkEnvelope::get_preliminary_get_data_request,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        GetDataResponse,
                    >(
                        "get_data_response",
                        NetworkEnvelope::has_get_data_response,
                        NetworkEnvelope::get_get_data_response,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        GetUpdatedDataRequest,
                    >(
                        "get_updated_data_request",
                        NetworkEnvelope::has_get_updated_data_request,
                        NetworkEnvelope::get_get_updated_data_request,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        GetPeersRequest,
                    >(
                        "get_peers_request",
                        NetworkEnvelope::has_get_peers_request,
                        NetworkEnvelope::get_get_peers_request,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        GetPeersResponse,
                    >(
                        "get_peers_response",
                        NetworkEnvelope::has_get_peers_response,
                        NetworkEnvelope::get_get_peers_response,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<_, Ping>(
                        "ping",
                        NetworkEnvelope::has_ping,
                        NetworkEnvelope::get_ping,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<_, Pong>(
                        "pong",
                        NetworkEnvelope::has_pong,
                        NetworkEnvelope::get_pong,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        OfferAvailabilityRequest,
                    >(
                        "offer_availability_request",
                        NetworkEnvelope::has_offer_availability_request,
                        NetworkEnvelope::get_offer_availability_request,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        OfferAvailabilityResponse,
                    >(
                        "offer_availability_response",
                        NetworkEnvelope::has_offer_availability_response,
                        NetworkEnvelope::get_offer_availability_response,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        RefreshOfferMessage,
                    >(
                        "refresh_offer_message",
                        NetworkEnvelope::has_refresh_offer_message,
                        NetworkEnvelope::get_refresh_offer_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        AddDataMessage,
                    >(
                        "add_data_message",
                        NetworkEnvelope::has_add_data_message,
                        NetworkEnvelope::get_add_data_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        RemoveDataMessage,
                    >(
                        "remove_data_message",
                        NetworkEnvelope::has_remove_data_message,
                        NetworkEnvelope::get_remove_data_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        RemoveMailboxDataMessage,
                    >(
                        "remove_mailbox_data_message",
                        NetworkEnvelope::has_remove_mailbox_data_message,
                        NetworkEnvelope::get_remove_mailbox_data_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        CloseConnectionMessage,
                    >(
                        "close_connection_message",
                        NetworkEnvelope::has_close_connection_message,
                        NetworkEnvelope::get_close_connection_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        PrefixedSealedAndSignedMessage,
                    >(
                        "prefixed_sealed_and_signed_message",
                        NetworkEnvelope::has_prefixed_sealed_and_signed_message,
                        NetworkEnvelope::get_prefixed_sealed_and_signed_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        InputsForDepositTxRequest,
                    >(
                        "inputs_for_deposit_tx_request",
                        NetworkEnvelope::has_inputs_for_deposit_tx_request,
                        NetworkEnvelope::get_inputs_for_deposit_tx_request,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        InputsForDepositTxResponse,
                    >(
                        "inputs_for_deposit_tx_response",
                        NetworkEnvelope::has_inputs_for_deposit_tx_response,
                        NetworkEnvelope::get_inputs_for_deposit_tx_response,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        DepositTxMessage,
                    >(
                        "deposit_tx_message",
                        NetworkEnvelope::has_deposit_tx_message,
                        NetworkEnvelope::get_deposit_tx_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        CounterCurrencyTransferStartedMessage,
                    >(
                        "counter_currency_transfer_started_message",
                        NetworkEnvelope::has_counter_currency_transfer_started_message,
                        NetworkEnvelope::get_counter_currency_transfer_started_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        PayoutTxPublishedMessage,
                    >(
                        "payout_tx_published_message",
                        NetworkEnvelope::has_payout_tx_published_message,
                        NetworkEnvelope::get_payout_tx_published_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        OpenNewDisputeMessage,
                    >(
                        "open_new_dispute_message",
                        NetworkEnvelope::has_open_new_dispute_message,
                        NetworkEnvelope::get_open_new_dispute_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        PeerOpenedDisputeMessage,
                    >(
                        "peer_opened_dispute_message",
                        NetworkEnvelope::has_peer_opened_dispute_message,
                        NetworkEnvelope::get_peer_opened_dispute_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChatMessage>(
                        "chat_message",
                        NetworkEnvelope::has_chat_message,
                        NetworkEnvelope::get_chat_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        DisputeResultMessage,
                    >(
                        "dispute_result_message",
                        NetworkEnvelope::has_dispute_result_message,
                        NetworkEnvelope::get_dispute_result_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        PeerPublishedDisputePayoutTxMessage,
                    >(
                        "peer_published_dispute_payout_tx_message",
                        NetworkEnvelope::has_peer_published_dispute_payout_tx_message,
                        NetworkEnvelope::get_peer_published_dispute_payout_tx_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        PrivateNotificationMessage,
                    >(
                        "private_notification_message",
                        NetworkEnvelope::has_private_notification_message,
                        NetworkEnvelope::get_private_notification_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        GetBlocksRequest,
                    >(
                        "get_blocks_request",
                        NetworkEnvelope::has_get_blocks_request,
                        NetworkEnvelope::get_get_blocks_request,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        GetBlocksResponse,
                    >(
                        "get_blocks_response",
                        NetworkEnvelope::has_get_blocks_response,
                        NetworkEnvelope::get_get_blocks_response,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        NewBlockBroadcastMessage,
                    >(
                        "new_block_broadcast_message",
                        NetworkEnvelope::has_new_block_broadcast_message,
                        NetworkEnvelope::get_new_block_broadcast_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        AddPersistableNetworkPayloadMessage,
                    >(
                        "add_persistable_network_payload_message",
                        NetworkEnvelope::has_add_persistable_network_payload_message,
                        NetworkEnvelope::get_add_persistable_network_payload_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<_, AckMessage>(
                        "ack_message",
                        NetworkEnvelope::has_ack_message,
                        NetworkEnvelope::get_ack_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        RepublishGovernanceDataRequest,
                    >(
                        "republish_governance_data_request",
                        NetworkEnvelope::has_republish_governance_data_request,
                        NetworkEnvelope::get_republish_governance_data_request,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        NewDaoStateHashMessage,
                    >(
                        "new_dao_state_hash_message",
                        NetworkEnvelope::has_new_dao_state_hash_message,
                        NetworkEnvelope::get_new_dao_state_hash_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        GetDaoStateHashesRequest,
                    >(
                        "get_dao_state_hashes_request",
                        NetworkEnvelope::has_get_dao_state_hashes_request,
                        NetworkEnvelope::get_get_dao_state_hashes_request,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        GetDaoStateHashesResponse,
                    >(
                        "get_dao_state_hashes_response",
                        NetworkEnvelope::has_get_dao_state_hashes_response,
                        NetworkEnvelope::get_get_dao_state_hashes_response,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        NewProposalStateHashMessage,
                    >(
                        "new_proposal_state_hash_message",
                        NetworkEnvelope::has_new_proposal_state_hash_message,
                        NetworkEnvelope::get_new_proposal_state_hash_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        GetProposalStateHashesRequest,
                    >(
                        "get_proposal_state_hashes_request",
                        NetworkEnvelope::has_get_proposal_state_hashes_request,
                        NetworkEnvelope::get_get_proposal_state_hashes_request,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        GetProposalStateHashesResponse,
                    >(
                        "get_proposal_state_hashes_response",
                        NetworkEnvelope::has_get_proposal_state_hashes_response,
                        NetworkEnvelope::get_get_proposal_state_hashes_response,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        NewBlindVoteStateHashMessage,
                    >(
                        "new_blind_vote_state_hash_message",
                        NetworkEnvelope::has_new_blind_vote_state_hash_message,
                        NetworkEnvelope::get_new_blind_vote_state_hash_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        GetBlindVoteStateHashesRequest,
                    >(
                        "get_blind_vote_state_hashes_request",
                        NetworkEnvelope::has_get_blind_vote_state_hashes_request,
                        NetworkEnvelope::get_get_blind_vote_state_hashes_request,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        GetBlindVoteStateHashesResponse,
                    >(
                        "get_blind_vote_state_hashes_response",
                        NetworkEnvelope::has_get_blind_vote_state_hashes_response,
                        NetworkEnvelope::get_get_blind_vote_state_hashes_response,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        BundleOfEnvelopes,
                    >(
                        "bundle_of_envelopes",
                        NetworkEnvelope::has_bundle_of_envelopes,
                        NetworkEnvelope::get_bundle_of_envelopes,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        MediatedPayoutTxSignatureMessage,
                    >(
                        "mediated_payout_tx_signature_message",
                        NetworkEnvelope::has_mediated_payout_tx_signature_message,
                        NetworkEnvelope::get_mediated_payout_tx_signature_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        MediatedPayoutTxPublishedMessage,
                    >(
                        "mediated_payout_tx_published_message",
                        NetworkEnvelope::has_mediated_payout_tx_published_message,
                        NetworkEnvelope::get_mediated_payout_tx_published_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        DelayedPayoutTxSignatureRequest,
                    >(
                        "delayed_payout_tx_signature_request",
                        NetworkEnvelope::has_delayed_payout_tx_signature_request,
                        NetworkEnvelope::get_delayed_payout_tx_signature_request,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        DelayedPayoutTxSignatureResponse,
                    >(
                        "delayed_payout_tx_signature_response",
                        NetworkEnvelope::has_delayed_payout_tx_signature_response,
                        NetworkEnvelope::get_delayed_payout_tx_signature_response,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        DepositTxAndDelayedPayoutTxMessage,
                    >(
                        "deposit_tx_and_delayed_payout_tx_message",
                        NetworkEnvelope::has_deposit_tx_and_delayed_payout_tx_message,
                        NetworkEnvelope::get_deposit_tx_and_delayed_payout_tx_message,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        PeerPublishedDelayedPayoutTxMessage,
                    >(
                        "peer_published_delayed_payout_tx_message",
                        NetworkEnvelope::has_peer_published_delayed_payout_tx_message,
                        NetworkEnvelope::get_peer_published_delayed_payout_tx_message,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<NetworkEnvelope>(
                    "NetworkEnvelope",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static NetworkEnvelope {
        static mut instance: ::protobuf::lazy::Lazy<NetworkEnvelope> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NetworkEnvelope,
        };
        unsafe { instance.get(NetworkEnvelope::new) }
    }
}

impl ::protobuf::Clear for NetworkEnvelope {
    fn clear(&mut self) {
        self.message_version = 0;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkEnvelope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkEnvelope {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct BundleOfEnvelopes {
    // message fields
    pub envelopes: ::protobuf::RepeatedField<NetworkEnvelope>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BundleOfEnvelopes {
    fn default() -> &'a BundleOfEnvelopes {
        <BundleOfEnvelopes as ::protobuf::Message>::default_instance()
    }
}

impl BundleOfEnvelopes {
    pub fn new() -> BundleOfEnvelopes {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.NetworkEnvelope envelopes = 1;

    pub fn get_envelopes(&self) -> &[NetworkEnvelope] {
        &self.envelopes
    }
    pub fn clear_envelopes(&mut self) {
        self.envelopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_envelopes(&mut self, v: ::protobuf::RepeatedField<NetworkEnvelope>) {
        self.envelopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_envelopes(&mut self) -> &mut ::protobuf::RepeatedField<NetworkEnvelope> {
        &mut self.envelopes
    }

    // Take field
    pub fn take_envelopes(&mut self) -> ::protobuf::RepeatedField<NetworkEnvelope> {
        ::std::mem::replace(&mut self.envelopes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BundleOfEnvelopes {
    fn is_initialized(&self) -> bool {
        for v in &self.envelopes {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.envelopes)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.envelopes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.envelopes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BundleOfEnvelopes {
        BundleOfEnvelopes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NetworkEnvelope>,
                    >(
                        "envelopes",
                        |m: &BundleOfEnvelopes| &m.envelopes,
                        |m: &mut BundleOfEnvelopes| &mut m.envelopes,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<BundleOfEnvelopes>(
                    "BundleOfEnvelopes",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static BundleOfEnvelopes {
        static mut instance: ::protobuf::lazy::Lazy<BundleOfEnvelopes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BundleOfEnvelopes,
        };
        unsafe { instance.get(BundleOfEnvelopes::new) }
    }
}

impl ::protobuf::Clear for BundleOfEnvelopes {
    fn clear(&mut self) {
        self.envelopes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BundleOfEnvelopes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BundleOfEnvelopes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PreliminaryGetDataRequest {
    // message fields
    pub nonce: i32,
    pub excluded_keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub supported_capabilities: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreliminaryGetDataRequest {
    fn default() -> &'a PreliminaryGetDataRequest {
        <PreliminaryGetDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl PreliminaryGetDataRequest {
    pub fn new() -> PreliminaryGetDataRequest {
        ::std::default::Default::default()
    }

    // int32 nonce = 21;

    pub fn get_nonce(&self) -> i32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i32) {
        self.nonce = v;
    }

    // repeated bytes excluded_keys = 2;

    pub fn get_excluded_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.excluded_keys
    }
    pub fn clear_excluded_keys(&mut self) {
        self.excluded_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_excluded_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.excluded_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excluded_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.excluded_keys
    }

    // Take field
    pub fn take_excluded_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.excluded_keys, ::protobuf::RepeatedField::new())
    }

    // repeated int32 supported_capabilities = 3;

    pub fn get_supported_capabilities(&self) -> &[i32] {
        &self.supported_capabilities
    }
    pub fn clear_supported_capabilities(&mut self) {
        self.supported_capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_capabilities(&mut self, v: ::std::vec::Vec<i32>) {
        self.supported_capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_capabilities(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.supported_capabilities
    }

    // Take field
    pub fn take_supported_capabilities(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.supported_capabilities, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PreliminaryGetDataRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.nonce = tmp;
                }
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(
                        wire_type,
                        is,
                        &mut self.excluded_keys,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(
                        wire_type,
                        is,
                        &mut self.supported_capabilities,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nonce != 0 {
            my_size +=
                ::protobuf::rt::value_size(21, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.excluded_keys {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        }
        for value in &self.supported_capabilities {
            my_size +=
                ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.nonce != 0 {
            os.write_int32(21, self.nonce)?;
        }
        for v in &self.excluded_keys {
            os.write_bytes(2, &v)?;
        }
        for v in &self.supported_capabilities {
            os.write_int32(3, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreliminaryGetDataRequest {
        PreliminaryGetDataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "nonce",
                    |m: &PreliminaryGetDataRequest| &m.nonce,
                    |m: &mut PreliminaryGetDataRequest| &mut m.nonce,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeBytes,
                    >(
                        "excluded_keys",
                        |m: &PreliminaryGetDataRequest| &m.excluded_keys,
                        |m: &mut PreliminaryGetDataRequest| &mut m.excluded_keys,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "supported_capabilities",
                    |m: &PreliminaryGetDataRequest| &m.supported_capabilities,
                    |m: &mut PreliminaryGetDataRequest| &mut m.supported_capabilities,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PreliminaryGetDataRequest>(
                    "PreliminaryGetDataRequest",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PreliminaryGetDataRequest {
        static mut instance: ::protobuf::lazy::Lazy<PreliminaryGetDataRequest> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PreliminaryGetDataRequest,
            };
        unsafe { instance.get(PreliminaryGetDataRequest::new) }
    }
}

impl ::protobuf::Clear for PreliminaryGetDataRequest {
    fn clear(&mut self) {
        self.nonce = 0;
        self.excluded_keys.clear();
        self.supported_capabilities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreliminaryGetDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreliminaryGetDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct GetDataResponse {
    // message fields
    pub request_nonce: i32,
    pub is_get_updated_data_response: bool,
    pub data_set: ::protobuf::RepeatedField<StorageEntryWrapper>,
    pub supported_capabilities: ::std::vec::Vec<i32>,
    pub persistable_network_payload_items: ::protobuf::RepeatedField<PersistableNetworkPayload>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDataResponse {
    fn default() -> &'a GetDataResponse {
        <GetDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetDataResponse {
    pub fn new() -> GetDataResponse {
        ::std::default::Default::default()
    }

    // int32 request_nonce = 1;

    pub fn get_request_nonce(&self) -> i32 {
        self.request_nonce
    }
    pub fn clear_request_nonce(&mut self) {
        self.request_nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_request_nonce(&mut self, v: i32) {
        self.request_nonce = v;
    }

    // bool is_get_updated_data_response = 2;

    pub fn get_is_get_updated_data_response(&self) -> bool {
        self.is_get_updated_data_response
    }
    pub fn clear_is_get_updated_data_response(&mut self) {
        self.is_get_updated_data_response = false;
    }

    // Param is passed by value, moved
    pub fn set_is_get_updated_data_response(&mut self, v: bool) {
        self.is_get_updated_data_response = v;
    }

    // repeated .io.bisq.protobuffer.StorageEntryWrapper data_set = 3;

    pub fn get_data_set(&self) -> &[StorageEntryWrapper] {
        &self.data_set
    }
    pub fn clear_data_set(&mut self) {
        self.data_set.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_set(&mut self, v: ::protobuf::RepeatedField<StorageEntryWrapper>) {
        self.data_set = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_set(&mut self) -> &mut ::protobuf::RepeatedField<StorageEntryWrapper> {
        &mut self.data_set
    }

    // Take field
    pub fn take_data_set(&mut self) -> ::protobuf::RepeatedField<StorageEntryWrapper> {
        ::std::mem::replace(&mut self.data_set, ::protobuf::RepeatedField::new())
    }

    // repeated int32 supported_capabilities = 4;

    pub fn get_supported_capabilities(&self) -> &[i32] {
        &self.supported_capabilities
    }
    pub fn clear_supported_capabilities(&mut self) {
        self.supported_capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_capabilities(&mut self, v: ::std::vec::Vec<i32>) {
        self.supported_capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_capabilities(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.supported_capabilities
    }

    // Take field
    pub fn take_supported_capabilities(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.supported_capabilities, ::std::vec::Vec::new())
    }

    // repeated .io.bisq.protobuffer.PersistableNetworkPayload persistable_network_payload_items = 5;

    pub fn get_persistable_network_payload_items(&self) -> &[PersistableNetworkPayload] {
        &self.persistable_network_payload_items
    }
    pub fn clear_persistable_network_payload_items(&mut self) {
        self.persistable_network_payload_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_persistable_network_payload_items(
        &mut self,
        v: ::protobuf::RepeatedField<PersistableNetworkPayload>,
    ) {
        self.persistable_network_payload_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_persistable_network_payload_items(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<PersistableNetworkPayload> {
        &mut self.persistable_network_payload_items
    }

    // Take field
    pub fn take_persistable_network_payload_items(
        &mut self,
    ) -> ::protobuf::RepeatedField<PersistableNetworkPayload> {
        ::std::mem::replace(
            &mut self.persistable_network_payload_items,
            ::protobuf::RepeatedField::new(),
        )
    }
}

impl ::protobuf::Message for GetDataResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.data_set {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.persistable_network_payload_items {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.request_nonce = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_get_updated_data_response = tmp;
                }
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data_set)?;
                }
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(
                        wire_type,
                        is,
                        &mut self.supported_capabilities,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.persistable_network_payload_items,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.request_nonce != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.request_nonce,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.is_get_updated_data_response != false {
            my_size += 2;
        }
        for value in &self.data_set {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.supported_capabilities {
            my_size +=
                ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.persistable_network_payload_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.request_nonce != 0 {
            os.write_int32(1, self.request_nonce)?;
        }
        if self.is_get_updated_data_response != false {
            os.write_bool(2, self.is_get_updated_data_response)?;
        }
        for v in &self.data_set {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.supported_capabilities {
            os.write_int32(4, *v)?;
        }
        for v in &self.persistable_network_payload_items {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDataResponse {
        GetDataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "request_nonce",
                    |m: &GetDataResponse| &m.request_nonce,
                    |m: &mut GetDataResponse| &mut m.request_nonce,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_get_updated_data_response",
                    |m: &GetDataResponse| &m.is_get_updated_data_response,
                    |m: &mut GetDataResponse| &mut m.is_get_updated_data_response,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<StorageEntryWrapper>,
                    >(
                        "data_set",
                        |m: &GetDataResponse| &m.data_set,
                        |m: &mut GetDataResponse| &mut m.data_set,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "supported_capabilities",
                    |m: &GetDataResponse| &m.supported_capabilities,
                    |m: &mut GetDataResponse| &mut m.supported_capabilities,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PersistableNetworkPayload>,
                    >(
                        "persistable_network_payload_items",
                        |m: &GetDataResponse| &m.persistable_network_payload_items,
                        |m: &mut GetDataResponse| &mut m.persistable_network_payload_items,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<GetDataResponse>(
                    "GetDataResponse",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static GetDataResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetDataResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDataResponse,
        };
        unsafe { instance.get(GetDataResponse::new) }
    }
}

impl ::protobuf::Clear for GetDataResponse {
    fn clear(&mut self) {
        self.request_nonce = 0;
        self.is_get_updated_data_response = false;
        self.data_set.clear();
        self.supported_capabilities.clear();
        self.persistable_network_payload_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct GetUpdatedDataRequest {
    // message fields
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub nonce: i32,
    pub excluded_keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetUpdatedDataRequest {
    fn default() -> &'a GetUpdatedDataRequest {
        <GetUpdatedDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetUpdatedDataRequest {
    pub fn new() -> GetUpdatedDataRequest {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 1;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // int32 nonce = 2;

    pub fn get_nonce(&self) -> i32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i32) {
        self.nonce = v;
    }

    // repeated bytes excluded_keys = 3;

    pub fn get_excluded_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.excluded_keys
    }
    pub fn clear_excluded_keys(&mut self) {
        self.excluded_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_excluded_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.excluded_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excluded_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.excluded_keys
    }

    // Take field
    pub fn take_excluded_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.excluded_keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetUpdatedDataRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.nonce = tmp;
                }
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(
                        wire_type,
                        is,
                        &mut self.excluded_keys,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.nonce != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.excluded_keys {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.nonce != 0 {
            os.write_int32(2, self.nonce)?;
        }
        for v in &self.excluded_keys {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetUpdatedDataRequest {
        GetUpdatedDataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &GetUpdatedDataRequest| &m.sender_node_address,
                        |m: &mut GetUpdatedDataRequest| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "nonce",
                    |m: &GetUpdatedDataRequest| &m.nonce,
                    |m: &mut GetUpdatedDataRequest| &mut m.nonce,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeBytes,
                    >(
                        "excluded_keys",
                        |m: &GetUpdatedDataRequest| &m.excluded_keys,
                        |m: &mut GetUpdatedDataRequest| &mut m.excluded_keys,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<GetUpdatedDataRequest>(
                    "GetUpdatedDataRequest",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static GetUpdatedDataRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetUpdatedDataRequest> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const GetUpdatedDataRequest,
            };
        unsafe { instance.get(GetUpdatedDataRequest::new) }
    }
}

impl ::protobuf::Clear for GetUpdatedDataRequest {
    fn clear(&mut self) {
        self.sender_node_address.clear();
        self.nonce = 0;
        self.excluded_keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetUpdatedDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUpdatedDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct GetPeersRequest {
    // message fields
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub nonce: i32,
    pub supported_capabilities: ::std::vec::Vec<i32>,
    pub reported_peers: ::protobuf::RepeatedField<Peer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeersRequest {
    fn default() -> &'a GetPeersRequest {
        <GetPeersRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPeersRequest {
    pub fn new() -> GetPeersRequest {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 1;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // int32 nonce = 2;

    pub fn get_nonce(&self) -> i32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i32) {
        self.nonce = v;
    }

    // repeated int32 supported_capabilities = 3;

    pub fn get_supported_capabilities(&self) -> &[i32] {
        &self.supported_capabilities
    }
    pub fn clear_supported_capabilities(&mut self) {
        self.supported_capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_capabilities(&mut self, v: ::std::vec::Vec<i32>) {
        self.supported_capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_capabilities(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.supported_capabilities
    }

    // Take field
    pub fn take_supported_capabilities(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.supported_capabilities, ::std::vec::Vec::new())
    }

    // repeated .io.bisq.protobuffer.Peer reported_peers = 4;

    pub fn get_reported_peers(&self) -> &[Peer] {
        &self.reported_peers
    }
    pub fn clear_reported_peers(&mut self) {
        self.reported_peers.clear();
    }

    // Param is passed by value, moved
    pub fn set_reported_peers(&mut self, v: ::protobuf::RepeatedField<Peer>) {
        self.reported_peers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reported_peers(&mut self) -> &mut ::protobuf::RepeatedField<Peer> {
        &mut self.reported_peers
    }

    // Take field
    pub fn take_reported_peers(&mut self) -> ::protobuf::RepeatedField<Peer> {
        ::std::mem::replace(&mut self.reported_peers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetPeersRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.reported_peers {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.nonce = tmp;
                }
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(
                        wire_type,
                        is,
                        &mut self.supported_capabilities,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.reported_peers,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.nonce != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.supported_capabilities {
            my_size +=
                ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.reported_peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.nonce != 0 {
            os.write_int32(2, self.nonce)?;
        }
        for v in &self.supported_capabilities {
            os.write_int32(3, *v)?;
        }
        for v in &self.reported_peers {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeersRequest {
        GetPeersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &GetPeersRequest| &m.sender_node_address,
                        |m: &mut GetPeersRequest| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "nonce",
                    |m: &GetPeersRequest| &m.nonce,
                    |m: &mut GetPeersRequest| &mut m.nonce,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "supported_capabilities",
                    |m: &GetPeersRequest| &m.supported_capabilities,
                    |m: &mut GetPeersRequest| &mut m.supported_capabilities,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Peer>,
                    >(
                        "reported_peers",
                        |m: &GetPeersRequest| &m.reported_peers,
                        |m: &mut GetPeersRequest| &mut m.reported_peers,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<GetPeersRequest>(
                    "GetPeersRequest",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static GetPeersRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetPeersRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPeersRequest,
        };
        unsafe { instance.get(GetPeersRequest::new) }
    }
}

impl ::protobuf::Clear for GetPeersRequest {
    fn clear(&mut self) {
        self.sender_node_address.clear();
        self.nonce = 0;
        self.supported_capabilities.clear();
        self.reported_peers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct GetPeersResponse {
    // message fields
    pub request_nonce: i32,
    pub reported_peers: ::protobuf::RepeatedField<Peer>,
    pub supported_capabilities: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeersResponse {
    fn default() -> &'a GetPeersResponse {
        <GetPeersResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPeersResponse {
    pub fn new() -> GetPeersResponse {
        ::std::default::Default::default()
    }

    // int32 request_nonce = 1;

    pub fn get_request_nonce(&self) -> i32 {
        self.request_nonce
    }
    pub fn clear_request_nonce(&mut self) {
        self.request_nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_request_nonce(&mut self, v: i32) {
        self.request_nonce = v;
    }

    // repeated .io.bisq.protobuffer.Peer reported_peers = 2;

    pub fn get_reported_peers(&self) -> &[Peer] {
        &self.reported_peers
    }
    pub fn clear_reported_peers(&mut self) {
        self.reported_peers.clear();
    }

    // Param is passed by value, moved
    pub fn set_reported_peers(&mut self, v: ::protobuf::RepeatedField<Peer>) {
        self.reported_peers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reported_peers(&mut self) -> &mut ::protobuf::RepeatedField<Peer> {
        &mut self.reported_peers
    }

    // Take field
    pub fn take_reported_peers(&mut self) -> ::protobuf::RepeatedField<Peer> {
        ::std::mem::replace(&mut self.reported_peers, ::protobuf::RepeatedField::new())
    }

    // repeated int32 supported_capabilities = 3;

    pub fn get_supported_capabilities(&self) -> &[i32] {
        &self.supported_capabilities
    }
    pub fn clear_supported_capabilities(&mut self) {
        self.supported_capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_capabilities(&mut self, v: ::std::vec::Vec<i32>) {
        self.supported_capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_capabilities(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.supported_capabilities
    }

    // Take field
    pub fn take_supported_capabilities(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.supported_capabilities, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetPeersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.reported_peers {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.request_nonce = tmp;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.reported_peers,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(
                        wire_type,
                        is,
                        &mut self.supported_capabilities,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.request_nonce != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.request_nonce,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        for value in &self.reported_peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.supported_capabilities {
            my_size +=
                ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.request_nonce != 0 {
            os.write_int32(1, self.request_nonce)?;
        }
        for v in &self.reported_peers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.supported_capabilities {
            os.write_int32(3, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeersResponse {
        GetPeersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "request_nonce",
                    |m: &GetPeersResponse| &m.request_nonce,
                    |m: &mut GetPeersResponse| &mut m.request_nonce,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Peer>,
                    >(
                        "reported_peers",
                        |m: &GetPeersResponse| &m.reported_peers,
                        |m: &mut GetPeersResponse| &mut m.reported_peers,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "supported_capabilities",
                    |m: &GetPeersResponse| &m.supported_capabilities,
                    |m: &mut GetPeersResponse| &mut m.supported_capabilities,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPeersResponse>(
                    "GetPeersResponse",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static GetPeersResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetPeersResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPeersResponse,
        };
        unsafe { instance.get(GetPeersResponse::new) }
    }
}

impl ::protobuf::Clear for GetPeersResponse {
    fn clear(&mut self) {
        self.request_nonce = 0;
        self.reported_peers.clear();
        self.supported_capabilities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Ping {
    // message fields
    pub nonce: i32,
    pub last_round_trip_time: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ping {
    fn default() -> &'a Ping {
        <Ping as ::protobuf::Message>::default_instance()
    }
}

impl Ping {
    pub fn new() -> Ping {
        ::std::default::Default::default()
    }

    // int32 nonce = 1;

    pub fn get_nonce(&self) -> i32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i32) {
        self.nonce = v;
    }

    // int32 last_round_trip_time = 2;

    pub fn get_last_round_trip_time(&self) -> i32 {
        self.last_round_trip_time
    }
    pub fn clear_last_round_trip_time(&mut self) {
        self.last_round_trip_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_round_trip_time(&mut self, v: i32) {
        self.last_round_trip_time = v;
    }
}

impl ::protobuf::Message for Ping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.nonce = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.last_round_trip_time = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nonce != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_round_trip_time != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.last_round_trip_time,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.nonce != 0 {
            os.write_int32(1, self.nonce)?;
        }
        if self.last_round_trip_time != 0 {
            os.write_int32(2, self.last_round_trip_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ping {
        Ping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "nonce", |m: &Ping| &m.nonce, |m: &mut Ping| &mut m.nonce
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "last_round_trip_time",
                    |m: &Ping| &m.last_round_trip_time,
                    |m: &mut Ping| &mut m.last_round_trip_time,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Ping>(
                    "Ping",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Ping {
        static mut instance: ::protobuf::lazy::Lazy<Ping> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Ping,
        };
        unsafe { instance.get(Ping::new) }
    }
}

impl ::protobuf::Clear for Ping {
    fn clear(&mut self) {
        self.nonce = 0;
        self.last_round_trip_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Pong {
    // message fields
    pub request_nonce: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pong {
    fn default() -> &'a Pong {
        <Pong as ::protobuf::Message>::default_instance()
    }
}

impl Pong {
    pub fn new() -> Pong {
        ::std::default::Default::default()
    }

    // int32 request_nonce = 1;

    pub fn get_request_nonce(&self) -> i32 {
        self.request_nonce
    }
    pub fn clear_request_nonce(&mut self) {
        self.request_nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_request_nonce(&mut self, v: i32) {
        self.request_nonce = v;
    }
}

impl ::protobuf::Message for Pong {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.request_nonce = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.request_nonce != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.request_nonce,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.request_nonce != 0 {
            os.write_int32(1, self.request_nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pong {
        Pong::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "request_nonce",
                    |m: &Pong| &m.request_nonce,
                    |m: &mut Pong| &mut m.request_nonce,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Pong>(
                    "Pong",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Pong {
        static mut instance: ::protobuf::lazy::Lazy<Pong> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Pong,
        };
        unsafe { instance.get(Pong::new) }
    }
}

impl ::protobuf::Clear for Pong {
    fn clear(&mut self) {
        self.request_nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pong {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pong {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct OfferAvailabilityRequest {
    // message fields
    pub offer_id: ::std::string::String,
    pub pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub takers_trade_price: i64,
    pub supported_capabilities: ::std::vec::Vec<i32>,
    pub uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OfferAvailabilityRequest {
    fn default() -> &'a OfferAvailabilityRequest {
        <OfferAvailabilityRequest as ::protobuf::Message>::default_instance()
    }
}

impl OfferAvailabilityRequest {
    pub fn new() -> OfferAvailabilityRequest {
        ::std::default::Default::default()
    }

    // string offer_id = 1;

    pub fn get_offer_id(&self) -> &str {
        &self.offer_id
    }
    pub fn clear_offer_id(&mut self) {
        self.offer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_offer_id(&mut self, v: ::std::string::String) {
        self.offer_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer_id(&mut self) -> &mut ::std::string::String {
        &mut self.offer_id
    }

    // Take field
    pub fn take_offer_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.offer_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.PubKeyRing pub_key_ring = 2;

    pub fn get_pub_key_ring(&self) -> &PubKeyRing {
        self.pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_pub_key_ring(&mut self) {
        self.pub_key_ring.clear();
    }

    pub fn has_pub_key_ring(&self) -> bool {
        self.pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pub_key_ring(&mut self, v: PubKeyRing) {
        self.pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.pub_key_ring.is_none() {
            self.pub_key_ring.set_default();
        }
        self.pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_pub_key_ring(&mut self) -> PubKeyRing {
        self.pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // int64 takers_trade_price = 3;

    pub fn get_takers_trade_price(&self) -> i64 {
        self.takers_trade_price
    }
    pub fn clear_takers_trade_price(&mut self) {
        self.takers_trade_price = 0;
    }

    // Param is passed by value, moved
    pub fn set_takers_trade_price(&mut self, v: i64) {
        self.takers_trade_price = v;
    }

    // repeated int32 supported_capabilities = 4;

    pub fn get_supported_capabilities(&self) -> &[i32] {
        &self.supported_capabilities
    }
    pub fn clear_supported_capabilities(&mut self) {
        self.supported_capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_capabilities(&mut self, v: ::std::vec::Vec<i32>) {
        self.supported_capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_capabilities(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.supported_capabilities
    }

    // Take field
    pub fn take_supported_capabilities(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.supported_capabilities, ::std::vec::Vec::new())
    }

    // string uid = 5;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OfferAvailabilityRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.offer_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.pub_key_ring,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.takers_trade_price = tmp;
                }
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(
                        wire_type,
                        is,
                        &mut self.supported_capabilities,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.offer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.offer_id);
        }
        if let Some(ref v) = self.pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.takers_trade_price != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.takers_trade_price,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        for value in &self.supported_capabilities {
            my_size +=
                ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.offer_id.is_empty() {
            os.write_string(1, &self.offer_id)?;
        }
        if let Some(ref v) = self.pub_key_ring.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.takers_trade_price != 0 {
            os.write_int64(3, self.takers_trade_price)?;
        }
        for v in &self.supported_capabilities {
            os.write_int32(4, *v)?;
        }
        if !self.uid.is_empty() {
            os.write_string(5, &self.uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OfferAvailabilityRequest {
        OfferAvailabilityRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "offer_id",
                    |m: &OfferAvailabilityRequest| &m.offer_id,
                    |m: &mut OfferAvailabilityRequest| &mut m.offer_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "pub_key_ring",
                        |m: &OfferAvailabilityRequest| &m.pub_key_ring,
                        |m: &mut OfferAvailabilityRequest| &mut m.pub_key_ring,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "takers_trade_price",
                    |m: &OfferAvailabilityRequest| &m.takers_trade_price,
                    |m: &mut OfferAvailabilityRequest| &mut m.takers_trade_price,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "supported_capabilities",
                    |m: &OfferAvailabilityRequest| &m.supported_capabilities,
                    |m: &mut OfferAvailabilityRequest| &mut m.supported_capabilities,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &OfferAvailabilityRequest| &m.uid,
                    |m: &mut OfferAvailabilityRequest| &mut m.uid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OfferAvailabilityRequest>(
                    "OfferAvailabilityRequest",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static OfferAvailabilityRequest {
        static mut instance: ::protobuf::lazy::Lazy<OfferAvailabilityRequest> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const OfferAvailabilityRequest,
            };
        unsafe { instance.get(OfferAvailabilityRequest::new) }
    }
}

impl ::protobuf::Clear for OfferAvailabilityRequest {
    fn clear(&mut self) {
        self.offer_id.clear();
        self.pub_key_ring.clear();
        self.takers_trade_price = 0;
        self.supported_capabilities.clear();
        self.uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OfferAvailabilityRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OfferAvailabilityRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct OfferAvailabilityResponse {
    // message fields
    pub offer_id: ::std::string::String,
    pub availability_result: AvailabilityResult,
    pub supported_capabilities: ::std::vec::Vec<i32>,
    pub uid: ::std::string::String,
    pub arbitrator: ::protobuf::SingularPtrField<NodeAddress>,
    pub mediator: ::protobuf::SingularPtrField<NodeAddress>,
    pub refund_agent: ::protobuf::SingularPtrField<NodeAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OfferAvailabilityResponse {
    fn default() -> &'a OfferAvailabilityResponse {
        <OfferAvailabilityResponse as ::protobuf::Message>::default_instance()
    }
}

impl OfferAvailabilityResponse {
    pub fn new() -> OfferAvailabilityResponse {
        ::std::default::Default::default()
    }

    // string offer_id = 1;

    pub fn get_offer_id(&self) -> &str {
        &self.offer_id
    }
    pub fn clear_offer_id(&mut self) {
        self.offer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_offer_id(&mut self, v: ::std::string::String) {
        self.offer_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer_id(&mut self) -> &mut ::std::string::String {
        &mut self.offer_id
    }

    // Take field
    pub fn take_offer_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.offer_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.AvailabilityResult availability_result = 2;

    pub fn get_availability_result(&self) -> AvailabilityResult {
        self.availability_result
    }
    pub fn clear_availability_result(&mut self) {
        self.availability_result = AvailabilityResult::PB_ERROR;
    }

    // Param is passed by value, moved
    pub fn set_availability_result(&mut self, v: AvailabilityResult) {
        self.availability_result = v;
    }

    // repeated int32 supported_capabilities = 3;

    pub fn get_supported_capabilities(&self) -> &[i32] {
        &self.supported_capabilities
    }
    pub fn clear_supported_capabilities(&mut self) {
        self.supported_capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_capabilities(&mut self, v: ::std::vec::Vec<i32>) {
        self.supported_capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_capabilities(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.supported_capabilities
    }

    // Take field
    pub fn take_supported_capabilities(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.supported_capabilities, ::std::vec::Vec::new())
    }

    // string uid = 4;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.NodeAddress arbitrator = 5;

    pub fn get_arbitrator(&self) -> &NodeAddress {
        self.arbitrator
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_arbitrator(&mut self) {
        self.arbitrator.clear();
    }

    pub fn has_arbitrator(&self) -> bool {
        self.arbitrator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arbitrator(&mut self, v: NodeAddress) {
        self.arbitrator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arbitrator(&mut self) -> &mut NodeAddress {
        if self.arbitrator.is_none() {
            self.arbitrator.set_default();
        }
        self.arbitrator.as_mut().unwrap()
    }

    // Take field
    pub fn take_arbitrator(&mut self) -> NodeAddress {
        self.arbitrator.take().unwrap_or_else(|| NodeAddress::new())
    }

    // .io.bisq.protobuffer.NodeAddress mediator = 6;

    pub fn get_mediator(&self) -> &NodeAddress {
        self.mediator
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_mediator(&mut self) {
        self.mediator.clear();
    }

    pub fn has_mediator(&self) -> bool {
        self.mediator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediator(&mut self, v: NodeAddress) {
        self.mediator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediator(&mut self) -> &mut NodeAddress {
        if self.mediator.is_none() {
            self.mediator.set_default();
        }
        self.mediator.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediator(&mut self) -> NodeAddress {
        self.mediator.take().unwrap_or_else(|| NodeAddress::new())
    }

    // .io.bisq.protobuffer.NodeAddress refund_agent = 7;

    pub fn get_refund_agent(&self) -> &NodeAddress {
        self.refund_agent
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_refund_agent(&mut self) {
        self.refund_agent.clear();
    }

    pub fn has_refund_agent(&self) -> bool {
        self.refund_agent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refund_agent(&mut self, v: NodeAddress) {
        self.refund_agent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refund_agent(&mut self) -> &mut NodeAddress {
        if self.refund_agent.is_none() {
            self.refund_agent.set_default();
        }
        self.refund_agent.as_mut().unwrap()
    }

    // Take field
    pub fn take_refund_agent(&mut self) -> NodeAddress {
        self.refund_agent
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }
}

impl ::protobuf::Message for OfferAvailabilityResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.arbitrator {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.mediator {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.refund_agent {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.offer_id,
                    )?;
                }
                2 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.availability_result,
                    2,
                    &mut self.unknown_fields,
                )?,
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(
                        wire_type,
                        is,
                        &mut self.supported_capabilities,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                5 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.arbitrator,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mediator)?;
                }
                7 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.refund_agent,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.offer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.offer_id);
        }
        if self.availability_result != AvailabilityResult::PB_ERROR {
            my_size += ::protobuf::rt::enum_size(2, self.availability_result);
        }
        for value in &self.supported_capabilities {
            my_size +=
                ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.uid);
        }
        if let Some(ref v) = self.arbitrator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mediator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.refund_agent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.offer_id.is_empty() {
            os.write_string(1, &self.offer_id)?;
        }
        if self.availability_result != AvailabilityResult::PB_ERROR {
            os.write_enum(2, self.availability_result.value())?;
        }
        for v in &self.supported_capabilities {
            os.write_int32(3, *v)?;
        }
        if !self.uid.is_empty() {
            os.write_string(4, &self.uid)?;
        }
        if let Some(ref v) = self.arbitrator.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mediator.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.refund_agent.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OfferAvailabilityResponse {
        OfferAvailabilityResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "offer_id",
                    |m: &OfferAvailabilityResponse| &m.offer_id,
                    |m: &mut OfferAvailabilityResponse| &mut m.offer_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<AvailabilityResult>,
                >(
                    "availability_result",
                    |m: &OfferAvailabilityResponse| &m.availability_result,
                    |m: &mut OfferAvailabilityResponse| &mut m.availability_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "supported_capabilities",
                    |m: &OfferAvailabilityResponse| &m.supported_capabilities,
                    |m: &mut OfferAvailabilityResponse| &mut m.supported_capabilities,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &OfferAvailabilityResponse| &m.uid,
                    |m: &mut OfferAvailabilityResponse| &mut m.uid,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "arbitrator",
                        |m: &OfferAvailabilityResponse| &m.arbitrator,
                        |m: &mut OfferAvailabilityResponse| &mut m.arbitrator,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "mediator",
                        |m: &OfferAvailabilityResponse| &m.mediator,
                        |m: &mut OfferAvailabilityResponse| &mut m.mediator,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "refund_agent",
                        |m: &OfferAvailabilityResponse| &m.refund_agent,
                        |m: &mut OfferAvailabilityResponse| &mut m.refund_agent,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<OfferAvailabilityResponse>(
                    "OfferAvailabilityResponse",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static OfferAvailabilityResponse {
        static mut instance: ::protobuf::lazy::Lazy<OfferAvailabilityResponse> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const OfferAvailabilityResponse,
            };
        unsafe { instance.get(OfferAvailabilityResponse::new) }
    }
}

impl ::protobuf::Clear for OfferAvailabilityResponse {
    fn clear(&mut self) {
        self.offer_id.clear();
        self.availability_result = AvailabilityResult::PB_ERROR;
        self.supported_capabilities.clear();
        self.uid.clear();
        self.arbitrator.clear();
        self.mediator.clear();
        self.refund_agent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OfferAvailabilityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OfferAvailabilityResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RefreshOfferMessage {
    // message fields
    pub hash_of_data_and_seq_nr: ::std::vec::Vec<u8>,
    pub signature: ::std::vec::Vec<u8>,
    pub hash_of_payload: ::std::vec::Vec<u8>,
    pub sequence_number: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RefreshOfferMessage {
    fn default() -> &'a RefreshOfferMessage {
        <RefreshOfferMessage as ::protobuf::Message>::default_instance()
    }
}

impl RefreshOfferMessage {
    pub fn new() -> RefreshOfferMessage {
        ::std::default::Default::default()
    }

    // bytes hash_of_data_and_seq_nr = 1;

    pub fn get_hash_of_data_and_seq_nr(&self) -> &[u8] {
        &self.hash_of_data_and_seq_nr
    }
    pub fn clear_hash_of_data_and_seq_nr(&mut self) {
        self.hash_of_data_and_seq_nr.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash_of_data_and_seq_nr(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash_of_data_and_seq_nr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash_of_data_and_seq_nr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash_of_data_and_seq_nr
    }

    // Take field
    pub fn take_hash_of_data_and_seq_nr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash_of_data_and_seq_nr, ::std::vec::Vec::new())
    }

    // bytes signature = 2;

    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // bytes hash_of_payload = 3;

    pub fn get_hash_of_payload(&self) -> &[u8] {
        &self.hash_of_payload
    }
    pub fn clear_hash_of_payload(&mut self) {
        self.hash_of_payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash_of_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash_of_payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash_of_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash_of_payload
    }

    // Take field
    pub fn take_hash_of_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash_of_payload, ::std::vec::Vec::new())
    }

    // int32 sequence_number = 4;

    pub fn get_sequence_number(&self) -> i32 {
        self.sequence_number
    }
    pub fn clear_sequence_number(&mut self) {
        self.sequence_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence_number(&mut self, v: i32) {
        self.sequence_number = v;
    }
}

impl ::protobuf::Message for RefreshOfferMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.hash_of_data_and_seq_nr,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.signature,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.hash_of_payload,
                    )?;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.sequence_number = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash_of_data_and_seq_nr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash_of_data_and_seq_nr);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signature);
        }
        if !self.hash_of_payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.hash_of_payload);
        }
        if self.sequence_number != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.sequence_number,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.hash_of_data_and_seq_nr.is_empty() {
            os.write_bytes(1, &self.hash_of_data_and_seq_nr)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(2, &self.signature)?;
        }
        if !self.hash_of_payload.is_empty() {
            os.write_bytes(3, &self.hash_of_payload)?;
        }
        if self.sequence_number != 0 {
            os.write_int32(4, self.sequence_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RefreshOfferMessage {
        RefreshOfferMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "hash_of_data_and_seq_nr",
                    |m: &RefreshOfferMessage| &m.hash_of_data_and_seq_nr,
                    |m: &mut RefreshOfferMessage| &mut m.hash_of_data_and_seq_nr,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "signature",
                    |m: &RefreshOfferMessage| &m.signature,
                    |m: &mut RefreshOfferMessage| &mut m.signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "hash_of_payload",
                    |m: &RefreshOfferMessage| &m.hash_of_payload,
                    |m: &mut RefreshOfferMessage| &mut m.hash_of_payload,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "sequence_number",
                    |m: &RefreshOfferMessage| &m.sequence_number,
                    |m: &mut RefreshOfferMessage| &mut m.sequence_number,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RefreshOfferMessage>(
                    "RefreshOfferMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static RefreshOfferMessage {
        static mut instance: ::protobuf::lazy::Lazy<RefreshOfferMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RefreshOfferMessage,
        };
        unsafe { instance.get(RefreshOfferMessage::new) }
    }
}

impl ::protobuf::Clear for RefreshOfferMessage {
    fn clear(&mut self) {
        self.hash_of_data_and_seq_nr.clear();
        self.signature.clear();
        self.hash_of_payload.clear();
        self.sequence_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefreshOfferMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefreshOfferMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct AddDataMessage {
    // message fields
    pub entry: ::protobuf::SingularPtrField<StorageEntryWrapper>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddDataMessage {
    fn default() -> &'a AddDataMessage {
        <AddDataMessage as ::protobuf::Message>::default_instance()
    }
}

impl AddDataMessage {
    pub fn new() -> AddDataMessage {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.StorageEntryWrapper entry = 1;

    pub fn get_entry(&self) -> &StorageEntryWrapper {
        self.entry
            .as_ref()
            .unwrap_or_else(|| StorageEntryWrapper::default_instance())
    }
    pub fn clear_entry(&mut self) {
        self.entry.clear();
    }

    pub fn has_entry(&self) -> bool {
        self.entry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entry(&mut self, v: StorageEntryWrapper) {
        self.entry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entry(&mut self) -> &mut StorageEntryWrapper {
        if self.entry.is_none() {
            self.entry.set_default();
        }
        self.entry.as_mut().unwrap()
    }

    // Take field
    pub fn take_entry(&mut self) -> StorageEntryWrapper {
        self.entry
            .take()
            .unwrap_or_else(|| StorageEntryWrapper::new())
    }
}

impl ::protobuf::Message for AddDataMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.entry)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.entry.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddDataMessage {
        AddDataMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<StorageEntryWrapper>,
                    >(
                        "entry",
                        |m: &AddDataMessage| &m.entry,
                        |m: &mut AddDataMessage| &mut m.entry,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<AddDataMessage>(
                    "AddDataMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static AddDataMessage {
        static mut instance: ::protobuf::lazy::Lazy<AddDataMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddDataMessage,
        };
        unsafe { instance.get(AddDataMessage::new) }
    }
}

impl ::protobuf::Clear for AddDataMessage {
    fn clear(&mut self) {
        self.entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddDataMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddDataMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RemoveDataMessage {
    // message fields
    pub protected_storage_entry: ::protobuf::SingularPtrField<ProtectedStorageEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDataMessage {
    fn default() -> &'a RemoveDataMessage {
        <RemoveDataMessage as ::protobuf::Message>::default_instance()
    }
}

impl RemoveDataMessage {
    pub fn new() -> RemoveDataMessage {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.ProtectedStorageEntry protected_storage_entry = 1;

    pub fn get_protected_storage_entry(&self) -> &ProtectedStorageEntry {
        self.protected_storage_entry
            .as_ref()
            .unwrap_or_else(|| ProtectedStorageEntry::default_instance())
    }
    pub fn clear_protected_storage_entry(&mut self) {
        self.protected_storage_entry.clear();
    }

    pub fn has_protected_storage_entry(&self) -> bool {
        self.protected_storage_entry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protected_storage_entry(&mut self, v: ProtectedStorageEntry) {
        self.protected_storage_entry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protected_storage_entry(&mut self) -> &mut ProtectedStorageEntry {
        if self.protected_storage_entry.is_none() {
            self.protected_storage_entry.set_default();
        }
        self.protected_storage_entry.as_mut().unwrap()
    }

    // Take field
    pub fn take_protected_storage_entry(&mut self) -> ProtectedStorageEntry {
        self.protected_storage_entry
            .take()
            .unwrap_or_else(|| ProtectedStorageEntry::new())
    }
}

impl ::protobuf::Message for RemoveDataMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.protected_storage_entry {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.protected_storage_entry,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.protected_storage_entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.protected_storage_entry.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDataMessage {
        RemoveDataMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<ProtectedStorageEntry>,
                    >(
                        "protected_storage_entry",
                        |m: &RemoveDataMessage| &m.protected_storage_entry,
                        |m: &mut RemoveDataMessage| &mut m.protected_storage_entry,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<RemoveDataMessage>(
                    "RemoveDataMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDataMessage {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDataMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveDataMessage,
        };
        unsafe { instance.get(RemoveDataMessage::new) }
    }
}

impl ::protobuf::Clear for RemoveDataMessage {
    fn clear(&mut self) {
        self.protected_storage_entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDataMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDataMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RemoveMailboxDataMessage {
    // message fields
    pub protected_storage_entry: ::protobuf::SingularPtrField<ProtectedMailboxStorageEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveMailboxDataMessage {
    fn default() -> &'a RemoveMailboxDataMessage {
        <RemoveMailboxDataMessage as ::protobuf::Message>::default_instance()
    }
}

impl RemoveMailboxDataMessage {
    pub fn new() -> RemoveMailboxDataMessage {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.ProtectedMailboxStorageEntry protected_storage_entry = 1;

    pub fn get_protected_storage_entry(&self) -> &ProtectedMailboxStorageEntry {
        self.protected_storage_entry
            .as_ref()
            .unwrap_or_else(|| ProtectedMailboxStorageEntry::default_instance())
    }
    pub fn clear_protected_storage_entry(&mut self) {
        self.protected_storage_entry.clear();
    }

    pub fn has_protected_storage_entry(&self) -> bool {
        self.protected_storage_entry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protected_storage_entry(&mut self, v: ProtectedMailboxStorageEntry) {
        self.protected_storage_entry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protected_storage_entry(&mut self) -> &mut ProtectedMailboxStorageEntry {
        if self.protected_storage_entry.is_none() {
            self.protected_storage_entry.set_default();
        }
        self.protected_storage_entry.as_mut().unwrap()
    }

    // Take field
    pub fn take_protected_storage_entry(&mut self) -> ProtectedMailboxStorageEntry {
        self.protected_storage_entry
            .take()
            .unwrap_or_else(|| ProtectedMailboxStorageEntry::new())
    }
}

impl ::protobuf::Message for RemoveMailboxDataMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.protected_storage_entry {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.protected_storage_entry,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.protected_storage_entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.protected_storage_entry.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveMailboxDataMessage {
        RemoveMailboxDataMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<ProtectedMailboxStorageEntry>,
                    >(
                        "protected_storage_entry",
                        |m: &RemoveMailboxDataMessage| &m.protected_storage_entry,
                        |m: &mut RemoveMailboxDataMessage| &mut m.protected_storage_entry,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<RemoveMailboxDataMessage>(
                    "RemoveMailboxDataMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveMailboxDataMessage {
        static mut instance: ::protobuf::lazy::Lazy<RemoveMailboxDataMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const RemoveMailboxDataMessage,
            };
        unsafe { instance.get(RemoveMailboxDataMessage::new) }
    }
}

impl ::protobuf::Clear for RemoveMailboxDataMessage {
    fn clear(&mut self) {
        self.protected_storage_entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveMailboxDataMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveMailboxDataMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct AddPersistableNetworkPayloadMessage {
    // message fields
    pub payload: ::protobuf::SingularPtrField<PersistableNetworkPayload>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddPersistableNetworkPayloadMessage {
    fn default() -> &'a AddPersistableNetworkPayloadMessage {
        <AddPersistableNetworkPayloadMessage as ::protobuf::Message>::default_instance()
    }
}

impl AddPersistableNetworkPayloadMessage {
    pub fn new() -> AddPersistableNetworkPayloadMessage {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.PersistableNetworkPayload payload = 1;

    pub fn get_payload(&self) -> &PersistableNetworkPayload {
        self.payload
            .as_ref()
            .unwrap_or_else(|| PersistableNetworkPayload::default_instance())
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: PersistableNetworkPayload) {
        self.payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut PersistableNetworkPayload {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> PersistableNetworkPayload {
        self.payload
            .take()
            .unwrap_or_else(|| PersistableNetworkPayload::new())
    }
}

impl ::protobuf::Message for AddPersistableNetworkPayloadMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.payload {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payload)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.payload.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddPersistableNetworkPayloadMessage {
        AddPersistableNetworkPayloadMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PersistableNetworkPayload>,
                    >(
                        "payload",
                        |m: &AddPersistableNetworkPayloadMessage| &m.payload,
                        |m: &mut AddPersistableNetworkPayloadMessage| &mut m.payload,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<AddPersistableNetworkPayloadMessage>(
                    "AddPersistableNetworkPayloadMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static AddPersistableNetworkPayloadMessage {
        static mut instance: ::protobuf::lazy::Lazy<AddPersistableNetworkPayloadMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const AddPersistableNetworkPayloadMessage,
            };
        unsafe { instance.get(AddPersistableNetworkPayloadMessage::new) }
    }
}

impl ::protobuf::Clear for AddPersistableNetworkPayloadMessage {
    fn clear(&mut self) {
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddPersistableNetworkPayloadMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddPersistableNetworkPayloadMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct CloseConnectionMessage {
    // message fields
    pub reason: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloseConnectionMessage {
    fn default() -> &'a CloseConnectionMessage {
        <CloseConnectionMessage as ::protobuf::Message>::default_instance()
    }
}

impl CloseConnectionMessage {
    pub fn new() -> CloseConnectionMessage {
        ::std::default::Default::default()
    }

    // string reason = 1;

    pub fn get_reason(&self) -> &str {
        &self.reason
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        &mut self.reason
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reason, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CloseConnectionMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.reason,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.reason.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.reason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.reason.is_empty() {
            os.write_string(1, &self.reason)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseConnectionMessage {
        CloseConnectionMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "reason",
                    |m: &CloseConnectionMessage| &m.reason,
                    |m: &mut CloseConnectionMessage| &mut m.reason,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CloseConnectionMessage>(
                    "CloseConnectionMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static CloseConnectionMessage {
        static mut instance: ::protobuf::lazy::Lazy<CloseConnectionMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const CloseConnectionMessage,
            };
        unsafe { instance.get(CloseConnectionMessage::new) }
    }
}

impl ::protobuf::Clear for CloseConnectionMessage {
    fn clear(&mut self) {
        self.reason.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseConnectionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseConnectionMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct AckMessage {
    // message fields
    pub uid: ::std::string::String,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub source_type: ::std::string::String,
    pub source_msg_class_name: ::std::string::String,
    pub source_uid: ::std::string::String,
    pub source_id: ::std::string::String,
    pub success: bool,
    pub error_message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AckMessage {
    fn default() -> &'a AckMessage {
        <AckMessage as ::protobuf::Message>::default_instance()
    }
}

impl AckMessage {
    pub fn new() -> AckMessage {
        ::std::default::Default::default()
    }

    // string uid = 1;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 2;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // string source_type = 3;

    pub fn get_source_type(&self) -> &str {
        &self.source_type
    }
    pub fn clear_source_type(&mut self) {
        self.source_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_type(&mut self, v: ::std::string::String) {
        self.source_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_type(&mut self) -> &mut ::std::string::String {
        &mut self.source_type
    }

    // Take field
    pub fn take_source_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_type, ::std::string::String::new())
    }

    // string source_msg_class_name = 4;

    pub fn get_source_msg_class_name(&self) -> &str {
        &self.source_msg_class_name
    }
    pub fn clear_source_msg_class_name(&mut self) {
        self.source_msg_class_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_msg_class_name(&mut self, v: ::std::string::String) {
        self.source_msg_class_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_msg_class_name(&mut self) -> &mut ::std::string::String {
        &mut self.source_msg_class_name
    }

    // Take field
    pub fn take_source_msg_class_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.source_msg_class_name,
            ::std::string::String::new(),
        )
    }

    // string source_uid = 5;

    pub fn get_source_uid(&self) -> &str {
        &self.source_uid
    }
    pub fn clear_source_uid(&mut self) {
        self.source_uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_uid(&mut self, v: ::std::string::String) {
        self.source_uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_uid(&mut self) -> &mut ::std::string::String {
        &mut self.source_uid
    }

    // Take field
    pub fn take_source_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_uid, ::std::string::String::new())
    }

    // string source_id = 6;

    pub fn get_source_id(&self) -> &str {
        &self.source_id
    }
    pub fn clear_source_id(&mut self) {
        self.source_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_id(&mut self, v: ::std::string::String) {
        self.source_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_id(&mut self) -> &mut ::std::string::String {
        &mut self.source_id
    }

    // Take field
    pub fn take_source_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_id, ::std::string::String::new())
    }

    // bool success = 7;

    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string error_message = 8;

    pub fn get_error_message(&self) -> &str {
        &self.error_message
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        &mut self.error_message
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AckMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.source_type,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.source_msg_class_name,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.source_uid,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.source_id,
                    )?;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                }
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.error_message,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.source_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source_type);
        }
        if !self.source_msg_class_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.source_msg_class_name);
        }
        if !self.source_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.source_uid);
        }
        if !self.source_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.source_id);
        }
        if self.success != false {
            my_size += 2;
        }
        if !self.error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.error_message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.source_type.is_empty() {
            os.write_string(3, &self.source_type)?;
        }
        if !self.source_msg_class_name.is_empty() {
            os.write_string(4, &self.source_msg_class_name)?;
        }
        if !self.source_uid.is_empty() {
            os.write_string(5, &self.source_uid)?;
        }
        if !self.source_id.is_empty() {
            os.write_string(6, &self.source_id)?;
        }
        if self.success != false {
            os.write_bool(7, self.success)?;
        }
        if !self.error_message.is_empty() {
            os.write_string(8, &self.error_message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AckMessage {
        AckMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &AckMessage| &m.uid,
                    |m: &mut AckMessage| &mut m.uid,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &AckMessage| &m.sender_node_address,
                        |m: &mut AckMessage| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "source_type",
                    |m: &AckMessage| &m.source_type,
                    |m: &mut AckMessage| &mut m.source_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "source_msg_class_name",
                    |m: &AckMessage| &m.source_msg_class_name,
                    |m: &mut AckMessage| &mut m.source_msg_class_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "source_uid",
                    |m: &AckMessage| &m.source_uid,
                    |m: &mut AckMessage| &mut m.source_uid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "source_id",
                    |m: &AckMessage| &m.source_id,
                    |m: &mut AckMessage| &mut m.source_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "success",
                    |m: &AckMessage| &m.success,
                    |m: &mut AckMessage| &mut m.success,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "error_message",
                    |m: &AckMessage| &m.error_message,
                    |m: &mut AckMessage| &mut m.error_message,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AckMessage>(
                    "AckMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static AckMessage {
        static mut instance: ::protobuf::lazy::Lazy<AckMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AckMessage,
        };
        unsafe { instance.get(AckMessage::new) }
    }
}

impl ::protobuf::Clear for AckMessage {
    fn clear(&mut self) {
        self.uid.clear();
        self.sender_node_address.clear();
        self.source_type.clear();
        self.source_msg_class_name.clear();
        self.source_uid.clear();
        self.source_id.clear();
        self.success = false;
        self.error_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AckMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AckMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PrefixedSealedAndSignedMessage {
    // message fields
    pub node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub sealed_and_signed: ::protobuf::SingularPtrField<SealedAndSigned>,
    pub address_prefix_hash: ::std::vec::Vec<u8>,
    pub uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrefixedSealedAndSignedMessage {
    fn default() -> &'a PrefixedSealedAndSignedMessage {
        <PrefixedSealedAndSignedMessage as ::protobuf::Message>::default_instance()
    }
}

impl PrefixedSealedAndSignedMessage {
    pub fn new() -> PrefixedSealedAndSignedMessage {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.NodeAddress node_address = 1;

    pub fn get_node_address(&self) -> &NodeAddress {
        self.node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_node_address(&mut self) {
        self.node_address.clear();
    }

    pub fn has_node_address(&self) -> bool {
        self.node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_address(&mut self, v: NodeAddress) {
        self.node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_address(&mut self) -> &mut NodeAddress {
        if self.node_address.is_none() {
            self.node_address.set_default();
        }
        self.node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_node_address(&mut self) -> NodeAddress {
        self.node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // .io.bisq.protobuffer.SealedAndSigned sealed_and_signed = 2;

    pub fn get_sealed_and_signed(&self) -> &SealedAndSigned {
        self.sealed_and_signed
            .as_ref()
            .unwrap_or_else(|| SealedAndSigned::default_instance())
    }
    pub fn clear_sealed_and_signed(&mut self) {
        self.sealed_and_signed.clear();
    }

    pub fn has_sealed_and_signed(&self) -> bool {
        self.sealed_and_signed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sealed_and_signed(&mut self, v: SealedAndSigned) {
        self.sealed_and_signed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sealed_and_signed(&mut self) -> &mut SealedAndSigned {
        if self.sealed_and_signed.is_none() {
            self.sealed_and_signed.set_default();
        }
        self.sealed_and_signed.as_mut().unwrap()
    }

    // Take field
    pub fn take_sealed_and_signed(&mut self) -> SealedAndSigned {
        self.sealed_and_signed
            .take()
            .unwrap_or_else(|| SealedAndSigned::new())
    }

    // bytes address_prefix_hash = 3;

    pub fn get_address_prefix_hash(&self) -> &[u8] {
        &self.address_prefix_hash
    }
    pub fn clear_address_prefix_hash(&mut self) {
        self.address_prefix_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_prefix_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.address_prefix_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address_prefix_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address_prefix_hash
    }

    // Take field
    pub fn take_address_prefix_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address_prefix_hash, ::std::vec::Vec::new())
    }

    // string uid = 4;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PrefixedSealedAndSignedMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.sealed_and_signed {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.node_address,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sealed_and_signed,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.address_prefix_hash,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sealed_and_signed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.address_prefix_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.address_prefix_hash);
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.node_address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sealed_and_signed.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.address_prefix_hash.is_empty() {
            os.write_bytes(3, &self.address_prefix_hash)?;
        }
        if !self.uid.is_empty() {
            os.write_string(4, &self.uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrefixedSealedAndSignedMessage {
        PrefixedSealedAndSignedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "node_address",
                        |m: &PrefixedSealedAndSignedMessage| &m.node_address,
                        |m: &mut PrefixedSealedAndSignedMessage| &mut m.node_address,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<SealedAndSigned>,
                    >(
                        "sealed_and_signed",
                        |m: &PrefixedSealedAndSignedMessage| &m.sealed_and_signed,
                        |m: &mut PrefixedSealedAndSignedMessage| &mut m.sealed_and_signed,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "address_prefix_hash",
                    |m: &PrefixedSealedAndSignedMessage| &m.address_prefix_hash,
                    |m: &mut PrefixedSealedAndSignedMessage| &mut m.address_prefix_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &PrefixedSealedAndSignedMessage| &m.uid,
                    |m: &mut PrefixedSealedAndSignedMessage| &mut m.uid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PrefixedSealedAndSignedMessage>(
                    "PrefixedSealedAndSignedMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PrefixedSealedAndSignedMessage {
        static mut instance: ::protobuf::lazy::Lazy<PrefixedSealedAndSignedMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PrefixedSealedAndSignedMessage,
            };
        unsafe { instance.get(PrefixedSealedAndSignedMessage::new) }
    }
}

impl ::protobuf::Clear for PrefixedSealedAndSignedMessage {
    fn clear(&mut self) {
        self.node_address.clear();
        self.sealed_and_signed.clear();
        self.address_prefix_hash.clear();
        self.uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrefixedSealedAndSignedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrefixedSealedAndSignedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct InputsForDepositTxRequest {
    // message fields
    pub trade_id: ::std::string::String,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub trade_amount: i64,
    pub trade_price: i64,
    pub tx_fee: i64,
    pub taker_fee: i64,
    pub is_currency_for_taker_fee_btc: bool,
    pub raw_transaction_inputs: ::protobuf::RepeatedField<RawTransactionInput>,
    pub change_output_value: i64,
    pub change_output_address: ::std::string::String,
    pub taker_multi_sig_pub_key: ::std::vec::Vec<u8>,
    pub taker_payout_address_string: ::std::string::String,
    pub taker_pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub taker_payment_account_payload: ::protobuf::SingularPtrField<PaymentAccountPayload>,
    pub taker_account_id: ::std::string::String,
    pub taker_fee_tx_id: ::std::string::String,
    pub accepted_arbitrator_node_addresses: ::protobuf::RepeatedField<NodeAddress>,
    pub accepted_mediator_node_addresses: ::protobuf::RepeatedField<NodeAddress>,
    pub arbitrator_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub mediator_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub uid: ::std::string::String,
    pub account_age_witness_signature_of_offer_id: ::std::vec::Vec<u8>,
    pub current_date: i64,
    pub accepted_refund_agent_node_addresses: ::protobuf::RepeatedField<NodeAddress>,
    pub refund_agent_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InputsForDepositTxRequest {
    fn default() -> &'a InputsForDepositTxRequest {
        <InputsForDepositTxRequest as ::protobuf::Message>::default_instance()
    }
}

impl InputsForDepositTxRequest {
    pub fn new() -> InputsForDepositTxRequest {
        ::std::default::Default::default()
    }

    // string trade_id = 1;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 2;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // int64 trade_amount = 3;

    pub fn get_trade_amount(&self) -> i64 {
        self.trade_amount
    }
    pub fn clear_trade_amount(&mut self) {
        self.trade_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_amount(&mut self, v: i64) {
        self.trade_amount = v;
    }

    // int64 trade_price = 4;

    pub fn get_trade_price(&self) -> i64 {
        self.trade_price
    }
    pub fn clear_trade_price(&mut self) {
        self.trade_price = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_price(&mut self, v: i64) {
        self.trade_price = v;
    }

    // int64 tx_fee = 5;

    pub fn get_tx_fee(&self) -> i64 {
        self.tx_fee
    }
    pub fn clear_tx_fee(&mut self) {
        self.tx_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_fee(&mut self, v: i64) {
        self.tx_fee = v;
    }

    // int64 taker_fee = 6;

    pub fn get_taker_fee(&self) -> i64 {
        self.taker_fee
    }
    pub fn clear_taker_fee(&mut self) {
        self.taker_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_taker_fee(&mut self, v: i64) {
        self.taker_fee = v;
    }

    // bool is_currency_for_taker_fee_btc = 7;

    pub fn get_is_currency_for_taker_fee_btc(&self) -> bool {
        self.is_currency_for_taker_fee_btc
    }
    pub fn clear_is_currency_for_taker_fee_btc(&mut self) {
        self.is_currency_for_taker_fee_btc = false;
    }

    // Param is passed by value, moved
    pub fn set_is_currency_for_taker_fee_btc(&mut self, v: bool) {
        self.is_currency_for_taker_fee_btc = v;
    }

    // repeated .io.bisq.protobuffer.RawTransactionInput raw_transaction_inputs = 8;

    pub fn get_raw_transaction_inputs(&self) -> &[RawTransactionInput] {
        &self.raw_transaction_inputs
    }
    pub fn clear_raw_transaction_inputs(&mut self) {
        self.raw_transaction_inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_transaction_inputs(
        &mut self,
        v: ::protobuf::RepeatedField<RawTransactionInput>,
    ) {
        self.raw_transaction_inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_raw_transaction_inputs(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<RawTransactionInput> {
        &mut self.raw_transaction_inputs
    }

    // Take field
    pub fn take_raw_transaction_inputs(
        &mut self,
    ) -> ::protobuf::RepeatedField<RawTransactionInput> {
        ::std::mem::replace(
            &mut self.raw_transaction_inputs,
            ::protobuf::RepeatedField::new(),
        )
    }

    // int64 change_output_value = 9;

    pub fn get_change_output_value(&self) -> i64 {
        self.change_output_value
    }
    pub fn clear_change_output_value(&mut self) {
        self.change_output_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_change_output_value(&mut self, v: i64) {
        self.change_output_value = v;
    }

    // string change_output_address = 10;

    pub fn get_change_output_address(&self) -> &str {
        &self.change_output_address
    }
    pub fn clear_change_output_address(&mut self) {
        self.change_output_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_change_output_address(&mut self, v: ::std::string::String) {
        self.change_output_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_output_address(&mut self) -> &mut ::std::string::String {
        &mut self.change_output_address
    }

    // Take field
    pub fn take_change_output_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.change_output_address,
            ::std::string::String::new(),
        )
    }

    // bytes taker_multi_sig_pub_key = 11;

    pub fn get_taker_multi_sig_pub_key(&self) -> &[u8] {
        &self.taker_multi_sig_pub_key
    }
    pub fn clear_taker_multi_sig_pub_key(&mut self) {
        self.taker_multi_sig_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_multi_sig_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.taker_multi_sig_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_multi_sig_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.taker_multi_sig_pub_key
    }

    // Take field
    pub fn take_taker_multi_sig_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.taker_multi_sig_pub_key, ::std::vec::Vec::new())
    }

    // string taker_payout_address_string = 12;

    pub fn get_taker_payout_address_string(&self) -> &str {
        &self.taker_payout_address_string
    }
    pub fn clear_taker_payout_address_string(&mut self) {
        self.taker_payout_address_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_payout_address_string(&mut self, v: ::std::string::String) {
        self.taker_payout_address_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_payout_address_string(&mut self) -> &mut ::std::string::String {
        &mut self.taker_payout_address_string
    }

    // Take field
    pub fn take_taker_payout_address_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.taker_payout_address_string,
            ::std::string::String::new(),
        )
    }

    // .io.bisq.protobuffer.PubKeyRing taker_pub_key_ring = 13;

    pub fn get_taker_pub_key_ring(&self) -> &PubKeyRing {
        self.taker_pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_taker_pub_key_ring(&mut self) {
        self.taker_pub_key_ring.clear();
    }

    pub fn has_taker_pub_key_ring(&self) -> bool {
        self.taker_pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taker_pub_key_ring(&mut self, v: PubKeyRing) {
        self.taker_pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.taker_pub_key_ring.is_none() {
            self.taker_pub_key_ring.set_default();
        }
        self.taker_pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_taker_pub_key_ring(&mut self) -> PubKeyRing {
        self.taker_pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // .io.bisq.protobuffer.PaymentAccountPayload taker_payment_account_payload = 14;

    pub fn get_taker_payment_account_payload(&self) -> &PaymentAccountPayload {
        self.taker_payment_account_payload
            .as_ref()
            .unwrap_or_else(|| PaymentAccountPayload::default_instance())
    }
    pub fn clear_taker_payment_account_payload(&mut self) {
        self.taker_payment_account_payload.clear();
    }

    pub fn has_taker_payment_account_payload(&self) -> bool {
        self.taker_payment_account_payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taker_payment_account_payload(&mut self, v: PaymentAccountPayload) {
        self.taker_payment_account_payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_payment_account_payload(&mut self) -> &mut PaymentAccountPayload {
        if self.taker_payment_account_payload.is_none() {
            self.taker_payment_account_payload.set_default();
        }
        self.taker_payment_account_payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_taker_payment_account_payload(&mut self) -> PaymentAccountPayload {
        self.taker_payment_account_payload
            .take()
            .unwrap_or_else(|| PaymentAccountPayload::new())
    }

    // string taker_account_id = 15;

    pub fn get_taker_account_id(&self) -> &str {
        &self.taker_account_id
    }
    pub fn clear_taker_account_id(&mut self) {
        self.taker_account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_account_id(&mut self, v: ::std::string::String) {
        self.taker_account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.taker_account_id
    }

    // Take field
    pub fn take_taker_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_account_id, ::std::string::String::new())
    }

    // string taker_fee_tx_id = 16;

    pub fn get_taker_fee_tx_id(&self) -> &str {
        &self.taker_fee_tx_id
    }
    pub fn clear_taker_fee_tx_id(&mut self) {
        self.taker_fee_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_tx_id(&mut self, v: ::std::string::String) {
        self.taker_fee_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_tx_id
    }

    // Take field
    pub fn take_taker_fee_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_tx_id, ::std::string::String::new())
    }

    // repeated .io.bisq.protobuffer.NodeAddress accepted_arbitrator_node_addresses = 17;

    pub fn get_accepted_arbitrator_node_addresses(&self) -> &[NodeAddress] {
        &self.accepted_arbitrator_node_addresses
    }
    pub fn clear_accepted_arbitrator_node_addresses(&mut self) {
        self.accepted_arbitrator_node_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_accepted_arbitrator_node_addresses(
        &mut self,
        v: ::protobuf::RepeatedField<NodeAddress>,
    ) {
        self.accepted_arbitrator_node_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accepted_arbitrator_node_addresses(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<NodeAddress> {
        &mut self.accepted_arbitrator_node_addresses
    }

    // Take field
    pub fn take_accepted_arbitrator_node_addresses(
        &mut self,
    ) -> ::protobuf::RepeatedField<NodeAddress> {
        ::std::mem::replace(
            &mut self.accepted_arbitrator_node_addresses,
            ::protobuf::RepeatedField::new(),
        )
    }

    // repeated .io.bisq.protobuffer.NodeAddress accepted_mediator_node_addresses = 18;

    pub fn get_accepted_mediator_node_addresses(&self) -> &[NodeAddress] {
        &self.accepted_mediator_node_addresses
    }
    pub fn clear_accepted_mediator_node_addresses(&mut self) {
        self.accepted_mediator_node_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_accepted_mediator_node_addresses(
        &mut self,
        v: ::protobuf::RepeatedField<NodeAddress>,
    ) {
        self.accepted_mediator_node_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accepted_mediator_node_addresses(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<NodeAddress> {
        &mut self.accepted_mediator_node_addresses
    }

    // Take field
    pub fn take_accepted_mediator_node_addresses(
        &mut self,
    ) -> ::protobuf::RepeatedField<NodeAddress> {
        ::std::mem::replace(
            &mut self.accepted_mediator_node_addresses,
            ::protobuf::RepeatedField::new(),
        )
    }

    // .io.bisq.protobuffer.NodeAddress arbitrator_node_address = 19;

    pub fn get_arbitrator_node_address(&self) -> &NodeAddress {
        self.arbitrator_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_arbitrator_node_address(&mut self) {
        self.arbitrator_node_address.clear();
    }

    pub fn has_arbitrator_node_address(&self) -> bool {
        self.arbitrator_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arbitrator_node_address(&mut self, v: NodeAddress) {
        self.arbitrator_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arbitrator_node_address(&mut self) -> &mut NodeAddress {
        if self.arbitrator_node_address.is_none() {
            self.arbitrator_node_address.set_default();
        }
        self.arbitrator_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_arbitrator_node_address(&mut self) -> NodeAddress {
        self.arbitrator_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // .io.bisq.protobuffer.NodeAddress mediator_node_address = 20;

    pub fn get_mediator_node_address(&self) -> &NodeAddress {
        self.mediator_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_mediator_node_address(&mut self) {
        self.mediator_node_address.clear();
    }

    pub fn has_mediator_node_address(&self) -> bool {
        self.mediator_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediator_node_address(&mut self, v: NodeAddress) {
        self.mediator_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediator_node_address(&mut self) -> &mut NodeAddress {
        if self.mediator_node_address.is_none() {
            self.mediator_node_address.set_default();
        }
        self.mediator_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediator_node_address(&mut self) -> NodeAddress {
        self.mediator_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // string uid = 21;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // bytes account_age_witness_signature_of_offer_id = 22;

    pub fn get_account_age_witness_signature_of_offer_id(&self) -> &[u8] {
        &self.account_age_witness_signature_of_offer_id
    }
    pub fn clear_account_age_witness_signature_of_offer_id(&mut self) {
        self.account_age_witness_signature_of_offer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_age_witness_signature_of_offer_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_age_witness_signature_of_offer_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_age_witness_signature_of_offer_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_age_witness_signature_of_offer_id
    }

    // Take field
    pub fn take_account_age_witness_signature_of_offer_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(
            &mut self.account_age_witness_signature_of_offer_id,
            ::std::vec::Vec::new(),
        )
    }

    // int64 current_date = 23;

    pub fn get_current_date(&self) -> i64 {
        self.current_date
    }
    pub fn clear_current_date(&mut self) {
        self.current_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_date(&mut self, v: i64) {
        self.current_date = v;
    }

    // repeated .io.bisq.protobuffer.NodeAddress accepted_refund_agent_node_addresses = 24;

    pub fn get_accepted_refund_agent_node_addresses(&self) -> &[NodeAddress] {
        &self.accepted_refund_agent_node_addresses
    }
    pub fn clear_accepted_refund_agent_node_addresses(&mut self) {
        self.accepted_refund_agent_node_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_accepted_refund_agent_node_addresses(
        &mut self,
        v: ::protobuf::RepeatedField<NodeAddress>,
    ) {
        self.accepted_refund_agent_node_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accepted_refund_agent_node_addresses(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<NodeAddress> {
        &mut self.accepted_refund_agent_node_addresses
    }

    // Take field
    pub fn take_accepted_refund_agent_node_addresses(
        &mut self,
    ) -> ::protobuf::RepeatedField<NodeAddress> {
        ::std::mem::replace(
            &mut self.accepted_refund_agent_node_addresses,
            ::protobuf::RepeatedField::new(),
        )
    }

    // .io.bisq.protobuffer.NodeAddress refund_agent_node_address = 25;

    pub fn get_refund_agent_node_address(&self) -> &NodeAddress {
        self.refund_agent_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_refund_agent_node_address(&mut self) {
        self.refund_agent_node_address.clear();
    }

    pub fn has_refund_agent_node_address(&self) -> bool {
        self.refund_agent_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refund_agent_node_address(&mut self, v: NodeAddress) {
        self.refund_agent_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refund_agent_node_address(&mut self) -> &mut NodeAddress {
        if self.refund_agent_node_address.is_none() {
            self.refund_agent_node_address.set_default();
        }
        self.refund_agent_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_refund_agent_node_address(&mut self) -> NodeAddress {
        self.refund_agent_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }
}

impl ::protobuf::Message for InputsForDepositTxRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.raw_transaction_inputs {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.taker_pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.taker_payment_account_payload {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.accepted_arbitrator_node_addresses {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.accepted_mediator_node_addresses {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.arbitrator_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.mediator_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.accepted_refund_agent_node_addresses {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.refund_agent_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.trade_amount = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.trade_price = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.tx_fee = tmp;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.taker_fee = tmp;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_currency_for_taker_fee_btc = tmp;
                }
                8 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.raw_transaction_inputs,
                    )?;
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.change_output_value = tmp;
                }
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.change_output_address,
                    )?;
                }
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.taker_multi_sig_pub_key,
                    )?;
                }
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.taker_payout_address_string,
                    )?;
                }
                13 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.taker_pub_key_ring,
                    )?;
                }
                14 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.taker_payment_account_payload,
                    )?;
                }
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.taker_account_id,
                    )?;
                }
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.taker_fee_tx_id,
                    )?;
                }
                17 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.accepted_arbitrator_node_addresses,
                    )?;
                }
                18 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.accepted_mediator_node_addresses,
                    )?;
                }
                19 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.arbitrator_node_address,
                    )?;
                }
                20 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.mediator_node_address,
                    )?;
                }
                21 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                22 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.account_age_witness_signature_of_offer_id,
                    )?;
                }
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.current_date = tmp;
                }
                24 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.accepted_refund_agent_node_addresses,
                    )?;
                }
                25 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.refund_agent_node_address,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.trade_id);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.trade_amount != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.trade_amount,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.trade_price != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.trade_price,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.tx_fee != 0 {
            my_size +=
                ::protobuf::rt::value_size(5, self.tx_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.taker_fee != 0 {
            my_size += ::protobuf::rt::value_size(
                6,
                self.taker_fee,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.is_currency_for_taker_fee_btc != false {
            my_size += 2;
        }
        for value in &self.raw_transaction_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.change_output_value != 0 {
            my_size += ::protobuf::rt::value_size(
                9,
                self.change_output_value,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.change_output_address.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.change_output_address);
        }
        if !self.taker_multi_sig_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.taker_multi_sig_pub_key);
        }
        if !self.taker_payout_address_string.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.taker_payout_address_string);
        }
        if let Some(ref v) = self.taker_pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.taker_payment_account_payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.taker_account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.taker_account_id);
        }
        if !self.taker_fee_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.taker_fee_tx_id);
        }
        for value in &self.accepted_arbitrator_node_addresses {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.accepted_mediator_node_addresses {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.arbitrator_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mediator_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.uid);
        }
        if !self.account_age_witness_signature_of_offer_id.is_empty() {
            my_size +=
                ::protobuf::rt::bytes_size(22, &self.account_age_witness_signature_of_offer_id);
        }
        if self.current_date != 0 {
            my_size += ::protobuf::rt::value_size(
                23,
                self.current_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        for value in &self.accepted_refund_agent_node_addresses {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.refund_agent_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.trade_id.is_empty() {
            os.write_string(1, &self.trade_id)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.trade_amount != 0 {
            os.write_int64(3, self.trade_amount)?;
        }
        if self.trade_price != 0 {
            os.write_int64(4, self.trade_price)?;
        }
        if self.tx_fee != 0 {
            os.write_int64(5, self.tx_fee)?;
        }
        if self.taker_fee != 0 {
            os.write_int64(6, self.taker_fee)?;
        }
        if self.is_currency_for_taker_fee_btc != false {
            os.write_bool(7, self.is_currency_for_taker_fee_btc)?;
        }
        for v in &self.raw_transaction_inputs {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.change_output_value != 0 {
            os.write_int64(9, self.change_output_value)?;
        }
        if !self.change_output_address.is_empty() {
            os.write_string(10, &self.change_output_address)?;
        }
        if !self.taker_multi_sig_pub_key.is_empty() {
            os.write_bytes(11, &self.taker_multi_sig_pub_key)?;
        }
        if !self.taker_payout_address_string.is_empty() {
            os.write_string(12, &self.taker_payout_address_string)?;
        }
        if let Some(ref v) = self.taker_pub_key_ring.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.taker_payment_account_payload.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.taker_account_id.is_empty() {
            os.write_string(15, &self.taker_account_id)?;
        }
        if !self.taker_fee_tx_id.is_empty() {
            os.write_string(16, &self.taker_fee_tx_id)?;
        }
        for v in &self.accepted_arbitrator_node_addresses {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.accepted_mediator_node_addresses {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.arbitrator_node_address.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mediator_node_address.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.uid.is_empty() {
            os.write_string(21, &self.uid)?;
        }
        if !self.account_age_witness_signature_of_offer_id.is_empty() {
            os.write_bytes(22, &self.account_age_witness_signature_of_offer_id)?;
        }
        if self.current_date != 0 {
            os.write_int64(23, self.current_date)?;
        }
        for v in &self.accepted_refund_agent_node_addresses {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.refund_agent_node_address.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InputsForDepositTxRequest {
        InputsForDepositTxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &InputsForDepositTxRequest| &m.trade_id,
                    |m: &mut InputsForDepositTxRequest| &mut m.trade_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &InputsForDepositTxRequest| &m.sender_node_address,
                        |m: &mut InputsForDepositTxRequest| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "trade_amount",
                    |m: &InputsForDepositTxRequest| &m.trade_amount,
                    |m: &mut InputsForDepositTxRequest| &mut m.trade_amount,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "trade_price",
                    |m: &InputsForDepositTxRequest| &m.trade_price,
                    |m: &mut InputsForDepositTxRequest| &mut m.trade_price,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "tx_fee",
                    |m: &InputsForDepositTxRequest| &m.tx_fee,
                    |m: &mut InputsForDepositTxRequest| &mut m.tx_fee,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "taker_fee",
                    |m: &InputsForDepositTxRequest| &m.taker_fee,
                    |m: &mut InputsForDepositTxRequest| &mut m.taker_fee,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_currency_for_taker_fee_btc",
                    |m: &InputsForDepositTxRequest| &m.is_currency_for_taker_fee_btc,
                    |m: &mut InputsForDepositTxRequest| &mut m.is_currency_for_taker_fee_btc,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<RawTransactionInput>,
                    >(
                        "raw_transaction_inputs",
                        |m: &InputsForDepositTxRequest| &m.raw_transaction_inputs,
                        |m: &mut InputsForDepositTxRequest| &mut m.raw_transaction_inputs,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "change_output_value",
                    |m: &InputsForDepositTxRequest| &m.change_output_value,
                    |m: &mut InputsForDepositTxRequest| &mut m.change_output_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "change_output_address",
                    |m: &InputsForDepositTxRequest| &m.change_output_address,
                    |m: &mut InputsForDepositTxRequest| &mut m.change_output_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "taker_multi_sig_pub_key",
                    |m: &InputsForDepositTxRequest| &m.taker_multi_sig_pub_key,
                    |m: &mut InputsForDepositTxRequest| &mut m.taker_multi_sig_pub_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "taker_payout_address_string",
                    |m: &InputsForDepositTxRequest| &m.taker_payout_address_string,
                    |m: &mut InputsForDepositTxRequest| &mut m.taker_payout_address_string,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "taker_pub_key_ring",
                        |m: &InputsForDepositTxRequest| &m.taker_pub_key_ring,
                        |m: &mut InputsForDepositTxRequest| &mut m.taker_pub_key_ring,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PaymentAccountPayload>,
                    >(
                        "taker_payment_account_payload",
                        |m: &InputsForDepositTxRequest| &m.taker_payment_account_payload,
                        |m: &mut InputsForDepositTxRequest| &mut m.taker_payment_account_payload,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "taker_account_id",
                    |m: &InputsForDepositTxRequest| &m.taker_account_id,
                    |m: &mut InputsForDepositTxRequest| &mut m.taker_account_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "taker_fee_tx_id",
                    |m: &InputsForDepositTxRequest| &m.taker_fee_tx_id,
                    |m: &mut InputsForDepositTxRequest| &mut m.taker_fee_tx_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "accepted_arbitrator_node_addresses",
                        |m: &InputsForDepositTxRequest| &m.accepted_arbitrator_node_addresses,
                        |m: &mut InputsForDepositTxRequest| {
                            &mut m.accepted_arbitrator_node_addresses
                        },
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "accepted_mediator_node_addresses",
                        |m: &InputsForDepositTxRequest| &m.accepted_mediator_node_addresses,
                        |m: &mut InputsForDepositTxRequest| &mut m.accepted_mediator_node_addresses,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "arbitrator_node_address",
                        |m: &InputsForDepositTxRequest| &m.arbitrator_node_address,
                        |m: &mut InputsForDepositTxRequest| &mut m.arbitrator_node_address,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "mediator_node_address",
                        |m: &InputsForDepositTxRequest| &m.mediator_node_address,
                        |m: &mut InputsForDepositTxRequest| &mut m.mediator_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &InputsForDepositTxRequest| &m.uid,
                    |m: &mut InputsForDepositTxRequest| &mut m.uid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "account_age_witness_signature_of_offer_id",
                    |m: &InputsForDepositTxRequest| &m.account_age_witness_signature_of_offer_id,
                    |m: &mut InputsForDepositTxRequest| {
                        &mut m.account_age_witness_signature_of_offer_id
                    },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "current_date",
                    |m: &InputsForDepositTxRequest| &m.current_date,
                    |m: &mut InputsForDepositTxRequest| &mut m.current_date,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "accepted_refund_agent_node_addresses",
                        |m: &InputsForDepositTxRequest| &m.accepted_refund_agent_node_addresses,
                        |m: &mut InputsForDepositTxRequest| {
                            &mut m.accepted_refund_agent_node_addresses
                        },
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "refund_agent_node_address",
                        |m: &InputsForDepositTxRequest| &m.refund_agent_node_address,
                        |m: &mut InputsForDepositTxRequest| &mut m.refund_agent_node_address,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<InputsForDepositTxRequest>(
                    "InputsForDepositTxRequest",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static InputsForDepositTxRequest {
        static mut instance: ::protobuf::lazy::Lazy<InputsForDepositTxRequest> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const InputsForDepositTxRequest,
            };
        unsafe { instance.get(InputsForDepositTxRequest::new) }
    }
}

impl ::protobuf::Clear for InputsForDepositTxRequest {
    fn clear(&mut self) {
        self.trade_id.clear();
        self.sender_node_address.clear();
        self.trade_amount = 0;
        self.trade_price = 0;
        self.tx_fee = 0;
        self.taker_fee = 0;
        self.is_currency_for_taker_fee_btc = false;
        self.raw_transaction_inputs.clear();
        self.change_output_value = 0;
        self.change_output_address.clear();
        self.taker_multi_sig_pub_key.clear();
        self.taker_payout_address_string.clear();
        self.taker_pub_key_ring.clear();
        self.taker_payment_account_payload.clear();
        self.taker_account_id.clear();
        self.taker_fee_tx_id.clear();
        self.accepted_arbitrator_node_addresses.clear();
        self.accepted_mediator_node_addresses.clear();
        self.arbitrator_node_address.clear();
        self.mediator_node_address.clear();
        self.uid.clear();
        self.account_age_witness_signature_of_offer_id.clear();
        self.current_date = 0;
        self.accepted_refund_agent_node_addresses.clear();
        self.refund_agent_node_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InputsForDepositTxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputsForDepositTxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct InputsForDepositTxResponse {
    // message fields
    pub trade_id: ::std::string::String,
    pub maker_payment_account_payload: ::protobuf::SingularPtrField<PaymentAccountPayload>,
    pub maker_account_id: ::std::string::String,
    pub maker_contract_as_json: ::std::string::String,
    pub maker_contract_signature: ::std::string::String,
    pub maker_payout_address_string: ::std::string::String,
    pub prepared_deposit_tx: ::std::vec::Vec<u8>,
    pub maker_inputs: ::protobuf::RepeatedField<RawTransactionInput>,
    pub maker_multi_sig_pub_key: ::std::vec::Vec<u8>,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub uid: ::std::string::String,
    pub account_age_witness_signature_of_prepared_deposit_tx: ::std::vec::Vec<u8>,
    pub current_date: i64,
    pub lock_time: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InputsForDepositTxResponse {
    fn default() -> &'a InputsForDepositTxResponse {
        <InputsForDepositTxResponse as ::protobuf::Message>::default_instance()
    }
}

impl InputsForDepositTxResponse {
    pub fn new() -> InputsForDepositTxResponse {
        ::std::default::Default::default()
    }

    // string trade_id = 1;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.PaymentAccountPayload maker_payment_account_payload = 2;

    pub fn get_maker_payment_account_payload(&self) -> &PaymentAccountPayload {
        self.maker_payment_account_payload
            .as_ref()
            .unwrap_or_else(|| PaymentAccountPayload::default_instance())
    }
    pub fn clear_maker_payment_account_payload(&mut self) {
        self.maker_payment_account_payload.clear();
    }

    pub fn has_maker_payment_account_payload(&self) -> bool {
        self.maker_payment_account_payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maker_payment_account_payload(&mut self, v: PaymentAccountPayload) {
        self.maker_payment_account_payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_payment_account_payload(&mut self) -> &mut PaymentAccountPayload {
        if self.maker_payment_account_payload.is_none() {
            self.maker_payment_account_payload.set_default();
        }
        self.maker_payment_account_payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_maker_payment_account_payload(&mut self) -> PaymentAccountPayload {
        self.maker_payment_account_payload
            .take()
            .unwrap_or_else(|| PaymentAccountPayload::new())
    }

    // string maker_account_id = 3;

    pub fn get_maker_account_id(&self) -> &str {
        &self.maker_account_id
    }
    pub fn clear_maker_account_id(&mut self) {
        self.maker_account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_account_id(&mut self, v: ::std::string::String) {
        self.maker_account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.maker_account_id
    }

    // Take field
    pub fn take_maker_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_account_id, ::std::string::String::new())
    }

    // string maker_contract_as_json = 4;

    pub fn get_maker_contract_as_json(&self) -> &str {
        &self.maker_contract_as_json
    }
    pub fn clear_maker_contract_as_json(&mut self) {
        self.maker_contract_as_json.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_contract_as_json(&mut self, v: ::std::string::String) {
        self.maker_contract_as_json = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_contract_as_json(&mut self) -> &mut ::std::string::String {
        &mut self.maker_contract_as_json
    }

    // Take field
    pub fn take_maker_contract_as_json(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.maker_contract_as_json,
            ::std::string::String::new(),
        )
    }

    // string maker_contract_signature = 5;

    pub fn get_maker_contract_signature(&self) -> &str {
        &self.maker_contract_signature
    }
    pub fn clear_maker_contract_signature(&mut self) {
        self.maker_contract_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_contract_signature(&mut self, v: ::std::string::String) {
        self.maker_contract_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_contract_signature(&mut self) -> &mut ::std::string::String {
        &mut self.maker_contract_signature
    }

    // Take field
    pub fn take_maker_contract_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.maker_contract_signature,
            ::std::string::String::new(),
        )
    }

    // string maker_payout_address_string = 6;

    pub fn get_maker_payout_address_string(&self) -> &str {
        &self.maker_payout_address_string
    }
    pub fn clear_maker_payout_address_string(&mut self) {
        self.maker_payout_address_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_payout_address_string(&mut self, v: ::std::string::String) {
        self.maker_payout_address_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_payout_address_string(&mut self) -> &mut ::std::string::String {
        &mut self.maker_payout_address_string
    }

    // Take field
    pub fn take_maker_payout_address_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.maker_payout_address_string,
            ::std::string::String::new(),
        )
    }

    // bytes prepared_deposit_tx = 7;

    pub fn get_prepared_deposit_tx(&self) -> &[u8] {
        &self.prepared_deposit_tx
    }
    pub fn clear_prepared_deposit_tx(&mut self) {
        self.prepared_deposit_tx.clear();
    }

    // Param is passed by value, moved
    pub fn set_prepared_deposit_tx(&mut self, v: ::std::vec::Vec<u8>) {
        self.prepared_deposit_tx = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prepared_deposit_tx(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prepared_deposit_tx
    }

    // Take field
    pub fn take_prepared_deposit_tx(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prepared_deposit_tx, ::std::vec::Vec::new())
    }

    // repeated .io.bisq.protobuffer.RawTransactionInput maker_inputs = 8;

    pub fn get_maker_inputs(&self) -> &[RawTransactionInput] {
        &self.maker_inputs
    }
    pub fn clear_maker_inputs(&mut self) {
        self.maker_inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_inputs(&mut self, v: ::protobuf::RepeatedField<RawTransactionInput>) {
        self.maker_inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_maker_inputs(&mut self) -> &mut ::protobuf::RepeatedField<RawTransactionInput> {
        &mut self.maker_inputs
    }

    // Take field
    pub fn take_maker_inputs(&mut self) -> ::protobuf::RepeatedField<RawTransactionInput> {
        ::std::mem::replace(&mut self.maker_inputs, ::protobuf::RepeatedField::new())
    }

    // bytes maker_multi_sig_pub_key = 9;

    pub fn get_maker_multi_sig_pub_key(&self) -> &[u8] {
        &self.maker_multi_sig_pub_key
    }
    pub fn clear_maker_multi_sig_pub_key(&mut self) {
        self.maker_multi_sig_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_multi_sig_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.maker_multi_sig_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_multi_sig_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.maker_multi_sig_pub_key
    }

    // Take field
    pub fn take_maker_multi_sig_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.maker_multi_sig_pub_key, ::std::vec::Vec::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 10;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // string uid = 11;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // bytes account_age_witness_signature_of_prepared_deposit_tx = 12;

    pub fn get_account_age_witness_signature_of_prepared_deposit_tx(&self) -> &[u8] {
        &self.account_age_witness_signature_of_prepared_deposit_tx
    }
    pub fn clear_account_age_witness_signature_of_prepared_deposit_tx(&mut self) {
        self.account_age_witness_signature_of_prepared_deposit_tx
            .clear();
    }

    // Param is passed by value, moved
    pub fn set_account_age_witness_signature_of_prepared_deposit_tx(
        &mut self,
        v: ::std::vec::Vec<u8>,
    ) {
        self.account_age_witness_signature_of_prepared_deposit_tx = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_age_witness_signature_of_prepared_deposit_tx(
        &mut self,
    ) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_age_witness_signature_of_prepared_deposit_tx
    }

    // Take field
    pub fn take_account_age_witness_signature_of_prepared_deposit_tx(
        &mut self,
    ) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(
            &mut self.account_age_witness_signature_of_prepared_deposit_tx,
            ::std::vec::Vec::new(),
        )
    }

    // int64 current_date = 13;

    pub fn get_current_date(&self) -> i64 {
        self.current_date
    }
    pub fn clear_current_date(&mut self) {
        self.current_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_date(&mut self, v: i64) {
        self.current_date = v;
    }

    // int64 lock_time = 14;

    pub fn get_lock_time(&self) -> i64 {
        self.lock_time
    }
    pub fn clear_lock_time(&mut self) {
        self.lock_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_lock_time(&mut self, v: i64) {
        self.lock_time = v;
    }
}

impl ::protobuf::Message for InputsForDepositTxResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.maker_payment_account_payload {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.maker_inputs {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.maker_payment_account_payload,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.maker_account_id,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.maker_contract_as_json,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.maker_contract_signature,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.maker_payout_address_string,
                    )?;
                }
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.prepared_deposit_tx,
                    )?;
                }
                8 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.maker_inputs,
                    )?;
                }
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.maker_multi_sig_pub_key,
                    )?;
                }
                10 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.account_age_witness_signature_of_prepared_deposit_tx,
                    )?;
                }
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.current_date = tmp;
                }
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.lock_time = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.trade_id);
        }
        if let Some(ref v) = self.maker_payment_account_payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.maker_account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.maker_account_id);
        }
        if !self.maker_contract_as_json.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.maker_contract_as_json);
        }
        if !self.maker_contract_signature.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.maker_contract_signature);
        }
        if !self.maker_payout_address_string.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.maker_payout_address_string);
        }
        if !self.prepared_deposit_tx.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.prepared_deposit_tx);
        }
        for value in &self.maker_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.maker_multi_sig_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.maker_multi_sig_pub_key);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.uid);
        }
        if !self
            .account_age_witness_signature_of_prepared_deposit_tx
            .is_empty()
        {
            my_size += ::protobuf::rt::bytes_size(
                12,
                &self.account_age_witness_signature_of_prepared_deposit_tx,
            );
        }
        if self.current_date != 0 {
            my_size += ::protobuf::rt::value_size(
                13,
                self.current_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.lock_time != 0 {
            my_size += ::protobuf::rt::value_size(
                14,
                self.lock_time,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.trade_id.is_empty() {
            os.write_string(1, &self.trade_id)?;
        }
        if let Some(ref v) = self.maker_payment_account_payload.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.maker_account_id.is_empty() {
            os.write_string(3, &self.maker_account_id)?;
        }
        if !self.maker_contract_as_json.is_empty() {
            os.write_string(4, &self.maker_contract_as_json)?;
        }
        if !self.maker_contract_signature.is_empty() {
            os.write_string(5, &self.maker_contract_signature)?;
        }
        if !self.maker_payout_address_string.is_empty() {
            os.write_string(6, &self.maker_payout_address_string)?;
        }
        if !self.prepared_deposit_tx.is_empty() {
            os.write_bytes(7, &self.prepared_deposit_tx)?;
        }
        for v in &self.maker_inputs {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.maker_multi_sig_pub_key.is_empty() {
            os.write_bytes(9, &self.maker_multi_sig_pub_key)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.uid.is_empty() {
            os.write_string(11, &self.uid)?;
        }
        if !self
            .account_age_witness_signature_of_prepared_deposit_tx
            .is_empty()
        {
            os.write_bytes(
                12,
                &self.account_age_witness_signature_of_prepared_deposit_tx,
            )?;
        }
        if self.current_date != 0 {
            os.write_int64(13, self.current_date)?;
        }
        if self.lock_time != 0 {
            os.write_int64(14, self.lock_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InputsForDepositTxResponse {
        InputsForDepositTxResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &InputsForDepositTxResponse| &m.trade_id,
                    |m: &mut InputsForDepositTxResponse| &mut m.trade_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PaymentAccountPayload>,
                    >(
                        "maker_payment_account_payload",
                        |m: &InputsForDepositTxResponse| &m.maker_payment_account_payload,
                        |m: &mut InputsForDepositTxResponse| &mut m.maker_payment_account_payload,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "maker_account_id",
                    |m: &InputsForDepositTxResponse| &m.maker_account_id,
                    |m: &mut InputsForDepositTxResponse| &mut m.maker_account_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "maker_contract_as_json",
                    |m: &InputsForDepositTxResponse| &m.maker_contract_as_json,
                    |m: &mut InputsForDepositTxResponse| &mut m.maker_contract_as_json,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "maker_contract_signature",
                    |m: &InputsForDepositTxResponse| &m.maker_contract_signature,
                    |m: &mut InputsForDepositTxResponse| &mut m.maker_contract_signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "maker_payout_address_string",
                    |m: &InputsForDepositTxResponse| &m.maker_payout_address_string,
                    |m: &mut InputsForDepositTxResponse| &mut m.maker_payout_address_string,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "prepared_deposit_tx",
                    |m: &InputsForDepositTxResponse| &m.prepared_deposit_tx,
                    |m: &mut InputsForDepositTxResponse| &mut m.prepared_deposit_tx,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<RawTransactionInput>,
                    >(
                        "maker_inputs",
                        |m: &InputsForDepositTxResponse| &m.maker_inputs,
                        |m: &mut InputsForDepositTxResponse| &mut m.maker_inputs,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "maker_multi_sig_pub_key",
                    |m: &InputsForDepositTxResponse| &m.maker_multi_sig_pub_key,
                    |m: &mut InputsForDepositTxResponse| &mut m.maker_multi_sig_pub_key,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &InputsForDepositTxResponse| &m.sender_node_address,
                        |m: &mut InputsForDepositTxResponse| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &InputsForDepositTxResponse| &m.uid,
                    |m: &mut InputsForDepositTxResponse| &mut m.uid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "account_age_witness_signature_of_prepared_deposit_tx",
                    |m: &InputsForDepositTxResponse| {
                        &m.account_age_witness_signature_of_prepared_deposit_tx
                    },
                    |m: &mut InputsForDepositTxResponse| {
                        &mut m.account_age_witness_signature_of_prepared_deposit_tx
                    },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "current_date",
                    |m: &InputsForDepositTxResponse| &m.current_date,
                    |m: &mut InputsForDepositTxResponse| &mut m.current_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "lock_time",
                    |m: &InputsForDepositTxResponse| &m.lock_time,
                    |m: &mut InputsForDepositTxResponse| &mut m.lock_time,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InputsForDepositTxResponse>(
                    "InputsForDepositTxResponse",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static InputsForDepositTxResponse {
        static mut instance: ::protobuf::lazy::Lazy<InputsForDepositTxResponse> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const InputsForDepositTxResponse,
            };
        unsafe { instance.get(InputsForDepositTxResponse::new) }
    }
}

impl ::protobuf::Clear for InputsForDepositTxResponse {
    fn clear(&mut self) {
        self.trade_id.clear();
        self.maker_payment_account_payload.clear();
        self.maker_account_id.clear();
        self.maker_contract_as_json.clear();
        self.maker_contract_signature.clear();
        self.maker_payout_address_string.clear();
        self.prepared_deposit_tx.clear();
        self.maker_inputs.clear();
        self.maker_multi_sig_pub_key.clear();
        self.sender_node_address.clear();
        self.uid.clear();
        self.account_age_witness_signature_of_prepared_deposit_tx
            .clear();
        self.current_date = 0;
        self.lock_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InputsForDepositTxResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputsForDepositTxResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct DelayedPayoutTxSignatureRequest {
    // message fields
    pub uid: ::std::string::String,
    pub trade_id: ::std::string::String,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub delayed_payout_tx: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DelayedPayoutTxSignatureRequest {
    fn default() -> &'a DelayedPayoutTxSignatureRequest {
        <DelayedPayoutTxSignatureRequest as ::protobuf::Message>::default_instance()
    }
}

impl DelayedPayoutTxSignatureRequest {
    pub fn new() -> DelayedPayoutTxSignatureRequest {
        ::std::default::Default::default()
    }

    // string uid = 1;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // string trade_id = 2;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 3;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // bytes delayed_payout_tx = 4;

    pub fn get_delayed_payout_tx(&self) -> &[u8] {
        &self.delayed_payout_tx
    }
    pub fn clear_delayed_payout_tx(&mut self) {
        self.delayed_payout_tx.clear();
    }

    // Param is passed by value, moved
    pub fn set_delayed_payout_tx(&mut self, v: ::std::vec::Vec<u8>) {
        self.delayed_payout_tx = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delayed_payout_tx(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.delayed_payout_tx
    }

    // Take field
    pub fn take_delayed_payout_tx(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.delayed_payout_tx, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DelayedPayoutTxSignatureRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.delayed_payout_tx,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trade_id);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.delayed_payout_tx.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.delayed_payout_tx);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if !self.trade_id.is_empty() {
            os.write_string(2, &self.trade_id)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.delayed_payout_tx.is_empty() {
            os.write_bytes(4, &self.delayed_payout_tx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DelayedPayoutTxSignatureRequest {
        DelayedPayoutTxSignatureRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &DelayedPayoutTxSignatureRequest| &m.uid,
                    |m: &mut DelayedPayoutTxSignatureRequest| &mut m.uid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &DelayedPayoutTxSignatureRequest| &m.trade_id,
                    |m: &mut DelayedPayoutTxSignatureRequest| &mut m.trade_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &DelayedPayoutTxSignatureRequest| &m.sender_node_address,
                        |m: &mut DelayedPayoutTxSignatureRequest| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "delayed_payout_tx",
                    |m: &DelayedPayoutTxSignatureRequest| &m.delayed_payout_tx,
                    |m: &mut DelayedPayoutTxSignatureRequest| &mut m.delayed_payout_tx,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DelayedPayoutTxSignatureRequest>(
                    "DelayedPayoutTxSignatureRequest",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static DelayedPayoutTxSignatureRequest {
        static mut instance: ::protobuf::lazy::Lazy<DelayedPayoutTxSignatureRequest> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const DelayedPayoutTxSignatureRequest,
            };
        unsafe { instance.get(DelayedPayoutTxSignatureRequest::new) }
    }
}

impl ::protobuf::Clear for DelayedPayoutTxSignatureRequest {
    fn clear(&mut self) {
        self.uid.clear();
        self.trade_id.clear();
        self.sender_node_address.clear();
        self.delayed_payout_tx.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DelayedPayoutTxSignatureRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelayedPayoutTxSignatureRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct DelayedPayoutTxSignatureResponse {
    // message fields
    pub uid: ::std::string::String,
    pub trade_id: ::std::string::String,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub delayed_payout_tx_signature: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DelayedPayoutTxSignatureResponse {
    fn default() -> &'a DelayedPayoutTxSignatureResponse {
        <DelayedPayoutTxSignatureResponse as ::protobuf::Message>::default_instance()
    }
}

impl DelayedPayoutTxSignatureResponse {
    pub fn new() -> DelayedPayoutTxSignatureResponse {
        ::std::default::Default::default()
    }

    // string uid = 1;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // string trade_id = 2;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 3;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // bytes delayed_payout_tx_signature = 4;

    pub fn get_delayed_payout_tx_signature(&self) -> &[u8] {
        &self.delayed_payout_tx_signature
    }
    pub fn clear_delayed_payout_tx_signature(&mut self) {
        self.delayed_payout_tx_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_delayed_payout_tx_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.delayed_payout_tx_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delayed_payout_tx_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.delayed_payout_tx_signature
    }

    // Take field
    pub fn take_delayed_payout_tx_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(
            &mut self.delayed_payout_tx_signature,
            ::std::vec::Vec::new(),
        )
    }
}

impl ::protobuf::Message for DelayedPayoutTxSignatureResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.delayed_payout_tx_signature,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trade_id);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.delayed_payout_tx_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.delayed_payout_tx_signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if !self.trade_id.is_empty() {
            os.write_string(2, &self.trade_id)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.delayed_payout_tx_signature.is_empty() {
            os.write_bytes(4, &self.delayed_payout_tx_signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DelayedPayoutTxSignatureResponse {
        DelayedPayoutTxSignatureResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &DelayedPayoutTxSignatureResponse| &m.uid,
                    |m: &mut DelayedPayoutTxSignatureResponse| &mut m.uid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &DelayedPayoutTxSignatureResponse| &m.trade_id,
                    |m: &mut DelayedPayoutTxSignatureResponse| &mut m.trade_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &DelayedPayoutTxSignatureResponse| &m.sender_node_address,
                        |m: &mut DelayedPayoutTxSignatureResponse| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "delayed_payout_tx_signature",
                    |m: &DelayedPayoutTxSignatureResponse| &m.delayed_payout_tx_signature,
                    |m: &mut DelayedPayoutTxSignatureResponse| &mut m.delayed_payout_tx_signature,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DelayedPayoutTxSignatureResponse>(
                    "DelayedPayoutTxSignatureResponse",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static DelayedPayoutTxSignatureResponse {
        static mut instance: ::protobuf::lazy::Lazy<DelayedPayoutTxSignatureResponse> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const DelayedPayoutTxSignatureResponse,
            };
        unsafe { instance.get(DelayedPayoutTxSignatureResponse::new) }
    }
}

impl ::protobuf::Clear for DelayedPayoutTxSignatureResponse {
    fn clear(&mut self) {
        self.uid.clear();
        self.trade_id.clear();
        self.sender_node_address.clear();
        self.delayed_payout_tx_signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DelayedPayoutTxSignatureResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelayedPayoutTxSignatureResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct DepositTxAndDelayedPayoutTxMessage {
    // message fields
    pub uid: ::std::string::String,
    pub trade_id: ::std::string::String,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub deposit_tx: ::std::vec::Vec<u8>,
    pub delayed_payout_tx: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DepositTxAndDelayedPayoutTxMessage {
    fn default() -> &'a DepositTxAndDelayedPayoutTxMessage {
        <DepositTxAndDelayedPayoutTxMessage as ::protobuf::Message>::default_instance()
    }
}

impl DepositTxAndDelayedPayoutTxMessage {
    pub fn new() -> DepositTxAndDelayedPayoutTxMessage {
        ::std::default::Default::default()
    }

    // string uid = 1;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // string trade_id = 2;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 3;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // bytes deposit_tx = 4;

    pub fn get_deposit_tx(&self) -> &[u8] {
        &self.deposit_tx
    }
    pub fn clear_deposit_tx(&mut self) {
        self.deposit_tx.clear();
    }

    // Param is passed by value, moved
    pub fn set_deposit_tx(&mut self, v: ::std::vec::Vec<u8>) {
        self.deposit_tx = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deposit_tx(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.deposit_tx
    }

    // Take field
    pub fn take_deposit_tx(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.deposit_tx, ::std::vec::Vec::new())
    }

    // bytes delayed_payout_tx = 5;

    pub fn get_delayed_payout_tx(&self) -> &[u8] {
        &self.delayed_payout_tx
    }
    pub fn clear_delayed_payout_tx(&mut self) {
        self.delayed_payout_tx.clear();
    }

    // Param is passed by value, moved
    pub fn set_delayed_payout_tx(&mut self, v: ::std::vec::Vec<u8>) {
        self.delayed_payout_tx = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delayed_payout_tx(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.delayed_payout_tx
    }

    // Take field
    pub fn take_delayed_payout_tx(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.delayed_payout_tx, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DepositTxAndDelayedPayoutTxMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.deposit_tx,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.delayed_payout_tx,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trade_id);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.deposit_tx.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.deposit_tx);
        }
        if !self.delayed_payout_tx.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.delayed_payout_tx);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if !self.trade_id.is_empty() {
            os.write_string(2, &self.trade_id)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.deposit_tx.is_empty() {
            os.write_bytes(4, &self.deposit_tx)?;
        }
        if !self.delayed_payout_tx.is_empty() {
            os.write_bytes(5, &self.delayed_payout_tx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DepositTxAndDelayedPayoutTxMessage {
        DepositTxAndDelayedPayoutTxMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &DepositTxAndDelayedPayoutTxMessage| &m.uid,
                    |m: &mut DepositTxAndDelayedPayoutTxMessage| &mut m.uid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &DepositTxAndDelayedPayoutTxMessage| &m.trade_id,
                    |m: &mut DepositTxAndDelayedPayoutTxMessage| &mut m.trade_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &DepositTxAndDelayedPayoutTxMessage| &m.sender_node_address,
                        |m: &mut DepositTxAndDelayedPayoutTxMessage| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "deposit_tx",
                    |m: &DepositTxAndDelayedPayoutTxMessage| &m.deposit_tx,
                    |m: &mut DepositTxAndDelayedPayoutTxMessage| &mut m.deposit_tx,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "delayed_payout_tx",
                    |m: &DepositTxAndDelayedPayoutTxMessage| &m.delayed_payout_tx,
                    |m: &mut DepositTxAndDelayedPayoutTxMessage| &mut m.delayed_payout_tx,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DepositTxAndDelayedPayoutTxMessage>(
                    "DepositTxAndDelayedPayoutTxMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static DepositTxAndDelayedPayoutTxMessage {
        static mut instance: ::protobuf::lazy::Lazy<DepositTxAndDelayedPayoutTxMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const DepositTxAndDelayedPayoutTxMessage,
            };
        unsafe { instance.get(DepositTxAndDelayedPayoutTxMessage::new) }
    }
}

impl ::protobuf::Clear for DepositTxAndDelayedPayoutTxMessage {
    fn clear(&mut self) {
        self.uid.clear();
        self.trade_id.clear();
        self.sender_node_address.clear();
        self.deposit_tx.clear();
        self.delayed_payout_tx.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DepositTxAndDelayedPayoutTxMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DepositTxAndDelayedPayoutTxMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct DepositTxMessage {
    // message fields
    pub uid: ::std::string::String,
    pub trade_id: ::std::string::String,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub deposit_tx: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DepositTxMessage {
    fn default() -> &'a DepositTxMessage {
        <DepositTxMessage as ::protobuf::Message>::default_instance()
    }
}

impl DepositTxMessage {
    pub fn new() -> DepositTxMessage {
        ::std::default::Default::default()
    }

    // string uid = 1;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // string trade_id = 2;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 3;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // bytes deposit_tx = 4;

    pub fn get_deposit_tx(&self) -> &[u8] {
        &self.deposit_tx
    }
    pub fn clear_deposit_tx(&mut self) {
        self.deposit_tx.clear();
    }

    // Param is passed by value, moved
    pub fn set_deposit_tx(&mut self, v: ::std::vec::Vec<u8>) {
        self.deposit_tx = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deposit_tx(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.deposit_tx
    }

    // Take field
    pub fn take_deposit_tx(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.deposit_tx, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DepositTxMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.deposit_tx,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trade_id);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.deposit_tx.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.deposit_tx);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if !self.trade_id.is_empty() {
            os.write_string(2, &self.trade_id)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.deposit_tx.is_empty() {
            os.write_bytes(4, &self.deposit_tx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DepositTxMessage {
        DepositTxMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &DepositTxMessage| &m.uid,
                    |m: &mut DepositTxMessage| &mut m.uid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &DepositTxMessage| &m.trade_id,
                    |m: &mut DepositTxMessage| &mut m.trade_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &DepositTxMessage| &m.sender_node_address,
                        |m: &mut DepositTxMessage| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "deposit_tx",
                    |m: &DepositTxMessage| &m.deposit_tx,
                    |m: &mut DepositTxMessage| &mut m.deposit_tx,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DepositTxMessage>(
                    "DepositTxMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static DepositTxMessage {
        static mut instance: ::protobuf::lazy::Lazy<DepositTxMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DepositTxMessage,
        };
        unsafe { instance.get(DepositTxMessage::new) }
    }
}

impl ::protobuf::Clear for DepositTxMessage {
    fn clear(&mut self) {
        self.uid.clear();
        self.trade_id.clear();
        self.sender_node_address.clear();
        self.deposit_tx.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DepositTxMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DepositTxMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PeerPublishedDelayedPayoutTxMessage {
    // message fields
    pub uid: ::std::string::String,
    pub trade_id: ::std::string::String,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeerPublishedDelayedPayoutTxMessage {
    fn default() -> &'a PeerPublishedDelayedPayoutTxMessage {
        <PeerPublishedDelayedPayoutTxMessage as ::protobuf::Message>::default_instance()
    }
}

impl PeerPublishedDelayedPayoutTxMessage {
    pub fn new() -> PeerPublishedDelayedPayoutTxMessage {
        ::std::default::Default::default()
    }

    // string uid = 1;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // string trade_id = 2;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 3;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }
}

impl ::protobuf::Message for PeerPublishedDelayedPayoutTxMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trade_id);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if !self.trade_id.is_empty() {
            os.write_string(2, &self.trade_id)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeerPublishedDelayedPayoutTxMessage {
        PeerPublishedDelayedPayoutTxMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &PeerPublishedDelayedPayoutTxMessage| &m.uid,
                    |m: &mut PeerPublishedDelayedPayoutTxMessage| &mut m.uid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &PeerPublishedDelayedPayoutTxMessage| &m.trade_id,
                    |m: &mut PeerPublishedDelayedPayoutTxMessage| &mut m.trade_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &PeerPublishedDelayedPayoutTxMessage| &m.sender_node_address,
                        |m: &mut PeerPublishedDelayedPayoutTxMessage| &mut m.sender_node_address,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<PeerPublishedDelayedPayoutTxMessage>(
                    "PeerPublishedDelayedPayoutTxMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PeerPublishedDelayedPayoutTxMessage {
        static mut instance: ::protobuf::lazy::Lazy<PeerPublishedDelayedPayoutTxMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PeerPublishedDelayedPayoutTxMessage,
            };
        unsafe { instance.get(PeerPublishedDelayedPayoutTxMessage::new) }
    }
}

impl ::protobuf::Clear for PeerPublishedDelayedPayoutTxMessage {
    fn clear(&mut self) {
        self.uid.clear();
        self.trade_id.clear();
        self.sender_node_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeerPublishedDelayedPayoutTxMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerPublishedDelayedPayoutTxMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct CounterCurrencyTransferStartedMessage {
    // message fields
    pub trade_id: ::std::string::String,
    pub buyer_payout_address: ::std::string::String,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub buyer_signature: ::std::vec::Vec<u8>,
    pub counter_currency_tx_id: ::std::string::String,
    pub uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CounterCurrencyTransferStartedMessage {
    fn default() -> &'a CounterCurrencyTransferStartedMessage {
        <CounterCurrencyTransferStartedMessage as ::protobuf::Message>::default_instance()
    }
}

impl CounterCurrencyTransferStartedMessage {
    pub fn new() -> CounterCurrencyTransferStartedMessage {
        ::std::default::Default::default()
    }

    // string trade_id = 1;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // string buyer_payout_address = 2;

    pub fn get_buyer_payout_address(&self) -> &str {
        &self.buyer_payout_address
    }
    pub fn clear_buyer_payout_address(&mut self) {
        self.buyer_payout_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_buyer_payout_address(&mut self, v: ::std::string::String) {
        self.buyer_payout_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buyer_payout_address(&mut self) -> &mut ::std::string::String {
        &mut self.buyer_payout_address
    }

    // Take field
    pub fn take_buyer_payout_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.buyer_payout_address, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 3;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // bytes buyer_signature = 4;

    pub fn get_buyer_signature(&self) -> &[u8] {
        &self.buyer_signature
    }
    pub fn clear_buyer_signature(&mut self) {
        self.buyer_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_buyer_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.buyer_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buyer_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.buyer_signature
    }

    // Take field
    pub fn take_buyer_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.buyer_signature, ::std::vec::Vec::new())
    }

    // string counter_currency_tx_id = 5;

    pub fn get_counter_currency_tx_id(&self) -> &str {
        &self.counter_currency_tx_id
    }
    pub fn clear_counter_currency_tx_id(&mut self) {
        self.counter_currency_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_counter_currency_tx_id(&mut self, v: ::std::string::String) {
        self.counter_currency_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counter_currency_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.counter_currency_tx_id
    }

    // Take field
    pub fn take_counter_currency_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.counter_currency_tx_id,
            ::std::string::String::new(),
        )
    }

    // string uid = 6;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CounterCurrencyTransferStartedMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.buyer_payout_address,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.buyer_signature,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.counter_currency_tx_id,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.trade_id);
        }
        if !self.buyer_payout_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.buyer_payout_address);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.buyer_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.buyer_signature);
        }
        if !self.counter_currency_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.counter_currency_tx_id);
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.trade_id.is_empty() {
            os.write_string(1, &self.trade_id)?;
        }
        if !self.buyer_payout_address.is_empty() {
            os.write_string(2, &self.buyer_payout_address)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.buyer_signature.is_empty() {
            os.write_bytes(4, &self.buyer_signature)?;
        }
        if !self.counter_currency_tx_id.is_empty() {
            os.write_string(5, &self.counter_currency_tx_id)?;
        }
        if !self.uid.is_empty() {
            os.write_string(6, &self.uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CounterCurrencyTransferStartedMessage {
        CounterCurrencyTransferStartedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "trade_id",
                    |m: &CounterCurrencyTransferStartedMessage| { &m.trade_id },
                    |m: &mut CounterCurrencyTransferStartedMessage| { &mut m.trade_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "buyer_payout_address",
                    |m: &CounterCurrencyTransferStartedMessage| { &m.buyer_payout_address },
                    |m: &mut CounterCurrencyTransferStartedMessage| { &mut m.buyer_payout_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeAddress>>(
                    "sender_node_address",
                    |m: &CounterCurrencyTransferStartedMessage| { &m.sender_node_address },
                    |m: &mut CounterCurrencyTransferStartedMessage| { &mut m.sender_node_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "buyer_signature",
                    |m: &CounterCurrencyTransferStartedMessage| { &m.buyer_signature },
                    |m: &mut CounterCurrencyTransferStartedMessage| { &mut m.buyer_signature },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "counter_currency_tx_id",
                    |m: &CounterCurrencyTransferStartedMessage| { &m.counter_currency_tx_id },
                    |m: &mut CounterCurrencyTransferStartedMessage| { &mut m.counter_currency_tx_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    |m: &CounterCurrencyTransferStartedMessage| { &m.uid },
                    |m: &mut CounterCurrencyTransferStartedMessage| { &mut m.uid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CounterCurrencyTransferStartedMessage>(
                    "CounterCurrencyTransferStartedMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CounterCurrencyTransferStartedMessage {
        static mut instance: ::protobuf::lazy::Lazy<CounterCurrencyTransferStartedMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const CounterCurrencyTransferStartedMessage,
            };
        unsafe { instance.get(CounterCurrencyTransferStartedMessage::new) }
    }
}

impl ::protobuf::Clear for CounterCurrencyTransferStartedMessage {
    fn clear(&mut self) {
        self.trade_id.clear();
        self.buyer_payout_address.clear();
        self.sender_node_address.clear();
        self.buyer_signature.clear();
        self.counter_currency_tx_id.clear();
        self.uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CounterCurrencyTransferStartedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CounterCurrencyTransferStartedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct FinalizePayoutTxRequest {
    // message fields
    pub trade_id: ::std::string::String,
    pub seller_signature: ::std::vec::Vec<u8>,
    pub seller_payout_address: ::std::string::String,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FinalizePayoutTxRequest {
    fn default() -> &'a FinalizePayoutTxRequest {
        <FinalizePayoutTxRequest as ::protobuf::Message>::default_instance()
    }
}

impl FinalizePayoutTxRequest {
    pub fn new() -> FinalizePayoutTxRequest {
        ::std::default::Default::default()
    }

    // string trade_id = 1;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // bytes seller_signature = 2;

    pub fn get_seller_signature(&self) -> &[u8] {
        &self.seller_signature
    }
    pub fn clear_seller_signature(&mut self) {
        self.seller_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_seller_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.seller_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seller_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.seller_signature
    }

    // Take field
    pub fn take_seller_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.seller_signature, ::std::vec::Vec::new())
    }

    // string seller_payout_address = 3;

    pub fn get_seller_payout_address(&self) -> &str {
        &self.seller_payout_address
    }
    pub fn clear_seller_payout_address(&mut self) {
        self.seller_payout_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_seller_payout_address(&mut self, v: ::std::string::String) {
        self.seller_payout_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seller_payout_address(&mut self) -> &mut ::std::string::String {
        &mut self.seller_payout_address
    }

    // Take field
    pub fn take_seller_payout_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.seller_payout_address,
            ::std::string::String::new(),
        )
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 4;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // string uid = 5;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FinalizePayoutTxRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.seller_signature,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.seller_payout_address,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.trade_id);
        }
        if !self.seller_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.seller_signature);
        }
        if !self.seller_payout_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.seller_payout_address);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.trade_id.is_empty() {
            os.write_string(1, &self.trade_id)?;
        }
        if !self.seller_signature.is_empty() {
            os.write_bytes(2, &self.seller_signature)?;
        }
        if !self.seller_payout_address.is_empty() {
            os.write_string(3, &self.seller_payout_address)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.uid.is_empty() {
            os.write_string(5, &self.uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinalizePayoutTxRequest {
        FinalizePayoutTxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &FinalizePayoutTxRequest| &m.trade_id,
                    |m: &mut FinalizePayoutTxRequest| &mut m.trade_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "seller_signature",
                    |m: &FinalizePayoutTxRequest| &m.seller_signature,
                    |m: &mut FinalizePayoutTxRequest| &mut m.seller_signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "seller_payout_address",
                    |m: &FinalizePayoutTxRequest| &m.seller_payout_address,
                    |m: &mut FinalizePayoutTxRequest| &mut m.seller_payout_address,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &FinalizePayoutTxRequest| &m.sender_node_address,
                        |m: &mut FinalizePayoutTxRequest| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &FinalizePayoutTxRequest| &m.uid,
                    |m: &mut FinalizePayoutTxRequest| &mut m.uid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FinalizePayoutTxRequest>(
                    "FinalizePayoutTxRequest",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static FinalizePayoutTxRequest {
        static mut instance: ::protobuf::lazy::Lazy<FinalizePayoutTxRequest> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const FinalizePayoutTxRequest,
            };
        unsafe { instance.get(FinalizePayoutTxRequest::new) }
    }
}

impl ::protobuf::Clear for FinalizePayoutTxRequest {
    fn clear(&mut self) {
        self.trade_id.clear();
        self.seller_signature.clear();
        self.seller_payout_address.clear();
        self.sender_node_address.clear();
        self.uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinalizePayoutTxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizePayoutTxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PayoutTxPublishedMessage {
    // message fields
    pub trade_id: ::std::string::String,
    pub payout_tx: ::std::vec::Vec<u8>,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PayoutTxPublishedMessage {
    fn default() -> &'a PayoutTxPublishedMessage {
        <PayoutTxPublishedMessage as ::protobuf::Message>::default_instance()
    }
}

impl PayoutTxPublishedMessage {
    pub fn new() -> PayoutTxPublishedMessage {
        ::std::default::Default::default()
    }

    // string trade_id = 1;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // bytes payout_tx = 2;

    pub fn get_payout_tx(&self) -> &[u8] {
        &self.payout_tx
    }
    pub fn clear_payout_tx(&mut self) {
        self.payout_tx.clear();
    }

    // Param is passed by value, moved
    pub fn set_payout_tx(&mut self, v: ::std::vec::Vec<u8>) {
        self.payout_tx = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payout_tx(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payout_tx
    }

    // Take field
    pub fn take_payout_tx(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payout_tx, ::std::vec::Vec::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 3;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // string uid = 4;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PayoutTxPublishedMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.payout_tx,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.trade_id);
        }
        if !self.payout_tx.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.payout_tx);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.trade_id.is_empty() {
            os.write_string(1, &self.trade_id)?;
        }
        if !self.payout_tx.is_empty() {
            os.write_bytes(2, &self.payout_tx)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.uid.is_empty() {
            os.write_string(4, &self.uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PayoutTxPublishedMessage {
        PayoutTxPublishedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &PayoutTxPublishedMessage| &m.trade_id,
                    |m: &mut PayoutTxPublishedMessage| &mut m.trade_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "payout_tx",
                    |m: &PayoutTxPublishedMessage| &m.payout_tx,
                    |m: &mut PayoutTxPublishedMessage| &mut m.payout_tx,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &PayoutTxPublishedMessage| &m.sender_node_address,
                        |m: &mut PayoutTxPublishedMessage| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &PayoutTxPublishedMessage| &m.uid,
                    |m: &mut PayoutTxPublishedMessage| &mut m.uid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PayoutTxPublishedMessage>(
                    "PayoutTxPublishedMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PayoutTxPublishedMessage {
        static mut instance: ::protobuf::lazy::Lazy<PayoutTxPublishedMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PayoutTxPublishedMessage,
            };
        unsafe { instance.get(PayoutTxPublishedMessage::new) }
    }
}

impl ::protobuf::Clear for PayoutTxPublishedMessage {
    fn clear(&mut self) {
        self.trade_id.clear();
        self.payout_tx.clear();
        self.sender_node_address.clear();
        self.uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PayoutTxPublishedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PayoutTxPublishedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MediatedPayoutTxPublishedMessage {
    // message fields
    pub trade_id: ::std::string::String,
    pub payout_tx: ::std::vec::Vec<u8>,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MediatedPayoutTxPublishedMessage {
    fn default() -> &'a MediatedPayoutTxPublishedMessage {
        <MediatedPayoutTxPublishedMessage as ::protobuf::Message>::default_instance()
    }
}

impl MediatedPayoutTxPublishedMessage {
    pub fn new() -> MediatedPayoutTxPublishedMessage {
        ::std::default::Default::default()
    }

    // string trade_id = 1;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // bytes payout_tx = 2;

    pub fn get_payout_tx(&self) -> &[u8] {
        &self.payout_tx
    }
    pub fn clear_payout_tx(&mut self) {
        self.payout_tx.clear();
    }

    // Param is passed by value, moved
    pub fn set_payout_tx(&mut self, v: ::std::vec::Vec<u8>) {
        self.payout_tx = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payout_tx(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payout_tx
    }

    // Take field
    pub fn take_payout_tx(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payout_tx, ::std::vec::Vec::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 3;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // string uid = 4;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MediatedPayoutTxPublishedMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.payout_tx,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.trade_id);
        }
        if !self.payout_tx.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.payout_tx);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.trade_id.is_empty() {
            os.write_string(1, &self.trade_id)?;
        }
        if !self.payout_tx.is_empty() {
            os.write_bytes(2, &self.payout_tx)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.uid.is_empty() {
            os.write_string(4, &self.uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MediatedPayoutTxPublishedMessage {
        MediatedPayoutTxPublishedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &MediatedPayoutTxPublishedMessage| &m.trade_id,
                    |m: &mut MediatedPayoutTxPublishedMessage| &mut m.trade_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "payout_tx",
                    |m: &MediatedPayoutTxPublishedMessage| &m.payout_tx,
                    |m: &mut MediatedPayoutTxPublishedMessage| &mut m.payout_tx,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &MediatedPayoutTxPublishedMessage| &m.sender_node_address,
                        |m: &mut MediatedPayoutTxPublishedMessage| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &MediatedPayoutTxPublishedMessage| &m.uid,
                    |m: &mut MediatedPayoutTxPublishedMessage| &mut m.uid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MediatedPayoutTxPublishedMessage>(
                    "MediatedPayoutTxPublishedMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MediatedPayoutTxPublishedMessage {
        static mut instance: ::protobuf::lazy::Lazy<MediatedPayoutTxPublishedMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const MediatedPayoutTxPublishedMessage,
            };
        unsafe { instance.get(MediatedPayoutTxPublishedMessage::new) }
    }
}

impl ::protobuf::Clear for MediatedPayoutTxPublishedMessage {
    fn clear(&mut self) {
        self.trade_id.clear();
        self.payout_tx.clear();
        self.sender_node_address.clear();
        self.uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MediatedPayoutTxPublishedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediatedPayoutTxPublishedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MediatedPayoutTxSignatureMessage {
    // message fields
    pub uid: ::std::string::String,
    pub trade_id: ::std::string::String,
    pub tx_signature: ::std::vec::Vec<u8>,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MediatedPayoutTxSignatureMessage {
    fn default() -> &'a MediatedPayoutTxSignatureMessage {
        <MediatedPayoutTxSignatureMessage as ::protobuf::Message>::default_instance()
    }
}

impl MediatedPayoutTxSignatureMessage {
    pub fn new() -> MediatedPayoutTxSignatureMessage {
        ::std::default::Default::default()
    }

    // string uid = 1;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // string trade_id = 3;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // bytes tx_signature = 2;

    pub fn get_tx_signature(&self) -> &[u8] {
        &self.tx_signature
    }
    pub fn clear_tx_signature(&mut self) {
        self.tx_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.tx_signature
    }

    // Take field
    pub fn take_tx_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.tx_signature, ::std::vec::Vec::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 4;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }
}

impl ::protobuf::Message for MediatedPayoutTxSignatureMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.tx_signature,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.trade_id);
        }
        if !self.tx_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.tx_signature);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if !self.trade_id.is_empty() {
            os.write_string(3, &self.trade_id)?;
        }
        if !self.tx_signature.is_empty() {
            os.write_bytes(2, &self.tx_signature)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MediatedPayoutTxSignatureMessage {
        MediatedPayoutTxSignatureMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &MediatedPayoutTxSignatureMessage| &m.uid,
                    |m: &mut MediatedPayoutTxSignatureMessage| &mut m.uid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &MediatedPayoutTxSignatureMessage| &m.trade_id,
                    |m: &mut MediatedPayoutTxSignatureMessage| &mut m.trade_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "tx_signature",
                    |m: &MediatedPayoutTxSignatureMessage| &m.tx_signature,
                    |m: &mut MediatedPayoutTxSignatureMessage| &mut m.tx_signature,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &MediatedPayoutTxSignatureMessage| &m.sender_node_address,
                        |m: &mut MediatedPayoutTxSignatureMessage| &mut m.sender_node_address,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<MediatedPayoutTxSignatureMessage>(
                    "MediatedPayoutTxSignatureMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MediatedPayoutTxSignatureMessage {
        static mut instance: ::protobuf::lazy::Lazy<MediatedPayoutTxSignatureMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const MediatedPayoutTxSignatureMessage,
            };
        unsafe { instance.get(MediatedPayoutTxSignatureMessage::new) }
    }
}

impl ::protobuf::Clear for MediatedPayoutTxSignatureMessage {
    fn clear(&mut self) {
        self.uid.clear();
        self.trade_id.clear();
        self.tx_signature.clear();
        self.sender_node_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MediatedPayoutTxSignatureMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediatedPayoutTxSignatureMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct OpenNewDisputeMessage {
    // message fields
    pub dispute: ::protobuf::SingularPtrField<Dispute>,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub uid: ::std::string::String,
    pub field_type: SupportType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpenNewDisputeMessage {
    fn default() -> &'a OpenNewDisputeMessage {
        <OpenNewDisputeMessage as ::protobuf::Message>::default_instance()
    }
}

impl OpenNewDisputeMessage {
    pub fn new() -> OpenNewDisputeMessage {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Dispute dispute = 1;

    pub fn get_dispute(&self) -> &Dispute {
        self.dispute
            .as_ref()
            .unwrap_or_else(|| Dispute::default_instance())
    }
    pub fn clear_dispute(&mut self) {
        self.dispute.clear();
    }

    pub fn has_dispute(&self) -> bool {
        self.dispute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dispute(&mut self, v: Dispute) {
        self.dispute = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dispute(&mut self) -> &mut Dispute {
        if self.dispute.is_none() {
            self.dispute.set_default();
        }
        self.dispute.as_mut().unwrap()
    }

    // Take field
    pub fn take_dispute(&mut self) -> Dispute {
        self.dispute.take().unwrap_or_else(|| Dispute::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 2;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // string uid = 3;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.SupportType type = 4;

    pub fn get_field_type(&self) -> SupportType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = SupportType::ARBITRATION;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SupportType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for OpenNewDisputeMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.dispute {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dispute)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                4 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.field_type,
                    4,
                    &mut self.unknown_fields,
                )?,
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dispute.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.uid);
        }
        if self.field_type != SupportType::ARBITRATION {
            my_size += ::protobuf::rt::enum_size(4, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dispute.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.uid.is_empty() {
            os.write_string(3, &self.uid)?;
        }
        if self.field_type != SupportType::ARBITRATION {
            os.write_enum(4, self.field_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenNewDisputeMessage {
        OpenNewDisputeMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Dispute>,
                    >(
                        "dispute",
                        |m: &OpenNewDisputeMessage| &m.dispute,
                        |m: &mut OpenNewDisputeMessage| &mut m.dispute,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &OpenNewDisputeMessage| &m.sender_node_address,
                        |m: &mut OpenNewDisputeMessage| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &OpenNewDisputeMessage| &m.uid,
                    |m: &mut OpenNewDisputeMessage| &mut m.uid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<SupportType>,
                >(
                    "type",
                    |m: &OpenNewDisputeMessage| &m.field_type,
                    |m: &mut OpenNewDisputeMessage| &mut m.field_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpenNewDisputeMessage>(
                    "OpenNewDisputeMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static OpenNewDisputeMessage {
        static mut instance: ::protobuf::lazy::Lazy<OpenNewDisputeMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const OpenNewDisputeMessage,
            };
        unsafe { instance.get(OpenNewDisputeMessage::new) }
    }
}

impl ::protobuf::Clear for OpenNewDisputeMessage {
    fn clear(&mut self) {
        self.dispute.clear();
        self.sender_node_address.clear();
        self.uid.clear();
        self.field_type = SupportType::ARBITRATION;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenNewDisputeMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenNewDisputeMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PeerOpenedDisputeMessage {
    // message fields
    pub dispute: ::protobuf::SingularPtrField<Dispute>,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub uid: ::std::string::String,
    pub field_type: SupportType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeerOpenedDisputeMessage {
    fn default() -> &'a PeerOpenedDisputeMessage {
        <PeerOpenedDisputeMessage as ::protobuf::Message>::default_instance()
    }
}

impl PeerOpenedDisputeMessage {
    pub fn new() -> PeerOpenedDisputeMessage {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Dispute dispute = 1;

    pub fn get_dispute(&self) -> &Dispute {
        self.dispute
            .as_ref()
            .unwrap_or_else(|| Dispute::default_instance())
    }
    pub fn clear_dispute(&mut self) {
        self.dispute.clear();
    }

    pub fn has_dispute(&self) -> bool {
        self.dispute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dispute(&mut self, v: Dispute) {
        self.dispute = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dispute(&mut self) -> &mut Dispute {
        if self.dispute.is_none() {
            self.dispute.set_default();
        }
        self.dispute.as_mut().unwrap()
    }

    // Take field
    pub fn take_dispute(&mut self) -> Dispute {
        self.dispute.take().unwrap_or_else(|| Dispute::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 2;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // string uid = 3;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.SupportType type = 4;

    pub fn get_field_type(&self) -> SupportType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = SupportType::ARBITRATION;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SupportType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for PeerOpenedDisputeMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.dispute {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dispute)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                4 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.field_type,
                    4,
                    &mut self.unknown_fields,
                )?,
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dispute.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.uid);
        }
        if self.field_type != SupportType::ARBITRATION {
            my_size += ::protobuf::rt::enum_size(4, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dispute.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.uid.is_empty() {
            os.write_string(3, &self.uid)?;
        }
        if self.field_type != SupportType::ARBITRATION {
            os.write_enum(4, self.field_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeerOpenedDisputeMessage {
        PeerOpenedDisputeMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Dispute>,
                    >(
                        "dispute",
                        |m: &PeerOpenedDisputeMessage| &m.dispute,
                        |m: &mut PeerOpenedDisputeMessage| &mut m.dispute,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &PeerOpenedDisputeMessage| &m.sender_node_address,
                        |m: &mut PeerOpenedDisputeMessage| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &PeerOpenedDisputeMessage| &m.uid,
                    |m: &mut PeerOpenedDisputeMessage| &mut m.uid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<SupportType>,
                >(
                    "type",
                    |m: &PeerOpenedDisputeMessage| &m.field_type,
                    |m: &mut PeerOpenedDisputeMessage| &mut m.field_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PeerOpenedDisputeMessage>(
                    "PeerOpenedDisputeMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PeerOpenedDisputeMessage {
        static mut instance: ::protobuf::lazy::Lazy<PeerOpenedDisputeMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PeerOpenedDisputeMessage,
            };
        unsafe { instance.get(PeerOpenedDisputeMessage::new) }
    }
}

impl ::protobuf::Clear for PeerOpenedDisputeMessage {
    fn clear(&mut self) {
        self.dispute.clear();
        self.sender_node_address.clear();
        self.uid.clear();
        self.field_type = SupportType::ARBITRATION;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeerOpenedDisputeMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerOpenedDisputeMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ChatMessage {
    // message fields
    pub date: i64,
    pub trade_id: ::std::string::String,
    pub trader_id: i32,
    pub sender_is_trader: bool,
    pub message: ::std::string::String,
    pub attachments: ::protobuf::RepeatedField<Attachment>,
    pub arrived: bool,
    pub stored_in_mailbox: bool,
    pub is_system_message: bool,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub uid: ::std::string::String,
    pub send_message_error: ::std::string::String,
    pub acknowledged: bool,
    pub ack_error: ::std::string::String,
    pub field_type: SupportType,
    pub was_displayed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChatMessage {
    fn default() -> &'a ChatMessage {
        <ChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl ChatMessage {
    pub fn new() -> ChatMessage {
        ::std::default::Default::default()
    }

    // int64 date = 1;

    pub fn get_date(&self) -> i64 {
        self.date
    }
    pub fn clear_date(&mut self) {
        self.date = 0;
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: i64) {
        self.date = v;
    }

    // string trade_id = 2;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // int32 trader_id = 3;

    pub fn get_trader_id(&self) -> i32 {
        self.trader_id
    }
    pub fn clear_trader_id(&mut self) {
        self.trader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_trader_id(&mut self, v: i32) {
        self.trader_id = v;
    }

    // bool sender_is_trader = 4;

    pub fn get_sender_is_trader(&self) -> bool {
        self.sender_is_trader
    }
    pub fn clear_sender_is_trader(&mut self) {
        self.sender_is_trader = false;
    }

    // Param is passed by value, moved
    pub fn set_sender_is_trader(&mut self, v: bool) {
        self.sender_is_trader = v;
    }

    // string message = 5;

    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // repeated .io.bisq.protobuffer.Attachment attachments = 6;

    pub fn get_attachments(&self) -> &[Attachment] {
        &self.attachments
    }
    pub fn clear_attachments(&mut self) {
        self.attachments.clear();
    }

    // Param is passed by value, moved
    pub fn set_attachments(&mut self, v: ::protobuf::RepeatedField<Attachment>) {
        self.attachments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attachments(&mut self) -> &mut ::protobuf::RepeatedField<Attachment> {
        &mut self.attachments
    }

    // Take field
    pub fn take_attachments(&mut self) -> ::protobuf::RepeatedField<Attachment> {
        ::std::mem::replace(&mut self.attachments, ::protobuf::RepeatedField::new())
    }

    // bool arrived = 7;

    pub fn get_arrived(&self) -> bool {
        self.arrived
    }
    pub fn clear_arrived(&mut self) {
        self.arrived = false;
    }

    // Param is passed by value, moved
    pub fn set_arrived(&mut self, v: bool) {
        self.arrived = v;
    }

    // bool stored_in_mailbox = 8;

    pub fn get_stored_in_mailbox(&self) -> bool {
        self.stored_in_mailbox
    }
    pub fn clear_stored_in_mailbox(&mut self) {
        self.stored_in_mailbox = false;
    }

    // Param is passed by value, moved
    pub fn set_stored_in_mailbox(&mut self, v: bool) {
        self.stored_in_mailbox = v;
    }

    // bool is_system_message = 9;

    pub fn get_is_system_message(&self) -> bool {
        self.is_system_message
    }
    pub fn clear_is_system_message(&mut self) {
        self.is_system_message = false;
    }

    // Param is passed by value, moved
    pub fn set_is_system_message(&mut self, v: bool) {
        self.is_system_message = v;
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 10;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // string uid = 11;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // string send_message_error = 12;

    pub fn get_send_message_error(&self) -> &str {
        &self.send_message_error
    }
    pub fn clear_send_message_error(&mut self) {
        self.send_message_error.clear();
    }

    // Param is passed by value, moved
    pub fn set_send_message_error(&mut self, v: ::std::string::String) {
        self.send_message_error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_send_message_error(&mut self) -> &mut ::std::string::String {
        &mut self.send_message_error
    }

    // Take field
    pub fn take_send_message_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.send_message_error, ::std::string::String::new())
    }

    // bool acknowledged = 13;

    pub fn get_acknowledged(&self) -> bool {
        self.acknowledged
    }
    pub fn clear_acknowledged(&mut self) {
        self.acknowledged = false;
    }

    // Param is passed by value, moved
    pub fn set_acknowledged(&mut self, v: bool) {
        self.acknowledged = v;
    }

    // string ack_error = 14;

    pub fn get_ack_error(&self) -> &str {
        &self.ack_error
    }
    pub fn clear_ack_error(&mut self) {
        self.ack_error.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_error(&mut self, v: ::std::string::String) {
        self.ack_error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ack_error(&mut self) -> &mut ::std::string::String {
        &mut self.ack_error
    }

    // Take field
    pub fn take_ack_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ack_error, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.SupportType type = 15;

    pub fn get_field_type(&self) -> SupportType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = SupportType::ARBITRATION;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SupportType) {
        self.field_type = v;
    }

    // bool was_displayed = 16;

    pub fn get_was_displayed(&self) -> bool {
        self.was_displayed
    }
    pub fn clear_was_displayed(&mut self) {
        self.was_displayed = false;
    }

    // Param is passed by value, moved
    pub fn set_was_displayed(&mut self, v: bool) {
        self.was_displayed = v;
    }
}

impl ::protobuf::Message for ChatMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.attachments {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.date = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.trader_id = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.sender_is_trader = tmp;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.message,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.attachments,
                    )?;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.arrived = tmp;
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.stored_in_mailbox = tmp;
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_system_message = tmp;
                }
                10 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.send_message_error,
                    )?;
                }
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.acknowledged = tmp;
                }
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.ack_error,
                    )?;
                }
                15 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.field_type,
                    15,
                    &mut self.unknown_fields,
                )?,
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.was_displayed = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.date != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.date, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trade_id);
        }
        if self.trader_id != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.trader_id,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.sender_is_trader != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.message);
        }
        for value in &self.attachments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.arrived != false {
            my_size += 2;
        }
        if self.stored_in_mailbox != false {
            my_size += 2;
        }
        if self.is_system_message != false {
            my_size += 2;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.uid);
        }
        if !self.send_message_error.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.send_message_error);
        }
        if self.acknowledged != false {
            my_size += 2;
        }
        if !self.ack_error.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.ack_error);
        }
        if self.field_type != SupportType::ARBITRATION {
            my_size += ::protobuf::rt::enum_size(15, self.field_type);
        }
        if self.was_displayed != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.date != 0 {
            os.write_int64(1, self.date)?;
        }
        if !self.trade_id.is_empty() {
            os.write_string(2, &self.trade_id)?;
        }
        if self.trader_id != 0 {
            os.write_int32(3, self.trader_id)?;
        }
        if self.sender_is_trader != false {
            os.write_bool(4, self.sender_is_trader)?;
        }
        if !self.message.is_empty() {
            os.write_string(5, &self.message)?;
        }
        for v in &self.attachments {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.arrived != false {
            os.write_bool(7, self.arrived)?;
        }
        if self.stored_in_mailbox != false {
            os.write_bool(8, self.stored_in_mailbox)?;
        }
        if self.is_system_message != false {
            os.write_bool(9, self.is_system_message)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.uid.is_empty() {
            os.write_string(11, &self.uid)?;
        }
        if !self.send_message_error.is_empty() {
            os.write_string(12, &self.send_message_error)?;
        }
        if self.acknowledged != false {
            os.write_bool(13, self.acknowledged)?;
        }
        if !self.ack_error.is_empty() {
            os.write_string(14, &self.ack_error)?;
        }
        if self.field_type != SupportType::ARBITRATION {
            os.write_enum(15, self.field_type.value())?;
        }
        if self.was_displayed != false {
            os.write_bool(16, self.was_displayed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChatMessage {
        ChatMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "date",
                    |m: &ChatMessage| &m.date,
                    |m: &mut ChatMessage| &mut m.date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &ChatMessage| &m.trade_id,
                    |m: &mut ChatMessage| &mut m.trade_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "trader_id",
                    |m: &ChatMessage| &m.trader_id,
                    |m: &mut ChatMessage| &mut m.trader_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "sender_is_trader",
                    |m: &ChatMessage| &m.sender_is_trader,
                    |m: &mut ChatMessage| &mut m.sender_is_trader,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "message",
                    |m: &ChatMessage| &m.message,
                    |m: &mut ChatMessage| &mut m.message,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Attachment>,
                    >(
                        "attachments",
                        |m: &ChatMessage| &m.attachments,
                        |m: &mut ChatMessage| &mut m.attachments,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "arrived",
                    |m: &ChatMessage| &m.arrived,
                    |m: &mut ChatMessage| &mut m.arrived,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "stored_in_mailbox",
                    |m: &ChatMessage| &m.stored_in_mailbox,
                    |m: &mut ChatMessage| &mut m.stored_in_mailbox,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_system_message",
                    |m: &ChatMessage| &m.is_system_message,
                    |m: &mut ChatMessage| &mut m.is_system_message,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &ChatMessage| &m.sender_node_address,
                        |m: &mut ChatMessage| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &ChatMessage| &m.uid,
                    |m: &mut ChatMessage| &mut m.uid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "send_message_error",
                    |m: &ChatMessage| &m.send_message_error,
                    |m: &mut ChatMessage| &mut m.send_message_error,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "acknowledged",
                    |m: &ChatMessage| &m.acknowledged,
                    |m: &mut ChatMessage| &mut m.acknowledged,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "ack_error",
                    |m: &ChatMessage| &m.ack_error,
                    |m: &mut ChatMessage| &mut m.ack_error,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<SupportType>,
                >(
                    "type",
                    |m: &ChatMessage| &m.field_type,
                    |m: &mut ChatMessage| &mut m.field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "was_displayed",
                    |m: &ChatMessage| &m.was_displayed,
                    |m: &mut ChatMessage| &mut m.was_displayed,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChatMessage>(
                    "ChatMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ChatMessage {
        static mut instance: ::protobuf::lazy::Lazy<ChatMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChatMessage,
        };
        unsafe { instance.get(ChatMessage::new) }
    }
}

impl ::protobuf::Clear for ChatMessage {
    fn clear(&mut self) {
        self.date = 0;
        self.trade_id.clear();
        self.trader_id = 0;
        self.sender_is_trader = false;
        self.message.clear();
        self.attachments.clear();
        self.arrived = false;
        self.stored_in_mailbox = false;
        self.is_system_message = false;
        self.sender_node_address.clear();
        self.uid.clear();
        self.send_message_error.clear();
        self.acknowledged = false;
        self.ack_error.clear();
        self.field_type = SupportType::ARBITRATION;
        self.was_displayed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct DisputeResultMessage {
    // message fields
    pub uid: ::std::string::String,
    pub dispute_result: ::protobuf::SingularPtrField<DisputeResult>,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub field_type: SupportType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisputeResultMessage {
    fn default() -> &'a DisputeResultMessage {
        <DisputeResultMessage as ::protobuf::Message>::default_instance()
    }
}

impl DisputeResultMessage {
    pub fn new() -> DisputeResultMessage {
        ::std::default::Default::default()
    }

    // string uid = 1;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.DisputeResult dispute_result = 2;

    pub fn get_dispute_result(&self) -> &DisputeResult {
        self.dispute_result
            .as_ref()
            .unwrap_or_else(|| DisputeResult::default_instance())
    }
    pub fn clear_dispute_result(&mut self) {
        self.dispute_result.clear();
    }

    pub fn has_dispute_result(&self) -> bool {
        self.dispute_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dispute_result(&mut self, v: DisputeResult) {
        self.dispute_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dispute_result(&mut self) -> &mut DisputeResult {
        if self.dispute_result.is_none() {
            self.dispute_result.set_default();
        }
        self.dispute_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_dispute_result(&mut self) -> DisputeResult {
        self.dispute_result
            .take()
            .unwrap_or_else(|| DisputeResult::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 3;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // .io.bisq.protobuffer.SupportType type = 4;

    pub fn get_field_type(&self) -> SupportType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = SupportType::ARBITRATION;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SupportType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for DisputeResultMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.dispute_result {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.dispute_result,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                4 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.field_type,
                    4,
                    &mut self.unknown_fields,
                )?,
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if let Some(ref v) = self.dispute_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.field_type != SupportType::ARBITRATION {
            my_size += ::protobuf::rt::enum_size(4, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if let Some(ref v) = self.dispute_result.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.field_type != SupportType::ARBITRATION {
            os.write_enum(4, self.field_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisputeResultMessage {
        DisputeResultMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &DisputeResultMessage| &m.uid,
                    |m: &mut DisputeResultMessage| &mut m.uid,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<DisputeResult>,
                    >(
                        "dispute_result",
                        |m: &DisputeResultMessage| &m.dispute_result,
                        |m: &mut DisputeResultMessage| &mut m.dispute_result,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &DisputeResultMessage| &m.sender_node_address,
                        |m: &mut DisputeResultMessage| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<SupportType>,
                >(
                    "type",
                    |m: &DisputeResultMessage| &m.field_type,
                    |m: &mut DisputeResultMessage| &mut m.field_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DisputeResultMessage>(
                    "DisputeResultMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static DisputeResultMessage {
        static mut instance: ::protobuf::lazy::Lazy<DisputeResultMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const DisputeResultMessage,
            };
        unsafe { instance.get(DisputeResultMessage::new) }
    }
}

impl ::protobuf::Clear for DisputeResultMessage {
    fn clear(&mut self) {
        self.uid.clear();
        self.dispute_result.clear();
        self.sender_node_address.clear();
        self.field_type = SupportType::ARBITRATION;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisputeResultMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisputeResultMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PeerPublishedDisputePayoutTxMessage {
    // message fields
    pub uid: ::std::string::String,
    pub transaction: ::std::vec::Vec<u8>,
    pub trade_id: ::std::string::String,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub field_type: SupportType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeerPublishedDisputePayoutTxMessage {
    fn default() -> &'a PeerPublishedDisputePayoutTxMessage {
        <PeerPublishedDisputePayoutTxMessage as ::protobuf::Message>::default_instance()
    }
}

impl PeerPublishedDisputePayoutTxMessage {
    pub fn new() -> PeerPublishedDisputePayoutTxMessage {
        ::std::default::Default::default()
    }

    // string uid = 1;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // bytes transaction = 2;

    pub fn get_transaction(&self) -> &[u8] {
        &self.transaction
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::std::vec::Vec<u8>) {
        self.transaction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transaction
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transaction, ::std::vec::Vec::new())
    }

    // string trade_id = 3;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 4;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // .io.bisq.protobuffer.SupportType type = 5;

    pub fn get_field_type(&self) -> SupportType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = SupportType::ARBITRATION;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SupportType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for PeerPublishedDisputePayoutTxMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.transaction,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                5 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.field_type,
                    5,
                    &mut self.unknown_fields,
                )?,
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if !self.transaction.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.transaction);
        }
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.trade_id);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.field_type != SupportType::ARBITRATION {
            my_size += ::protobuf::rt::enum_size(5, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if !self.transaction.is_empty() {
            os.write_bytes(2, &self.transaction)?;
        }
        if !self.trade_id.is_empty() {
            os.write_string(3, &self.trade_id)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.field_type != SupportType::ARBITRATION {
            os.write_enum(5, self.field_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeerPublishedDisputePayoutTxMessage {
        PeerPublishedDisputePayoutTxMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &PeerPublishedDisputePayoutTxMessage| &m.uid,
                    |m: &mut PeerPublishedDisputePayoutTxMessage| &mut m.uid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "transaction",
                    |m: &PeerPublishedDisputePayoutTxMessage| &m.transaction,
                    |m: &mut PeerPublishedDisputePayoutTxMessage| &mut m.transaction,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &PeerPublishedDisputePayoutTxMessage| &m.trade_id,
                    |m: &mut PeerPublishedDisputePayoutTxMessage| &mut m.trade_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &PeerPublishedDisputePayoutTxMessage| &m.sender_node_address,
                        |m: &mut PeerPublishedDisputePayoutTxMessage| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<SupportType>,
                >(
                    "type",
                    |m: &PeerPublishedDisputePayoutTxMessage| &m.field_type,
                    |m: &mut PeerPublishedDisputePayoutTxMessage| &mut m.field_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PeerPublishedDisputePayoutTxMessage>(
                    "PeerPublishedDisputePayoutTxMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PeerPublishedDisputePayoutTxMessage {
        static mut instance: ::protobuf::lazy::Lazy<PeerPublishedDisputePayoutTxMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PeerPublishedDisputePayoutTxMessage,
            };
        unsafe { instance.get(PeerPublishedDisputePayoutTxMessage::new) }
    }
}

impl ::protobuf::Clear for PeerPublishedDisputePayoutTxMessage {
    fn clear(&mut self) {
        self.uid.clear();
        self.transaction.clear();
        self.trade_id.clear();
        self.sender_node_address.clear();
        self.field_type = SupportType::ARBITRATION;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeerPublishedDisputePayoutTxMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerPublishedDisputePayoutTxMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PrivateNotificationMessage {
    // message fields
    pub uid: ::std::string::String,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub private_notification_payload: ::protobuf::SingularPtrField<PrivateNotificationPayload>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrivateNotificationMessage {
    fn default() -> &'a PrivateNotificationMessage {
        <PrivateNotificationMessage as ::protobuf::Message>::default_instance()
    }
}

impl PrivateNotificationMessage {
    pub fn new() -> PrivateNotificationMessage {
        ::std::default::Default::default()
    }

    // string uid = 1;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 2;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // .io.bisq.protobuffer.PrivateNotificationPayload private_notification_payload = 3;

    pub fn get_private_notification_payload(&self) -> &PrivateNotificationPayload {
        self.private_notification_payload
            .as_ref()
            .unwrap_or_else(|| PrivateNotificationPayload::default_instance())
    }
    pub fn clear_private_notification_payload(&mut self) {
        self.private_notification_payload.clear();
    }

    pub fn has_private_notification_payload(&self) -> bool {
        self.private_notification_payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_notification_payload(&mut self, v: PrivateNotificationPayload) {
        self.private_notification_payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_private_notification_payload(&mut self) -> &mut PrivateNotificationPayload {
        if self.private_notification_payload.is_none() {
            self.private_notification_payload.set_default();
        }
        self.private_notification_payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_private_notification_payload(&mut self) -> PrivateNotificationPayload {
        self.private_notification_payload
            .take()
            .unwrap_or_else(|| PrivateNotificationPayload::new())
    }
}

impl ::protobuf::Message for PrivateNotificationMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.private_notification_payload {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.private_notification_payload,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.private_notification_payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.private_notification_payload.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrivateNotificationMessage {
        PrivateNotificationMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &PrivateNotificationMessage| &m.uid,
                    |m: &mut PrivateNotificationMessage| &mut m.uid,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &PrivateNotificationMessage| &m.sender_node_address,
                        |m: &mut PrivateNotificationMessage| &mut m.sender_node_address,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PrivateNotificationPayload>,
                    >(
                        "private_notification_payload",
                        |m: &PrivateNotificationMessage| &m.private_notification_payload,
                        |m: &mut PrivateNotificationMessage| &mut m.private_notification_payload,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<PrivateNotificationMessage>(
                    "PrivateNotificationMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PrivateNotificationMessage {
        static mut instance: ::protobuf::lazy::Lazy<PrivateNotificationMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PrivateNotificationMessage,
            };
        unsafe { instance.get(PrivateNotificationMessage::new) }
    }
}

impl ::protobuf::Clear for PrivateNotificationMessage {
    fn clear(&mut self) {
        self.uid.clear();
        self.sender_node_address.clear();
        self.private_notification_payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrivateNotificationMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrivateNotificationMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct GetBlocksRequest {
    // message fields
    pub from_block_height: i32,
    pub nonce: i32,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub supported_capabilities: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlocksRequest {
    fn default() -> &'a GetBlocksRequest {
        <GetBlocksRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBlocksRequest {
    pub fn new() -> GetBlocksRequest {
        ::std::default::Default::default()
    }

    // int32 from_block_height = 1;

    pub fn get_from_block_height(&self) -> i32 {
        self.from_block_height
    }
    pub fn clear_from_block_height(&mut self) {
        self.from_block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_from_block_height(&mut self, v: i32) {
        self.from_block_height = v;
    }

    // int32 nonce = 2;

    pub fn get_nonce(&self) -> i32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i32) {
        self.nonce = v;
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 3;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // repeated int32 supported_capabilities = 4;

    pub fn get_supported_capabilities(&self) -> &[i32] {
        &self.supported_capabilities
    }
    pub fn clear_supported_capabilities(&mut self) {
        self.supported_capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_capabilities(&mut self, v: ::std::vec::Vec<i32>) {
        self.supported_capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_capabilities(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.supported_capabilities
    }

    // Take field
    pub fn take_supported_capabilities(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.supported_capabilities, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetBlocksRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.from_block_height = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.nonce = tmp;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(
                        wire_type,
                        is,
                        &mut self.supported_capabilities,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.from_block_height != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.from_block_height,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.nonce != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.supported_capabilities {
            my_size +=
                ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.from_block_height != 0 {
            os.write_int32(1, self.from_block_height)?;
        }
        if self.nonce != 0 {
            os.write_int32(2, self.nonce)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.supported_capabilities {
            os.write_int32(4, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlocksRequest {
        GetBlocksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "from_block_height",
                    |m: &GetBlocksRequest| &m.from_block_height,
                    |m: &mut GetBlocksRequest| &mut m.from_block_height,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "nonce",
                    |m: &GetBlocksRequest| &m.nonce,
                    |m: &mut GetBlocksRequest| &mut m.nonce,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &GetBlocksRequest| &m.sender_node_address,
                        |m: &mut GetBlocksRequest| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "supported_capabilities",
                    |m: &GetBlocksRequest| &m.supported_capabilities,
                    |m: &mut GetBlocksRequest| &mut m.supported_capabilities,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlocksRequest>(
                    "GetBlocksRequest",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlocksRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetBlocksRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlocksRequest,
        };
        unsafe { instance.get(GetBlocksRequest::new) }
    }
}

impl ::protobuf::Clear for GetBlocksRequest {
    fn clear(&mut self) {
        self.from_block_height = 0;
        self.nonce = 0;
        self.sender_node_address.clear();
        self.supported_capabilities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlocksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlocksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct GetBlocksResponse {
    // message fields
    pub raw_blocks: ::protobuf::RepeatedField<BaseBlock>,
    pub request_nonce: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlocksResponse {
    fn default() -> &'a GetBlocksResponse {
        <GetBlocksResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBlocksResponse {
    pub fn new() -> GetBlocksResponse {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.BaseBlock raw_blocks = 1;

    pub fn get_raw_blocks(&self) -> &[BaseBlock] {
        &self.raw_blocks
    }
    pub fn clear_raw_blocks(&mut self) {
        self.raw_blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_blocks(&mut self, v: ::protobuf::RepeatedField<BaseBlock>) {
        self.raw_blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_raw_blocks(&mut self) -> &mut ::protobuf::RepeatedField<BaseBlock> {
        &mut self.raw_blocks
    }

    // Take field
    pub fn take_raw_blocks(&mut self) -> ::protobuf::RepeatedField<BaseBlock> {
        ::std::mem::replace(&mut self.raw_blocks, ::protobuf::RepeatedField::new())
    }

    // int32 request_nonce = 2;

    pub fn get_request_nonce(&self) -> i32 {
        self.request_nonce
    }
    pub fn clear_request_nonce(&mut self) {
        self.request_nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_request_nonce(&mut self, v: i32) {
        self.request_nonce = v;
    }
}

impl ::protobuf::Message for GetBlocksResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.raw_blocks {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.raw_blocks,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.request_nonce = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.raw_blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.request_nonce != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.request_nonce,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.raw_blocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.request_nonce != 0 {
            os.write_int32(2, self.request_nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlocksResponse {
        GetBlocksResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BaseBlock>,
                    >(
                        "raw_blocks",
                        |m: &GetBlocksResponse| &m.raw_blocks,
                        |m: &mut GetBlocksResponse| &mut m.raw_blocks,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "request_nonce",
                    |m: &GetBlocksResponse| &m.request_nonce,
                    |m: &mut GetBlocksResponse| &mut m.request_nonce,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlocksResponse>(
                    "GetBlocksResponse",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlocksResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetBlocksResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlocksResponse,
        };
        unsafe { instance.get(GetBlocksResponse::new) }
    }
}

impl ::protobuf::Clear for GetBlocksResponse {
    fn clear(&mut self) {
        self.raw_blocks.clear();
        self.request_nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlocksResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlocksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct NewBlockBroadcastMessage {
    // message fields
    pub raw_block: ::protobuf::SingularPtrField<BaseBlock>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NewBlockBroadcastMessage {
    fn default() -> &'a NewBlockBroadcastMessage {
        <NewBlockBroadcastMessage as ::protobuf::Message>::default_instance()
    }
}

impl NewBlockBroadcastMessage {
    pub fn new() -> NewBlockBroadcastMessage {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.BaseBlock raw_block = 1;

    pub fn get_raw_block(&self) -> &BaseBlock {
        self.raw_block
            .as_ref()
            .unwrap_or_else(|| BaseBlock::default_instance())
    }
    pub fn clear_raw_block(&mut self) {
        self.raw_block.clear();
    }

    pub fn has_raw_block(&self) -> bool {
        self.raw_block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_block(&mut self, v: BaseBlock) {
        self.raw_block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_block(&mut self) -> &mut BaseBlock {
        if self.raw_block.is_none() {
            self.raw_block.set_default();
        }
        self.raw_block.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_block(&mut self) -> BaseBlock {
        self.raw_block.take().unwrap_or_else(|| BaseBlock::new())
    }
}

impl ::protobuf::Message for NewBlockBroadcastMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.raw_block {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.raw_block)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.raw_block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.raw_block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewBlockBroadcastMessage {
        NewBlockBroadcastMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BaseBlock>,
                    >(
                        "raw_block",
                        |m: &NewBlockBroadcastMessage| &m.raw_block,
                        |m: &mut NewBlockBroadcastMessage| &mut m.raw_block,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<NewBlockBroadcastMessage>(
                    "NewBlockBroadcastMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static NewBlockBroadcastMessage {
        static mut instance: ::protobuf::lazy::Lazy<NewBlockBroadcastMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const NewBlockBroadcastMessage,
            };
        unsafe { instance.get(NewBlockBroadcastMessage::new) }
    }
}

impl ::protobuf::Clear for NewBlockBroadcastMessage {
    fn clear(&mut self) {
        self.raw_block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewBlockBroadcastMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewBlockBroadcastMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RepublishGovernanceDataRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RepublishGovernanceDataRequest {
    fn default() -> &'a RepublishGovernanceDataRequest {
        <RepublishGovernanceDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl RepublishGovernanceDataRequest {
    pub fn new() -> RepublishGovernanceDataRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RepublishGovernanceDataRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RepublishGovernanceDataRequest {
        RepublishGovernanceDataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RepublishGovernanceDataRequest>(
                    "RepublishGovernanceDataRequest",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static RepublishGovernanceDataRequest {
        static mut instance: ::protobuf::lazy::Lazy<RepublishGovernanceDataRequest> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const RepublishGovernanceDataRequest,
            };
        unsafe { instance.get(RepublishGovernanceDataRequest::new) }
    }
}

impl ::protobuf::Clear for RepublishGovernanceDataRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RepublishGovernanceDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RepublishGovernanceDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct NewDaoStateHashMessage {
    // message fields
    pub state_hash: ::protobuf::SingularPtrField<DaoStateHash>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NewDaoStateHashMessage {
    fn default() -> &'a NewDaoStateHashMessage {
        <NewDaoStateHashMessage as ::protobuf::Message>::default_instance()
    }
}

impl NewDaoStateHashMessage {
    pub fn new() -> NewDaoStateHashMessage {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.DaoStateHash state_hash = 1;

    pub fn get_state_hash(&self) -> &DaoStateHash {
        self.state_hash
            .as_ref()
            .unwrap_or_else(|| DaoStateHash::default_instance())
    }
    pub fn clear_state_hash(&mut self) {
        self.state_hash.clear();
    }

    pub fn has_state_hash(&self) -> bool {
        self.state_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_hash(&mut self, v: DaoStateHash) {
        self.state_hash = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state_hash(&mut self) -> &mut DaoStateHash {
        if self.state_hash.is_none() {
            self.state_hash.set_default();
        }
        self.state_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_state_hash(&mut self) -> DaoStateHash {
        self.state_hash
            .take()
            .unwrap_or_else(|| DaoStateHash::new())
    }
}

impl ::protobuf::Message for NewDaoStateHashMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.state_hash {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.state_hash,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state_hash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state_hash.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewDaoStateHashMessage {
        NewDaoStateHashMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<DaoStateHash>,
                    >(
                        "state_hash",
                        |m: &NewDaoStateHashMessage| &m.state_hash,
                        |m: &mut NewDaoStateHashMessage| &mut m.state_hash,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<NewDaoStateHashMessage>(
                    "NewDaoStateHashMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static NewDaoStateHashMessage {
        static mut instance: ::protobuf::lazy::Lazy<NewDaoStateHashMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const NewDaoStateHashMessage,
            };
        unsafe { instance.get(NewDaoStateHashMessage::new) }
    }
}

impl ::protobuf::Clear for NewDaoStateHashMessage {
    fn clear(&mut self) {
        self.state_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewDaoStateHashMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewDaoStateHashMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct NewProposalStateHashMessage {
    // message fields
    pub state_hash: ::protobuf::SingularPtrField<ProposalStateHash>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NewProposalStateHashMessage {
    fn default() -> &'a NewProposalStateHashMessage {
        <NewProposalStateHashMessage as ::protobuf::Message>::default_instance()
    }
}

impl NewProposalStateHashMessage {
    pub fn new() -> NewProposalStateHashMessage {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.ProposalStateHash state_hash = 1;

    pub fn get_state_hash(&self) -> &ProposalStateHash {
        self.state_hash
            .as_ref()
            .unwrap_or_else(|| ProposalStateHash::default_instance())
    }
    pub fn clear_state_hash(&mut self) {
        self.state_hash.clear();
    }

    pub fn has_state_hash(&self) -> bool {
        self.state_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_hash(&mut self, v: ProposalStateHash) {
        self.state_hash = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state_hash(&mut self) -> &mut ProposalStateHash {
        if self.state_hash.is_none() {
            self.state_hash.set_default();
        }
        self.state_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_state_hash(&mut self) -> ProposalStateHash {
        self.state_hash
            .take()
            .unwrap_or_else(|| ProposalStateHash::new())
    }
}

impl ::protobuf::Message for NewProposalStateHashMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.state_hash {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.state_hash,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state_hash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state_hash.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewProposalStateHashMessage {
        NewProposalStateHashMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<ProposalStateHash>,
                    >(
                        "state_hash",
                        |m: &NewProposalStateHashMessage| &m.state_hash,
                        |m: &mut NewProposalStateHashMessage| &mut m.state_hash,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<NewProposalStateHashMessage>(
                    "NewProposalStateHashMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static NewProposalStateHashMessage {
        static mut instance: ::protobuf::lazy::Lazy<NewProposalStateHashMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const NewProposalStateHashMessage,
            };
        unsafe { instance.get(NewProposalStateHashMessage::new) }
    }
}

impl ::protobuf::Clear for NewProposalStateHashMessage {
    fn clear(&mut self) {
        self.state_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewProposalStateHashMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewProposalStateHashMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct NewBlindVoteStateHashMessage {
    // message fields
    pub state_hash: ::protobuf::SingularPtrField<BlindVoteStateHash>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NewBlindVoteStateHashMessage {
    fn default() -> &'a NewBlindVoteStateHashMessage {
        <NewBlindVoteStateHashMessage as ::protobuf::Message>::default_instance()
    }
}

impl NewBlindVoteStateHashMessage {
    pub fn new() -> NewBlindVoteStateHashMessage {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.BlindVoteStateHash state_hash = 1;

    pub fn get_state_hash(&self) -> &BlindVoteStateHash {
        self.state_hash
            .as_ref()
            .unwrap_or_else(|| BlindVoteStateHash::default_instance())
    }
    pub fn clear_state_hash(&mut self) {
        self.state_hash.clear();
    }

    pub fn has_state_hash(&self) -> bool {
        self.state_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_hash(&mut self, v: BlindVoteStateHash) {
        self.state_hash = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state_hash(&mut self) -> &mut BlindVoteStateHash {
        if self.state_hash.is_none() {
            self.state_hash.set_default();
        }
        self.state_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_state_hash(&mut self) -> BlindVoteStateHash {
        self.state_hash
            .take()
            .unwrap_or_else(|| BlindVoteStateHash::new())
    }
}

impl ::protobuf::Message for NewBlindVoteStateHashMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.state_hash {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.state_hash,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state_hash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state_hash.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewBlindVoteStateHashMessage {
        NewBlindVoteStateHashMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BlindVoteStateHash>,
                    >(
                        "state_hash",
                        |m: &NewBlindVoteStateHashMessage| &m.state_hash,
                        |m: &mut NewBlindVoteStateHashMessage| &mut m.state_hash,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<NewBlindVoteStateHashMessage>(
                    "NewBlindVoteStateHashMessage",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static NewBlindVoteStateHashMessage {
        static mut instance: ::protobuf::lazy::Lazy<NewBlindVoteStateHashMessage> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const NewBlindVoteStateHashMessage,
            };
        unsafe { instance.get(NewBlindVoteStateHashMessage::new) }
    }
}

impl ::protobuf::Clear for NewBlindVoteStateHashMessage {
    fn clear(&mut self) {
        self.state_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewBlindVoteStateHashMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewBlindVoteStateHashMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct GetDaoStateHashesRequest {
    // message fields
    pub height: i32,
    pub nonce: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDaoStateHashesRequest {
    fn default() -> &'a GetDaoStateHashesRequest {
        <GetDaoStateHashesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDaoStateHashesRequest {
    pub fn new() -> GetDaoStateHashesRequest {
        ::std::default::Default::default()
    }

    // int32 height = 1;

    pub fn get_height(&self) -> i32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = v;
    }

    // int32 nonce = 2;

    pub fn get_nonce(&self) -> i32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i32) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for GetDaoStateHashesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.height = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.nonce = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nonce != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_int32(1, self.height)?;
        }
        if self.nonce != 0 {
            os.write_int32(2, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDaoStateHashesRequest {
        GetDaoStateHashesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "height",
                    |m: &GetDaoStateHashesRequest| &m.height,
                    |m: &mut GetDaoStateHashesRequest| &mut m.height,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "nonce",
                    |m: &GetDaoStateHashesRequest| &m.nonce,
                    |m: &mut GetDaoStateHashesRequest| &mut m.nonce,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDaoStateHashesRequest>(
                    "GetDaoStateHashesRequest",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static GetDaoStateHashesRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetDaoStateHashesRequest> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const GetDaoStateHashesRequest,
            };
        unsafe { instance.get(GetDaoStateHashesRequest::new) }
    }
}

impl ::protobuf::Clear for GetDaoStateHashesRequest {
    fn clear(&mut self) {
        self.height = 0;
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDaoStateHashesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDaoStateHashesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct GetProposalStateHashesRequest {
    // message fields
    pub height: i32,
    pub nonce: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetProposalStateHashesRequest {
    fn default() -> &'a GetProposalStateHashesRequest {
        <GetProposalStateHashesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetProposalStateHashesRequest {
    pub fn new() -> GetProposalStateHashesRequest {
        ::std::default::Default::default()
    }

    // int32 height = 1;

    pub fn get_height(&self) -> i32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = v;
    }

    // int32 nonce = 2;

    pub fn get_nonce(&self) -> i32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i32) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for GetProposalStateHashesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.height = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.nonce = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nonce != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_int32(1, self.height)?;
        }
        if self.nonce != 0 {
            os.write_int32(2, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetProposalStateHashesRequest {
        GetProposalStateHashesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "height",
                    |m: &GetProposalStateHashesRequest| &m.height,
                    |m: &mut GetProposalStateHashesRequest| &mut m.height,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "nonce",
                    |m: &GetProposalStateHashesRequest| &m.nonce,
                    |m: &mut GetProposalStateHashesRequest| &mut m.nonce,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetProposalStateHashesRequest>(
                    "GetProposalStateHashesRequest",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static GetProposalStateHashesRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetProposalStateHashesRequest> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const GetProposalStateHashesRequest,
            };
        unsafe { instance.get(GetProposalStateHashesRequest::new) }
    }
}

impl ::protobuf::Clear for GetProposalStateHashesRequest {
    fn clear(&mut self) {
        self.height = 0;
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetProposalStateHashesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetProposalStateHashesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct GetBlindVoteStateHashesRequest {
    // message fields
    pub height: i32,
    pub nonce: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlindVoteStateHashesRequest {
    fn default() -> &'a GetBlindVoteStateHashesRequest {
        <GetBlindVoteStateHashesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBlindVoteStateHashesRequest {
    pub fn new() -> GetBlindVoteStateHashesRequest {
        ::std::default::Default::default()
    }

    // int32 height = 1;

    pub fn get_height(&self) -> i32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = v;
    }

    // int32 nonce = 2;

    pub fn get_nonce(&self) -> i32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i32) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for GetBlindVoteStateHashesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.height = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.nonce = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nonce != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_int32(1, self.height)?;
        }
        if self.nonce != 0 {
            os.write_int32(2, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlindVoteStateHashesRequest {
        GetBlindVoteStateHashesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "height",
                    |m: &GetBlindVoteStateHashesRequest| &m.height,
                    |m: &mut GetBlindVoteStateHashesRequest| &mut m.height,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "nonce",
                    |m: &GetBlindVoteStateHashesRequest| &m.nonce,
                    |m: &mut GetBlindVoteStateHashesRequest| &mut m.nonce,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlindVoteStateHashesRequest>(
                    "GetBlindVoteStateHashesRequest",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlindVoteStateHashesRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetBlindVoteStateHashesRequest> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const GetBlindVoteStateHashesRequest,
            };
        unsafe { instance.get(GetBlindVoteStateHashesRequest::new) }
    }
}

impl ::protobuf::Clear for GetBlindVoteStateHashesRequest {
    fn clear(&mut self) {
        self.height = 0;
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlindVoteStateHashesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlindVoteStateHashesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct GetDaoStateHashesResponse {
    // message fields
    pub state_hashes: ::protobuf::RepeatedField<DaoStateHash>,
    pub request_nonce: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDaoStateHashesResponse {
    fn default() -> &'a GetDaoStateHashesResponse {
        <GetDaoStateHashesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetDaoStateHashesResponse {
    pub fn new() -> GetDaoStateHashesResponse {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.DaoStateHash state_hashes = 1;

    pub fn get_state_hashes(&self) -> &[DaoStateHash] {
        &self.state_hashes
    }
    pub fn clear_state_hashes(&mut self) {
        self.state_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_state_hashes(&mut self, v: ::protobuf::RepeatedField<DaoStateHash>) {
        self.state_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_state_hashes(&mut self) -> &mut ::protobuf::RepeatedField<DaoStateHash> {
        &mut self.state_hashes
    }

    // Take field
    pub fn take_state_hashes(&mut self) -> ::protobuf::RepeatedField<DaoStateHash> {
        ::std::mem::replace(&mut self.state_hashes, ::protobuf::RepeatedField::new())
    }

    // int32 request_nonce = 2;

    pub fn get_request_nonce(&self) -> i32 {
        self.request_nonce
    }
    pub fn clear_request_nonce(&mut self) {
        self.request_nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_request_nonce(&mut self, v: i32) {
        self.request_nonce = v;
    }
}

impl ::protobuf::Message for GetDaoStateHashesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.state_hashes {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.state_hashes,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.request_nonce = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.state_hashes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.request_nonce != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.request_nonce,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.state_hashes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.request_nonce != 0 {
            os.write_int32(2, self.request_nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDaoStateHashesResponse {
        GetDaoStateHashesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<DaoStateHash>,
                    >(
                        "state_hashes",
                        |m: &GetDaoStateHashesResponse| &m.state_hashes,
                        |m: &mut GetDaoStateHashesResponse| &mut m.state_hashes,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "request_nonce",
                    |m: &GetDaoStateHashesResponse| &m.request_nonce,
                    |m: &mut GetDaoStateHashesResponse| &mut m.request_nonce,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDaoStateHashesResponse>(
                    "GetDaoStateHashesResponse",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static GetDaoStateHashesResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetDaoStateHashesResponse> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const GetDaoStateHashesResponse,
            };
        unsafe { instance.get(GetDaoStateHashesResponse::new) }
    }
}

impl ::protobuf::Clear for GetDaoStateHashesResponse {
    fn clear(&mut self) {
        self.state_hashes.clear();
        self.request_nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDaoStateHashesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDaoStateHashesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct GetProposalStateHashesResponse {
    // message fields
    pub state_hashes: ::protobuf::RepeatedField<ProposalStateHash>,
    pub request_nonce: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetProposalStateHashesResponse {
    fn default() -> &'a GetProposalStateHashesResponse {
        <GetProposalStateHashesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetProposalStateHashesResponse {
    pub fn new() -> GetProposalStateHashesResponse {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.ProposalStateHash state_hashes = 1;

    pub fn get_state_hashes(&self) -> &[ProposalStateHash] {
        &self.state_hashes
    }
    pub fn clear_state_hashes(&mut self) {
        self.state_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_state_hashes(&mut self, v: ::protobuf::RepeatedField<ProposalStateHash>) {
        self.state_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_state_hashes(&mut self) -> &mut ::protobuf::RepeatedField<ProposalStateHash> {
        &mut self.state_hashes
    }

    // Take field
    pub fn take_state_hashes(&mut self) -> ::protobuf::RepeatedField<ProposalStateHash> {
        ::std::mem::replace(&mut self.state_hashes, ::protobuf::RepeatedField::new())
    }

    // int32 request_nonce = 2;

    pub fn get_request_nonce(&self) -> i32 {
        self.request_nonce
    }
    pub fn clear_request_nonce(&mut self) {
        self.request_nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_request_nonce(&mut self, v: i32) {
        self.request_nonce = v;
    }
}

impl ::protobuf::Message for GetProposalStateHashesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.state_hashes {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.state_hashes,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.request_nonce = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.state_hashes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.request_nonce != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.request_nonce,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.state_hashes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.request_nonce != 0 {
            os.write_int32(2, self.request_nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetProposalStateHashesResponse {
        GetProposalStateHashesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<ProposalStateHash>,
                    >(
                        "state_hashes",
                        |m: &GetProposalStateHashesResponse| &m.state_hashes,
                        |m: &mut GetProposalStateHashesResponse| &mut m.state_hashes,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "request_nonce",
                    |m: &GetProposalStateHashesResponse| &m.request_nonce,
                    |m: &mut GetProposalStateHashesResponse| &mut m.request_nonce,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetProposalStateHashesResponse>(
                    "GetProposalStateHashesResponse",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static GetProposalStateHashesResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetProposalStateHashesResponse> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const GetProposalStateHashesResponse,
            };
        unsafe { instance.get(GetProposalStateHashesResponse::new) }
    }
}

impl ::protobuf::Clear for GetProposalStateHashesResponse {
    fn clear(&mut self) {
        self.state_hashes.clear();
        self.request_nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetProposalStateHashesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetProposalStateHashesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct GetBlindVoteStateHashesResponse {
    // message fields
    pub state_hashes: ::protobuf::RepeatedField<BlindVoteStateHash>,
    pub request_nonce: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlindVoteStateHashesResponse {
    fn default() -> &'a GetBlindVoteStateHashesResponse {
        <GetBlindVoteStateHashesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBlindVoteStateHashesResponse {
    pub fn new() -> GetBlindVoteStateHashesResponse {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.BlindVoteStateHash state_hashes = 1;

    pub fn get_state_hashes(&self) -> &[BlindVoteStateHash] {
        &self.state_hashes
    }
    pub fn clear_state_hashes(&mut self) {
        self.state_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_state_hashes(&mut self, v: ::protobuf::RepeatedField<BlindVoteStateHash>) {
        self.state_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_state_hashes(&mut self) -> &mut ::protobuf::RepeatedField<BlindVoteStateHash> {
        &mut self.state_hashes
    }

    // Take field
    pub fn take_state_hashes(&mut self) -> ::protobuf::RepeatedField<BlindVoteStateHash> {
        ::std::mem::replace(&mut self.state_hashes, ::protobuf::RepeatedField::new())
    }

    // int32 request_nonce = 2;

    pub fn get_request_nonce(&self) -> i32 {
        self.request_nonce
    }
    pub fn clear_request_nonce(&mut self) {
        self.request_nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_request_nonce(&mut self, v: i32) {
        self.request_nonce = v;
    }
}

impl ::protobuf::Message for GetBlindVoteStateHashesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.state_hashes {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.state_hashes,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.request_nonce = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.state_hashes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.request_nonce != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.request_nonce,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.state_hashes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.request_nonce != 0 {
            os.write_int32(2, self.request_nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlindVoteStateHashesResponse {
        GetBlindVoteStateHashesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BlindVoteStateHash>,
                    >(
                        "state_hashes",
                        |m: &GetBlindVoteStateHashesResponse| &m.state_hashes,
                        |m: &mut GetBlindVoteStateHashesResponse| &mut m.state_hashes,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "request_nonce",
                    |m: &GetBlindVoteStateHashesResponse| &m.request_nonce,
                    |m: &mut GetBlindVoteStateHashesResponse| &mut m.request_nonce,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlindVoteStateHashesResponse>(
                    "GetBlindVoteStateHashesResponse",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlindVoteStateHashesResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetBlindVoteStateHashesResponse> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const GetBlindVoteStateHashesResponse,
            };
        unsafe { instance.get(GetBlindVoteStateHashesResponse::new) }
    }
}

impl ::protobuf::Clear for GetBlindVoteStateHashesResponse {
    fn clear(&mut self) {
        self.state_hashes.clear();
        self.request_nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlindVoteStateHashesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlindVoteStateHashesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct NodeAddress {
    // message fields
    pub host_name: ::std::string::String,
    pub port: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeAddress {
    fn default() -> &'a NodeAddress {
        <NodeAddress as ::protobuf::Message>::default_instance()
    }
}

impl NodeAddress {
    pub fn new() -> NodeAddress {
        ::std::default::Default::default()
    }

    // string host_name = 1;

    pub fn get_host_name(&self) -> &str {
        &self.host_name
    }
    pub fn clear_host_name(&mut self) {
        self.host_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_host_name(&mut self, v: ::std::string::String) {
        self.host_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
        &mut self.host_name
    }

    // Take field
    pub fn take_host_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host_name, ::std::string::String::new())
    }

    // int32 port = 2;

    pub fn get_port(&self) -> i32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = v;
    }
}

impl ::protobuf::Message for NodeAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.host_name,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.port = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host_name);
        }
        if self.port != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.host_name.is_empty() {
            os.write_string(1, &self.host_name)?;
        }
        if self.port != 0 {
            os.write_int32(2, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeAddress {
        NodeAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "host_name",
                    |m: &NodeAddress| &m.host_name,
                    |m: &mut NodeAddress| &mut m.host_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "port",
                    |m: &NodeAddress| &m.port,
                    |m: &mut NodeAddress| &mut m.port,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeAddress>(
                    "NodeAddress",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static NodeAddress {
        static mut instance: ::protobuf::lazy::Lazy<NodeAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeAddress,
        };
        unsafe { instance.get(NodeAddress::new) }
    }
}

impl ::protobuf::Clear for NodeAddress {
    fn clear(&mut self) {
        self.host_name.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Peer {
    // message fields
    pub node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub date: i64,
    pub supported_capabilities: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Peer {
    fn default() -> &'a Peer {
        <Peer as ::protobuf::Message>::default_instance()
    }
}

impl Peer {
    pub fn new() -> Peer {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.NodeAddress node_address = 1;

    pub fn get_node_address(&self) -> &NodeAddress {
        self.node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_node_address(&mut self) {
        self.node_address.clear();
    }

    pub fn has_node_address(&self) -> bool {
        self.node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_address(&mut self, v: NodeAddress) {
        self.node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_address(&mut self) -> &mut NodeAddress {
        if self.node_address.is_none() {
            self.node_address.set_default();
        }
        self.node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_node_address(&mut self) -> NodeAddress {
        self.node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // int64 date = 2;

    pub fn get_date(&self) -> i64 {
        self.date
    }
    pub fn clear_date(&mut self) {
        self.date = 0;
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: i64) {
        self.date = v;
    }

    // repeated int32 supported_capabilities = 3;

    pub fn get_supported_capabilities(&self) -> &[i32] {
        &self.supported_capabilities
    }
    pub fn clear_supported_capabilities(&mut self) {
        self.supported_capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_capabilities(&mut self, v: ::std::vec::Vec<i32>) {
        self.supported_capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_capabilities(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.supported_capabilities
    }

    // Take field
    pub fn take_supported_capabilities(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.supported_capabilities, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Peer {
    fn is_initialized(&self) -> bool {
        for v in &self.node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.node_address,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.date = tmp;
                }
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(
                        wire_type,
                        is,
                        &mut self.supported_capabilities,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.date != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.date, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.supported_capabilities {
            my_size +=
                ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.node_address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.date != 0 {
            os.write_int64(2, self.date)?;
        }
        for v in &self.supported_capabilities {
            os.write_int32(3, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Peer {
        Peer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "node_address",
                        |m: &Peer| &m.node_address,
                        |m: &mut Peer| &mut m.node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "date", |m: &Peer| &m.date, |m: &mut Peer| &mut m.date
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "supported_capabilities",
                    |m: &Peer| &m.supported_capabilities,
                    |m: &mut Peer| &mut m.supported_capabilities,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Peer>(
                    "Peer",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Peer {
        static mut instance: ::protobuf::lazy::Lazy<Peer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Peer,
        };
        unsafe { instance.get(Peer::new) }
    }
}

impl ::protobuf::Clear for Peer {
    fn clear(&mut self) {
        self.node_address.clear();
        self.date = 0;
        self.supported_capabilities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Peer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Peer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PubKeyRing {
    // message fields
    pub signature_pub_key_bytes: ::std::vec::Vec<u8>,
    pub encryption_pub_key_bytes: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PubKeyRing {
    fn default() -> &'a PubKeyRing {
        <PubKeyRing as ::protobuf::Message>::default_instance()
    }
}

impl PubKeyRing {
    pub fn new() -> PubKeyRing {
        ::std::default::Default::default()
    }

    // bytes signature_pub_key_bytes = 1;

    pub fn get_signature_pub_key_bytes(&self) -> &[u8] {
        &self.signature_pub_key_bytes
    }
    pub fn clear_signature_pub_key_bytes(&mut self) {
        self.signature_pub_key_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature_pub_key_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature_pub_key_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature_pub_key_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature_pub_key_bytes
    }

    // Take field
    pub fn take_signature_pub_key_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature_pub_key_bytes, ::std::vec::Vec::new())
    }

    // bytes encryption_pub_key_bytes = 2;

    pub fn get_encryption_pub_key_bytes(&self) -> &[u8] {
        &self.encryption_pub_key_bytes
    }
    pub fn clear_encryption_pub_key_bytes(&mut self) {
        self.encryption_pub_key_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryption_pub_key_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.encryption_pub_key_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_pub_key_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.encryption_pub_key_bytes
    }

    // Take field
    pub fn take_encryption_pub_key_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.encryption_pub_key_bytes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PubKeyRing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.signature_pub_key_bytes,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.encryption_pub_key_bytes,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signature_pub_key_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.signature_pub_key_bytes);
        }
        if !self.encryption_pub_key_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.encryption_pub_key_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.signature_pub_key_bytes.is_empty() {
            os.write_bytes(1, &self.signature_pub_key_bytes)?;
        }
        if !self.encryption_pub_key_bytes.is_empty() {
            os.write_bytes(2, &self.encryption_pub_key_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PubKeyRing {
        PubKeyRing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "signature_pub_key_bytes",
                    |m: &PubKeyRing| &m.signature_pub_key_bytes,
                    |m: &mut PubKeyRing| &mut m.signature_pub_key_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "encryption_pub_key_bytes",
                    |m: &PubKeyRing| &m.encryption_pub_key_bytes,
                    |m: &mut PubKeyRing| &mut m.encryption_pub_key_bytes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PubKeyRing>(
                    "PubKeyRing",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PubKeyRing {
        static mut instance: ::protobuf::lazy::Lazy<PubKeyRing> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PubKeyRing,
        };
        unsafe { instance.get(PubKeyRing::new) }
    }
}

impl ::protobuf::Clear for PubKeyRing {
    fn clear(&mut self) {
        self.signature_pub_key_bytes.clear();
        self.encryption_pub_key_bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PubKeyRing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubKeyRing {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct SealedAndSigned {
    // message fields
    pub encrypted_secret_key: ::std::vec::Vec<u8>,
    pub encrypted_payload_with_hmac: ::std::vec::Vec<u8>,
    pub signature: ::std::vec::Vec<u8>,
    pub sig_public_key_bytes: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SealedAndSigned {
    fn default() -> &'a SealedAndSigned {
        <SealedAndSigned as ::protobuf::Message>::default_instance()
    }
}

impl SealedAndSigned {
    pub fn new() -> SealedAndSigned {
        ::std::default::Default::default()
    }

    // bytes encrypted_secret_key = 1;

    pub fn get_encrypted_secret_key(&self) -> &[u8] {
        &self.encrypted_secret_key
    }
    pub fn clear_encrypted_secret_key(&mut self) {
        self.encrypted_secret_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_encrypted_secret_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_secret_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_secret_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.encrypted_secret_key
    }

    // Take field
    pub fn take_encrypted_secret_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.encrypted_secret_key, ::std::vec::Vec::new())
    }

    // bytes encrypted_payload_with_hmac = 2;

    pub fn get_encrypted_payload_with_hmac(&self) -> &[u8] {
        &self.encrypted_payload_with_hmac
    }
    pub fn clear_encrypted_payload_with_hmac(&mut self) {
        self.encrypted_payload_with_hmac.clear();
    }

    // Param is passed by value, moved
    pub fn set_encrypted_payload_with_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_payload_with_hmac = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_payload_with_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.encrypted_payload_with_hmac
    }

    // Take field
    pub fn take_encrypted_payload_with_hmac(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(
            &mut self.encrypted_payload_with_hmac,
            ::std::vec::Vec::new(),
        )
    }

    // bytes signature = 3;

    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // bytes sig_public_key_bytes = 4;

    pub fn get_sig_public_key_bytes(&self) -> &[u8] {
        &self.sig_public_key_bytes
    }
    pub fn clear_sig_public_key_bytes(&mut self) {
        self.sig_public_key_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_sig_public_key_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.sig_public_key_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig_public_key_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sig_public_key_bytes
    }

    // Take field
    pub fn take_sig_public_key_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sig_public_key_bytes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SealedAndSigned {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.encrypted_secret_key,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.encrypted_payload_with_hmac,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.signature,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.sig_public_key_bytes,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.encrypted_secret_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.encrypted_secret_key);
        }
        if !self.encrypted_payload_with_hmac.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.encrypted_payload_with_hmac);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.signature);
        }
        if !self.sig_public_key_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.sig_public_key_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.encrypted_secret_key.is_empty() {
            os.write_bytes(1, &self.encrypted_secret_key)?;
        }
        if !self.encrypted_payload_with_hmac.is_empty() {
            os.write_bytes(2, &self.encrypted_payload_with_hmac)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(3, &self.signature)?;
        }
        if !self.sig_public_key_bytes.is_empty() {
            os.write_bytes(4, &self.sig_public_key_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SealedAndSigned {
        SealedAndSigned::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "encrypted_secret_key",
                    |m: &SealedAndSigned| &m.encrypted_secret_key,
                    |m: &mut SealedAndSigned| &mut m.encrypted_secret_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "encrypted_payload_with_hmac",
                    |m: &SealedAndSigned| &m.encrypted_payload_with_hmac,
                    |m: &mut SealedAndSigned| &mut m.encrypted_payload_with_hmac,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "signature",
                    |m: &SealedAndSigned| &m.signature,
                    |m: &mut SealedAndSigned| &mut m.signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "sig_public_key_bytes",
                    |m: &SealedAndSigned| &m.sig_public_key_bytes,
                    |m: &mut SealedAndSigned| &mut m.sig_public_key_bytes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SealedAndSigned>(
                    "SealedAndSigned",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static SealedAndSigned {
        static mut instance: ::protobuf::lazy::Lazy<SealedAndSigned> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SealedAndSigned,
        };
        unsafe { instance.get(SealedAndSigned::new) }
    }
}

impl ::protobuf::Clear for SealedAndSigned {
    fn clear(&mut self) {
        self.encrypted_secret_key.clear();
        self.encrypted_payload_with_hmac.clear();
        self.signature.clear();
        self.sig_public_key_bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SealedAndSigned {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SealedAndSigned {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct StoragePayload {
    // message oneof groups
    pub message: ::std::option::Option<StoragePayload_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StoragePayload {
    fn default() -> &'a StoragePayload {
        <StoragePayload as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum StoragePayload_oneof_message {
    alert(Alert),
    arbitrator(Arbitrator),
    mediator(Mediator),
    filter(Filter),
    trade_statistics(TradeStatistics),
    mailbox_storage_payload(MailboxStoragePayload),
    offer_payload(OfferPayload),
    temp_proposal_payload(TempProposalPayload),
    refund_agent(RefundAgent),
}

impl StoragePayload {
    pub fn new() -> StoragePayload {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Alert alert = 1;

    pub fn get_alert(&self) -> &Alert {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::alert(ref v)) => v,
            _ => Alert::default_instance(),
        }
    }
    pub fn clear_alert(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_alert(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::alert(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_alert(&mut self, v: Alert) {
        self.message = ::std::option::Option::Some(StoragePayload_oneof_message::alert(v))
    }

    // Mutable pointer to the field.
    pub fn mut_alert(&mut self) -> &mut Alert {
        if let ::std::option::Option::Some(StoragePayload_oneof_message::alert(_)) = self.message {
        } else {
            self.message =
                ::std::option::Option::Some(StoragePayload_oneof_message::alert(Alert::new()));
        }
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::alert(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_alert(&mut self) -> Alert {
        if self.has_alert() {
            match self.message.take() {
                ::std::option::Option::Some(StoragePayload_oneof_message::alert(v)) => v,
                _ => panic!(),
            }
        } else {
            Alert::new()
        }
    }

    // .io.bisq.protobuffer.Arbitrator arbitrator = 2;

    pub fn get_arbitrator(&self) -> &Arbitrator {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::arbitrator(ref v)) => v,
            _ => Arbitrator::default_instance(),
        }
    }
    pub fn clear_arbitrator(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_arbitrator(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::arbitrator(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_arbitrator(&mut self, v: Arbitrator) {
        self.message = ::std::option::Option::Some(StoragePayload_oneof_message::arbitrator(v))
    }

    // Mutable pointer to the field.
    pub fn mut_arbitrator(&mut self) -> &mut Arbitrator {
        if let ::std::option::Option::Some(StoragePayload_oneof_message::arbitrator(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(StoragePayload_oneof_message::arbitrator(
                Arbitrator::new(),
            ));
        }
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::arbitrator(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_arbitrator(&mut self) -> Arbitrator {
        if self.has_arbitrator() {
            match self.message.take() {
                ::std::option::Option::Some(StoragePayload_oneof_message::arbitrator(v)) => v,
                _ => panic!(),
            }
        } else {
            Arbitrator::new()
        }
    }

    // .io.bisq.protobuffer.Mediator mediator = 3;

    pub fn get_mediator(&self) -> &Mediator {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::mediator(ref v)) => v,
            _ => Mediator::default_instance(),
        }
    }
    pub fn clear_mediator(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_mediator(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::mediator(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mediator(&mut self, v: Mediator) {
        self.message = ::std::option::Option::Some(StoragePayload_oneof_message::mediator(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mediator(&mut self) -> &mut Mediator {
        if let ::std::option::Option::Some(StoragePayload_oneof_message::mediator(_)) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(StoragePayload_oneof_message::mediator(
                Mediator::new(),
            ));
        }
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::mediator(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mediator(&mut self) -> Mediator {
        if self.has_mediator() {
            match self.message.take() {
                ::std::option::Option::Some(StoragePayload_oneof_message::mediator(v)) => v,
                _ => panic!(),
            }
        } else {
            Mediator::new()
        }
    }

    // .io.bisq.protobuffer.Filter filter = 4;

    pub fn get_filter(&self) -> &Filter {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::filter(ref v)) => v,
            _ => Filter::default_instance(),
        }
    }
    pub fn clear_filter(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_filter(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: Filter) {
        self.message = ::std::option::Option::Some(StoragePayload_oneof_message::filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter(&mut self) -> &mut Filter {
        if let ::std::option::Option::Some(StoragePayload_oneof_message::filter(_)) = self.message {
        } else {
            self.message =
                ::std::option::Option::Some(StoragePayload_oneof_message::filter(Filter::new()));
        }
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter(&mut self) -> Filter {
        if self.has_filter() {
            match self.message.take() {
                ::std::option::Option::Some(StoragePayload_oneof_message::filter(v)) => v,
                _ => panic!(),
            }
        } else {
            Filter::new()
        }
    }

    // .io.bisq.protobuffer.TradeStatistics trade_statistics = 5;

    pub fn get_trade_statistics(&self) -> &TradeStatistics {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::trade_statistics(ref v)) => v,
            _ => TradeStatistics::default_instance(),
        }
    }
    pub fn clear_trade_statistics(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_trade_statistics(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::trade_statistics(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_trade_statistics(&mut self, v: TradeStatistics) {
        self.message =
            ::std::option::Option::Some(StoragePayload_oneof_message::trade_statistics(v))
    }

    // Mutable pointer to the field.
    pub fn mut_trade_statistics(&mut self) -> &mut TradeStatistics {
        if let ::std::option::Option::Some(StoragePayload_oneof_message::trade_statistics(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                StoragePayload_oneof_message::trade_statistics(TradeStatistics::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::trade_statistics(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_trade_statistics(&mut self) -> TradeStatistics {
        if self.has_trade_statistics() {
            match self.message.take() {
                ::std::option::Option::Some(StoragePayload_oneof_message::trade_statistics(v)) => v,
                _ => panic!(),
            }
        } else {
            TradeStatistics::new()
        }
    }

    // .io.bisq.protobuffer.MailboxStoragePayload mailbox_storage_payload = 6;

    pub fn get_mailbox_storage_payload(&self) -> &MailboxStoragePayload {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::mailbox_storage_payload(
                ref v,
            )) => v,
            _ => MailboxStoragePayload::default_instance(),
        }
    }
    pub fn clear_mailbox_storage_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_mailbox_storage_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::mailbox_storage_payload(
                ..,
            )) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mailbox_storage_payload(&mut self, v: MailboxStoragePayload) {
        self.message =
            ::std::option::Option::Some(StoragePayload_oneof_message::mailbox_storage_payload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mailbox_storage_payload(&mut self) -> &mut MailboxStoragePayload {
        if let ::std::option::Option::Some(StoragePayload_oneof_message::mailbox_storage_payload(
            _,
        )) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                StoragePayload_oneof_message::mailbox_storage_payload(MailboxStoragePayload::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::mailbox_storage_payload(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mailbox_storage_payload(&mut self) -> MailboxStoragePayload {
        if self.has_mailbox_storage_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    StoragePayload_oneof_message::mailbox_storage_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            MailboxStoragePayload::new()
        }
    }

    // .io.bisq.protobuffer.OfferPayload offer_payload = 7;

    pub fn get_offer_payload(&self) -> &OfferPayload {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::offer_payload(ref v)) => v,
            _ => OfferPayload::default_instance(),
        }
    }
    pub fn clear_offer_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_offer_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::offer_payload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_offer_payload(&mut self, v: OfferPayload) {
        self.message = ::std::option::Option::Some(StoragePayload_oneof_message::offer_payload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_offer_payload(&mut self) -> &mut OfferPayload {
        if let ::std::option::Option::Some(StoragePayload_oneof_message::offer_payload(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                StoragePayload_oneof_message::offer_payload(OfferPayload::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::offer_payload(ref mut v)) => {
                v
            }
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_offer_payload(&mut self) -> OfferPayload {
        if self.has_offer_payload() {
            match self.message.take() {
                ::std::option::Option::Some(StoragePayload_oneof_message::offer_payload(v)) => v,
                _ => panic!(),
            }
        } else {
            OfferPayload::new()
        }
    }

    // .io.bisq.protobuffer.TempProposalPayload temp_proposal_payload = 8;

    pub fn get_temp_proposal_payload(&self) -> &TempProposalPayload {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::temp_proposal_payload(
                ref v,
            )) => v,
            _ => TempProposalPayload::default_instance(),
        }
    }
    pub fn clear_temp_proposal_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_temp_proposal_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::temp_proposal_payload(
                ..,
            )) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_temp_proposal_payload(&mut self, v: TempProposalPayload) {
        self.message =
            ::std::option::Option::Some(StoragePayload_oneof_message::temp_proposal_payload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_temp_proposal_payload(&mut self) -> &mut TempProposalPayload {
        if let ::std::option::Option::Some(StoragePayload_oneof_message::temp_proposal_payload(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                StoragePayload_oneof_message::temp_proposal_payload(TempProposalPayload::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::temp_proposal_payload(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_temp_proposal_payload(&mut self) -> TempProposalPayload {
        if self.has_temp_proposal_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    StoragePayload_oneof_message::temp_proposal_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            TempProposalPayload::new()
        }
    }

    // .io.bisq.protobuffer.RefundAgent refund_agent = 9;

    pub fn get_refund_agent(&self) -> &RefundAgent {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::refund_agent(ref v)) => v,
            _ => RefundAgent::default_instance(),
        }
    }
    pub fn clear_refund_agent(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_refund_agent(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::refund_agent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_refund_agent(&mut self, v: RefundAgent) {
        self.message = ::std::option::Option::Some(StoragePayload_oneof_message::refund_agent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_refund_agent(&mut self) -> &mut RefundAgent {
        if let ::std::option::Option::Some(StoragePayload_oneof_message::refund_agent(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(StoragePayload_oneof_message::refund_agent(
                RefundAgent::new(),
            ));
        }
        match self.message {
            ::std::option::Option::Some(StoragePayload_oneof_message::refund_agent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_refund_agent(&mut self) -> RefundAgent {
        if self.has_refund_agent() {
            match self.message.take() {
                ::std::option::Option::Some(StoragePayload_oneof_message::refund_agent(v)) => v,
                _ => panic!(),
            }
        } else {
            RefundAgent::new()
        }
    }
}

impl ::protobuf::Message for StoragePayload {
    fn is_initialized(&self) -> bool {
        if let Some(StoragePayload_oneof_message::alert(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StoragePayload_oneof_message::arbitrator(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StoragePayload_oneof_message::mediator(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StoragePayload_oneof_message::filter(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StoragePayload_oneof_message::trade_statistics(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StoragePayload_oneof_message::mailbox_storage_payload(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StoragePayload_oneof_message::offer_payload(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StoragePayload_oneof_message::temp_proposal_payload(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StoragePayload_oneof_message::refund_agent(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        StoragePayload_oneof_message::alert(is.read_message()?),
                    );
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        StoragePayload_oneof_message::arbitrator(is.read_message()?),
                    );
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        StoragePayload_oneof_message::mediator(is.read_message()?),
                    );
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        StoragePayload_oneof_message::filter(is.read_message()?),
                    );
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        StoragePayload_oneof_message::trade_statistics(is.read_message()?),
                    );
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        StoragePayload_oneof_message::mailbox_storage_payload(is.read_message()?),
                    );
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        StoragePayload_oneof_message::offer_payload(is.read_message()?),
                    );
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        StoragePayload_oneof_message::temp_proposal_payload(is.read_message()?),
                    );
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        StoragePayload_oneof_message::refund_agent(is.read_message()?),
                    );
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &StoragePayload_oneof_message::alert(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &StoragePayload_oneof_message::arbitrator(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &StoragePayload_oneof_message::mediator(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &StoragePayload_oneof_message::filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &StoragePayload_oneof_message::trade_statistics(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &StoragePayload_oneof_message::mailbox_storage_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &StoragePayload_oneof_message::offer_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &StoragePayload_oneof_message::temp_proposal_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &StoragePayload_oneof_message::refund_agent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &StoragePayload_oneof_message::alert(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &StoragePayload_oneof_message::arbitrator(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &StoragePayload_oneof_message::mediator(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &StoragePayload_oneof_message::filter(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &StoragePayload_oneof_message::trade_statistics(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &StoragePayload_oneof_message::mailbox_storage_payload(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &StoragePayload_oneof_message::offer_payload(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &StoragePayload_oneof_message::temp_proposal_payload(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &StoragePayload_oneof_message::refund_agent(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StoragePayload {
        StoragePayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Alert>(
                    "alert",
                    StoragePayload::has_alert,
                    StoragePayload::get_alert,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Arbitrator>(
                    "arbitrator",
                    StoragePayload::has_arbitrator,
                    StoragePayload::get_arbitrator,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Mediator>(
                    "mediator",
                    StoragePayload::has_mediator,
                    StoragePayload::get_mediator,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Filter>(
                    "filter",
                    StoragePayload::has_filter,
                    StoragePayload::get_filter,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TradeStatistics>(
                    "trade_statistics",
                    StoragePayload::has_trade_statistics,
                    StoragePayload::get_trade_statistics,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MailboxStoragePayload>(
                    "mailbox_storage_payload",
                    StoragePayload::has_mailbox_storage_payload,
                    StoragePayload::get_mailbox_storage_payload,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OfferPayload>(
                    "offer_payload",
                    StoragePayload::has_offer_payload,
                    StoragePayload::get_offer_payload,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TempProposalPayload>(
                    "temp_proposal_payload",
                    StoragePayload::has_temp_proposal_payload,
                    StoragePayload::get_temp_proposal_payload,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RefundAgent>(
                    "refund_agent",
                    StoragePayload::has_refund_agent,
                    StoragePayload::get_refund_agent,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StoragePayload>(
                    "StoragePayload",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StoragePayload {
        static mut instance: ::protobuf::lazy::Lazy<StoragePayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StoragePayload,
        };
        unsafe { instance.get(StoragePayload::new) }
    }
}

impl ::protobuf::Clear for StoragePayload {
    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StoragePayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoragePayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PersistableNetworkPayload {
    // message oneof groups
    pub message: ::std::option::Option<PersistableNetworkPayload_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistableNetworkPayload {
    fn default() -> &'a PersistableNetworkPayload {
        <PersistableNetworkPayload as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum PersistableNetworkPayload_oneof_message {
    account_age_witness(AccountAgeWitness),
    trade_statistics2(TradeStatistics2),
    proposal_payload(ProposalPayload),
    blind_vote_payload(BlindVotePayload),
    signed_witness(SignedWitness),
}

impl PersistableNetworkPayload {
    pub fn new() -> PersistableNetworkPayload {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.AccountAgeWitness account_age_witness = 1;

    pub fn get_account_age_witness(&self) -> &AccountAgeWitness {
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::account_age_witness(ref v),
            ) => v,
            _ => AccountAgeWitness::default_instance(),
        }
    }
    pub fn clear_account_age_witness(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_account_age_witness(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::account_age_witness(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_account_age_witness(&mut self, v: AccountAgeWitness) {
        self.message = ::std::option::Option::Some(
            PersistableNetworkPayload_oneof_message::account_age_witness(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_account_age_witness(&mut self) -> &mut AccountAgeWitness {
        if let ::std::option::Option::Some(
            PersistableNetworkPayload_oneof_message::account_age_witness(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::account_age_witness(
                    AccountAgeWitness::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::account_age_witness(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_account_age_witness(&mut self) -> AccountAgeWitness {
        if self.has_account_age_witness() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableNetworkPayload_oneof_message::account_age_witness(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            AccountAgeWitness::new()
        }
    }

    // .io.bisq.protobuffer.TradeStatistics2 trade_statistics2 = 2;

    pub fn get_trade_statistics2(&self) -> &TradeStatistics2 {
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::trade_statistics2(ref v),
            ) => v,
            _ => TradeStatistics2::default_instance(),
        }
    }
    pub fn clear_trade_statistics2(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_trade_statistics2(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::trade_statistics2(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_trade_statistics2(&mut self, v: TradeStatistics2) {
        self.message = ::std::option::Option::Some(
            PersistableNetworkPayload_oneof_message::trade_statistics2(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_trade_statistics2(&mut self) -> &mut TradeStatistics2 {
        if let ::std::option::Option::Some(
            PersistableNetworkPayload_oneof_message::trade_statistics2(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::trade_statistics2(TradeStatistics2::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::trade_statistics2(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_trade_statistics2(&mut self) -> TradeStatistics2 {
        if self.has_trade_statistics2() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableNetworkPayload_oneof_message::trade_statistics2(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            TradeStatistics2::new()
        }
    }

    // .io.bisq.protobuffer.ProposalPayload proposal_payload = 3;

    pub fn get_proposal_payload(&self) -> &ProposalPayload {
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::proposal_payload(ref v),
            ) => v,
            _ => ProposalPayload::default_instance(),
        }
    }
    pub fn clear_proposal_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_proposal_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::proposal_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_proposal_payload(&mut self, v: ProposalPayload) {
        self.message = ::std::option::Option::Some(
            PersistableNetworkPayload_oneof_message::proposal_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_proposal_payload(&mut self) -> &mut ProposalPayload {
        if let ::std::option::Option::Some(
            PersistableNetworkPayload_oneof_message::proposal_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::proposal_payload(ProposalPayload::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::proposal_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_proposal_payload(&mut self) -> ProposalPayload {
        if self.has_proposal_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableNetworkPayload_oneof_message::proposal_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            ProposalPayload::new()
        }
    }

    // .io.bisq.protobuffer.BlindVotePayload blind_vote_payload = 4;

    pub fn get_blind_vote_payload(&self) -> &BlindVotePayload {
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::blind_vote_payload(ref v),
            ) => v,
            _ => BlindVotePayload::default_instance(),
        }
    }
    pub fn clear_blind_vote_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_blind_vote_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::blind_vote_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_blind_vote_payload(&mut self, v: BlindVotePayload) {
        self.message = ::std::option::Option::Some(
            PersistableNetworkPayload_oneof_message::blind_vote_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_blind_vote_payload(&mut self) -> &mut BlindVotePayload {
        if let ::std::option::Option::Some(
            PersistableNetworkPayload_oneof_message::blind_vote_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::blind_vote_payload(BlindVotePayload::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::blind_vote_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_blind_vote_payload(&mut self) -> BlindVotePayload {
        if self.has_blind_vote_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableNetworkPayload_oneof_message::blind_vote_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            BlindVotePayload::new()
        }
    }

    // .io.bisq.protobuffer.SignedWitness signed_witness = 5;

    pub fn get_signed_witness(&self) -> &SignedWitness {
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::signed_witness(ref v),
            ) => v,
            _ => SignedWitness::default_instance(),
        }
    }
    pub fn clear_signed_witness(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_signed_witness(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::signed_witness(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_witness(&mut self, v: SignedWitness) {
        self.message =
            ::std::option::Option::Some(PersistableNetworkPayload_oneof_message::signed_witness(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_witness(&mut self) -> &mut SignedWitness {
        if let ::std::option::Option::Some(
            PersistableNetworkPayload_oneof_message::signed_witness(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::signed_witness(SignedWitness::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableNetworkPayload_oneof_message::signed_witness(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_witness(&mut self) -> SignedWitness {
        if self.has_signed_witness() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableNetworkPayload_oneof_message::signed_witness(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            SignedWitness::new()
        }
    }
}

impl ::protobuf::Message for PersistableNetworkPayload {
    fn is_initialized(&self) -> bool {
        if let Some(PersistableNetworkPayload_oneof_message::account_age_witness(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableNetworkPayload_oneof_message::trade_statistics2(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableNetworkPayload_oneof_message::proposal_payload(ref v)) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableNetworkPayload_oneof_message::blind_vote_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableNetworkPayload_oneof_message::signed_witness(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableNetworkPayload_oneof_message::account_age_witness(
                            is.read_message()?,
                        ),
                    );
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableNetworkPayload_oneof_message::trade_statistics2(
                            is.read_message()?,
                        ),
                    );
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableNetworkPayload_oneof_message::proposal_payload(
                            is.read_message()?,
                        ),
                    );
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableNetworkPayload_oneof_message::blind_vote_payload(
                            is.read_message()?,
                        ),
                    );
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableNetworkPayload_oneof_message::signed_witness(is.read_message()?),
                    );
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &PersistableNetworkPayload_oneof_message::account_age_witness(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableNetworkPayload_oneof_message::trade_statistics2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableNetworkPayload_oneof_message::proposal_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableNetworkPayload_oneof_message::blind_vote_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableNetworkPayload_oneof_message::signed_witness(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &PersistableNetworkPayload_oneof_message::account_age_witness(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableNetworkPayload_oneof_message::trade_statistics2(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableNetworkPayload_oneof_message::proposal_payload(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableNetworkPayload_oneof_message::blind_vote_payload(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableNetworkPayload_oneof_message::signed_witness(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistableNetworkPayload {
        PersistableNetworkPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AccountAgeWitness>(
                    "account_age_witness",
                    PersistableNetworkPayload::has_account_age_witness,
                    PersistableNetworkPayload::get_account_age_witness,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TradeStatistics2>(
                    "trade_statistics2",
                    PersistableNetworkPayload::has_trade_statistics2,
                    PersistableNetworkPayload::get_trade_statistics2,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProposalPayload>(
                    "proposal_payload",
                    PersistableNetworkPayload::has_proposal_payload,
                    PersistableNetworkPayload::get_proposal_payload,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BlindVotePayload>(
                    "blind_vote_payload",
                    PersistableNetworkPayload::has_blind_vote_payload,
                    PersistableNetworkPayload::get_blind_vote_payload,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SignedWitness>(
                    "signed_witness",
                    PersistableNetworkPayload::has_signed_witness,
                    PersistableNetworkPayload::get_signed_witness,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistableNetworkPayload>(
                    "PersistableNetworkPayload",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PersistableNetworkPayload {
        static mut instance: ::protobuf::lazy::Lazy<PersistableNetworkPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PersistableNetworkPayload,
            };
        unsafe { instance.get(PersistableNetworkPayload::new) }
    }
}

impl ::protobuf::Clear for PersistableNetworkPayload {
    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistableNetworkPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistableNetworkPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ProtectedStorageEntry {
    // message fields
    pub storagePayload: ::protobuf::SingularPtrField<StoragePayload>,
    pub owner_pub_key_bytes: ::std::vec::Vec<u8>,
    pub sequence_number: i32,
    pub signature: ::std::vec::Vec<u8>,
    pub creation_time_stamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtectedStorageEntry {
    fn default() -> &'a ProtectedStorageEntry {
        <ProtectedStorageEntry as ::protobuf::Message>::default_instance()
    }
}

impl ProtectedStorageEntry {
    pub fn new() -> ProtectedStorageEntry {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.StoragePayload storagePayload = 1;

    pub fn get_storagePayload(&self) -> &StoragePayload {
        self.storagePayload
            .as_ref()
            .unwrap_or_else(|| StoragePayload::default_instance())
    }
    pub fn clear_storagePayload(&mut self) {
        self.storagePayload.clear();
    }

    pub fn has_storagePayload(&self) -> bool {
        self.storagePayload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePayload(&mut self, v: StoragePayload) {
        self.storagePayload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePayload(&mut self) -> &mut StoragePayload {
        if self.storagePayload.is_none() {
            self.storagePayload.set_default();
        }
        self.storagePayload.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePayload(&mut self) -> StoragePayload {
        self.storagePayload
            .take()
            .unwrap_or_else(|| StoragePayload::new())
    }

    // bytes owner_pub_key_bytes = 2;

    pub fn get_owner_pub_key_bytes(&self) -> &[u8] {
        &self.owner_pub_key_bytes
    }
    pub fn clear_owner_pub_key_bytes(&mut self) {
        self.owner_pub_key_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_pub_key_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_pub_key_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_pub_key_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_pub_key_bytes
    }

    // Take field
    pub fn take_owner_pub_key_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_pub_key_bytes, ::std::vec::Vec::new())
    }

    // int32 sequence_number = 3;

    pub fn get_sequence_number(&self) -> i32 {
        self.sequence_number
    }
    pub fn clear_sequence_number(&mut self) {
        self.sequence_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence_number(&mut self, v: i32) {
        self.sequence_number = v;
    }

    // bytes signature = 4;

    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // int64 creation_time_stamp = 5;

    pub fn get_creation_time_stamp(&self) -> i64 {
        self.creation_time_stamp
    }
    pub fn clear_creation_time_stamp(&mut self) {
        self.creation_time_stamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_time_stamp(&mut self, v: i64) {
        self.creation_time_stamp = v;
    }
}

impl ::protobuf::Message for ProtectedStorageEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.storagePayload {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.storagePayload,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.owner_pub_key_bytes,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.sequence_number = tmp;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.signature,
                    )?;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_time_stamp = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.storagePayload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.owner_pub_key_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.owner_pub_key_bytes);
        }
        if self.sequence_number != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.sequence_number,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.signature);
        }
        if self.creation_time_stamp != 0 {
            my_size += ::protobuf::rt::value_size(
                5,
                self.creation_time_stamp,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.storagePayload.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.owner_pub_key_bytes.is_empty() {
            os.write_bytes(2, &self.owner_pub_key_bytes)?;
        }
        if self.sequence_number != 0 {
            os.write_int32(3, self.sequence_number)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(4, &self.signature)?;
        }
        if self.creation_time_stamp != 0 {
            os.write_int64(5, self.creation_time_stamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProtectedStorageEntry {
        ProtectedStorageEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<StoragePayload>,
                    >(
                        "storagePayload",
                        |m: &ProtectedStorageEntry| &m.storagePayload,
                        |m: &mut ProtectedStorageEntry| &mut m.storagePayload,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "owner_pub_key_bytes",
                    |m: &ProtectedStorageEntry| &m.owner_pub_key_bytes,
                    |m: &mut ProtectedStorageEntry| &mut m.owner_pub_key_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "sequence_number",
                    |m: &ProtectedStorageEntry| &m.sequence_number,
                    |m: &mut ProtectedStorageEntry| &mut m.sequence_number,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "signature",
                    |m: &ProtectedStorageEntry| &m.signature,
                    |m: &mut ProtectedStorageEntry| &mut m.signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "creation_time_stamp",
                    |m: &ProtectedStorageEntry| &m.creation_time_stamp,
                    |m: &mut ProtectedStorageEntry| &mut m.creation_time_stamp,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtectedStorageEntry>(
                    "ProtectedStorageEntry",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ProtectedStorageEntry {
        static mut instance: ::protobuf::lazy::Lazy<ProtectedStorageEntry> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ProtectedStorageEntry,
            };
        unsafe { instance.get(ProtectedStorageEntry::new) }
    }
}

impl ::protobuf::Clear for ProtectedStorageEntry {
    fn clear(&mut self) {
        self.storagePayload.clear();
        self.owner_pub_key_bytes.clear();
        self.sequence_number = 0;
        self.signature.clear();
        self.creation_time_stamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtectedStorageEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtectedStorageEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct StorageEntryWrapper {
    // message oneof groups
    pub message: ::std::option::Option<StorageEntryWrapper_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageEntryWrapper {
    fn default() -> &'a StorageEntryWrapper {
        <StorageEntryWrapper as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum StorageEntryWrapper_oneof_message {
    protected_storage_entry(ProtectedStorageEntry),
    protected_mailbox_storage_entry(ProtectedMailboxStorageEntry),
}

impl StorageEntryWrapper {
    pub fn new() -> StorageEntryWrapper {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.ProtectedStorageEntry protected_storage_entry = 1;

    pub fn get_protected_storage_entry(&self) -> &ProtectedStorageEntry {
        match self.message {
            ::std::option::Option::Some(
                StorageEntryWrapper_oneof_message::protected_storage_entry(ref v),
            ) => v,
            _ => ProtectedStorageEntry::default_instance(),
        }
    }
    pub fn clear_protected_storage_entry(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_protected_storage_entry(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                StorageEntryWrapper_oneof_message::protected_storage_entry(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_protected_storage_entry(&mut self, v: ProtectedStorageEntry) {
        self.message = ::std::option::Option::Some(
            StorageEntryWrapper_oneof_message::protected_storage_entry(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_protected_storage_entry(&mut self) -> &mut ProtectedStorageEntry {
        if let ::std::option::Option::Some(
            StorageEntryWrapper_oneof_message::protected_storage_entry(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                StorageEntryWrapper_oneof_message::protected_storage_entry(
                    ProtectedStorageEntry::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                StorageEntryWrapper_oneof_message::protected_storage_entry(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_protected_storage_entry(&mut self) -> ProtectedStorageEntry {
        if self.has_protected_storage_entry() {
            match self.message.take() {
                ::std::option::Option::Some(
                    StorageEntryWrapper_oneof_message::protected_storage_entry(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            ProtectedStorageEntry::new()
        }
    }

    // .io.bisq.protobuffer.ProtectedMailboxStorageEntry protected_mailbox_storage_entry = 2;

    pub fn get_protected_mailbox_storage_entry(&self) -> &ProtectedMailboxStorageEntry {
        match self.message {
            ::std::option::Option::Some(
                StorageEntryWrapper_oneof_message::protected_mailbox_storage_entry(ref v),
            ) => v,
            _ => ProtectedMailboxStorageEntry::default_instance(),
        }
    }
    pub fn clear_protected_mailbox_storage_entry(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_protected_mailbox_storage_entry(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                StorageEntryWrapper_oneof_message::protected_mailbox_storage_entry(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_protected_mailbox_storage_entry(&mut self, v: ProtectedMailboxStorageEntry) {
        self.message = ::std::option::Option::Some(
            StorageEntryWrapper_oneof_message::protected_mailbox_storage_entry(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_protected_mailbox_storage_entry(&mut self) -> &mut ProtectedMailboxStorageEntry {
        if let ::std::option::Option::Some(
            StorageEntryWrapper_oneof_message::protected_mailbox_storage_entry(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                StorageEntryWrapper_oneof_message::protected_mailbox_storage_entry(
                    ProtectedMailboxStorageEntry::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                StorageEntryWrapper_oneof_message::protected_mailbox_storage_entry(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_protected_mailbox_storage_entry(&mut self) -> ProtectedMailboxStorageEntry {
        if self.has_protected_mailbox_storage_entry() {
            match self.message.take() {
                ::std::option::Option::Some(
                    StorageEntryWrapper_oneof_message::protected_mailbox_storage_entry(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            ProtectedMailboxStorageEntry::new()
        }
    }
}

impl ::protobuf::Message for StorageEntryWrapper {
    fn is_initialized(&self) -> bool {
        if let Some(StorageEntryWrapper_oneof_message::protected_storage_entry(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StorageEntryWrapper_oneof_message::protected_mailbox_storage_entry(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        StorageEntryWrapper_oneof_message::protected_storage_entry(
                            is.read_message()?,
                        ),
                    );
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        StorageEntryWrapper_oneof_message::protected_mailbox_storage_entry(
                            is.read_message()?,
                        ),
                    );
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &StorageEntryWrapper_oneof_message::protected_storage_entry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &StorageEntryWrapper_oneof_message::protected_mailbox_storage_entry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &StorageEntryWrapper_oneof_message::protected_storage_entry(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &StorageEntryWrapper_oneof_message::protected_mailbox_storage_entry(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageEntryWrapper {
        StorageEntryWrapper::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        ProtectedStorageEntry,
                    >(
                        "protected_storage_entry",
                        StorageEntryWrapper::has_protected_storage_entry,
                        StorageEntryWrapper::get_protected_storage_entry,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        ProtectedMailboxStorageEntry,
                    >(
                        "protected_mailbox_storage_entry",
                        StorageEntryWrapper::has_protected_mailbox_storage_entry,
                        StorageEntryWrapper::get_protected_mailbox_storage_entry,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<StorageEntryWrapper>(
                    "StorageEntryWrapper",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static StorageEntryWrapper {
        static mut instance: ::protobuf::lazy::Lazy<StorageEntryWrapper> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorageEntryWrapper,
        };
        unsafe { instance.get(StorageEntryWrapper::new) }
    }
}

impl ::protobuf::Clear for StorageEntryWrapper {
    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageEntryWrapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageEntryWrapper {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ProtectedMailboxStorageEntry {
    // message fields
    pub entry: ::protobuf::SingularPtrField<ProtectedStorageEntry>,
    pub receivers_pub_key_bytes: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtectedMailboxStorageEntry {
    fn default() -> &'a ProtectedMailboxStorageEntry {
        <ProtectedMailboxStorageEntry as ::protobuf::Message>::default_instance()
    }
}

impl ProtectedMailboxStorageEntry {
    pub fn new() -> ProtectedMailboxStorageEntry {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.ProtectedStorageEntry entry = 1;

    pub fn get_entry(&self) -> &ProtectedStorageEntry {
        self.entry
            .as_ref()
            .unwrap_or_else(|| ProtectedStorageEntry::default_instance())
    }
    pub fn clear_entry(&mut self) {
        self.entry.clear();
    }

    pub fn has_entry(&self) -> bool {
        self.entry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entry(&mut self, v: ProtectedStorageEntry) {
        self.entry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entry(&mut self) -> &mut ProtectedStorageEntry {
        if self.entry.is_none() {
            self.entry.set_default();
        }
        self.entry.as_mut().unwrap()
    }

    // Take field
    pub fn take_entry(&mut self) -> ProtectedStorageEntry {
        self.entry
            .take()
            .unwrap_or_else(|| ProtectedStorageEntry::new())
    }

    // bytes receivers_pub_key_bytes = 2;

    pub fn get_receivers_pub_key_bytes(&self) -> &[u8] {
        &self.receivers_pub_key_bytes
    }
    pub fn clear_receivers_pub_key_bytes(&mut self) {
        self.receivers_pub_key_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_receivers_pub_key_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.receivers_pub_key_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receivers_pub_key_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.receivers_pub_key_bytes
    }

    // Take field
    pub fn take_receivers_pub_key_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.receivers_pub_key_bytes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ProtectedMailboxStorageEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.entry)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.receivers_pub_key_bytes,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.receivers_pub_key_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.receivers_pub_key_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.entry.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.receivers_pub_key_bytes.is_empty() {
            os.write_bytes(2, &self.receivers_pub_key_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProtectedMailboxStorageEntry {
        ProtectedMailboxStorageEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<ProtectedStorageEntry>,
                    >(
                        "entry",
                        |m: &ProtectedMailboxStorageEntry| &m.entry,
                        |m: &mut ProtectedMailboxStorageEntry| &mut m.entry,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "receivers_pub_key_bytes",
                    |m: &ProtectedMailboxStorageEntry| &m.receivers_pub_key_bytes,
                    |m: &mut ProtectedMailboxStorageEntry| &mut m.receivers_pub_key_bytes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtectedMailboxStorageEntry>(
                    "ProtectedMailboxStorageEntry",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ProtectedMailboxStorageEntry {
        static mut instance: ::protobuf::lazy::Lazy<ProtectedMailboxStorageEntry> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ProtectedMailboxStorageEntry,
            };
        unsafe { instance.get(ProtectedMailboxStorageEntry::new) }
    }
}

impl ::protobuf::Clear for ProtectedMailboxStorageEntry {
    fn clear(&mut self) {
        self.entry.clear();
        self.receivers_pub_key_bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtectedMailboxStorageEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtectedMailboxStorageEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct DataAndSeqNrPair {
    // message fields
    pub payload: ::protobuf::SingularPtrField<StoragePayload>,
    pub sequence_number: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataAndSeqNrPair {
    fn default() -> &'a DataAndSeqNrPair {
        <DataAndSeqNrPair as ::protobuf::Message>::default_instance()
    }
}

impl DataAndSeqNrPair {
    pub fn new() -> DataAndSeqNrPair {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.StoragePayload payload = 1;

    pub fn get_payload(&self) -> &StoragePayload {
        self.payload
            .as_ref()
            .unwrap_or_else(|| StoragePayload::default_instance())
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: StoragePayload) {
        self.payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut StoragePayload {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> StoragePayload {
        self.payload.take().unwrap_or_else(|| StoragePayload::new())
    }

    // int32 sequence_number = 2;

    pub fn get_sequence_number(&self) -> i32 {
        self.sequence_number
    }
    pub fn clear_sequence_number(&mut self) {
        self.sequence_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence_number(&mut self, v: i32) {
        self.sequence_number = v;
    }
}

impl ::protobuf::Message for DataAndSeqNrPair {
    fn is_initialized(&self) -> bool {
        for v in &self.payload {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payload)?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.sequence_number = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.sequence_number != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.sequence_number,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.payload.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.sequence_number != 0 {
            os.write_int32(2, self.sequence_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataAndSeqNrPair {
        DataAndSeqNrPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<StoragePayload>,
                    >(
                        "payload",
                        |m: &DataAndSeqNrPair| &m.payload,
                        |m: &mut DataAndSeqNrPair| &mut m.payload,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "sequence_number",
                    |m: &DataAndSeqNrPair| &m.sequence_number,
                    |m: &mut DataAndSeqNrPair| &mut m.sequence_number,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DataAndSeqNrPair>(
                    "DataAndSeqNrPair",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static DataAndSeqNrPair {
        static mut instance: ::protobuf::lazy::Lazy<DataAndSeqNrPair> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DataAndSeqNrPair,
        };
        unsafe { instance.get(DataAndSeqNrPair::new) }
    }
}

impl ::protobuf::Clear for DataAndSeqNrPair {
    fn clear(&mut self) {
        self.payload.clear();
        self.sequence_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataAndSeqNrPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataAndSeqNrPair {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PrivateNotificationPayload {
    // message fields
    pub message: ::std::string::String,
    pub signature_as_base64: ::std::string::String,
    pub sig_public_key_bytes: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrivateNotificationPayload {
    fn default() -> &'a PrivateNotificationPayload {
        <PrivateNotificationPayload as ::protobuf::Message>::default_instance()
    }
}

impl PrivateNotificationPayload {
    pub fn new() -> PrivateNotificationPayload {
        ::std::default::Default::default()
    }

    // string message = 1;

    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // string signature_as_base64 = 2;

    pub fn get_signature_as_base64(&self) -> &str {
        &self.signature_as_base64
    }
    pub fn clear_signature_as_base64(&mut self) {
        self.signature_as_base64.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature_as_base64(&mut self, v: ::std::string::String) {
        self.signature_as_base64 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature_as_base64(&mut self) -> &mut ::std::string::String {
        &mut self.signature_as_base64
    }

    // Take field
    pub fn take_signature_as_base64(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature_as_base64, ::std::string::String::new())
    }

    // bytes sig_public_key_bytes = 3;

    pub fn get_sig_public_key_bytes(&self) -> &[u8] {
        &self.sig_public_key_bytes
    }
    pub fn clear_sig_public_key_bytes(&mut self) {
        self.sig_public_key_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_sig_public_key_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.sig_public_key_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig_public_key_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sig_public_key_bytes
    }

    // Take field
    pub fn take_sig_public_key_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sig_public_key_bytes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PrivateNotificationPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.message,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.signature_as_base64,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.sig_public_key_bytes,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        if !self.signature_as_base64.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.signature_as_base64);
        }
        if !self.sig_public_key_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.sig_public_key_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        if !self.signature_as_base64.is_empty() {
            os.write_string(2, &self.signature_as_base64)?;
        }
        if !self.sig_public_key_bytes.is_empty() {
            os.write_bytes(3, &self.sig_public_key_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrivateNotificationPayload {
        PrivateNotificationPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "message",
                    |m: &PrivateNotificationPayload| &m.message,
                    |m: &mut PrivateNotificationPayload| &mut m.message,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "signature_as_base64",
                    |m: &PrivateNotificationPayload| &m.signature_as_base64,
                    |m: &mut PrivateNotificationPayload| &mut m.signature_as_base64,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "sig_public_key_bytes",
                    |m: &PrivateNotificationPayload| &m.sig_public_key_bytes,
                    |m: &mut PrivateNotificationPayload| &mut m.sig_public_key_bytes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PrivateNotificationPayload>(
                    "PrivateNotificationPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PrivateNotificationPayload {
        static mut instance: ::protobuf::lazy::Lazy<PrivateNotificationPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PrivateNotificationPayload,
            };
        unsafe { instance.get(PrivateNotificationPayload::new) }
    }
}

impl ::protobuf::Clear for PrivateNotificationPayload {
    fn clear(&mut self) {
        self.message.clear();
        self.signature_as_base64.clear();
        self.sig_public_key_bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrivateNotificationPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrivateNotificationPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PaymentAccountFilter {
    // message fields
    pub payment_method_id: ::std::string::String,
    pub get_method_name: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentAccountFilter {
    fn default() -> &'a PaymentAccountFilter {
        <PaymentAccountFilter as ::protobuf::Message>::default_instance()
    }
}

impl PaymentAccountFilter {
    pub fn new() -> PaymentAccountFilter {
        ::std::default::Default::default()
    }

    // string payment_method_id = 1;

    pub fn get_payment_method_id(&self) -> &str {
        &self.payment_method_id
    }
    pub fn clear_payment_method_id(&mut self) {
        self.payment_method_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_method_id(&mut self, v: ::std::string::String) {
        self.payment_method_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_method_id(&mut self) -> &mut ::std::string::String {
        &mut self.payment_method_id
    }

    // Take field
    pub fn take_payment_method_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_method_id, ::std::string::String::new())
    }

    // string get_method_name = 2;

    pub fn get_get_method_name(&self) -> &str {
        &self.get_method_name
    }
    pub fn clear_get_method_name(&mut self) {
        self.get_method_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_get_method_name(&mut self, v: ::std::string::String) {
        self.get_method_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_get_method_name(&mut self) -> &mut ::std::string::String {
        &mut self.get_method_name
    }

    // Take field
    pub fn take_get_method_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.get_method_name, ::std::string::String::new())
    }

    // string value = 3;

    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PaymentAccountFilter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.payment_method_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.get_method_name,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.value,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_method_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.payment_method_id);
        }
        if !self.get_method_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.get_method_name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_method_id.is_empty() {
            os.write_string(1, &self.payment_method_id)?;
        }
        if !self.get_method_name.is_empty() {
            os.write_string(2, &self.get_method_name)?;
        }
        if !self.value.is_empty() {
            os.write_string(3, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaymentAccountFilter {
        PaymentAccountFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "payment_method_id",
                    |m: &PaymentAccountFilter| &m.payment_method_id,
                    |m: &mut PaymentAccountFilter| &mut m.payment_method_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "get_method_name",
                    |m: &PaymentAccountFilter| &m.get_method_name,
                    |m: &mut PaymentAccountFilter| &mut m.get_method_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "value",
                    |m: &PaymentAccountFilter| &m.value,
                    |m: &mut PaymentAccountFilter| &mut m.value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PaymentAccountFilter>(
                    "PaymentAccountFilter",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PaymentAccountFilter {
        static mut instance: ::protobuf::lazy::Lazy<PaymentAccountFilter> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PaymentAccountFilter,
            };
        unsafe { instance.get(PaymentAccountFilter::new) }
    }
}

impl ::protobuf::Clear for PaymentAccountFilter {
    fn clear(&mut self) {
        self.payment_method_id.clear();
        self.get_method_name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentAccountFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentAccountFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Alert {
    // message fields
    pub message: ::std::string::String,
    pub version: ::std::string::String,
    pub is_update_info: bool,
    pub signature_as_base64: ::std::string::String,
    pub owner_pub_key_bytes: ::std::vec::Vec<u8>,
    pub extra_data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Alert {
    fn default() -> &'a Alert {
        <Alert as ::protobuf::Message>::default_instance()
    }
}

impl Alert {
    pub fn new() -> Alert {
        ::std::default::Default::default()
    }

    // string message = 1;

    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // string version = 2;

    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // bool is_update_info = 3;

    pub fn get_is_update_info(&self) -> bool {
        self.is_update_info
    }
    pub fn clear_is_update_info(&mut self) {
        self.is_update_info = false;
    }

    // Param is passed by value, moved
    pub fn set_is_update_info(&mut self, v: bool) {
        self.is_update_info = v;
    }

    // string signature_as_base64 = 4;

    pub fn get_signature_as_base64(&self) -> &str {
        &self.signature_as_base64
    }
    pub fn clear_signature_as_base64(&mut self) {
        self.signature_as_base64.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature_as_base64(&mut self, v: ::std::string::String) {
        self.signature_as_base64 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature_as_base64(&mut self) -> &mut ::std::string::String {
        &mut self.signature_as_base64
    }

    // Take field
    pub fn take_signature_as_base64(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature_as_base64, ::std::string::String::new())
    }

    // bytes owner_pub_key_bytes = 5;

    pub fn get_owner_pub_key_bytes(&self) -> &[u8] {
        &self.owner_pub_key_bytes
    }
    pub fn clear_owner_pub_key_bytes(&mut self) {
        self.owner_pub_key_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_pub_key_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_pub_key_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_pub_key_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_pub_key_bytes
    }

    // Take field
    pub fn take_owner_pub_key_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_pub_key_bytes, ::std::vec::Vec::new())
    }

    // repeated .io.bisq.protobuffer.Alert.ExtraDataEntry extra_data = 6;

    pub fn get_extra_data(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.extra_data
    }
    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_data(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ) {
        self.extra_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_data(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.extra_data
    }

    // Take field
    pub fn take_extra_data(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.extra_data, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Alert {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.message,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.version,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_update_info = tmp;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.signature_as_base64,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.owner_pub_key_bytes,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeString,
                    >(wire_type, is, &mut self.extra_data)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if self.is_update_info != false {
            my_size += 2;
        }
        if !self.signature_as_base64.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.signature_as_base64);
        }
        if !self.owner_pub_key_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.owner_pub_key_bytes);
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(6, &self.extra_data);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if self.is_update_info != false {
            os.write_bool(3, self.is_update_info)?;
        }
        if !self.signature_as_base64.is_empty() {
            os.write_string(4, &self.signature_as_base64)?;
        }
        if !self.owner_pub_key_bytes.is_empty() {
            os.write_bytes(5, &self.owner_pub_key_bytes)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(6, &self.extra_data, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Alert {
        Alert::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "message",
                    |m: &Alert| &m.message,
                    |m: &mut Alert| &mut m.message,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "version",
                    |m: &Alert| &m.version,
                    |m: &mut Alert| &mut m.version,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_update_info",
                    |m: &Alert| &m.is_update_info,
                    |m: &mut Alert| &mut m.is_update_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "signature_as_base64",
                    |m: &Alert| &m.signature_as_base64,
                    |m: &mut Alert| &mut m.signature_as_base64,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "owner_pub_key_bytes",
                    |m: &Alert| &m.owner_pub_key_bytes,
                    |m: &mut Alert| &mut m.owner_pub_key_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "extra_data",
                    |m: &Alert| &m.extra_data,
                    |m: &mut Alert| &mut m.extra_data,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Alert>(
                    "Alert",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Alert {
        static mut instance: ::protobuf::lazy::Lazy<Alert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Alert,
        };
        unsafe { instance.get(Alert::new) }
    }
}

impl ::protobuf::Clear for Alert {
    fn clear(&mut self) {
        self.message.clear();
        self.version.clear();
        self.is_update_info = false;
        self.signature_as_base64.clear();
        self.owner_pub_key_bytes.clear();
        self.extra_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Alert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Alert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Arbitrator {
    // message fields
    pub node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub language_codes: ::protobuf::RepeatedField<::std::string::String>,
    pub registration_date: i64,
    pub registration_signature: ::std::string::String,
    pub registration_pub_key: ::std::vec::Vec<u8>,
    pub pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub btc_pub_key: ::std::vec::Vec<u8>,
    pub btc_address: ::std::string::String,
    pub email_address: ::std::string::String,
    pub info: ::std::string::String,
    pub extra_data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Arbitrator {
    fn default() -> &'a Arbitrator {
        <Arbitrator as ::protobuf::Message>::default_instance()
    }
}

impl Arbitrator {
    pub fn new() -> Arbitrator {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.NodeAddress node_address = 1;

    pub fn get_node_address(&self) -> &NodeAddress {
        self.node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_node_address(&mut self) {
        self.node_address.clear();
    }

    pub fn has_node_address(&self) -> bool {
        self.node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_address(&mut self, v: NodeAddress) {
        self.node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_address(&mut self) -> &mut NodeAddress {
        if self.node_address.is_none() {
            self.node_address.set_default();
        }
        self.node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_node_address(&mut self) -> NodeAddress {
        self.node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // repeated string language_codes = 2;

    pub fn get_language_codes(&self) -> &[::std::string::String] {
        &self.language_codes
    }
    pub fn clear_language_codes(&mut self) {
        self.language_codes.clear();
    }

    // Param is passed by value, moved
    pub fn set_language_codes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.language_codes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_language_codes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.language_codes
    }

    // Take field
    pub fn take_language_codes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.language_codes, ::protobuf::RepeatedField::new())
    }

    // int64 registration_date = 3;

    pub fn get_registration_date(&self) -> i64 {
        self.registration_date
    }
    pub fn clear_registration_date(&mut self) {
        self.registration_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_registration_date(&mut self, v: i64) {
        self.registration_date = v;
    }

    // string registration_signature = 4;

    pub fn get_registration_signature(&self) -> &str {
        &self.registration_signature
    }
    pub fn clear_registration_signature(&mut self) {
        self.registration_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_registration_signature(&mut self, v: ::std::string::String) {
        self.registration_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration_signature(&mut self) -> &mut ::std::string::String {
        &mut self.registration_signature
    }

    // Take field
    pub fn take_registration_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.registration_signature,
            ::std::string::String::new(),
        )
    }

    // bytes registration_pub_key = 5;

    pub fn get_registration_pub_key(&self) -> &[u8] {
        &self.registration_pub_key
    }
    pub fn clear_registration_pub_key(&mut self) {
        self.registration_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_registration_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.registration_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.registration_pub_key
    }

    // Take field
    pub fn take_registration_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.registration_pub_key, ::std::vec::Vec::new())
    }

    // .io.bisq.protobuffer.PubKeyRing pub_key_ring = 6;

    pub fn get_pub_key_ring(&self) -> &PubKeyRing {
        self.pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_pub_key_ring(&mut self) {
        self.pub_key_ring.clear();
    }

    pub fn has_pub_key_ring(&self) -> bool {
        self.pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pub_key_ring(&mut self, v: PubKeyRing) {
        self.pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.pub_key_ring.is_none() {
            self.pub_key_ring.set_default();
        }
        self.pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_pub_key_ring(&mut self) -> PubKeyRing {
        self.pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // bytes btc_pub_key = 7;

    pub fn get_btc_pub_key(&self) -> &[u8] {
        &self.btc_pub_key
    }
    pub fn clear_btc_pub_key(&mut self) {
        self.btc_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_btc_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.btc_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_btc_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.btc_pub_key
    }

    // Take field
    pub fn take_btc_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.btc_pub_key, ::std::vec::Vec::new())
    }

    // string btc_address = 8;

    pub fn get_btc_address(&self) -> &str {
        &self.btc_address
    }
    pub fn clear_btc_address(&mut self) {
        self.btc_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_btc_address(&mut self, v: ::std::string::String) {
        self.btc_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_btc_address(&mut self) -> &mut ::std::string::String {
        &mut self.btc_address
    }

    // Take field
    pub fn take_btc_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.btc_address, ::std::string::String::new())
    }

    // string email_address = 9;

    pub fn get_email_address(&self) -> &str {
        &self.email_address
    }
    pub fn clear_email_address(&mut self) {
        self.email_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_email_address(&mut self, v: ::std::string::String) {
        self.email_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email_address(&mut self) -> &mut ::std::string::String {
        &mut self.email_address
    }

    // Take field
    pub fn take_email_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email_address, ::std::string::String::new())
    }

    // string info = 10;

    pub fn get_info(&self) -> &str {
        &self.info
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        &mut self.info
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.info, ::std::string::String::new())
    }

    // repeated .io.bisq.protobuffer.Arbitrator.ExtraDataEntry extra_data = 11;

    pub fn get_extra_data(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.extra_data
    }
    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_data(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ) {
        self.extra_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_data(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.extra_data
    }

    // Take field
    pub fn take_extra_data(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.extra_data, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Arbitrator {
    fn is_initialized(&self) -> bool {
        for v in &self.node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.node_address,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.language_codes,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.registration_date = tmp;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.registration_signature,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.registration_pub_key,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.pub_key_ring,
                    )?;
                }
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.btc_pub_key,
                    )?;
                }
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.btc_address,
                    )?;
                }
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.email_address,
                    )?;
                }
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.info,
                    )?;
                }
                11 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeString,
                    >(wire_type, is, &mut self.extra_data)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.language_codes {
            my_size += ::protobuf::rt::string_size(2, &value);
        }
        if self.registration_date != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.registration_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.registration_signature.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.registration_signature);
        }
        if !self.registration_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.registration_pub_key);
        }
        if let Some(ref v) = self.pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.btc_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.btc_pub_key);
        }
        if !self.btc_address.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.btc_address);
        }
        if !self.email_address.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.email_address);
        }
        if !self.info.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.info);
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(11, &self.extra_data);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.node_address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.language_codes {
            os.write_string(2, &v)?;
        }
        if self.registration_date != 0 {
            os.write_int64(3, self.registration_date)?;
        }
        if !self.registration_signature.is_empty() {
            os.write_string(4, &self.registration_signature)?;
        }
        if !self.registration_pub_key.is_empty() {
            os.write_bytes(5, &self.registration_pub_key)?;
        }
        if let Some(ref v) = self.pub_key_ring.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.btc_pub_key.is_empty() {
            os.write_bytes(7, &self.btc_pub_key)?;
        }
        if !self.btc_address.is_empty() {
            os.write_string(8, &self.btc_address)?;
        }
        if !self.email_address.is_empty() {
            os.write_string(9, &self.email_address)?;
        }
        if !self.info.is_empty() {
            os.write_string(10, &self.info)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(11, &self.extra_data, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Arbitrator {
        Arbitrator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "node_address",
                        |m: &Arbitrator| &m.node_address,
                        |m: &mut Arbitrator| &mut m.node_address,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "language_codes",
                        |m: &Arbitrator| &m.language_codes,
                        |m: &mut Arbitrator| &mut m.language_codes,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "registration_date",
                    |m: &Arbitrator| &m.registration_date,
                    |m: &mut Arbitrator| &mut m.registration_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "registration_signature",
                    |m: &Arbitrator| &m.registration_signature,
                    |m: &mut Arbitrator| &mut m.registration_signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "registration_pub_key",
                    |m: &Arbitrator| &m.registration_pub_key,
                    |m: &mut Arbitrator| &mut m.registration_pub_key,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "pub_key_ring",
                        |m: &Arbitrator| &m.pub_key_ring,
                        |m: &mut Arbitrator| &mut m.pub_key_ring,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "btc_pub_key",
                    |m: &Arbitrator| &m.btc_pub_key,
                    |m: &mut Arbitrator| &mut m.btc_pub_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "btc_address",
                    |m: &Arbitrator| &m.btc_address,
                    |m: &mut Arbitrator| &mut m.btc_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "email_address",
                    |m: &Arbitrator| &m.email_address,
                    |m: &mut Arbitrator| &mut m.email_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "info",
                    |m: &Arbitrator| &m.info,
                    |m: &mut Arbitrator| &mut m.info,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "extra_data",
                    |m: &Arbitrator| &m.extra_data,
                    |m: &mut Arbitrator| &mut m.extra_data,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Arbitrator>(
                    "Arbitrator",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Arbitrator {
        static mut instance: ::protobuf::lazy::Lazy<Arbitrator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Arbitrator,
        };
        unsafe { instance.get(Arbitrator::new) }
    }
}

impl ::protobuf::Clear for Arbitrator {
    fn clear(&mut self) {
        self.node_address.clear();
        self.language_codes.clear();
        self.registration_date = 0;
        self.registration_signature.clear();
        self.registration_pub_key.clear();
        self.pub_key_ring.clear();
        self.btc_pub_key.clear();
        self.btc_address.clear();
        self.email_address.clear();
        self.info.clear();
        self.extra_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Arbitrator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Arbitrator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Mediator {
    // message fields
    pub node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub language_codes: ::protobuf::RepeatedField<::std::string::String>,
    pub registration_date: i64,
    pub registration_signature: ::std::string::String,
    pub registration_pub_key: ::std::vec::Vec<u8>,
    pub pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub email_address: ::std::string::String,
    pub info: ::std::string::String,
    pub extra_data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mediator {
    fn default() -> &'a Mediator {
        <Mediator as ::protobuf::Message>::default_instance()
    }
}

impl Mediator {
    pub fn new() -> Mediator {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.NodeAddress node_address = 1;

    pub fn get_node_address(&self) -> &NodeAddress {
        self.node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_node_address(&mut self) {
        self.node_address.clear();
    }

    pub fn has_node_address(&self) -> bool {
        self.node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_address(&mut self, v: NodeAddress) {
        self.node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_address(&mut self) -> &mut NodeAddress {
        if self.node_address.is_none() {
            self.node_address.set_default();
        }
        self.node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_node_address(&mut self) -> NodeAddress {
        self.node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // repeated string language_codes = 2;

    pub fn get_language_codes(&self) -> &[::std::string::String] {
        &self.language_codes
    }
    pub fn clear_language_codes(&mut self) {
        self.language_codes.clear();
    }

    // Param is passed by value, moved
    pub fn set_language_codes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.language_codes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_language_codes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.language_codes
    }

    // Take field
    pub fn take_language_codes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.language_codes, ::protobuf::RepeatedField::new())
    }

    // int64 registration_date = 3;

    pub fn get_registration_date(&self) -> i64 {
        self.registration_date
    }
    pub fn clear_registration_date(&mut self) {
        self.registration_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_registration_date(&mut self, v: i64) {
        self.registration_date = v;
    }

    // string registration_signature = 4;

    pub fn get_registration_signature(&self) -> &str {
        &self.registration_signature
    }
    pub fn clear_registration_signature(&mut self) {
        self.registration_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_registration_signature(&mut self, v: ::std::string::String) {
        self.registration_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration_signature(&mut self) -> &mut ::std::string::String {
        &mut self.registration_signature
    }

    // Take field
    pub fn take_registration_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.registration_signature,
            ::std::string::String::new(),
        )
    }

    // bytes registration_pub_key = 5;

    pub fn get_registration_pub_key(&self) -> &[u8] {
        &self.registration_pub_key
    }
    pub fn clear_registration_pub_key(&mut self) {
        self.registration_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_registration_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.registration_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.registration_pub_key
    }

    // Take field
    pub fn take_registration_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.registration_pub_key, ::std::vec::Vec::new())
    }

    // .io.bisq.protobuffer.PubKeyRing pub_key_ring = 6;

    pub fn get_pub_key_ring(&self) -> &PubKeyRing {
        self.pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_pub_key_ring(&mut self) {
        self.pub_key_ring.clear();
    }

    pub fn has_pub_key_ring(&self) -> bool {
        self.pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pub_key_ring(&mut self, v: PubKeyRing) {
        self.pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.pub_key_ring.is_none() {
            self.pub_key_ring.set_default();
        }
        self.pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_pub_key_ring(&mut self) -> PubKeyRing {
        self.pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // string email_address = 7;

    pub fn get_email_address(&self) -> &str {
        &self.email_address
    }
    pub fn clear_email_address(&mut self) {
        self.email_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_email_address(&mut self, v: ::std::string::String) {
        self.email_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email_address(&mut self) -> &mut ::std::string::String {
        &mut self.email_address
    }

    // Take field
    pub fn take_email_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email_address, ::std::string::String::new())
    }

    // string info = 8;

    pub fn get_info(&self) -> &str {
        &self.info
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        &mut self.info
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.info, ::std::string::String::new())
    }

    // repeated .io.bisq.protobuffer.Mediator.ExtraDataEntry extra_data = 9;

    pub fn get_extra_data(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.extra_data
    }
    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_data(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ) {
        self.extra_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_data(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.extra_data
    }

    // Take field
    pub fn take_extra_data(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.extra_data, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Mediator {
    fn is_initialized(&self) -> bool {
        for v in &self.node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.node_address,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.language_codes,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.registration_date = tmp;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.registration_signature,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.registration_pub_key,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.pub_key_ring,
                    )?;
                }
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.email_address,
                    )?;
                }
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.info,
                    )?;
                }
                9 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeString,
                    >(wire_type, is, &mut self.extra_data)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.language_codes {
            my_size += ::protobuf::rt::string_size(2, &value);
        }
        if self.registration_date != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.registration_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.registration_signature.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.registration_signature);
        }
        if !self.registration_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.registration_pub_key);
        }
        if let Some(ref v) = self.pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.email_address.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.email_address);
        }
        if !self.info.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.info);
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(9, &self.extra_data);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.node_address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.language_codes {
            os.write_string(2, &v)?;
        }
        if self.registration_date != 0 {
            os.write_int64(3, self.registration_date)?;
        }
        if !self.registration_signature.is_empty() {
            os.write_string(4, &self.registration_signature)?;
        }
        if !self.registration_pub_key.is_empty() {
            os.write_bytes(5, &self.registration_pub_key)?;
        }
        if let Some(ref v) = self.pub_key_ring.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.email_address.is_empty() {
            os.write_string(7, &self.email_address)?;
        }
        if !self.info.is_empty() {
            os.write_string(8, &self.info)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(9, &self.extra_data, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mediator {
        Mediator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "node_address",
                        |m: &Mediator| &m.node_address,
                        |m: &mut Mediator| &mut m.node_address,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "language_codes",
                        |m: &Mediator| &m.language_codes,
                        |m: &mut Mediator| &mut m.language_codes,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "registration_date",
                    |m: &Mediator| &m.registration_date,
                    |m: &mut Mediator| &mut m.registration_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "registration_signature",
                    |m: &Mediator| &m.registration_signature,
                    |m: &mut Mediator| &mut m.registration_signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "registration_pub_key",
                    |m: &Mediator| &m.registration_pub_key,
                    |m: &mut Mediator| &mut m.registration_pub_key,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "pub_key_ring",
                        |m: &Mediator| &m.pub_key_ring,
                        |m: &mut Mediator| &mut m.pub_key_ring,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "email_address",
                    |m: &Mediator| &m.email_address,
                    |m: &mut Mediator| &mut m.email_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "info",
                    |m: &Mediator| &m.info,
                    |m: &mut Mediator| &mut m.info,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "extra_data",
                    |m: &Mediator| &m.extra_data,
                    |m: &mut Mediator| &mut m.extra_data,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Mediator>(
                    "Mediator",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Mediator {
        static mut instance: ::protobuf::lazy::Lazy<Mediator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Mediator,
        };
        unsafe { instance.get(Mediator::new) }
    }
}

impl ::protobuf::Clear for Mediator {
    fn clear(&mut self) {
        self.node_address.clear();
        self.language_codes.clear();
        self.registration_date = 0;
        self.registration_signature.clear();
        self.registration_pub_key.clear();
        self.pub_key_ring.clear();
        self.email_address.clear();
        self.info.clear();
        self.extra_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mediator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mediator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RefundAgent {
    // message fields
    pub node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub language_codes: ::protobuf::RepeatedField<::std::string::String>,
    pub registration_date: i64,
    pub registration_signature: ::std::string::String,
    pub registration_pub_key: ::std::vec::Vec<u8>,
    pub pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub email_address: ::std::string::String,
    pub info: ::std::string::String,
    pub extra_data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RefundAgent {
    fn default() -> &'a RefundAgent {
        <RefundAgent as ::protobuf::Message>::default_instance()
    }
}

impl RefundAgent {
    pub fn new() -> RefundAgent {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.NodeAddress node_address = 1;

    pub fn get_node_address(&self) -> &NodeAddress {
        self.node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_node_address(&mut self) {
        self.node_address.clear();
    }

    pub fn has_node_address(&self) -> bool {
        self.node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_address(&mut self, v: NodeAddress) {
        self.node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_address(&mut self) -> &mut NodeAddress {
        if self.node_address.is_none() {
            self.node_address.set_default();
        }
        self.node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_node_address(&mut self) -> NodeAddress {
        self.node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // repeated string language_codes = 2;

    pub fn get_language_codes(&self) -> &[::std::string::String] {
        &self.language_codes
    }
    pub fn clear_language_codes(&mut self) {
        self.language_codes.clear();
    }

    // Param is passed by value, moved
    pub fn set_language_codes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.language_codes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_language_codes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.language_codes
    }

    // Take field
    pub fn take_language_codes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.language_codes, ::protobuf::RepeatedField::new())
    }

    // int64 registration_date = 3;

    pub fn get_registration_date(&self) -> i64 {
        self.registration_date
    }
    pub fn clear_registration_date(&mut self) {
        self.registration_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_registration_date(&mut self, v: i64) {
        self.registration_date = v;
    }

    // string registration_signature = 4;

    pub fn get_registration_signature(&self) -> &str {
        &self.registration_signature
    }
    pub fn clear_registration_signature(&mut self) {
        self.registration_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_registration_signature(&mut self, v: ::std::string::String) {
        self.registration_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration_signature(&mut self) -> &mut ::std::string::String {
        &mut self.registration_signature
    }

    // Take field
    pub fn take_registration_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.registration_signature,
            ::std::string::String::new(),
        )
    }

    // bytes registration_pub_key = 5;

    pub fn get_registration_pub_key(&self) -> &[u8] {
        &self.registration_pub_key
    }
    pub fn clear_registration_pub_key(&mut self) {
        self.registration_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_registration_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.registration_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.registration_pub_key
    }

    // Take field
    pub fn take_registration_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.registration_pub_key, ::std::vec::Vec::new())
    }

    // .io.bisq.protobuffer.PubKeyRing pub_key_ring = 6;

    pub fn get_pub_key_ring(&self) -> &PubKeyRing {
        self.pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_pub_key_ring(&mut self) {
        self.pub_key_ring.clear();
    }

    pub fn has_pub_key_ring(&self) -> bool {
        self.pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pub_key_ring(&mut self, v: PubKeyRing) {
        self.pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.pub_key_ring.is_none() {
            self.pub_key_ring.set_default();
        }
        self.pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_pub_key_ring(&mut self) -> PubKeyRing {
        self.pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // string email_address = 7;

    pub fn get_email_address(&self) -> &str {
        &self.email_address
    }
    pub fn clear_email_address(&mut self) {
        self.email_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_email_address(&mut self, v: ::std::string::String) {
        self.email_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email_address(&mut self) -> &mut ::std::string::String {
        &mut self.email_address
    }

    // Take field
    pub fn take_email_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email_address, ::std::string::String::new())
    }

    // string info = 8;

    pub fn get_info(&self) -> &str {
        &self.info
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        &mut self.info
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.info, ::std::string::String::new())
    }

    // repeated .io.bisq.protobuffer.RefundAgent.ExtraDataEntry extra_data = 9;

    pub fn get_extra_data(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.extra_data
    }
    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_data(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ) {
        self.extra_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_data(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.extra_data
    }

    // Take field
    pub fn take_extra_data(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.extra_data, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for RefundAgent {
    fn is_initialized(&self) -> bool {
        for v in &self.node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.node_address,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.language_codes,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.registration_date = tmp;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.registration_signature,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.registration_pub_key,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.pub_key_ring,
                    )?;
                }
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.email_address,
                    )?;
                }
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.info,
                    )?;
                }
                9 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeString,
                    >(wire_type, is, &mut self.extra_data)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.language_codes {
            my_size += ::protobuf::rt::string_size(2, &value);
        }
        if self.registration_date != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.registration_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.registration_signature.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.registration_signature);
        }
        if !self.registration_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.registration_pub_key);
        }
        if let Some(ref v) = self.pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.email_address.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.email_address);
        }
        if !self.info.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.info);
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(9, &self.extra_data);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.node_address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.language_codes {
            os.write_string(2, &v)?;
        }
        if self.registration_date != 0 {
            os.write_int64(3, self.registration_date)?;
        }
        if !self.registration_signature.is_empty() {
            os.write_string(4, &self.registration_signature)?;
        }
        if !self.registration_pub_key.is_empty() {
            os.write_bytes(5, &self.registration_pub_key)?;
        }
        if let Some(ref v) = self.pub_key_ring.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.email_address.is_empty() {
            os.write_string(7, &self.email_address)?;
        }
        if !self.info.is_empty() {
            os.write_string(8, &self.info)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(9, &self.extra_data, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RefundAgent {
        RefundAgent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "node_address",
                        |m: &RefundAgent| &m.node_address,
                        |m: &mut RefundAgent| &mut m.node_address,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "language_codes",
                        |m: &RefundAgent| &m.language_codes,
                        |m: &mut RefundAgent| &mut m.language_codes,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "registration_date",
                    |m: &RefundAgent| &m.registration_date,
                    |m: &mut RefundAgent| &mut m.registration_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "registration_signature",
                    |m: &RefundAgent| &m.registration_signature,
                    |m: &mut RefundAgent| &mut m.registration_signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "registration_pub_key",
                    |m: &RefundAgent| &m.registration_pub_key,
                    |m: &mut RefundAgent| &mut m.registration_pub_key,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "pub_key_ring",
                        |m: &RefundAgent| &m.pub_key_ring,
                        |m: &mut RefundAgent| &mut m.pub_key_ring,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "email_address",
                    |m: &RefundAgent| &m.email_address,
                    |m: &mut RefundAgent| &mut m.email_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "info",
                    |m: &RefundAgent| &m.info,
                    |m: &mut RefundAgent| &mut m.info,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "extra_data",
                    |m: &RefundAgent| &m.extra_data,
                    |m: &mut RefundAgent| &mut m.extra_data,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RefundAgent>(
                    "RefundAgent",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static RefundAgent {
        static mut instance: ::protobuf::lazy::Lazy<RefundAgent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RefundAgent,
        };
        unsafe { instance.get(RefundAgent::new) }
    }
}

impl ::protobuf::Clear for RefundAgent {
    fn clear(&mut self) {
        self.node_address.clear();
        self.language_codes.clear();
        self.registration_date = 0;
        self.registration_signature.clear();
        self.registration_pub_key.clear();
        self.pub_key_ring.clear();
        self.email_address.clear();
        self.info.clear();
        self.extra_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefundAgent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefundAgent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Filter {
    // message fields
    pub banned_node_address: ::protobuf::RepeatedField<::std::string::String>,
    pub banned_offer_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub banned_payment_accounts: ::protobuf::RepeatedField<PaymentAccountFilter>,
    pub signature_as_base64: ::std::string::String,
    pub owner_pub_key_bytes: ::std::vec::Vec<u8>,
    pub extra_data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub banned_currencies: ::protobuf::RepeatedField<::std::string::String>,
    pub banned_payment_methods: ::protobuf::RepeatedField<::std::string::String>,
    pub arbitrators: ::protobuf::RepeatedField<::std::string::String>,
    pub seed_nodes: ::protobuf::RepeatedField<::std::string::String>,
    pub price_relay_nodes: ::protobuf::RepeatedField<::std::string::String>,
    pub prevent_public_btc_network: bool,
    pub btc_nodes: ::protobuf::RepeatedField<::std::string::String>,
    pub disable_dao: bool,
    pub disable_dao_below_version: ::std::string::String,
    pub disable_trade_below_version: ::std::string::String,
    pub mediators: ::protobuf::RepeatedField<::std::string::String>,
    pub refundAgents: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Filter {
    fn default() -> &'a Filter {
        <Filter as ::protobuf::Message>::default_instance()
    }
}

impl Filter {
    pub fn new() -> Filter {
        ::std::default::Default::default()
    }

    // repeated string banned_node_address = 1;

    pub fn get_banned_node_address(&self) -> &[::std::string::String] {
        &self.banned_node_address
    }
    pub fn clear_banned_node_address(&mut self) {
        self.banned_node_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_banned_node_address(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.banned_node_address = v;
    }

    // Mutable pointer to the field.
    pub fn mut_banned_node_address(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.banned_node_address
    }

    // Take field
    pub fn take_banned_node_address(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(
            &mut self.banned_node_address,
            ::protobuf::RepeatedField::new(),
        )
    }

    // repeated string banned_offer_ids = 2;

    pub fn get_banned_offer_ids(&self) -> &[::std::string::String] {
        &self.banned_offer_ids
    }
    pub fn clear_banned_offer_ids(&mut self) {
        self.banned_offer_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_banned_offer_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.banned_offer_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_banned_offer_ids(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.banned_offer_ids
    }

    // Take field
    pub fn take_banned_offer_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.banned_offer_ids, ::protobuf::RepeatedField::new())
    }

    // repeated .io.bisq.protobuffer.PaymentAccountFilter banned_payment_accounts = 3;

    pub fn get_banned_payment_accounts(&self) -> &[PaymentAccountFilter] {
        &self.banned_payment_accounts
    }
    pub fn clear_banned_payment_accounts(&mut self) {
        self.banned_payment_accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_banned_payment_accounts(
        &mut self,
        v: ::protobuf::RepeatedField<PaymentAccountFilter>,
    ) {
        self.banned_payment_accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_banned_payment_accounts(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<PaymentAccountFilter> {
        &mut self.banned_payment_accounts
    }

    // Take field
    pub fn take_banned_payment_accounts(
        &mut self,
    ) -> ::protobuf::RepeatedField<PaymentAccountFilter> {
        ::std::mem::replace(
            &mut self.banned_payment_accounts,
            ::protobuf::RepeatedField::new(),
        )
    }

    // string signature_as_base64 = 4;

    pub fn get_signature_as_base64(&self) -> &str {
        &self.signature_as_base64
    }
    pub fn clear_signature_as_base64(&mut self) {
        self.signature_as_base64.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature_as_base64(&mut self, v: ::std::string::String) {
        self.signature_as_base64 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature_as_base64(&mut self) -> &mut ::std::string::String {
        &mut self.signature_as_base64
    }

    // Take field
    pub fn take_signature_as_base64(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature_as_base64, ::std::string::String::new())
    }

    // bytes owner_pub_key_bytes = 5;

    pub fn get_owner_pub_key_bytes(&self) -> &[u8] {
        &self.owner_pub_key_bytes
    }
    pub fn clear_owner_pub_key_bytes(&mut self) {
        self.owner_pub_key_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_pub_key_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_pub_key_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_pub_key_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_pub_key_bytes
    }

    // Take field
    pub fn take_owner_pub_key_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_pub_key_bytes, ::std::vec::Vec::new())
    }

    // repeated .io.bisq.protobuffer.Filter.ExtraDataEntry extra_data = 6;

    pub fn get_extra_data(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.extra_data
    }
    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_data(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ) {
        self.extra_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_data(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.extra_data
    }

    // Take field
    pub fn take_extra_data(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.extra_data, ::std::collections::HashMap::new())
    }

    // repeated string banned_currencies = 7;

    pub fn get_banned_currencies(&self) -> &[::std::string::String] {
        &self.banned_currencies
    }
    pub fn clear_banned_currencies(&mut self) {
        self.banned_currencies.clear();
    }

    // Param is passed by value, moved
    pub fn set_banned_currencies(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.banned_currencies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_banned_currencies(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.banned_currencies
    }

    // Take field
    pub fn take_banned_currencies(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(
            &mut self.banned_currencies,
            ::protobuf::RepeatedField::new(),
        )
    }

    // repeated string banned_payment_methods = 8;

    pub fn get_banned_payment_methods(&self) -> &[::std::string::String] {
        &self.banned_payment_methods
    }
    pub fn clear_banned_payment_methods(&mut self) {
        self.banned_payment_methods.clear();
    }

    // Param is passed by value, moved
    pub fn set_banned_payment_methods(
        &mut self,
        v: ::protobuf::RepeatedField<::std::string::String>,
    ) {
        self.banned_payment_methods = v;
    }

    // Mutable pointer to the field.
    pub fn mut_banned_payment_methods(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.banned_payment_methods
    }

    // Take field
    pub fn take_banned_payment_methods(
        &mut self,
    ) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(
            &mut self.banned_payment_methods,
            ::protobuf::RepeatedField::new(),
        )
    }

    // repeated string arbitrators = 9;

    pub fn get_arbitrators(&self) -> &[::std::string::String] {
        &self.arbitrators
    }
    pub fn clear_arbitrators(&mut self) {
        self.arbitrators.clear();
    }

    // Param is passed by value, moved
    pub fn set_arbitrators(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.arbitrators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arbitrators(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.arbitrators
    }

    // Take field
    pub fn take_arbitrators(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.arbitrators, ::protobuf::RepeatedField::new())
    }

    // repeated string seed_nodes = 10;

    pub fn get_seed_nodes(&self) -> &[::std::string::String] {
        &self.seed_nodes
    }
    pub fn clear_seed_nodes(&mut self) {
        self.seed_nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_seed_nodes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.seed_nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_seed_nodes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.seed_nodes
    }

    // Take field
    pub fn take_seed_nodes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.seed_nodes, ::protobuf::RepeatedField::new())
    }

    // repeated string price_relay_nodes = 11;

    pub fn get_price_relay_nodes(&self) -> &[::std::string::String] {
        &self.price_relay_nodes
    }
    pub fn clear_price_relay_nodes(&mut self) {
        self.price_relay_nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_price_relay_nodes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.price_relay_nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_price_relay_nodes(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.price_relay_nodes
    }

    // Take field
    pub fn take_price_relay_nodes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(
            &mut self.price_relay_nodes,
            ::protobuf::RepeatedField::new(),
        )
    }

    // bool prevent_public_btc_network = 12;

    pub fn get_prevent_public_btc_network(&self) -> bool {
        self.prevent_public_btc_network
    }
    pub fn clear_prevent_public_btc_network(&mut self) {
        self.prevent_public_btc_network = false;
    }

    // Param is passed by value, moved
    pub fn set_prevent_public_btc_network(&mut self, v: bool) {
        self.prevent_public_btc_network = v;
    }

    // repeated string btc_nodes = 13;

    pub fn get_btc_nodes(&self) -> &[::std::string::String] {
        &self.btc_nodes
    }
    pub fn clear_btc_nodes(&mut self) {
        self.btc_nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_btc_nodes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.btc_nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_btc_nodes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.btc_nodes
    }

    // Take field
    pub fn take_btc_nodes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.btc_nodes, ::protobuf::RepeatedField::new())
    }

    // bool disable_dao = 14;

    pub fn get_disable_dao(&self) -> bool {
        self.disable_dao
    }
    pub fn clear_disable_dao(&mut self) {
        self.disable_dao = false;
    }

    // Param is passed by value, moved
    pub fn set_disable_dao(&mut self, v: bool) {
        self.disable_dao = v;
    }

    // string disable_dao_below_version = 15;

    pub fn get_disable_dao_below_version(&self) -> &str {
        &self.disable_dao_below_version
    }
    pub fn clear_disable_dao_below_version(&mut self) {
        self.disable_dao_below_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_disable_dao_below_version(&mut self, v: ::std::string::String) {
        self.disable_dao_below_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disable_dao_below_version(&mut self) -> &mut ::std::string::String {
        &mut self.disable_dao_below_version
    }

    // Take field
    pub fn take_disable_dao_below_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.disable_dao_below_version,
            ::std::string::String::new(),
        )
    }

    // string disable_trade_below_version = 16;

    pub fn get_disable_trade_below_version(&self) -> &str {
        &self.disable_trade_below_version
    }
    pub fn clear_disable_trade_below_version(&mut self) {
        self.disable_trade_below_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_disable_trade_below_version(&mut self, v: ::std::string::String) {
        self.disable_trade_below_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disable_trade_below_version(&mut self) -> &mut ::std::string::String {
        &mut self.disable_trade_below_version
    }

    // Take field
    pub fn take_disable_trade_below_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.disable_trade_below_version,
            ::std::string::String::new(),
        )
    }

    // repeated string mediators = 17;

    pub fn get_mediators(&self) -> &[::std::string::String] {
        &self.mediators
    }
    pub fn clear_mediators(&mut self) {
        self.mediators.clear();
    }

    // Param is passed by value, moved
    pub fn set_mediators(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mediators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mediators(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mediators
    }

    // Take field
    pub fn take_mediators(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mediators, ::protobuf::RepeatedField::new())
    }

    // repeated string refundAgents = 18;

    pub fn get_refundAgents(&self) -> &[::std::string::String] {
        &self.refundAgents
    }
    pub fn clear_refundAgents(&mut self) {
        self.refundAgents.clear();
    }

    // Param is passed by value, moved
    pub fn set_refundAgents(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.refundAgents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_refundAgents(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.refundAgents
    }

    // Take field
    pub fn take_refundAgents(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.refundAgents, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Filter {
    fn is_initialized(&self) -> bool {
        for v in &self.banned_payment_accounts {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.banned_node_address,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.banned_offer_ids,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.banned_payment_accounts,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.signature_as_base64,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.owner_pub_key_bytes,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeString,
                    >(wire_type, is, &mut self.extra_data)?;
                }
                7 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.banned_currencies,
                    )?;
                }
                8 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.banned_payment_methods,
                    )?;
                }
                9 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.arbitrators,
                    )?;
                }
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.seed_nodes)?;
                }
                11 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.price_relay_nodes,
                    )?;
                }
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.prevent_public_btc_network = tmp;
                }
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.btc_nodes)?;
                }
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_dao = tmp;
                }
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.disable_dao_below_version,
                    )?;
                }
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.disable_trade_below_version,
                    )?;
                }
                17 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mediators)?;
                }
                18 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.refundAgents,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.banned_node_address {
            my_size += ::protobuf::rt::string_size(1, &value);
        }
        for value in &self.banned_offer_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        }
        for value in &self.banned_payment_accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signature_as_base64.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.signature_as_base64);
        }
        if !self.owner_pub_key_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.owner_pub_key_bytes);
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(6, &self.extra_data);
        for value in &self.banned_currencies {
            my_size += ::protobuf::rt::string_size(7, &value);
        }
        for value in &self.banned_payment_methods {
            my_size += ::protobuf::rt::string_size(8, &value);
        }
        for value in &self.arbitrators {
            my_size += ::protobuf::rt::string_size(9, &value);
        }
        for value in &self.seed_nodes {
            my_size += ::protobuf::rt::string_size(10, &value);
        }
        for value in &self.price_relay_nodes {
            my_size += ::protobuf::rt::string_size(11, &value);
        }
        if self.prevent_public_btc_network != false {
            my_size += 2;
        }
        for value in &self.btc_nodes {
            my_size += ::protobuf::rt::string_size(13, &value);
        }
        if self.disable_dao != false {
            my_size += 2;
        }
        if !self.disable_dao_below_version.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.disable_dao_below_version);
        }
        if !self.disable_trade_below_version.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.disable_trade_below_version);
        }
        for value in &self.mediators {
            my_size += ::protobuf::rt::string_size(17, &value);
        }
        for value in &self.refundAgents {
            my_size += ::protobuf::rt::string_size(18, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.banned_node_address {
            os.write_string(1, &v)?;
        }
        for v in &self.banned_offer_ids {
            os.write_string(2, &v)?;
        }
        for v in &self.banned_payment_accounts {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signature_as_base64.is_empty() {
            os.write_string(4, &self.signature_as_base64)?;
        }
        if !self.owner_pub_key_bytes.is_empty() {
            os.write_bytes(5, &self.owner_pub_key_bytes)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(6, &self.extra_data, os)?;
        for v in &self.banned_currencies {
            os.write_string(7, &v)?;
        }
        for v in &self.banned_payment_methods {
            os.write_string(8, &v)?;
        }
        for v in &self.arbitrators {
            os.write_string(9, &v)?;
        }
        for v in &self.seed_nodes {
            os.write_string(10, &v)?;
        }
        for v in &self.price_relay_nodes {
            os.write_string(11, &v)?;
        }
        if self.prevent_public_btc_network != false {
            os.write_bool(12, self.prevent_public_btc_network)?;
        }
        for v in &self.btc_nodes {
            os.write_string(13, &v)?;
        }
        if self.disable_dao != false {
            os.write_bool(14, self.disable_dao)?;
        }
        if !self.disable_dao_below_version.is_empty() {
            os.write_string(15, &self.disable_dao_below_version)?;
        }
        if !self.disable_trade_below_version.is_empty() {
            os.write_string(16, &self.disable_trade_below_version)?;
        }
        for v in &self.mediators {
            os.write_string(17, &v)?;
        }
        for v in &self.refundAgents {
            os.write_string(18, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Filter {
        Filter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "banned_node_address",
                        |m: &Filter| &m.banned_node_address,
                        |m: &mut Filter| &mut m.banned_node_address,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "banned_offer_ids",
                        |m: &Filter| &m.banned_offer_ids,
                        |m: &mut Filter| &mut m.banned_offer_ids,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PaymentAccountFilter>,
                    >(
                        "banned_payment_accounts",
                        |m: &Filter| &m.banned_payment_accounts,
                        |m: &mut Filter| &mut m.banned_payment_accounts,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "signature_as_base64",
                    |m: &Filter| &m.signature_as_base64,
                    |m: &mut Filter| &mut m.signature_as_base64,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "owner_pub_key_bytes",
                    |m: &Filter| &m.owner_pub_key_bytes,
                    |m: &mut Filter| &mut m.owner_pub_key_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "extra_data",
                    |m: &Filter| &m.extra_data,
                    |m: &mut Filter| &mut m.extra_data,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "banned_currencies",
                        |m: &Filter| &m.banned_currencies,
                        |m: &mut Filter| &mut m.banned_currencies,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "banned_payment_methods",
                        |m: &Filter| &m.banned_payment_methods,
                        |m: &mut Filter| &mut m.banned_payment_methods,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "arbitrators",
                        |m: &Filter| &m.arbitrators,
                        |m: &mut Filter| &mut m.arbitrators,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "seed_nodes",
                        |m: &Filter| &m.seed_nodes,
                        |m: &mut Filter| &mut m.seed_nodes,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "price_relay_nodes",
                        |m: &Filter| &m.price_relay_nodes,
                        |m: &mut Filter| &mut m.price_relay_nodes,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "prevent_public_btc_network",
                    |m: &Filter| &m.prevent_public_btc_network,
                    |m: &mut Filter| &mut m.prevent_public_btc_network,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "btc_nodes",
                        |m: &Filter| &m.btc_nodes,
                        |m: &mut Filter| &mut m.btc_nodes,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "disable_dao",
                    |m: &Filter| &m.disable_dao,
                    |m: &mut Filter| &mut m.disable_dao,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "disable_dao_below_version",
                    |m: &Filter| &m.disable_dao_below_version,
                    |m: &mut Filter| &mut m.disable_dao_below_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "disable_trade_below_version",
                    |m: &Filter| &m.disable_trade_below_version,
                    |m: &mut Filter| &mut m.disable_trade_below_version,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "mediators",
                        |m: &Filter| &m.mediators,
                        |m: &mut Filter| &mut m.mediators,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "refundAgents",
                        |m: &Filter| &m.refundAgents,
                        |m: &mut Filter| &mut m.refundAgents,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<Filter>(
                    "Filter",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Filter {
        static mut instance: ::protobuf::lazy::Lazy<Filter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Filter,
        };
        unsafe { instance.get(Filter::new) }
    }
}

impl ::protobuf::Clear for Filter {
    fn clear(&mut self) {
        self.banned_node_address.clear();
        self.banned_offer_ids.clear();
        self.banned_payment_accounts.clear();
        self.signature_as_base64.clear();
        self.owner_pub_key_bytes.clear();
        self.extra_data.clear();
        self.banned_currencies.clear();
        self.banned_payment_methods.clear();
        self.arbitrators.clear();
        self.seed_nodes.clear();
        self.price_relay_nodes.clear();
        self.prevent_public_btc_network = false;
        self.btc_nodes.clear();
        self.disable_dao = false;
        self.disable_dao_below_version.clear();
        self.disable_trade_below_version.clear();
        self.mediators.clear();
        self.refundAgents.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Filter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Filter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct TradeStatistics {
    // message fields
    pub base_currency: ::std::string::String,
    pub counter_currency: ::std::string::String,
    pub direction: OfferPayload_Direction,
    pub trade_price: i64,
    pub trade_amount: i64,
    pub trade_date: i64,
    pub payment_method_id: ::std::string::String,
    pub offer_date: i64,
    pub offer_use_market_based_price: bool,
    pub offer_market_price_margin: f64,
    pub offer_amount: i64,
    pub offer_min_amount: i64,
    pub offer_id: ::std::string::String,
    pub deposit_tx_id: ::std::string::String,
    pub signature_pub_key_bytes: ::std::vec::Vec<u8>,
    pub extra_data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradeStatistics {
    fn default() -> &'a TradeStatistics {
        <TradeStatistics as ::protobuf::Message>::default_instance()
    }
}

impl TradeStatistics {
    pub fn new() -> TradeStatistics {
        ::std::default::Default::default()
    }

    // string base_currency = 1;

    pub fn get_base_currency(&self) -> &str {
        &self.base_currency
    }
    pub fn clear_base_currency(&mut self) {
        self.base_currency.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_currency(&mut self, v: ::std::string::String) {
        self.base_currency = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_currency(&mut self) -> &mut ::std::string::String {
        &mut self.base_currency
    }

    // Take field
    pub fn take_base_currency(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base_currency, ::std::string::String::new())
    }

    // string counter_currency = 2;

    pub fn get_counter_currency(&self) -> &str {
        &self.counter_currency
    }
    pub fn clear_counter_currency(&mut self) {
        self.counter_currency.clear();
    }

    // Param is passed by value, moved
    pub fn set_counter_currency(&mut self, v: ::std::string::String) {
        self.counter_currency = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counter_currency(&mut self) -> &mut ::std::string::String {
        &mut self.counter_currency
    }

    // Take field
    pub fn take_counter_currency(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.counter_currency, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.OfferPayload.Direction direction = 3;

    pub fn get_direction(&self) -> OfferPayload_Direction {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = OfferPayload_Direction::PB_ERROR;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: OfferPayload_Direction) {
        self.direction = v;
    }

    // int64 trade_price = 4;

    pub fn get_trade_price(&self) -> i64 {
        self.trade_price
    }
    pub fn clear_trade_price(&mut self) {
        self.trade_price = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_price(&mut self, v: i64) {
        self.trade_price = v;
    }

    // int64 trade_amount = 5;

    pub fn get_trade_amount(&self) -> i64 {
        self.trade_amount
    }
    pub fn clear_trade_amount(&mut self) {
        self.trade_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_amount(&mut self, v: i64) {
        self.trade_amount = v;
    }

    // int64 trade_date = 6;

    pub fn get_trade_date(&self) -> i64 {
        self.trade_date
    }
    pub fn clear_trade_date(&mut self) {
        self.trade_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_date(&mut self, v: i64) {
        self.trade_date = v;
    }

    // string payment_method_id = 7;

    pub fn get_payment_method_id(&self) -> &str {
        &self.payment_method_id
    }
    pub fn clear_payment_method_id(&mut self) {
        self.payment_method_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_method_id(&mut self, v: ::std::string::String) {
        self.payment_method_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_method_id(&mut self) -> &mut ::std::string::String {
        &mut self.payment_method_id
    }

    // Take field
    pub fn take_payment_method_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_method_id, ::std::string::String::new())
    }

    // int64 offer_date = 8;

    pub fn get_offer_date(&self) -> i64 {
        self.offer_date
    }
    pub fn clear_offer_date(&mut self) {
        self.offer_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_offer_date(&mut self, v: i64) {
        self.offer_date = v;
    }

    // bool offer_use_market_based_price = 9;

    pub fn get_offer_use_market_based_price(&self) -> bool {
        self.offer_use_market_based_price
    }
    pub fn clear_offer_use_market_based_price(&mut self) {
        self.offer_use_market_based_price = false;
    }

    // Param is passed by value, moved
    pub fn set_offer_use_market_based_price(&mut self, v: bool) {
        self.offer_use_market_based_price = v;
    }

    // double offer_market_price_margin = 10;

    pub fn get_offer_market_price_margin(&self) -> f64 {
        self.offer_market_price_margin
    }
    pub fn clear_offer_market_price_margin(&mut self) {
        self.offer_market_price_margin = 0.;
    }

    // Param is passed by value, moved
    pub fn set_offer_market_price_margin(&mut self, v: f64) {
        self.offer_market_price_margin = v;
    }

    // int64 offer_amount = 11;

    pub fn get_offer_amount(&self) -> i64 {
        self.offer_amount
    }
    pub fn clear_offer_amount(&mut self) {
        self.offer_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_offer_amount(&mut self, v: i64) {
        self.offer_amount = v;
    }

    // int64 offer_min_amount = 12;

    pub fn get_offer_min_amount(&self) -> i64 {
        self.offer_min_amount
    }
    pub fn clear_offer_min_amount(&mut self) {
        self.offer_min_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_offer_min_amount(&mut self, v: i64) {
        self.offer_min_amount = v;
    }

    // string offer_id = 13;

    pub fn get_offer_id(&self) -> &str {
        &self.offer_id
    }
    pub fn clear_offer_id(&mut self) {
        self.offer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_offer_id(&mut self, v: ::std::string::String) {
        self.offer_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer_id(&mut self) -> &mut ::std::string::String {
        &mut self.offer_id
    }

    // Take field
    pub fn take_offer_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.offer_id, ::std::string::String::new())
    }

    // string deposit_tx_id = 14;

    pub fn get_deposit_tx_id(&self) -> &str {
        &self.deposit_tx_id
    }
    pub fn clear_deposit_tx_id(&mut self) {
        self.deposit_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_deposit_tx_id(&mut self, v: ::std::string::String) {
        self.deposit_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deposit_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.deposit_tx_id
    }

    // Take field
    pub fn take_deposit_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.deposit_tx_id, ::std::string::String::new())
    }

    // bytes signature_pub_key_bytes = 15;

    pub fn get_signature_pub_key_bytes(&self) -> &[u8] {
        &self.signature_pub_key_bytes
    }
    pub fn clear_signature_pub_key_bytes(&mut self) {
        self.signature_pub_key_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature_pub_key_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature_pub_key_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature_pub_key_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature_pub_key_bytes
    }

    // Take field
    pub fn take_signature_pub_key_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature_pub_key_bytes, ::std::vec::Vec::new())
    }

    // repeated .io.bisq.protobuffer.TradeStatistics.ExtraDataEntry extra_data = 16;

    pub fn get_extra_data(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.extra_data
    }
    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_data(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ) {
        self.extra_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_data(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.extra_data
    }

    // Take field
    pub fn take_extra_data(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.extra_data, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for TradeStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.base_currency,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.counter_currency,
                    )?;
                }
                3 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.direction,
                    3,
                    &mut self.unknown_fields,
                )?,
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.trade_price = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.trade_amount = tmp;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.trade_date = tmp;
                }
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.payment_method_id,
                    )?;
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.offer_date = tmp;
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.offer_use_market_based_price = tmp;
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.offer_market_price_margin = tmp;
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.offer_amount = tmp;
                }
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.offer_min_amount = tmp;
                }
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.offer_id,
                    )?;
                }
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.deposit_tx_id,
                    )?;
                }
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.signature_pub_key_bytes,
                    )?;
                }
                16 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeString,
                    >(wire_type, is, &mut self.extra_data)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.base_currency.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.base_currency);
        }
        if !self.counter_currency.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.counter_currency);
        }
        if self.direction != OfferPayload_Direction::PB_ERROR {
            my_size += ::protobuf::rt::enum_size(3, self.direction);
        }
        if self.trade_price != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.trade_price,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.trade_amount != 0 {
            my_size += ::protobuf::rt::value_size(
                5,
                self.trade_amount,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.trade_date != 0 {
            my_size += ::protobuf::rt::value_size(
                6,
                self.trade_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.payment_method_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.payment_method_id);
        }
        if self.offer_date != 0 {
            my_size += ::protobuf::rt::value_size(
                8,
                self.offer_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.offer_use_market_based_price != false {
            my_size += 2;
        }
        if self.offer_market_price_margin != 0. {
            my_size += 9;
        }
        if self.offer_amount != 0 {
            my_size += ::protobuf::rt::value_size(
                11,
                self.offer_amount,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.offer_min_amount != 0 {
            my_size += ::protobuf::rt::value_size(
                12,
                self.offer_min_amount,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.offer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.offer_id);
        }
        if !self.deposit_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.deposit_tx_id);
        }
        if !self.signature_pub_key_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.signature_pub_key_bytes);
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(16, &self.extra_data);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.base_currency.is_empty() {
            os.write_string(1, &self.base_currency)?;
        }
        if !self.counter_currency.is_empty() {
            os.write_string(2, &self.counter_currency)?;
        }
        if self.direction != OfferPayload_Direction::PB_ERROR {
            os.write_enum(3, self.direction.value())?;
        }
        if self.trade_price != 0 {
            os.write_int64(4, self.trade_price)?;
        }
        if self.trade_amount != 0 {
            os.write_int64(5, self.trade_amount)?;
        }
        if self.trade_date != 0 {
            os.write_int64(6, self.trade_date)?;
        }
        if !self.payment_method_id.is_empty() {
            os.write_string(7, &self.payment_method_id)?;
        }
        if self.offer_date != 0 {
            os.write_int64(8, self.offer_date)?;
        }
        if self.offer_use_market_based_price != false {
            os.write_bool(9, self.offer_use_market_based_price)?;
        }
        if self.offer_market_price_margin != 0. {
            os.write_double(10, self.offer_market_price_margin)?;
        }
        if self.offer_amount != 0 {
            os.write_int64(11, self.offer_amount)?;
        }
        if self.offer_min_amount != 0 {
            os.write_int64(12, self.offer_min_amount)?;
        }
        if !self.offer_id.is_empty() {
            os.write_string(13, &self.offer_id)?;
        }
        if !self.deposit_tx_id.is_empty() {
            os.write_string(14, &self.deposit_tx_id)?;
        }
        if !self.signature_pub_key_bytes.is_empty() {
            os.write_bytes(15, &self.signature_pub_key_bytes)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(16, &self.extra_data, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradeStatistics {
        TradeStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "base_currency",
                    |m: &TradeStatistics| &m.base_currency,
                    |m: &mut TradeStatistics| &mut m.base_currency,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "counter_currency",
                    |m: &TradeStatistics| &m.counter_currency,
                    |m: &mut TradeStatistics| &mut m.counter_currency,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<OfferPayload_Direction>,
                >(
                    "direction",
                    |m: &TradeStatistics| &m.direction,
                    |m: &mut TradeStatistics| &mut m.direction,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "trade_price",
                    |m: &TradeStatistics| &m.trade_price,
                    |m: &mut TradeStatistics| &mut m.trade_price,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "trade_amount",
                    |m: &TradeStatistics| &m.trade_amount,
                    |m: &mut TradeStatistics| &mut m.trade_amount,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "trade_date",
                    |m: &TradeStatistics| &m.trade_date,
                    |m: &mut TradeStatistics| &mut m.trade_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "payment_method_id",
                    |m: &TradeStatistics| &m.payment_method_id,
                    |m: &mut TradeStatistics| &mut m.payment_method_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "offer_date",
                    |m: &TradeStatistics| &m.offer_date,
                    |m: &mut TradeStatistics| &mut m.offer_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "offer_use_market_based_price",
                    |m: &TradeStatistics| &m.offer_use_market_based_price,
                    |m: &mut TradeStatistics| &mut m.offer_use_market_based_price,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "offer_market_price_margin",
                    |m: &TradeStatistics| &m.offer_market_price_margin,
                    |m: &mut TradeStatistics| &mut m.offer_market_price_margin,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "offer_amount",
                    |m: &TradeStatistics| &m.offer_amount,
                    |m: &mut TradeStatistics| &mut m.offer_amount,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "offer_min_amount",
                    |m: &TradeStatistics| &m.offer_min_amount,
                    |m: &mut TradeStatistics| &mut m.offer_min_amount,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "offer_id",
                    |m: &TradeStatistics| &m.offer_id,
                    |m: &mut TradeStatistics| &mut m.offer_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "deposit_tx_id",
                    |m: &TradeStatistics| &m.deposit_tx_id,
                    |m: &mut TradeStatistics| &mut m.deposit_tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "signature_pub_key_bytes",
                    |m: &TradeStatistics| &m.signature_pub_key_bytes,
                    |m: &mut TradeStatistics| &mut m.signature_pub_key_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "extra_data",
                    |m: &TradeStatistics| &m.extra_data,
                    |m: &mut TradeStatistics| &mut m.extra_data,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TradeStatistics>(
                    "TradeStatistics",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static TradeStatistics {
        static mut instance: ::protobuf::lazy::Lazy<TradeStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TradeStatistics,
        };
        unsafe { instance.get(TradeStatistics::new) }
    }
}

impl ::protobuf::Clear for TradeStatistics {
    fn clear(&mut self) {
        self.base_currency.clear();
        self.counter_currency.clear();
        self.direction = OfferPayload_Direction::PB_ERROR;
        self.trade_price = 0;
        self.trade_amount = 0;
        self.trade_date = 0;
        self.payment_method_id.clear();
        self.offer_date = 0;
        self.offer_use_market_based_price = false;
        self.offer_market_price_margin = 0.;
        self.offer_amount = 0;
        self.offer_min_amount = 0;
        self.offer_id.clear();
        self.deposit_tx_id.clear();
        self.signature_pub_key_bytes.clear();
        self.extra_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TradeStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TradeStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct TradeStatistics2 {
    // message fields
    pub base_currency: ::std::string::String,
    pub counter_currency: ::std::string::String,
    pub direction: OfferPayload_Direction,
    pub trade_price: i64,
    pub trade_amount: i64,
    pub trade_date: i64,
    pub payment_method_id: ::std::string::String,
    pub offer_date: i64,
    pub offer_use_market_based_price: bool,
    pub offer_market_price_margin: f64,
    pub offer_amount: i64,
    pub offer_min_amount: i64,
    pub offer_id: ::std::string::String,
    pub deposit_tx_id: ::std::string::String,
    pub hash: ::std::vec::Vec<u8>,
    pub extra_data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradeStatistics2 {
    fn default() -> &'a TradeStatistics2 {
        <TradeStatistics2 as ::protobuf::Message>::default_instance()
    }
}

impl TradeStatistics2 {
    pub fn new() -> TradeStatistics2 {
        ::std::default::Default::default()
    }

    // string base_currency = 1;

    pub fn get_base_currency(&self) -> &str {
        &self.base_currency
    }
    pub fn clear_base_currency(&mut self) {
        self.base_currency.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_currency(&mut self, v: ::std::string::String) {
        self.base_currency = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_currency(&mut self) -> &mut ::std::string::String {
        &mut self.base_currency
    }

    // Take field
    pub fn take_base_currency(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base_currency, ::std::string::String::new())
    }

    // string counter_currency = 2;

    pub fn get_counter_currency(&self) -> &str {
        &self.counter_currency
    }
    pub fn clear_counter_currency(&mut self) {
        self.counter_currency.clear();
    }

    // Param is passed by value, moved
    pub fn set_counter_currency(&mut self, v: ::std::string::String) {
        self.counter_currency = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counter_currency(&mut self) -> &mut ::std::string::String {
        &mut self.counter_currency
    }

    // Take field
    pub fn take_counter_currency(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.counter_currency, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.OfferPayload.Direction direction = 3;

    pub fn get_direction(&self) -> OfferPayload_Direction {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = OfferPayload_Direction::PB_ERROR;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: OfferPayload_Direction) {
        self.direction = v;
    }

    // int64 trade_price = 4;

    pub fn get_trade_price(&self) -> i64 {
        self.trade_price
    }
    pub fn clear_trade_price(&mut self) {
        self.trade_price = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_price(&mut self, v: i64) {
        self.trade_price = v;
    }

    // int64 trade_amount = 5;

    pub fn get_trade_amount(&self) -> i64 {
        self.trade_amount
    }
    pub fn clear_trade_amount(&mut self) {
        self.trade_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_amount(&mut self, v: i64) {
        self.trade_amount = v;
    }

    // int64 trade_date = 6;

    pub fn get_trade_date(&self) -> i64 {
        self.trade_date
    }
    pub fn clear_trade_date(&mut self) {
        self.trade_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_date(&mut self, v: i64) {
        self.trade_date = v;
    }

    // string payment_method_id = 7;

    pub fn get_payment_method_id(&self) -> &str {
        &self.payment_method_id
    }
    pub fn clear_payment_method_id(&mut self) {
        self.payment_method_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_method_id(&mut self, v: ::std::string::String) {
        self.payment_method_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_method_id(&mut self) -> &mut ::std::string::String {
        &mut self.payment_method_id
    }

    // Take field
    pub fn take_payment_method_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_method_id, ::std::string::String::new())
    }

    // int64 offer_date = 8;

    pub fn get_offer_date(&self) -> i64 {
        self.offer_date
    }
    pub fn clear_offer_date(&mut self) {
        self.offer_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_offer_date(&mut self, v: i64) {
        self.offer_date = v;
    }

    // bool offer_use_market_based_price = 9;

    pub fn get_offer_use_market_based_price(&self) -> bool {
        self.offer_use_market_based_price
    }
    pub fn clear_offer_use_market_based_price(&mut self) {
        self.offer_use_market_based_price = false;
    }

    // Param is passed by value, moved
    pub fn set_offer_use_market_based_price(&mut self, v: bool) {
        self.offer_use_market_based_price = v;
    }

    // double offer_market_price_margin = 10;

    pub fn get_offer_market_price_margin(&self) -> f64 {
        self.offer_market_price_margin
    }
    pub fn clear_offer_market_price_margin(&mut self) {
        self.offer_market_price_margin = 0.;
    }

    // Param is passed by value, moved
    pub fn set_offer_market_price_margin(&mut self, v: f64) {
        self.offer_market_price_margin = v;
    }

    // int64 offer_amount = 11;

    pub fn get_offer_amount(&self) -> i64 {
        self.offer_amount
    }
    pub fn clear_offer_amount(&mut self) {
        self.offer_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_offer_amount(&mut self, v: i64) {
        self.offer_amount = v;
    }

    // int64 offer_min_amount = 12;

    pub fn get_offer_min_amount(&self) -> i64 {
        self.offer_min_amount
    }
    pub fn clear_offer_min_amount(&mut self) {
        self.offer_min_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_offer_min_amount(&mut self, v: i64) {
        self.offer_min_amount = v;
    }

    // string offer_id = 13;

    pub fn get_offer_id(&self) -> &str {
        &self.offer_id
    }
    pub fn clear_offer_id(&mut self) {
        self.offer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_offer_id(&mut self, v: ::std::string::String) {
        self.offer_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer_id(&mut self) -> &mut ::std::string::String {
        &mut self.offer_id
    }

    // Take field
    pub fn take_offer_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.offer_id, ::std::string::String::new())
    }

    // string deposit_tx_id = 14;

    pub fn get_deposit_tx_id(&self) -> &str {
        &self.deposit_tx_id
    }
    pub fn clear_deposit_tx_id(&mut self) {
        self.deposit_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_deposit_tx_id(&mut self, v: ::std::string::String) {
        self.deposit_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deposit_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.deposit_tx_id
    }

    // Take field
    pub fn take_deposit_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.deposit_tx_id, ::std::string::String::new())
    }

    // bytes hash = 15;

    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // repeated .io.bisq.protobuffer.TradeStatistics2.ExtraDataEntry extra_data = 16;

    pub fn get_extra_data(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.extra_data
    }
    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_data(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ) {
        self.extra_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_data(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.extra_data
    }

    // Take field
    pub fn take_extra_data(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.extra_data, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for TradeStatistics2 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.base_currency,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.counter_currency,
                    )?;
                }
                3 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.direction,
                    3,
                    &mut self.unknown_fields,
                )?,
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.trade_price = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.trade_amount = tmp;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.trade_date = tmp;
                }
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.payment_method_id,
                    )?;
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.offer_date = tmp;
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.offer_use_market_based_price = tmp;
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.offer_market_price_margin = tmp;
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.offer_amount = tmp;
                }
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.offer_min_amount = tmp;
                }
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.offer_id,
                    )?;
                }
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.deposit_tx_id,
                    )?;
                }
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                }
                16 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeString,
                    >(wire_type, is, &mut self.extra_data)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.base_currency.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.base_currency);
        }
        if !self.counter_currency.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.counter_currency);
        }
        if self.direction != OfferPayload_Direction::PB_ERROR {
            my_size += ::protobuf::rt::enum_size(3, self.direction);
        }
        if self.trade_price != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.trade_price,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.trade_amount != 0 {
            my_size += ::protobuf::rt::value_size(
                5,
                self.trade_amount,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.trade_date != 0 {
            my_size += ::protobuf::rt::value_size(
                6,
                self.trade_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.payment_method_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.payment_method_id);
        }
        if self.offer_date != 0 {
            my_size += ::protobuf::rt::value_size(
                8,
                self.offer_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.offer_use_market_based_price != false {
            my_size += 2;
        }
        if self.offer_market_price_margin != 0. {
            my_size += 9;
        }
        if self.offer_amount != 0 {
            my_size += ::protobuf::rt::value_size(
                11,
                self.offer_amount,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.offer_min_amount != 0 {
            my_size += ::protobuf::rt::value_size(
                12,
                self.offer_min_amount,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.offer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.offer_id);
        }
        if !self.deposit_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.deposit_tx_id);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.hash);
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(16, &self.extra_data);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.base_currency.is_empty() {
            os.write_string(1, &self.base_currency)?;
        }
        if !self.counter_currency.is_empty() {
            os.write_string(2, &self.counter_currency)?;
        }
        if self.direction != OfferPayload_Direction::PB_ERROR {
            os.write_enum(3, self.direction.value())?;
        }
        if self.trade_price != 0 {
            os.write_int64(4, self.trade_price)?;
        }
        if self.trade_amount != 0 {
            os.write_int64(5, self.trade_amount)?;
        }
        if self.trade_date != 0 {
            os.write_int64(6, self.trade_date)?;
        }
        if !self.payment_method_id.is_empty() {
            os.write_string(7, &self.payment_method_id)?;
        }
        if self.offer_date != 0 {
            os.write_int64(8, self.offer_date)?;
        }
        if self.offer_use_market_based_price != false {
            os.write_bool(9, self.offer_use_market_based_price)?;
        }
        if self.offer_market_price_margin != 0. {
            os.write_double(10, self.offer_market_price_margin)?;
        }
        if self.offer_amount != 0 {
            os.write_int64(11, self.offer_amount)?;
        }
        if self.offer_min_amount != 0 {
            os.write_int64(12, self.offer_min_amount)?;
        }
        if !self.offer_id.is_empty() {
            os.write_string(13, &self.offer_id)?;
        }
        if !self.deposit_tx_id.is_empty() {
            os.write_string(14, &self.deposit_tx_id)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(15, &self.hash)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(16, &self.extra_data, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradeStatistics2 {
        TradeStatistics2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "base_currency",
                    |m: &TradeStatistics2| &m.base_currency,
                    |m: &mut TradeStatistics2| &mut m.base_currency,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "counter_currency",
                    |m: &TradeStatistics2| &m.counter_currency,
                    |m: &mut TradeStatistics2| &mut m.counter_currency,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<OfferPayload_Direction>,
                >(
                    "direction",
                    |m: &TradeStatistics2| &m.direction,
                    |m: &mut TradeStatistics2| &mut m.direction,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "trade_price",
                    |m: &TradeStatistics2| &m.trade_price,
                    |m: &mut TradeStatistics2| &mut m.trade_price,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "trade_amount",
                    |m: &TradeStatistics2| &m.trade_amount,
                    |m: &mut TradeStatistics2| &mut m.trade_amount,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "trade_date",
                    |m: &TradeStatistics2| &m.trade_date,
                    |m: &mut TradeStatistics2| &mut m.trade_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "payment_method_id",
                    |m: &TradeStatistics2| &m.payment_method_id,
                    |m: &mut TradeStatistics2| &mut m.payment_method_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "offer_date",
                    |m: &TradeStatistics2| &m.offer_date,
                    |m: &mut TradeStatistics2| &mut m.offer_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "offer_use_market_based_price",
                    |m: &TradeStatistics2| &m.offer_use_market_based_price,
                    |m: &mut TradeStatistics2| &mut m.offer_use_market_based_price,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "offer_market_price_margin",
                    |m: &TradeStatistics2| &m.offer_market_price_margin,
                    |m: &mut TradeStatistics2| &mut m.offer_market_price_margin,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "offer_amount",
                    |m: &TradeStatistics2| &m.offer_amount,
                    |m: &mut TradeStatistics2| &mut m.offer_amount,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "offer_min_amount",
                    |m: &TradeStatistics2| &m.offer_min_amount,
                    |m: &mut TradeStatistics2| &mut m.offer_min_amount,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "offer_id",
                    |m: &TradeStatistics2| &m.offer_id,
                    |m: &mut TradeStatistics2| &mut m.offer_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "deposit_tx_id",
                    |m: &TradeStatistics2| &m.deposit_tx_id,
                    |m: &mut TradeStatistics2| &mut m.deposit_tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "hash",
                    |m: &TradeStatistics2| &m.hash,
                    |m: &mut TradeStatistics2| &mut m.hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "extra_data",
                    |m: &TradeStatistics2| &m.extra_data,
                    |m: &mut TradeStatistics2| &mut m.extra_data,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TradeStatistics2>(
                    "TradeStatistics2",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static TradeStatistics2 {
        static mut instance: ::protobuf::lazy::Lazy<TradeStatistics2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TradeStatistics2,
        };
        unsafe { instance.get(TradeStatistics2::new) }
    }
}

impl ::protobuf::Clear for TradeStatistics2 {
    fn clear(&mut self) {
        self.base_currency.clear();
        self.counter_currency.clear();
        self.direction = OfferPayload_Direction::PB_ERROR;
        self.trade_price = 0;
        self.trade_amount = 0;
        self.trade_date = 0;
        self.payment_method_id.clear();
        self.offer_date = 0;
        self.offer_use_market_based_price = false;
        self.offer_market_price_margin = 0.;
        self.offer_amount = 0;
        self.offer_min_amount = 0;
        self.offer_id.clear();
        self.deposit_tx_id.clear();
        self.hash.clear();
        self.extra_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TradeStatistics2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TradeStatistics2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MailboxStoragePayload {
    // message fields
    pub prefixed_sealed_and_signed_message:
        ::protobuf::SingularPtrField<PrefixedSealedAndSignedMessage>,
    pub sender_pub_key_for_add_operation_bytes: ::std::vec::Vec<u8>,
    pub owner_pub_key_bytes: ::std::vec::Vec<u8>,
    pub extra_data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MailboxStoragePayload {
    fn default() -> &'a MailboxStoragePayload {
        <MailboxStoragePayload as ::protobuf::Message>::default_instance()
    }
}

impl MailboxStoragePayload {
    pub fn new() -> MailboxStoragePayload {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.PrefixedSealedAndSignedMessage prefixed_sealed_and_signed_message = 1;

    pub fn get_prefixed_sealed_and_signed_message(&self) -> &PrefixedSealedAndSignedMessage {
        self.prefixed_sealed_and_signed_message
            .as_ref()
            .unwrap_or_else(|| PrefixedSealedAndSignedMessage::default_instance())
    }
    pub fn clear_prefixed_sealed_and_signed_message(&mut self) {
        self.prefixed_sealed_and_signed_message.clear();
    }

    pub fn has_prefixed_sealed_and_signed_message(&self) -> bool {
        self.prefixed_sealed_and_signed_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefixed_sealed_and_signed_message(&mut self, v: PrefixedSealedAndSignedMessage) {
        self.prefixed_sealed_and_signed_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefixed_sealed_and_signed_message(
        &mut self,
    ) -> &mut PrefixedSealedAndSignedMessage {
        if self.prefixed_sealed_and_signed_message.is_none() {
            self.prefixed_sealed_and_signed_message.set_default();
        }
        self.prefixed_sealed_and_signed_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_prefixed_sealed_and_signed_message(&mut self) -> PrefixedSealedAndSignedMessage {
        self.prefixed_sealed_and_signed_message
            .take()
            .unwrap_or_else(|| PrefixedSealedAndSignedMessage::new())
    }

    // bytes sender_pub_key_for_add_operation_bytes = 2;

    pub fn get_sender_pub_key_for_add_operation_bytes(&self) -> &[u8] {
        &self.sender_pub_key_for_add_operation_bytes
    }
    pub fn clear_sender_pub_key_for_add_operation_bytes(&mut self) {
        self.sender_pub_key_for_add_operation_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender_pub_key_for_add_operation_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.sender_pub_key_for_add_operation_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_pub_key_for_add_operation_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sender_pub_key_for_add_operation_bytes
    }

    // Take field
    pub fn take_sender_pub_key_for_add_operation_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(
            &mut self.sender_pub_key_for_add_operation_bytes,
            ::std::vec::Vec::new(),
        )
    }

    // bytes owner_pub_key_bytes = 3;

    pub fn get_owner_pub_key_bytes(&self) -> &[u8] {
        &self.owner_pub_key_bytes
    }
    pub fn clear_owner_pub_key_bytes(&mut self) {
        self.owner_pub_key_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_pub_key_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_pub_key_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_pub_key_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_pub_key_bytes
    }

    // Take field
    pub fn take_owner_pub_key_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_pub_key_bytes, ::std::vec::Vec::new())
    }

    // repeated .io.bisq.protobuffer.MailboxStoragePayload.ExtraDataEntry extra_data = 4;

    pub fn get_extra_data(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.extra_data
    }
    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_data(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ) {
        self.extra_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_data(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.extra_data
    }

    // Take field
    pub fn take_extra_data(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.extra_data, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for MailboxStoragePayload {
    fn is_initialized(&self) -> bool {
        for v in &self.prefixed_sealed_and_signed_message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.prefixed_sealed_and_signed_message,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.sender_pub_key_for_add_operation_bytes,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.owner_pub_key_bytes,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeString,
                    >(wire_type, is, &mut self.extra_data)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.prefixed_sealed_and_signed_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.sender_pub_key_for_add_operation_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.sender_pub_key_for_add_operation_bytes);
        }
        if !self.owner_pub_key_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.owner_pub_key_bytes);
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(4, &self.extra_data);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.prefixed_sealed_and_signed_message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.sender_pub_key_for_add_operation_bytes.is_empty() {
            os.write_bytes(2, &self.sender_pub_key_for_add_operation_bytes)?;
        }
        if !self.owner_pub_key_bytes.is_empty() {
            os.write_bytes(3, &self.owner_pub_key_bytes)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(4, &self.extra_data, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MailboxStoragePayload {
        MailboxStoragePayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PrefixedSealedAndSignedMessage>,
                    >(
                        "prefixed_sealed_and_signed_message",
                        |m: &MailboxStoragePayload| &m.prefixed_sealed_and_signed_message,
                        |m: &mut MailboxStoragePayload| &mut m.prefixed_sealed_and_signed_message,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "sender_pub_key_for_add_operation_bytes",
                    |m: &MailboxStoragePayload| &m.sender_pub_key_for_add_operation_bytes,
                    |m: &mut MailboxStoragePayload| &mut m.sender_pub_key_for_add_operation_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "owner_pub_key_bytes",
                    |m: &MailboxStoragePayload| &m.owner_pub_key_bytes,
                    |m: &mut MailboxStoragePayload| &mut m.owner_pub_key_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "extra_data",
                    |m: &MailboxStoragePayload| &m.extra_data,
                    |m: &mut MailboxStoragePayload| &mut m.extra_data,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MailboxStoragePayload>(
                    "MailboxStoragePayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MailboxStoragePayload {
        static mut instance: ::protobuf::lazy::Lazy<MailboxStoragePayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const MailboxStoragePayload,
            };
        unsafe { instance.get(MailboxStoragePayload::new) }
    }
}

impl ::protobuf::Clear for MailboxStoragePayload {
    fn clear(&mut self) {
        self.prefixed_sealed_and_signed_message.clear();
        self.sender_pub_key_for_add_operation_bytes.clear();
        self.owner_pub_key_bytes.clear();
        self.extra_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MailboxStoragePayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MailboxStoragePayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct OfferPayload {
    // message fields
    pub id: ::std::string::String,
    pub date: i64,
    pub owner_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub direction: OfferPayload_Direction,
    pub price: i64,
    pub market_price_margin: f64,
    pub use_market_based_price: bool,
    pub amount: i64,
    pub min_amount: i64,
    pub base_currency_code: ::std::string::String,
    pub counter_currency_code: ::std::string::String,
    pub arbitrator_node_addresses: ::protobuf::RepeatedField<NodeAddress>,
    pub mediator_node_addresses: ::protobuf::RepeatedField<NodeAddress>,
    pub payment_method_id: ::std::string::String,
    pub maker_payment_account_id: ::std::string::String,
    pub offer_fee_payment_tx_id: ::std::string::String,
    pub country_code: ::std::string::String,
    pub accepted_country_codes: ::protobuf::RepeatedField<::std::string::String>,
    pub bank_id: ::std::string::String,
    pub accepted_bank_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub version_nr: ::std::string::String,
    pub block_height_at_offer_creation: i64,
    pub tx_fee: i64,
    pub maker_fee: i64,
    pub is_currency_for_maker_fee_btc: bool,
    pub buyer_security_deposit: i64,
    pub seller_security_deposit: i64,
    pub max_trade_limit: i64,
    pub max_trade_period: i64,
    pub use_auto_close: bool,
    pub use_re_open_after_auto_close: bool,
    pub lower_close_price: i64,
    pub upper_close_price: i64,
    pub is_private_offer: bool,
    pub hash_of_challenge: ::std::string::String,
    pub extra_data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub protocol_version: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OfferPayload {
    fn default() -> &'a OfferPayload {
        <OfferPayload as ::protobuf::Message>::default_instance()
    }
}

impl OfferPayload {
    pub fn new() -> OfferPayload {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // int64 date = 2;

    pub fn get_date(&self) -> i64 {
        self.date
    }
    pub fn clear_date(&mut self) {
        self.date = 0;
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: i64) {
        self.date = v;
    }

    // .io.bisq.protobuffer.NodeAddress owner_node_address = 3;

    pub fn get_owner_node_address(&self) -> &NodeAddress {
        self.owner_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_owner_node_address(&mut self) {
        self.owner_node_address.clear();
    }

    pub fn has_owner_node_address(&self) -> bool {
        self.owner_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_node_address(&mut self, v: NodeAddress) {
        self.owner_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_node_address(&mut self) -> &mut NodeAddress {
        if self.owner_node_address.is_none() {
            self.owner_node_address.set_default();
        }
        self.owner_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner_node_address(&mut self) -> NodeAddress {
        self.owner_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // .io.bisq.protobuffer.PubKeyRing pub_key_ring = 4;

    pub fn get_pub_key_ring(&self) -> &PubKeyRing {
        self.pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_pub_key_ring(&mut self) {
        self.pub_key_ring.clear();
    }

    pub fn has_pub_key_ring(&self) -> bool {
        self.pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pub_key_ring(&mut self, v: PubKeyRing) {
        self.pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.pub_key_ring.is_none() {
            self.pub_key_ring.set_default();
        }
        self.pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_pub_key_ring(&mut self) -> PubKeyRing {
        self.pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // .io.bisq.protobuffer.OfferPayload.Direction direction = 5;

    pub fn get_direction(&self) -> OfferPayload_Direction {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = OfferPayload_Direction::PB_ERROR;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: OfferPayload_Direction) {
        self.direction = v;
    }

    // int64 price = 6;

    pub fn get_price(&self) -> i64 {
        self.price
    }
    pub fn clear_price(&mut self) {
        self.price = 0;
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: i64) {
        self.price = v;
    }

    // double market_price_margin = 7;

    pub fn get_market_price_margin(&self) -> f64 {
        self.market_price_margin
    }
    pub fn clear_market_price_margin(&mut self) {
        self.market_price_margin = 0.;
    }

    // Param is passed by value, moved
    pub fn set_market_price_margin(&mut self, v: f64) {
        self.market_price_margin = v;
    }

    // bool use_market_based_price = 8;

    pub fn get_use_market_based_price(&self) -> bool {
        self.use_market_based_price
    }
    pub fn clear_use_market_based_price(&mut self) {
        self.use_market_based_price = false;
    }

    // Param is passed by value, moved
    pub fn set_use_market_based_price(&mut self, v: bool) {
        self.use_market_based_price = v;
    }

    // int64 amount = 9;

    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }

    // int64 min_amount = 10;

    pub fn get_min_amount(&self) -> i64 {
        self.min_amount
    }
    pub fn clear_min_amount(&mut self) {
        self.min_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_amount(&mut self, v: i64) {
        self.min_amount = v;
    }

    // string base_currency_code = 11;

    pub fn get_base_currency_code(&self) -> &str {
        &self.base_currency_code
    }
    pub fn clear_base_currency_code(&mut self) {
        self.base_currency_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_currency_code(&mut self, v: ::std::string::String) {
        self.base_currency_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_currency_code(&mut self) -> &mut ::std::string::String {
        &mut self.base_currency_code
    }

    // Take field
    pub fn take_base_currency_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base_currency_code, ::std::string::String::new())
    }

    // string counter_currency_code = 12;

    pub fn get_counter_currency_code(&self) -> &str {
        &self.counter_currency_code
    }
    pub fn clear_counter_currency_code(&mut self) {
        self.counter_currency_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_counter_currency_code(&mut self, v: ::std::string::String) {
        self.counter_currency_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counter_currency_code(&mut self) -> &mut ::std::string::String {
        &mut self.counter_currency_code
    }

    // Take field
    pub fn take_counter_currency_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.counter_currency_code,
            ::std::string::String::new(),
        )
    }

    // repeated .io.bisq.protobuffer.NodeAddress arbitrator_node_addresses = 13;

    pub fn get_arbitrator_node_addresses(&self) -> &[NodeAddress] {
        &self.arbitrator_node_addresses
    }
    pub fn clear_arbitrator_node_addresses(&mut self) {
        self.arbitrator_node_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_arbitrator_node_addresses(&mut self, v: ::protobuf::RepeatedField<NodeAddress>) {
        self.arbitrator_node_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arbitrator_node_addresses(&mut self) -> &mut ::protobuf::RepeatedField<NodeAddress> {
        &mut self.arbitrator_node_addresses
    }

    // Take field
    pub fn take_arbitrator_node_addresses(&mut self) -> ::protobuf::RepeatedField<NodeAddress> {
        ::std::mem::replace(
            &mut self.arbitrator_node_addresses,
            ::protobuf::RepeatedField::new(),
        )
    }

    // repeated .io.bisq.protobuffer.NodeAddress mediator_node_addresses = 14;

    pub fn get_mediator_node_addresses(&self) -> &[NodeAddress] {
        &self.mediator_node_addresses
    }
    pub fn clear_mediator_node_addresses(&mut self) {
        self.mediator_node_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_mediator_node_addresses(&mut self, v: ::protobuf::RepeatedField<NodeAddress>) {
        self.mediator_node_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mediator_node_addresses(&mut self) -> &mut ::protobuf::RepeatedField<NodeAddress> {
        &mut self.mediator_node_addresses
    }

    // Take field
    pub fn take_mediator_node_addresses(&mut self) -> ::protobuf::RepeatedField<NodeAddress> {
        ::std::mem::replace(
            &mut self.mediator_node_addresses,
            ::protobuf::RepeatedField::new(),
        )
    }

    // string payment_method_id = 15;

    pub fn get_payment_method_id(&self) -> &str {
        &self.payment_method_id
    }
    pub fn clear_payment_method_id(&mut self) {
        self.payment_method_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_method_id(&mut self, v: ::std::string::String) {
        self.payment_method_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_method_id(&mut self) -> &mut ::std::string::String {
        &mut self.payment_method_id
    }

    // Take field
    pub fn take_payment_method_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_method_id, ::std::string::String::new())
    }

    // string maker_payment_account_id = 16;

    pub fn get_maker_payment_account_id(&self) -> &str {
        &self.maker_payment_account_id
    }
    pub fn clear_maker_payment_account_id(&mut self) {
        self.maker_payment_account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_payment_account_id(&mut self, v: ::std::string::String) {
        self.maker_payment_account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_payment_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.maker_payment_account_id
    }

    // Take field
    pub fn take_maker_payment_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.maker_payment_account_id,
            ::std::string::String::new(),
        )
    }

    // string offer_fee_payment_tx_id = 17;

    pub fn get_offer_fee_payment_tx_id(&self) -> &str {
        &self.offer_fee_payment_tx_id
    }
    pub fn clear_offer_fee_payment_tx_id(&mut self) {
        self.offer_fee_payment_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_offer_fee_payment_tx_id(&mut self, v: ::std::string::String) {
        self.offer_fee_payment_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer_fee_payment_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.offer_fee_payment_tx_id
    }

    // Take field
    pub fn take_offer_fee_payment_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.offer_fee_payment_tx_id,
            ::std::string::String::new(),
        )
    }

    // string country_code = 18;

    pub fn get_country_code(&self) -> &str {
        &self.country_code
    }
    pub fn clear_country_code(&mut self) {
        self.country_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        &mut self.country_code
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.country_code, ::std::string::String::new())
    }

    // repeated string accepted_country_codes = 19;

    pub fn get_accepted_country_codes(&self) -> &[::std::string::String] {
        &self.accepted_country_codes
    }
    pub fn clear_accepted_country_codes(&mut self) {
        self.accepted_country_codes.clear();
    }

    // Param is passed by value, moved
    pub fn set_accepted_country_codes(
        &mut self,
        v: ::protobuf::RepeatedField<::std::string::String>,
    ) {
        self.accepted_country_codes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accepted_country_codes(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accepted_country_codes
    }

    // Take field
    pub fn take_accepted_country_codes(
        &mut self,
    ) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(
            &mut self.accepted_country_codes,
            ::protobuf::RepeatedField::new(),
        )
    }

    // string bank_id = 20;

    pub fn get_bank_id(&self) -> &str {
        &self.bank_id
    }
    pub fn clear_bank_id(&mut self) {
        self.bank_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_bank_id(&mut self, v: ::std::string::String) {
        self.bank_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bank_id(&mut self) -> &mut ::std::string::String {
        &mut self.bank_id
    }

    // Take field
    pub fn take_bank_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bank_id, ::std::string::String::new())
    }

    // repeated string accepted_bank_ids = 21;

    pub fn get_accepted_bank_ids(&self) -> &[::std::string::String] {
        &self.accepted_bank_ids
    }
    pub fn clear_accepted_bank_ids(&mut self) {
        self.accepted_bank_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_accepted_bank_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.accepted_bank_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accepted_bank_ids(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accepted_bank_ids
    }

    // Take field
    pub fn take_accepted_bank_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(
            &mut self.accepted_bank_ids,
            ::protobuf::RepeatedField::new(),
        )
    }

    // string version_nr = 22;

    pub fn get_version_nr(&self) -> &str {
        &self.version_nr
    }
    pub fn clear_version_nr(&mut self) {
        self.version_nr.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_nr(&mut self, v: ::std::string::String) {
        self.version_nr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_nr(&mut self) -> &mut ::std::string::String {
        &mut self.version_nr
    }

    // Take field
    pub fn take_version_nr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_nr, ::std::string::String::new())
    }

    // int64 block_height_at_offer_creation = 23;

    pub fn get_block_height_at_offer_creation(&self) -> i64 {
        self.block_height_at_offer_creation
    }
    pub fn clear_block_height_at_offer_creation(&mut self) {
        self.block_height_at_offer_creation = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height_at_offer_creation(&mut self, v: i64) {
        self.block_height_at_offer_creation = v;
    }

    // int64 tx_fee = 24;

    pub fn get_tx_fee(&self) -> i64 {
        self.tx_fee
    }
    pub fn clear_tx_fee(&mut self) {
        self.tx_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_fee(&mut self, v: i64) {
        self.tx_fee = v;
    }

    // int64 maker_fee = 25;

    pub fn get_maker_fee(&self) -> i64 {
        self.maker_fee
    }
    pub fn clear_maker_fee(&mut self) {
        self.maker_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_maker_fee(&mut self, v: i64) {
        self.maker_fee = v;
    }

    // bool is_currency_for_maker_fee_btc = 26;

    pub fn get_is_currency_for_maker_fee_btc(&self) -> bool {
        self.is_currency_for_maker_fee_btc
    }
    pub fn clear_is_currency_for_maker_fee_btc(&mut self) {
        self.is_currency_for_maker_fee_btc = false;
    }

    // Param is passed by value, moved
    pub fn set_is_currency_for_maker_fee_btc(&mut self, v: bool) {
        self.is_currency_for_maker_fee_btc = v;
    }

    // int64 buyer_security_deposit = 27;

    pub fn get_buyer_security_deposit(&self) -> i64 {
        self.buyer_security_deposit
    }
    pub fn clear_buyer_security_deposit(&mut self) {
        self.buyer_security_deposit = 0;
    }

    // Param is passed by value, moved
    pub fn set_buyer_security_deposit(&mut self, v: i64) {
        self.buyer_security_deposit = v;
    }

    // int64 seller_security_deposit = 28;

    pub fn get_seller_security_deposit(&self) -> i64 {
        self.seller_security_deposit
    }
    pub fn clear_seller_security_deposit(&mut self) {
        self.seller_security_deposit = 0;
    }

    // Param is passed by value, moved
    pub fn set_seller_security_deposit(&mut self, v: i64) {
        self.seller_security_deposit = v;
    }

    // int64 max_trade_limit = 29;

    pub fn get_max_trade_limit(&self) -> i64 {
        self.max_trade_limit
    }
    pub fn clear_max_trade_limit(&mut self) {
        self.max_trade_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_trade_limit(&mut self, v: i64) {
        self.max_trade_limit = v;
    }

    // int64 max_trade_period = 30;

    pub fn get_max_trade_period(&self) -> i64 {
        self.max_trade_period
    }
    pub fn clear_max_trade_period(&mut self) {
        self.max_trade_period = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_trade_period(&mut self, v: i64) {
        self.max_trade_period = v;
    }

    // bool use_auto_close = 31;

    pub fn get_use_auto_close(&self) -> bool {
        self.use_auto_close
    }
    pub fn clear_use_auto_close(&mut self) {
        self.use_auto_close = false;
    }

    // Param is passed by value, moved
    pub fn set_use_auto_close(&mut self, v: bool) {
        self.use_auto_close = v;
    }

    // bool use_re_open_after_auto_close = 32;

    pub fn get_use_re_open_after_auto_close(&self) -> bool {
        self.use_re_open_after_auto_close
    }
    pub fn clear_use_re_open_after_auto_close(&mut self) {
        self.use_re_open_after_auto_close = false;
    }

    // Param is passed by value, moved
    pub fn set_use_re_open_after_auto_close(&mut self, v: bool) {
        self.use_re_open_after_auto_close = v;
    }

    // int64 lower_close_price = 33;

    pub fn get_lower_close_price(&self) -> i64 {
        self.lower_close_price
    }
    pub fn clear_lower_close_price(&mut self) {
        self.lower_close_price = 0;
    }

    // Param is passed by value, moved
    pub fn set_lower_close_price(&mut self, v: i64) {
        self.lower_close_price = v;
    }

    // int64 upper_close_price = 34;

    pub fn get_upper_close_price(&self) -> i64 {
        self.upper_close_price
    }
    pub fn clear_upper_close_price(&mut self) {
        self.upper_close_price = 0;
    }

    // Param is passed by value, moved
    pub fn set_upper_close_price(&mut self, v: i64) {
        self.upper_close_price = v;
    }

    // bool is_private_offer = 35;

    pub fn get_is_private_offer(&self) -> bool {
        self.is_private_offer
    }
    pub fn clear_is_private_offer(&mut self) {
        self.is_private_offer = false;
    }

    // Param is passed by value, moved
    pub fn set_is_private_offer(&mut self, v: bool) {
        self.is_private_offer = v;
    }

    // string hash_of_challenge = 36;

    pub fn get_hash_of_challenge(&self) -> &str {
        &self.hash_of_challenge
    }
    pub fn clear_hash_of_challenge(&mut self) {
        self.hash_of_challenge.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash_of_challenge(&mut self, v: ::std::string::String) {
        self.hash_of_challenge = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash_of_challenge(&mut self) -> &mut ::std::string::String {
        &mut self.hash_of_challenge
    }

    // Take field
    pub fn take_hash_of_challenge(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash_of_challenge, ::std::string::String::new())
    }

    // repeated .io.bisq.protobuffer.OfferPayload.ExtraDataEntry extra_data = 37;

    pub fn get_extra_data(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.extra_data
    }
    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_data(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ) {
        self.extra_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_data(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.extra_data
    }

    // Take field
    pub fn take_extra_data(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.extra_data, ::std::collections::HashMap::new())
    }

    // int32 protocol_version = 38;

    pub fn get_protocol_version(&self) -> i32 {
        self.protocol_version
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: i32) {
        self.protocol_version = v;
    }
}

impl ::protobuf::Message for OfferPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.owner_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.arbitrator_node_addresses {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.mediator_node_addresses {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.date = tmp;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.owner_node_address,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.pub_key_ring,
                    )?;
                }
                5 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.direction,
                    5,
                    &mut self.unknown_fields,
                )?,
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.price = tmp;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.market_price_margin = tmp;
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.use_market_based_price = tmp;
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.min_amount = tmp;
                }
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.base_currency_code,
                    )?;
                }
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.counter_currency_code,
                    )?;
                }
                13 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.arbitrator_node_addresses,
                    )?;
                }
                14 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.mediator_node_addresses,
                    )?;
                }
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.payment_method_id,
                    )?;
                }
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.maker_payment_account_id,
                    )?;
                }
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.offer_fee_payment_tx_id,
                    )?;
                }
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.country_code,
                    )?;
                }
                19 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.accepted_country_codes,
                    )?;
                }
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bank_id,
                    )?;
                }
                21 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.accepted_bank_ids,
                    )?;
                }
                22 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.version_nr,
                    )?;
                }
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.block_height_at_offer_creation = tmp;
                }
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.tx_fee = tmp;
                }
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.maker_fee = tmp;
                }
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_currency_for_maker_fee_btc = tmp;
                }
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.buyer_security_deposit = tmp;
                }
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.seller_security_deposit = tmp;
                }
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.max_trade_limit = tmp;
                }
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.max_trade_period = tmp;
                }
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.use_auto_close = tmp;
                }
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.use_re_open_after_auto_close = tmp;
                }
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.lower_close_price = tmp;
                }
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.upper_close_price = tmp;
                }
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_private_offer = tmp;
                }
                36 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.hash_of_challenge,
                    )?;
                }
                37 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeString,
                    >(wire_type, is, &mut self.extra_data)?;
                }
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.protocol_version = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.date != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.date, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.owner_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.direction != OfferPayload_Direction::PB_ERROR {
            my_size += ::protobuf::rt::enum_size(5, self.direction);
        }
        if self.price != 0 {
            my_size +=
                ::protobuf::rt::value_size(6, self.price, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.market_price_margin != 0. {
            my_size += 9;
        }
        if self.use_market_based_price != false {
            my_size += 2;
        }
        if self.amount != 0 {
            my_size +=
                ::protobuf::rt::value_size(9, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_amount != 0 {
            my_size += ::protobuf::rt::value_size(
                10,
                self.min_amount,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.base_currency_code.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.base_currency_code);
        }
        if !self.counter_currency_code.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.counter_currency_code);
        }
        for value in &self.arbitrator_node_addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.mediator_node_addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.payment_method_id.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.payment_method_id);
        }
        if !self.maker_payment_account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.maker_payment_account_id);
        }
        if !self.offer_fee_payment_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.offer_fee_payment_tx_id);
        }
        if !self.country_code.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.country_code);
        }
        for value in &self.accepted_country_codes {
            my_size += ::protobuf::rt::string_size(19, &value);
        }
        if !self.bank_id.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.bank_id);
        }
        for value in &self.accepted_bank_ids {
            my_size += ::protobuf::rt::string_size(21, &value);
        }
        if !self.version_nr.is_empty() {
            my_size += ::protobuf::rt::string_size(22, &self.version_nr);
        }
        if self.block_height_at_offer_creation != 0 {
            my_size += ::protobuf::rt::value_size(
                23,
                self.block_height_at_offer_creation,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.tx_fee != 0 {
            my_size += ::protobuf::rt::value_size(
                24,
                self.tx_fee,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.maker_fee != 0 {
            my_size += ::protobuf::rt::value_size(
                25,
                self.maker_fee,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.is_currency_for_maker_fee_btc != false {
            my_size += 3;
        }
        if self.buyer_security_deposit != 0 {
            my_size += ::protobuf::rt::value_size(
                27,
                self.buyer_security_deposit,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.seller_security_deposit != 0 {
            my_size += ::protobuf::rt::value_size(
                28,
                self.seller_security_deposit,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.max_trade_limit != 0 {
            my_size += ::protobuf::rt::value_size(
                29,
                self.max_trade_limit,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.max_trade_period != 0 {
            my_size += ::protobuf::rt::value_size(
                30,
                self.max_trade_period,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.use_auto_close != false {
            my_size += 3;
        }
        if self.use_re_open_after_auto_close != false {
            my_size += 3;
        }
        if self.lower_close_price != 0 {
            my_size += ::protobuf::rt::value_size(
                33,
                self.lower_close_price,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.upper_close_price != 0 {
            my_size += ::protobuf::rt::value_size(
                34,
                self.upper_close_price,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.is_private_offer != false {
            my_size += 3;
        }
        if !self.hash_of_challenge.is_empty() {
            my_size += ::protobuf::rt::string_size(36, &self.hash_of_challenge);
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(37, &self.extra_data);
        if self.protocol_version != 0 {
            my_size += ::protobuf::rt::value_size(
                38,
                self.protocol_version,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.date != 0 {
            os.write_int64(2, self.date)?;
        }
        if let Some(ref v) = self.owner_node_address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pub_key_ring.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.direction != OfferPayload_Direction::PB_ERROR {
            os.write_enum(5, self.direction.value())?;
        }
        if self.price != 0 {
            os.write_int64(6, self.price)?;
        }
        if self.market_price_margin != 0. {
            os.write_double(7, self.market_price_margin)?;
        }
        if self.use_market_based_price != false {
            os.write_bool(8, self.use_market_based_price)?;
        }
        if self.amount != 0 {
            os.write_int64(9, self.amount)?;
        }
        if self.min_amount != 0 {
            os.write_int64(10, self.min_amount)?;
        }
        if !self.base_currency_code.is_empty() {
            os.write_string(11, &self.base_currency_code)?;
        }
        if !self.counter_currency_code.is_empty() {
            os.write_string(12, &self.counter_currency_code)?;
        }
        for v in &self.arbitrator_node_addresses {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.mediator_node_addresses {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.payment_method_id.is_empty() {
            os.write_string(15, &self.payment_method_id)?;
        }
        if !self.maker_payment_account_id.is_empty() {
            os.write_string(16, &self.maker_payment_account_id)?;
        }
        if !self.offer_fee_payment_tx_id.is_empty() {
            os.write_string(17, &self.offer_fee_payment_tx_id)?;
        }
        if !self.country_code.is_empty() {
            os.write_string(18, &self.country_code)?;
        }
        for v in &self.accepted_country_codes {
            os.write_string(19, &v)?;
        }
        if !self.bank_id.is_empty() {
            os.write_string(20, &self.bank_id)?;
        }
        for v in &self.accepted_bank_ids {
            os.write_string(21, &v)?;
        }
        if !self.version_nr.is_empty() {
            os.write_string(22, &self.version_nr)?;
        }
        if self.block_height_at_offer_creation != 0 {
            os.write_int64(23, self.block_height_at_offer_creation)?;
        }
        if self.tx_fee != 0 {
            os.write_int64(24, self.tx_fee)?;
        }
        if self.maker_fee != 0 {
            os.write_int64(25, self.maker_fee)?;
        }
        if self.is_currency_for_maker_fee_btc != false {
            os.write_bool(26, self.is_currency_for_maker_fee_btc)?;
        }
        if self.buyer_security_deposit != 0 {
            os.write_int64(27, self.buyer_security_deposit)?;
        }
        if self.seller_security_deposit != 0 {
            os.write_int64(28, self.seller_security_deposit)?;
        }
        if self.max_trade_limit != 0 {
            os.write_int64(29, self.max_trade_limit)?;
        }
        if self.max_trade_period != 0 {
            os.write_int64(30, self.max_trade_period)?;
        }
        if self.use_auto_close != false {
            os.write_bool(31, self.use_auto_close)?;
        }
        if self.use_re_open_after_auto_close != false {
            os.write_bool(32, self.use_re_open_after_auto_close)?;
        }
        if self.lower_close_price != 0 {
            os.write_int64(33, self.lower_close_price)?;
        }
        if self.upper_close_price != 0 {
            os.write_int64(34, self.upper_close_price)?;
        }
        if self.is_private_offer != false {
            os.write_bool(35, self.is_private_offer)?;
        }
        if !self.hash_of_challenge.is_empty() {
            os.write_string(36, &self.hash_of_challenge)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(37, &self.extra_data, os)?;
        if self.protocol_version != 0 {
            os.write_int32(38, self.protocol_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OfferPayload {
        OfferPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "id",
                    |m: &OfferPayload| &m.id,
                    |m: &mut OfferPayload| &mut m.id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "date",
                    |m: &OfferPayload| &m.date,
                    |m: &mut OfferPayload| &mut m.date,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "owner_node_address",
                        |m: &OfferPayload| &m.owner_node_address,
                        |m: &mut OfferPayload| &mut m.owner_node_address,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "pub_key_ring",
                        |m: &OfferPayload| &m.pub_key_ring,
                        |m: &mut OfferPayload| &mut m.pub_key_ring,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<OfferPayload_Direction>,
                >(
                    "direction",
                    |m: &OfferPayload| &m.direction,
                    |m: &mut OfferPayload| &mut m.direction,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "price",
                    |m: &OfferPayload| &m.price,
                    |m: &mut OfferPayload| &mut m.price,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "market_price_margin",
                    |m: &OfferPayload| &m.market_price_margin,
                    |m: &mut OfferPayload| &mut m.market_price_margin,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "use_market_based_price",
                    |m: &OfferPayload| &m.use_market_based_price,
                    |m: &mut OfferPayload| &mut m.use_market_based_price,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "amount",
                    |m: &OfferPayload| &m.amount,
                    |m: &mut OfferPayload| &mut m.amount,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "min_amount",
                    |m: &OfferPayload| &m.min_amount,
                    |m: &mut OfferPayload| &mut m.min_amount,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "base_currency_code",
                    |m: &OfferPayload| &m.base_currency_code,
                    |m: &mut OfferPayload| &mut m.base_currency_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "counter_currency_code",
                    |m: &OfferPayload| &m.counter_currency_code,
                    |m: &mut OfferPayload| &mut m.counter_currency_code,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "arbitrator_node_addresses",
                        |m: &OfferPayload| &m.arbitrator_node_addresses,
                        |m: &mut OfferPayload| &mut m.arbitrator_node_addresses,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "mediator_node_addresses",
                        |m: &OfferPayload| &m.mediator_node_addresses,
                        |m: &mut OfferPayload| &mut m.mediator_node_addresses,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "payment_method_id",
                    |m: &OfferPayload| &m.payment_method_id,
                    |m: &mut OfferPayload| &mut m.payment_method_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "maker_payment_account_id",
                    |m: &OfferPayload| &m.maker_payment_account_id,
                    |m: &mut OfferPayload| &mut m.maker_payment_account_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "offer_fee_payment_tx_id",
                    |m: &OfferPayload| &m.offer_fee_payment_tx_id,
                    |m: &mut OfferPayload| &mut m.offer_fee_payment_tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "country_code",
                    |m: &OfferPayload| &m.country_code,
                    |m: &mut OfferPayload| &mut m.country_code,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "accepted_country_codes",
                        |m: &OfferPayload| &m.accepted_country_codes,
                        |m: &mut OfferPayload| &mut m.accepted_country_codes,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bank_id",
                    |m: &OfferPayload| &m.bank_id,
                    |m: &mut OfferPayload| &mut m.bank_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "accepted_bank_ids",
                        |m: &OfferPayload| &m.accepted_bank_ids,
                        |m: &mut OfferPayload| &mut m.accepted_bank_ids,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "version_nr",
                    |m: &OfferPayload| &m.version_nr,
                    |m: &mut OfferPayload| &mut m.version_nr,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "block_height_at_offer_creation",
                    |m: &OfferPayload| &m.block_height_at_offer_creation,
                    |m: &mut OfferPayload| &mut m.block_height_at_offer_creation,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "tx_fee",
                    |m: &OfferPayload| &m.tx_fee,
                    |m: &mut OfferPayload| &mut m.tx_fee,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "maker_fee",
                    |m: &OfferPayload| &m.maker_fee,
                    |m: &mut OfferPayload| &mut m.maker_fee,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_currency_for_maker_fee_btc",
                    |m: &OfferPayload| &m.is_currency_for_maker_fee_btc,
                    |m: &mut OfferPayload| &mut m.is_currency_for_maker_fee_btc,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "buyer_security_deposit",
                    |m: &OfferPayload| &m.buyer_security_deposit,
                    |m: &mut OfferPayload| &mut m.buyer_security_deposit,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "seller_security_deposit",
                    |m: &OfferPayload| &m.seller_security_deposit,
                    |m: &mut OfferPayload| &mut m.seller_security_deposit,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "max_trade_limit",
                    |m: &OfferPayload| &m.max_trade_limit,
                    |m: &mut OfferPayload| &mut m.max_trade_limit,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "max_trade_period",
                    |m: &OfferPayload| &m.max_trade_period,
                    |m: &mut OfferPayload| &mut m.max_trade_period,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "use_auto_close",
                    |m: &OfferPayload| &m.use_auto_close,
                    |m: &mut OfferPayload| &mut m.use_auto_close,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "use_re_open_after_auto_close",
                    |m: &OfferPayload| &m.use_re_open_after_auto_close,
                    |m: &mut OfferPayload| &mut m.use_re_open_after_auto_close,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "lower_close_price",
                    |m: &OfferPayload| &m.lower_close_price,
                    |m: &mut OfferPayload| &mut m.lower_close_price,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "upper_close_price",
                    |m: &OfferPayload| &m.upper_close_price,
                    |m: &mut OfferPayload| &mut m.upper_close_price,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_private_offer",
                    |m: &OfferPayload| &m.is_private_offer,
                    |m: &mut OfferPayload| &mut m.is_private_offer,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "hash_of_challenge",
                    |m: &OfferPayload| &m.hash_of_challenge,
                    |m: &mut OfferPayload| &mut m.hash_of_challenge,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "extra_data",
                    |m: &OfferPayload| &m.extra_data,
                    |m: &mut OfferPayload| &mut m.extra_data,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "protocol_version",
                    |m: &OfferPayload| &m.protocol_version,
                    |m: &mut OfferPayload| &mut m.protocol_version,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OfferPayload>(
                    "OfferPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static OfferPayload {
        static mut instance: ::protobuf::lazy::Lazy<OfferPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OfferPayload,
        };
        unsafe { instance.get(OfferPayload::new) }
    }
}

impl ::protobuf::Clear for OfferPayload {
    fn clear(&mut self) {
        self.id.clear();
        self.date = 0;
        self.owner_node_address.clear();
        self.pub_key_ring.clear();
        self.direction = OfferPayload_Direction::PB_ERROR;
        self.price = 0;
        self.market_price_margin = 0.;
        self.use_market_based_price = false;
        self.amount = 0;
        self.min_amount = 0;
        self.base_currency_code.clear();
        self.counter_currency_code.clear();
        self.arbitrator_node_addresses.clear();
        self.mediator_node_addresses.clear();
        self.payment_method_id.clear();
        self.maker_payment_account_id.clear();
        self.offer_fee_payment_tx_id.clear();
        self.country_code.clear();
        self.accepted_country_codes.clear();
        self.bank_id.clear();
        self.accepted_bank_ids.clear();
        self.version_nr.clear();
        self.block_height_at_offer_creation = 0;
        self.tx_fee = 0;
        self.maker_fee = 0;
        self.is_currency_for_maker_fee_btc = false;
        self.buyer_security_deposit = 0;
        self.seller_security_deposit = 0;
        self.max_trade_limit = 0;
        self.max_trade_period = 0;
        self.use_auto_close = false;
        self.use_re_open_after_auto_close = false;
        self.lower_close_price = 0;
        self.upper_close_price = 0;
        self.is_private_offer = false;
        self.hash_of_challenge.clear();
        self.extra_data.clear();
        self.protocol_version = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OfferPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OfferPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum OfferPayload_Direction {
    PB_ERROR = 0,
    BUY = 1,
    SELL = 2,
}

impl ::protobuf::ProtobufEnum for OfferPayload_Direction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OfferPayload_Direction> {
        match value {
            0 => ::std::option::Option::Some(OfferPayload_Direction::PB_ERROR),
            1 => ::std::option::Option::Some(OfferPayload_Direction::BUY),
            2 => ::std::option::Option::Some(OfferPayload_Direction::SELL),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OfferPayload_Direction] = &[
            OfferPayload_Direction::PB_ERROR,
            OfferPayload_Direction::BUY,
            OfferPayload_Direction::SELL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new(
                    "OfferPayload_Direction",
                    file_descriptor_proto(),
                )
            })
        }
    }
}

impl ::std::marker::Copy for OfferPayload_Direction {}

impl ::std::default::Default for OfferPayload_Direction {
    fn default() -> Self {
        OfferPayload_Direction::PB_ERROR
    }
}

impl ::protobuf::reflect::ProtobufValue for OfferPayload_Direction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct AccountAgeWitness {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub date: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountAgeWitness {
    fn default() -> &'a AccountAgeWitness {
        <AccountAgeWitness as ::protobuf::Message>::default_instance()
    }
}

impl AccountAgeWitness {
    pub fn new() -> AccountAgeWitness {
        ::std::default::Default::default()
    }

    // bytes hash = 1;

    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // int64 date = 2;

    pub fn get_date(&self) -> i64 {
        self.date
    }
    pub fn clear_date(&mut self) {
        self.date = 0;
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: i64) {
        self.date = v;
    }
}

impl ::protobuf::Message for AccountAgeWitness {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.date = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if self.date != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.date, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if self.date != 0 {
            os.write_int64(2, self.date)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountAgeWitness {
        AccountAgeWitness::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "hash",
                    |m: &AccountAgeWitness| &m.hash,
                    |m: &mut AccountAgeWitness| &mut m.hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "date",
                    |m: &AccountAgeWitness| &m.date,
                    |m: &mut AccountAgeWitness| &mut m.date,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountAgeWitness>(
                    "AccountAgeWitness",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static AccountAgeWitness {
        static mut instance: ::protobuf::lazy::Lazy<AccountAgeWitness> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountAgeWitness,
        };
        unsafe { instance.get(AccountAgeWitness::new) }
    }
}

impl ::protobuf::Clear for AccountAgeWitness {
    fn clear(&mut self) {
        self.hash.clear();
        self.date = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountAgeWitness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountAgeWitness {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct SignedWitness {
    // message fields
    pub verification_method: SignedWitness_VerificationMethod,
    pub account_age_witness_hash: ::std::vec::Vec<u8>,
    pub signature: ::std::vec::Vec<u8>,
    pub signer_pub_key: ::std::vec::Vec<u8>,
    pub witness_owner_pub_key: ::std::vec::Vec<u8>,
    pub date: i64,
    pub trade_amount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignedWitness {
    fn default() -> &'a SignedWitness {
        <SignedWitness as ::protobuf::Message>::default_instance()
    }
}

impl SignedWitness {
    pub fn new() -> SignedWitness {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.SignedWitness.VerificationMethod verification_method = 1;

    pub fn get_verification_method(&self) -> SignedWitness_VerificationMethod {
        self.verification_method
    }
    pub fn clear_verification_method(&mut self) {
        self.verification_method = SignedWitness_VerificationMethod::PB_ERROR;
    }

    // Param is passed by value, moved
    pub fn set_verification_method(&mut self, v: SignedWitness_VerificationMethod) {
        self.verification_method = v;
    }

    // bytes account_age_witness_hash = 2;

    pub fn get_account_age_witness_hash(&self) -> &[u8] {
        &self.account_age_witness_hash
    }
    pub fn clear_account_age_witness_hash(&mut self) {
        self.account_age_witness_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_age_witness_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_age_witness_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_age_witness_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_age_witness_hash
    }

    // Take field
    pub fn take_account_age_witness_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account_age_witness_hash, ::std::vec::Vec::new())
    }

    // bytes signature = 3;

    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // bytes signer_pub_key = 4;

    pub fn get_signer_pub_key(&self) -> &[u8] {
        &self.signer_pub_key
    }
    pub fn clear_signer_pub_key(&mut self) {
        self.signer_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.signer_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signer_pub_key
    }

    // Take field
    pub fn take_signer_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signer_pub_key, ::std::vec::Vec::new())
    }

    // bytes witness_owner_pub_key = 5;

    pub fn get_witness_owner_pub_key(&self) -> &[u8] {
        &self.witness_owner_pub_key
    }
    pub fn clear_witness_owner_pub_key(&mut self) {
        self.witness_owner_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_witness_owner_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.witness_owner_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_witness_owner_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.witness_owner_pub_key
    }

    // Take field
    pub fn take_witness_owner_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.witness_owner_pub_key, ::std::vec::Vec::new())
    }

    // int64 date = 6;

    pub fn get_date(&self) -> i64 {
        self.date
    }
    pub fn clear_date(&mut self) {
        self.date = 0;
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: i64) {
        self.date = v;
    }

    // int64 trade_amount = 7;

    pub fn get_trade_amount(&self) -> i64 {
        self.trade_amount
    }
    pub fn clear_trade_amount(&mut self) {
        self.trade_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_amount(&mut self, v: i64) {
        self.trade_amount = v;
    }
}

impl ::protobuf::Message for SignedWitness {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.verification_method,
                    1,
                    &mut self.unknown_fields,
                )?,
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.account_age_witness_hash,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.signature,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.signer_pub_key,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.witness_owner_pub_key,
                    )?;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.date = tmp;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.trade_amount = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.verification_method != SignedWitness_VerificationMethod::PB_ERROR {
            my_size += ::protobuf::rt::enum_size(1, self.verification_method);
        }
        if !self.account_age_witness_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.account_age_witness_hash);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.signature);
        }
        if !self.signer_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.signer_pub_key);
        }
        if !self.witness_owner_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.witness_owner_pub_key);
        }
        if self.date != 0 {
            my_size +=
                ::protobuf::rt::value_size(6, self.date, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.trade_amount != 0 {
            my_size += ::protobuf::rt::value_size(
                7,
                self.trade_amount,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.verification_method != SignedWitness_VerificationMethod::PB_ERROR {
            os.write_enum(1, self.verification_method.value())?;
        }
        if !self.account_age_witness_hash.is_empty() {
            os.write_bytes(2, &self.account_age_witness_hash)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(3, &self.signature)?;
        }
        if !self.signer_pub_key.is_empty() {
            os.write_bytes(4, &self.signer_pub_key)?;
        }
        if !self.witness_owner_pub_key.is_empty() {
            os.write_bytes(5, &self.witness_owner_pub_key)?;
        }
        if self.date != 0 {
            os.write_int64(6, self.date)?;
        }
        if self.trade_amount != 0 {
            os.write_int64(7, self.trade_amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignedWitness {
        SignedWitness::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<SignedWitness_VerificationMethod>,
                >(
                    "verification_method",
                    |m: &SignedWitness| &m.verification_method,
                    |m: &mut SignedWitness| &mut m.verification_method,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "account_age_witness_hash",
                    |m: &SignedWitness| &m.account_age_witness_hash,
                    |m: &mut SignedWitness| &mut m.account_age_witness_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "signature",
                    |m: &SignedWitness| &m.signature,
                    |m: &mut SignedWitness| &mut m.signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "signer_pub_key",
                    |m: &SignedWitness| &m.signer_pub_key,
                    |m: &mut SignedWitness| &mut m.signer_pub_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "witness_owner_pub_key",
                    |m: &SignedWitness| &m.witness_owner_pub_key,
                    |m: &mut SignedWitness| &mut m.witness_owner_pub_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "date",
                    |m: &SignedWitness| &m.date,
                    |m: &mut SignedWitness| &mut m.date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "trade_amount",
                    |m: &SignedWitness| &m.trade_amount,
                    |m: &mut SignedWitness| &mut m.trade_amount,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SignedWitness>(
                    "SignedWitness",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static SignedWitness {
        static mut instance: ::protobuf::lazy::Lazy<SignedWitness> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SignedWitness,
        };
        unsafe { instance.get(SignedWitness::new) }
    }
}

impl ::protobuf::Clear for SignedWitness {
    fn clear(&mut self) {
        self.verification_method = SignedWitness_VerificationMethod::PB_ERROR;
        self.account_age_witness_hash.clear();
        self.signature.clear();
        self.signer_pub_key.clear();
        self.witness_owner_pub_key.clear();
        self.date = 0;
        self.trade_amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedWitness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedWitness {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum SignedWitness_VerificationMethod {
    PB_ERROR = 0,
    ARBITRATOR = 1,
    TRADE = 2,
}

impl ::protobuf::ProtobufEnum for SignedWitness_VerificationMethod {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SignedWitness_VerificationMethod> {
        match value {
            0 => ::std::option::Option::Some(SignedWitness_VerificationMethod::PB_ERROR),
            1 => ::std::option::Option::Some(SignedWitness_VerificationMethod::ARBITRATOR),
            2 => ::std::option::Option::Some(SignedWitness_VerificationMethod::TRADE),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SignedWitness_VerificationMethod] = &[
            SignedWitness_VerificationMethod::PB_ERROR,
            SignedWitness_VerificationMethod::ARBITRATOR,
            SignedWitness_VerificationMethod::TRADE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new(
                    "SignedWitness_VerificationMethod",
                    file_descriptor_proto(),
                )
            })
        }
    }
}

impl ::std::marker::Copy for SignedWitness_VerificationMethod {}

impl ::std::default::Default for SignedWitness_VerificationMethod {
    fn default() -> Self {
        SignedWitness_VerificationMethod::PB_ERROR
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedWitness_VerificationMethod {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Dispute {
    // message fields
    pub trade_id: ::std::string::String,
    pub id: ::std::string::String,
    pub trader_id: i32,
    pub dispute_opener_is_buyer: bool,
    pub dispute_opener_is_maker: bool,
    pub opening_date: i64,
    pub trader_pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub trade_date: i64,
    pub contract: ::protobuf::SingularPtrField<Contract>,
    pub contract_hash: ::std::vec::Vec<u8>,
    pub deposit_tx_serialized: ::std::vec::Vec<u8>,
    pub payout_tx_serialized: ::std::vec::Vec<u8>,
    pub deposit_tx_id: ::std::string::String,
    pub payout_tx_id: ::std::string::String,
    pub contract_as_json: ::std::string::String,
    pub maker_contract_signature: ::std::string::String,
    pub taker_contract_signature: ::std::string::String,
    pub agent_pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub is_support_ticket: bool,
    pub chat_message: ::protobuf::RepeatedField<ChatMessage>,
    pub is_closed: bool,
    pub dispute_result: ::protobuf::SingularPtrField<DisputeResult>,
    pub dispute_payout_tx_id: ::std::string::String,
    pub support_type: SupportType,
    pub mediators_dispute_result: ::std::string::String,
    pub delayed_payout_tx_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Dispute {
    fn default() -> &'a Dispute {
        <Dispute as ::protobuf::Message>::default_instance()
    }
}

impl Dispute {
    pub fn new() -> Dispute {
        ::std::default::Default::default()
    }

    // string trade_id = 1;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // string id = 2;

    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // int32 trader_id = 3;

    pub fn get_trader_id(&self) -> i32 {
        self.trader_id
    }
    pub fn clear_trader_id(&mut self) {
        self.trader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_trader_id(&mut self, v: i32) {
        self.trader_id = v;
    }

    // bool dispute_opener_is_buyer = 4;

    pub fn get_dispute_opener_is_buyer(&self) -> bool {
        self.dispute_opener_is_buyer
    }
    pub fn clear_dispute_opener_is_buyer(&mut self) {
        self.dispute_opener_is_buyer = false;
    }

    // Param is passed by value, moved
    pub fn set_dispute_opener_is_buyer(&mut self, v: bool) {
        self.dispute_opener_is_buyer = v;
    }

    // bool dispute_opener_is_maker = 5;

    pub fn get_dispute_opener_is_maker(&self) -> bool {
        self.dispute_opener_is_maker
    }
    pub fn clear_dispute_opener_is_maker(&mut self) {
        self.dispute_opener_is_maker = false;
    }

    // Param is passed by value, moved
    pub fn set_dispute_opener_is_maker(&mut self, v: bool) {
        self.dispute_opener_is_maker = v;
    }

    // int64 opening_date = 6;

    pub fn get_opening_date(&self) -> i64 {
        self.opening_date
    }
    pub fn clear_opening_date(&mut self) {
        self.opening_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_opening_date(&mut self, v: i64) {
        self.opening_date = v;
    }

    // .io.bisq.protobuffer.PubKeyRing trader_pub_key_ring = 7;

    pub fn get_trader_pub_key_ring(&self) -> &PubKeyRing {
        self.trader_pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_trader_pub_key_ring(&mut self) {
        self.trader_pub_key_ring.clear();
    }

    pub fn has_trader_pub_key_ring(&self) -> bool {
        self.trader_pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trader_pub_key_ring(&mut self, v: PubKeyRing) {
        self.trader_pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trader_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.trader_pub_key_ring.is_none() {
            self.trader_pub_key_ring.set_default();
        }
        self.trader_pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_trader_pub_key_ring(&mut self) -> PubKeyRing {
        self.trader_pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // int64 trade_date = 8;

    pub fn get_trade_date(&self) -> i64 {
        self.trade_date
    }
    pub fn clear_trade_date(&mut self) {
        self.trade_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_date(&mut self, v: i64) {
        self.trade_date = v;
    }

    // .io.bisq.protobuffer.Contract contract = 9;

    pub fn get_contract(&self) -> &Contract {
        self.contract
            .as_ref()
            .unwrap_or_else(|| Contract::default_instance())
    }
    pub fn clear_contract(&mut self) {
        self.contract.clear();
    }

    pub fn has_contract(&self) -> bool {
        self.contract.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract(&mut self, v: Contract) {
        self.contract = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract(&mut self) -> &mut Contract {
        if self.contract.is_none() {
            self.contract.set_default();
        }
        self.contract.as_mut().unwrap()
    }

    // Take field
    pub fn take_contract(&mut self) -> Contract {
        self.contract.take().unwrap_or_else(|| Contract::new())
    }

    // bytes contract_hash = 10;

    pub fn get_contract_hash(&self) -> &[u8] {
        &self.contract_hash
    }
    pub fn clear_contract_hash(&mut self) {
        self.contract_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract_hash
    }

    // Take field
    pub fn take_contract_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract_hash, ::std::vec::Vec::new())
    }

    // bytes deposit_tx_serialized = 11;

    pub fn get_deposit_tx_serialized(&self) -> &[u8] {
        &self.deposit_tx_serialized
    }
    pub fn clear_deposit_tx_serialized(&mut self) {
        self.deposit_tx_serialized.clear();
    }

    // Param is passed by value, moved
    pub fn set_deposit_tx_serialized(&mut self, v: ::std::vec::Vec<u8>) {
        self.deposit_tx_serialized = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deposit_tx_serialized(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.deposit_tx_serialized
    }

    // Take field
    pub fn take_deposit_tx_serialized(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.deposit_tx_serialized, ::std::vec::Vec::new())
    }

    // bytes payout_tx_serialized = 12;

    pub fn get_payout_tx_serialized(&self) -> &[u8] {
        &self.payout_tx_serialized
    }
    pub fn clear_payout_tx_serialized(&mut self) {
        self.payout_tx_serialized.clear();
    }

    // Param is passed by value, moved
    pub fn set_payout_tx_serialized(&mut self, v: ::std::vec::Vec<u8>) {
        self.payout_tx_serialized = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payout_tx_serialized(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payout_tx_serialized
    }

    // Take field
    pub fn take_payout_tx_serialized(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payout_tx_serialized, ::std::vec::Vec::new())
    }

    // string deposit_tx_id = 13;

    pub fn get_deposit_tx_id(&self) -> &str {
        &self.deposit_tx_id
    }
    pub fn clear_deposit_tx_id(&mut self) {
        self.deposit_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_deposit_tx_id(&mut self, v: ::std::string::String) {
        self.deposit_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deposit_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.deposit_tx_id
    }

    // Take field
    pub fn take_deposit_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.deposit_tx_id, ::std::string::String::new())
    }

    // string payout_tx_id = 14;

    pub fn get_payout_tx_id(&self) -> &str {
        &self.payout_tx_id
    }
    pub fn clear_payout_tx_id(&mut self) {
        self.payout_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_payout_tx_id(&mut self, v: ::std::string::String) {
        self.payout_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payout_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.payout_tx_id
    }

    // Take field
    pub fn take_payout_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payout_tx_id, ::std::string::String::new())
    }

    // string contract_as_json = 15;

    pub fn get_contract_as_json(&self) -> &str {
        &self.contract_as_json
    }
    pub fn clear_contract_as_json(&mut self) {
        self.contract_as_json.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_as_json(&mut self, v: ::std::string::String) {
        self.contract_as_json = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_as_json(&mut self) -> &mut ::std::string::String {
        &mut self.contract_as_json
    }

    // Take field
    pub fn take_contract_as_json(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contract_as_json, ::std::string::String::new())
    }

    // string maker_contract_signature = 16;

    pub fn get_maker_contract_signature(&self) -> &str {
        &self.maker_contract_signature
    }
    pub fn clear_maker_contract_signature(&mut self) {
        self.maker_contract_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_contract_signature(&mut self, v: ::std::string::String) {
        self.maker_contract_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_contract_signature(&mut self) -> &mut ::std::string::String {
        &mut self.maker_contract_signature
    }

    // Take field
    pub fn take_maker_contract_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.maker_contract_signature,
            ::std::string::String::new(),
        )
    }

    // string taker_contract_signature = 17;

    pub fn get_taker_contract_signature(&self) -> &str {
        &self.taker_contract_signature
    }
    pub fn clear_taker_contract_signature(&mut self) {
        self.taker_contract_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_contract_signature(&mut self, v: ::std::string::String) {
        self.taker_contract_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_contract_signature(&mut self) -> &mut ::std::string::String {
        &mut self.taker_contract_signature
    }

    // Take field
    pub fn take_taker_contract_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.taker_contract_signature,
            ::std::string::String::new(),
        )
    }

    // .io.bisq.protobuffer.PubKeyRing agent_pub_key_ring = 18;

    pub fn get_agent_pub_key_ring(&self) -> &PubKeyRing {
        self.agent_pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_agent_pub_key_ring(&mut self) {
        self.agent_pub_key_ring.clear();
    }

    pub fn has_agent_pub_key_ring(&self) -> bool {
        self.agent_pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_pub_key_ring(&mut self, v: PubKeyRing) {
        self.agent_pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.agent_pub_key_ring.is_none() {
            self.agent_pub_key_ring.set_default();
        }
        self.agent_pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_pub_key_ring(&mut self) -> PubKeyRing {
        self.agent_pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // bool is_support_ticket = 19;

    pub fn get_is_support_ticket(&self) -> bool {
        self.is_support_ticket
    }
    pub fn clear_is_support_ticket(&mut self) {
        self.is_support_ticket = false;
    }

    // Param is passed by value, moved
    pub fn set_is_support_ticket(&mut self, v: bool) {
        self.is_support_ticket = v;
    }

    // repeated .io.bisq.protobuffer.ChatMessage chat_message = 20;

    pub fn get_chat_message(&self) -> &[ChatMessage] {
        &self.chat_message
    }
    pub fn clear_chat_message(&mut self) {
        self.chat_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_message(&mut self, v: ::protobuf::RepeatedField<ChatMessage>) {
        self.chat_message = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_message(&mut self) -> &mut ::protobuf::RepeatedField<ChatMessage> {
        &mut self.chat_message
    }

    // Take field
    pub fn take_chat_message(&mut self) -> ::protobuf::RepeatedField<ChatMessage> {
        ::std::mem::replace(&mut self.chat_message, ::protobuf::RepeatedField::new())
    }

    // bool is_closed = 21;

    pub fn get_is_closed(&self) -> bool {
        self.is_closed
    }
    pub fn clear_is_closed(&mut self) {
        self.is_closed = false;
    }

    // Param is passed by value, moved
    pub fn set_is_closed(&mut self, v: bool) {
        self.is_closed = v;
    }

    // .io.bisq.protobuffer.DisputeResult dispute_result = 22;

    pub fn get_dispute_result(&self) -> &DisputeResult {
        self.dispute_result
            .as_ref()
            .unwrap_or_else(|| DisputeResult::default_instance())
    }
    pub fn clear_dispute_result(&mut self) {
        self.dispute_result.clear();
    }

    pub fn has_dispute_result(&self) -> bool {
        self.dispute_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dispute_result(&mut self, v: DisputeResult) {
        self.dispute_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dispute_result(&mut self) -> &mut DisputeResult {
        if self.dispute_result.is_none() {
            self.dispute_result.set_default();
        }
        self.dispute_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_dispute_result(&mut self) -> DisputeResult {
        self.dispute_result
            .take()
            .unwrap_or_else(|| DisputeResult::new())
    }

    // string dispute_payout_tx_id = 23;

    pub fn get_dispute_payout_tx_id(&self) -> &str {
        &self.dispute_payout_tx_id
    }
    pub fn clear_dispute_payout_tx_id(&mut self) {
        self.dispute_payout_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dispute_payout_tx_id(&mut self, v: ::std::string::String) {
        self.dispute_payout_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dispute_payout_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.dispute_payout_tx_id
    }

    // Take field
    pub fn take_dispute_payout_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dispute_payout_tx_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.SupportType support_type = 24;

    pub fn get_support_type(&self) -> SupportType {
        self.support_type
    }
    pub fn clear_support_type(&mut self) {
        self.support_type = SupportType::ARBITRATION;
    }

    // Param is passed by value, moved
    pub fn set_support_type(&mut self, v: SupportType) {
        self.support_type = v;
    }

    // string mediators_dispute_result = 25;

    pub fn get_mediators_dispute_result(&self) -> &str {
        &self.mediators_dispute_result
    }
    pub fn clear_mediators_dispute_result(&mut self) {
        self.mediators_dispute_result.clear();
    }

    // Param is passed by value, moved
    pub fn set_mediators_dispute_result(&mut self, v: ::std::string::String) {
        self.mediators_dispute_result = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediators_dispute_result(&mut self) -> &mut ::std::string::String {
        &mut self.mediators_dispute_result
    }

    // Take field
    pub fn take_mediators_dispute_result(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.mediators_dispute_result,
            ::std::string::String::new(),
        )
    }

    // string delayed_payout_tx_id = 26;

    pub fn get_delayed_payout_tx_id(&self) -> &str {
        &self.delayed_payout_tx_id
    }
    pub fn clear_delayed_payout_tx_id(&mut self) {
        self.delayed_payout_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_delayed_payout_tx_id(&mut self, v: ::std::string::String) {
        self.delayed_payout_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delayed_payout_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.delayed_payout_tx_id
    }

    // Take field
    pub fn take_delayed_payout_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delayed_payout_tx_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Dispute {
    fn is_initialized(&self) -> bool {
        for v in &self.trader_pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.contract {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.agent_pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.chat_message {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.dispute_result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.trader_id = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.dispute_opener_is_buyer = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.dispute_opener_is_maker = tmp;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.opening_date = tmp;
                }
                7 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.trader_pub_key_ring,
                    )?;
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.trade_date = tmp;
                }
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contract)?;
                }
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.contract_hash,
                    )?;
                }
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.deposit_tx_serialized,
                    )?;
                }
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.payout_tx_serialized,
                    )?;
                }
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.deposit_tx_id,
                    )?;
                }
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.payout_tx_id,
                    )?;
                }
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.contract_as_json,
                    )?;
                }
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.maker_contract_signature,
                    )?;
                }
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.taker_contract_signature,
                    )?;
                }
                18 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.agent_pub_key_ring,
                    )?;
                }
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_support_ticket = tmp;
                }
                20 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.chat_message,
                    )?;
                }
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_closed = tmp;
                }
                22 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.dispute_result,
                    )?;
                }
                23 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.dispute_payout_tx_id,
                    )?;
                }
                24 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.support_type,
                    24,
                    &mut self.unknown_fields,
                )?,
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mediators_dispute_result,
                    )?;
                }
                26 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.delayed_payout_tx_id,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.trade_id);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if self.trader_id != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.trader_id,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.dispute_opener_is_buyer != false {
            my_size += 2;
        }
        if self.dispute_opener_is_maker != false {
            my_size += 2;
        }
        if self.opening_date != 0 {
            my_size += ::protobuf::rt::value_size(
                6,
                self.opening_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if let Some(ref v) = self.trader_pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.trade_date != 0 {
            my_size += ::protobuf::rt::value_size(
                8,
                self.trade_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if let Some(ref v) = self.contract.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.contract_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.contract_hash);
        }
        if !self.deposit_tx_serialized.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.deposit_tx_serialized);
        }
        if !self.payout_tx_serialized.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.payout_tx_serialized);
        }
        if !self.deposit_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.deposit_tx_id);
        }
        if !self.payout_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.payout_tx_id);
        }
        if !self.contract_as_json.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.contract_as_json);
        }
        if !self.maker_contract_signature.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.maker_contract_signature);
        }
        if !self.taker_contract_signature.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.taker_contract_signature);
        }
        if let Some(ref v) = self.agent_pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_support_ticket != false {
            my_size += 3;
        }
        for value in &self.chat_message {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_closed != false {
            my_size += 3;
        }
        if let Some(ref v) = self.dispute_result.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.dispute_payout_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.dispute_payout_tx_id);
        }
        if self.support_type != SupportType::ARBITRATION {
            my_size += ::protobuf::rt::enum_size(24, self.support_type);
        }
        if !self.mediators_dispute_result.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.mediators_dispute_result);
        }
        if !self.delayed_payout_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(26, &self.delayed_payout_tx_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.trade_id.is_empty() {
            os.write_string(1, &self.trade_id)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if self.trader_id != 0 {
            os.write_int32(3, self.trader_id)?;
        }
        if self.dispute_opener_is_buyer != false {
            os.write_bool(4, self.dispute_opener_is_buyer)?;
        }
        if self.dispute_opener_is_maker != false {
            os.write_bool(5, self.dispute_opener_is_maker)?;
        }
        if self.opening_date != 0 {
            os.write_int64(6, self.opening_date)?;
        }
        if let Some(ref v) = self.trader_pub_key_ring.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.trade_date != 0 {
            os.write_int64(8, self.trade_date)?;
        }
        if let Some(ref v) = self.contract.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.contract_hash.is_empty() {
            os.write_bytes(10, &self.contract_hash)?;
        }
        if !self.deposit_tx_serialized.is_empty() {
            os.write_bytes(11, &self.deposit_tx_serialized)?;
        }
        if !self.payout_tx_serialized.is_empty() {
            os.write_bytes(12, &self.payout_tx_serialized)?;
        }
        if !self.deposit_tx_id.is_empty() {
            os.write_string(13, &self.deposit_tx_id)?;
        }
        if !self.payout_tx_id.is_empty() {
            os.write_string(14, &self.payout_tx_id)?;
        }
        if !self.contract_as_json.is_empty() {
            os.write_string(15, &self.contract_as_json)?;
        }
        if !self.maker_contract_signature.is_empty() {
            os.write_string(16, &self.maker_contract_signature)?;
        }
        if !self.taker_contract_signature.is_empty() {
            os.write_string(17, &self.taker_contract_signature)?;
        }
        if let Some(ref v) = self.agent_pub_key_ring.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_support_ticket != false {
            os.write_bool(19, self.is_support_ticket)?;
        }
        for v in &self.chat_message {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_closed != false {
            os.write_bool(21, self.is_closed)?;
        }
        if let Some(ref v) = self.dispute_result.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.dispute_payout_tx_id.is_empty() {
            os.write_string(23, &self.dispute_payout_tx_id)?;
        }
        if self.support_type != SupportType::ARBITRATION {
            os.write_enum(24, self.support_type.value())?;
        }
        if !self.mediators_dispute_result.is_empty() {
            os.write_string(25, &self.mediators_dispute_result)?;
        }
        if !self.delayed_payout_tx_id.is_empty() {
            os.write_string(26, &self.delayed_payout_tx_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dispute {
        Dispute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &Dispute| &m.trade_id,
                    |m: &mut Dispute| &mut m.trade_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "id", |m: &Dispute| &m.id, |m: &mut Dispute| &mut m.id
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "trader_id",
                    |m: &Dispute| &m.trader_id,
                    |m: &mut Dispute| &mut m.trader_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "dispute_opener_is_buyer",
                    |m: &Dispute| &m.dispute_opener_is_buyer,
                    |m: &mut Dispute| &mut m.dispute_opener_is_buyer,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "dispute_opener_is_maker",
                    |m: &Dispute| &m.dispute_opener_is_maker,
                    |m: &mut Dispute| &mut m.dispute_opener_is_maker,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "opening_date",
                    |m: &Dispute| &m.opening_date,
                    |m: &mut Dispute| &mut m.opening_date,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "trader_pub_key_ring",
                        |m: &Dispute| &m.trader_pub_key_ring,
                        |m: &mut Dispute| &mut m.trader_pub_key_ring,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "trade_date",
                    |m: &Dispute| &m.trade_date,
                    |m: &mut Dispute| &mut m.trade_date,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Contract>,
                    >(
                        "contract",
                        |m: &Dispute| &m.contract,
                        |m: &mut Dispute| &mut m.contract,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "contract_hash",
                    |m: &Dispute| &m.contract_hash,
                    |m: &mut Dispute| &mut m.contract_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "deposit_tx_serialized",
                    |m: &Dispute| &m.deposit_tx_serialized,
                    |m: &mut Dispute| &mut m.deposit_tx_serialized,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "payout_tx_serialized",
                    |m: &Dispute| &m.payout_tx_serialized,
                    |m: &mut Dispute| &mut m.payout_tx_serialized,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "deposit_tx_id",
                    |m: &Dispute| &m.deposit_tx_id,
                    |m: &mut Dispute| &mut m.deposit_tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "payout_tx_id",
                    |m: &Dispute| &m.payout_tx_id,
                    |m: &mut Dispute| &mut m.payout_tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "contract_as_json",
                    |m: &Dispute| &m.contract_as_json,
                    |m: &mut Dispute| &mut m.contract_as_json,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "maker_contract_signature",
                    |m: &Dispute| &m.maker_contract_signature,
                    |m: &mut Dispute| &mut m.maker_contract_signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "taker_contract_signature",
                    |m: &Dispute| &m.taker_contract_signature,
                    |m: &mut Dispute| &mut m.taker_contract_signature,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "agent_pub_key_ring",
                        |m: &Dispute| &m.agent_pub_key_ring,
                        |m: &mut Dispute| &mut m.agent_pub_key_ring,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_support_ticket",
                    |m: &Dispute| &m.is_support_ticket,
                    |m: &mut Dispute| &mut m.is_support_ticket,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<ChatMessage>,
                    >(
                        "chat_message",
                        |m: &Dispute| &m.chat_message,
                        |m: &mut Dispute| &mut m.chat_message,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_closed",
                    |m: &Dispute| &m.is_closed,
                    |m: &mut Dispute| &mut m.is_closed,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<DisputeResult>,
                    >(
                        "dispute_result",
                        |m: &Dispute| &m.dispute_result,
                        |m: &mut Dispute| &mut m.dispute_result,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "dispute_payout_tx_id",
                    |m: &Dispute| &m.dispute_payout_tx_id,
                    |m: &mut Dispute| &mut m.dispute_payout_tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<SupportType>,
                >(
                    "support_type",
                    |m: &Dispute| &m.support_type,
                    |m: &mut Dispute| &mut m.support_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "mediators_dispute_result",
                    |m: &Dispute| &m.mediators_dispute_result,
                    |m: &mut Dispute| &mut m.mediators_dispute_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "delayed_payout_tx_id",
                    |m: &Dispute| &m.delayed_payout_tx_id,
                    |m: &mut Dispute| &mut m.delayed_payout_tx_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Dispute>(
                    "Dispute",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Dispute {
        static mut instance: ::protobuf::lazy::Lazy<Dispute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Dispute,
        };
        unsafe { instance.get(Dispute::new) }
    }
}

impl ::protobuf::Clear for Dispute {
    fn clear(&mut self) {
        self.trade_id.clear();
        self.id.clear();
        self.trader_id = 0;
        self.dispute_opener_is_buyer = false;
        self.dispute_opener_is_maker = false;
        self.opening_date = 0;
        self.trader_pub_key_ring.clear();
        self.trade_date = 0;
        self.contract.clear();
        self.contract_hash.clear();
        self.deposit_tx_serialized.clear();
        self.payout_tx_serialized.clear();
        self.deposit_tx_id.clear();
        self.payout_tx_id.clear();
        self.contract_as_json.clear();
        self.maker_contract_signature.clear();
        self.taker_contract_signature.clear();
        self.agent_pub_key_ring.clear();
        self.is_support_ticket = false;
        self.chat_message.clear();
        self.is_closed = false;
        self.dispute_result.clear();
        self.dispute_payout_tx_id.clear();
        self.support_type = SupportType::ARBITRATION;
        self.mediators_dispute_result.clear();
        self.delayed_payout_tx_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dispute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dispute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Attachment {
    // message fields
    pub file_name: ::std::string::String,
    pub bytes: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Attachment {
    fn default() -> &'a Attachment {
        <Attachment as ::protobuf::Message>::default_instance()
    }
}

impl Attachment {
    pub fn new() -> Attachment {
        ::std::default::Default::default()
    }

    // string file_name = 1;

    pub fn get_file_name(&self) -> &str {
        &self.file_name
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        &mut self.file_name
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_name, ::std::string::String::new())
    }

    // bytes bytes = 2;

    pub fn get_bytes(&self) -> &[u8] {
        &self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.bytes
    }

    // Take field
    pub fn take_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.bytes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Attachment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.file_name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.bytes,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file_name);
        }
        if !self.bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.file_name.is_empty() {
            os.write_string(1, &self.file_name)?;
        }
        if !self.bytes.is_empty() {
            os.write_bytes(2, &self.bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Attachment {
        Attachment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "file_name",
                    |m: &Attachment| &m.file_name,
                    |m: &mut Attachment| &mut m.file_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "bytes",
                    |m: &Attachment| &m.bytes,
                    |m: &mut Attachment| &mut m.bytes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Attachment>(
                    "Attachment",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Attachment {
        static mut instance: ::protobuf::lazy::Lazy<Attachment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Attachment,
        };
        unsafe { instance.get(Attachment::new) }
    }
}

impl ::protobuf::Clear for Attachment {
    fn clear(&mut self) {
        self.file_name.clear();
        self.bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Attachment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Attachment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct DisputeResult {
    // message fields
    pub trade_id: ::std::string::String,
    pub trader_id: i32,
    pub winner: DisputeResult_Winner,
    pub reason_ordinal: i32,
    pub tamper_proof_evidence: bool,
    pub id_verification: bool,
    pub screen_cast: bool,
    pub summary_notes: ::std::string::String,
    pub chat_message: ::protobuf::SingularPtrField<ChatMessage>,
    pub arbitrator_signature: ::std::vec::Vec<u8>,
    pub buyer_payout_amount: i64,
    pub seller_payout_amount: i64,
    pub arbitrator_pub_key: ::std::vec::Vec<u8>,
    pub close_date: i64,
    pub is_loser_publisher: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisputeResult {
    fn default() -> &'a DisputeResult {
        <DisputeResult as ::protobuf::Message>::default_instance()
    }
}

impl DisputeResult {
    pub fn new() -> DisputeResult {
        ::std::default::Default::default()
    }

    // string trade_id = 1;

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // int32 trader_id = 2;

    pub fn get_trader_id(&self) -> i32 {
        self.trader_id
    }
    pub fn clear_trader_id(&mut self) {
        self.trader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_trader_id(&mut self, v: i32) {
        self.trader_id = v;
    }

    // .io.bisq.protobuffer.DisputeResult.Winner winner = 3;

    pub fn get_winner(&self) -> DisputeResult_Winner {
        self.winner
    }
    pub fn clear_winner(&mut self) {
        self.winner = DisputeResult_Winner::PB_ERROR_WINNER;
    }

    // Param is passed by value, moved
    pub fn set_winner(&mut self, v: DisputeResult_Winner) {
        self.winner = v;
    }

    // int32 reason_ordinal = 4;

    pub fn get_reason_ordinal(&self) -> i32 {
        self.reason_ordinal
    }
    pub fn clear_reason_ordinal(&mut self) {
        self.reason_ordinal = 0;
    }

    // Param is passed by value, moved
    pub fn set_reason_ordinal(&mut self, v: i32) {
        self.reason_ordinal = v;
    }

    // bool tamper_proof_evidence = 5;

    pub fn get_tamper_proof_evidence(&self) -> bool {
        self.tamper_proof_evidence
    }
    pub fn clear_tamper_proof_evidence(&mut self) {
        self.tamper_proof_evidence = false;
    }

    // Param is passed by value, moved
    pub fn set_tamper_proof_evidence(&mut self, v: bool) {
        self.tamper_proof_evidence = v;
    }

    // bool id_verification = 6;

    pub fn get_id_verification(&self) -> bool {
        self.id_verification
    }
    pub fn clear_id_verification(&mut self) {
        self.id_verification = false;
    }

    // Param is passed by value, moved
    pub fn set_id_verification(&mut self, v: bool) {
        self.id_verification = v;
    }

    // bool screen_cast = 7;

    pub fn get_screen_cast(&self) -> bool {
        self.screen_cast
    }
    pub fn clear_screen_cast(&mut self) {
        self.screen_cast = false;
    }

    // Param is passed by value, moved
    pub fn set_screen_cast(&mut self, v: bool) {
        self.screen_cast = v;
    }

    // string summary_notes = 8;

    pub fn get_summary_notes(&self) -> &str {
        &self.summary_notes
    }
    pub fn clear_summary_notes(&mut self) {
        self.summary_notes.clear();
    }

    // Param is passed by value, moved
    pub fn set_summary_notes(&mut self, v: ::std::string::String) {
        self.summary_notes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary_notes(&mut self) -> &mut ::std::string::String {
        &mut self.summary_notes
    }

    // Take field
    pub fn take_summary_notes(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.summary_notes, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.ChatMessage chat_message = 9;

    pub fn get_chat_message(&self) -> &ChatMessage {
        self.chat_message
            .as_ref()
            .unwrap_or_else(|| ChatMessage::default_instance())
    }
    pub fn clear_chat_message(&mut self) {
        self.chat_message.clear();
    }

    pub fn has_chat_message(&self) -> bool {
        self.chat_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_message(&mut self, v: ChatMessage) {
        self.chat_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_message(&mut self) -> &mut ChatMessage {
        if self.chat_message.is_none() {
            self.chat_message.set_default();
        }
        self.chat_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_message(&mut self) -> ChatMessage {
        self.chat_message
            .take()
            .unwrap_or_else(|| ChatMessage::new())
    }

    // bytes arbitrator_signature = 10;

    pub fn get_arbitrator_signature(&self) -> &[u8] {
        &self.arbitrator_signature
    }
    pub fn clear_arbitrator_signature(&mut self) {
        self.arbitrator_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_arbitrator_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.arbitrator_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arbitrator_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.arbitrator_signature
    }

    // Take field
    pub fn take_arbitrator_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.arbitrator_signature, ::std::vec::Vec::new())
    }

    // int64 buyer_payout_amount = 11;

    pub fn get_buyer_payout_amount(&self) -> i64 {
        self.buyer_payout_amount
    }
    pub fn clear_buyer_payout_amount(&mut self) {
        self.buyer_payout_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_buyer_payout_amount(&mut self, v: i64) {
        self.buyer_payout_amount = v;
    }

    // int64 seller_payout_amount = 12;

    pub fn get_seller_payout_amount(&self) -> i64 {
        self.seller_payout_amount
    }
    pub fn clear_seller_payout_amount(&mut self) {
        self.seller_payout_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_seller_payout_amount(&mut self, v: i64) {
        self.seller_payout_amount = v;
    }

    // bytes arbitrator_pub_key = 13;

    pub fn get_arbitrator_pub_key(&self) -> &[u8] {
        &self.arbitrator_pub_key
    }
    pub fn clear_arbitrator_pub_key(&mut self) {
        self.arbitrator_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_arbitrator_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.arbitrator_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arbitrator_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.arbitrator_pub_key
    }

    // Take field
    pub fn take_arbitrator_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.arbitrator_pub_key, ::std::vec::Vec::new())
    }

    // int64 close_date = 14;

    pub fn get_close_date(&self) -> i64 {
        self.close_date
    }
    pub fn clear_close_date(&mut self) {
        self.close_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_close_date(&mut self, v: i64) {
        self.close_date = v;
    }

    // bool is_loser_publisher = 15;

    pub fn get_is_loser_publisher(&self) -> bool {
        self.is_loser_publisher
    }
    pub fn clear_is_loser_publisher(&mut self) {
        self.is_loser_publisher = false;
    }

    // Param is passed by value, moved
    pub fn set_is_loser_publisher(&mut self, v: bool) {
        self.is_loser_publisher = v;
    }
}

impl ::protobuf::Message for DisputeResult {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.trader_id = tmp;
                }
                3 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.winner,
                    3,
                    &mut self.unknown_fields,
                )?,
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.reason_ordinal = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.tamper_proof_evidence = tmp;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.id_verification = tmp;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.screen_cast = tmp;
                }
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.summary_notes,
                    )?;
                }
                9 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.chat_message,
                    )?;
                }
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.arbitrator_signature,
                    )?;
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.buyer_payout_amount = tmp;
                }
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.seller_payout_amount = tmp;
                }
                13 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.arbitrator_pub_key,
                    )?;
                }
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.close_date = tmp;
                }
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_loser_publisher = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.trade_id);
        }
        if self.trader_id != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.trader_id,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.winner != DisputeResult_Winner::PB_ERROR_WINNER {
            my_size += ::protobuf::rt::enum_size(3, self.winner);
        }
        if self.reason_ordinal != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.reason_ordinal,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.tamper_proof_evidence != false {
            my_size += 2;
        }
        if self.id_verification != false {
            my_size += 2;
        }
        if self.screen_cast != false {
            my_size += 2;
        }
        if !self.summary_notes.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.summary_notes);
        }
        if let Some(ref v) = self.chat_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.arbitrator_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.arbitrator_signature);
        }
        if self.buyer_payout_amount != 0 {
            my_size += ::protobuf::rt::value_size(
                11,
                self.buyer_payout_amount,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.seller_payout_amount != 0 {
            my_size += ::protobuf::rt::value_size(
                12,
                self.seller_payout_amount,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.arbitrator_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.arbitrator_pub_key);
        }
        if self.close_date != 0 {
            my_size += ::protobuf::rt::value_size(
                14,
                self.close_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.is_loser_publisher != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.trade_id.is_empty() {
            os.write_string(1, &self.trade_id)?;
        }
        if self.trader_id != 0 {
            os.write_int32(2, self.trader_id)?;
        }
        if self.winner != DisputeResult_Winner::PB_ERROR_WINNER {
            os.write_enum(3, self.winner.value())?;
        }
        if self.reason_ordinal != 0 {
            os.write_int32(4, self.reason_ordinal)?;
        }
        if self.tamper_proof_evidence != false {
            os.write_bool(5, self.tamper_proof_evidence)?;
        }
        if self.id_verification != false {
            os.write_bool(6, self.id_verification)?;
        }
        if self.screen_cast != false {
            os.write_bool(7, self.screen_cast)?;
        }
        if !self.summary_notes.is_empty() {
            os.write_string(8, &self.summary_notes)?;
        }
        if let Some(ref v) = self.chat_message.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.arbitrator_signature.is_empty() {
            os.write_bytes(10, &self.arbitrator_signature)?;
        }
        if self.buyer_payout_amount != 0 {
            os.write_int64(11, self.buyer_payout_amount)?;
        }
        if self.seller_payout_amount != 0 {
            os.write_int64(12, self.seller_payout_amount)?;
        }
        if !self.arbitrator_pub_key.is_empty() {
            os.write_bytes(13, &self.arbitrator_pub_key)?;
        }
        if self.close_date != 0 {
            os.write_int64(14, self.close_date)?;
        }
        if self.is_loser_publisher != false {
            os.write_bool(15, self.is_loser_publisher)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisputeResult {
        DisputeResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &DisputeResult| &m.trade_id,
                    |m: &mut DisputeResult| &mut m.trade_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "trader_id",
                    |m: &DisputeResult| &m.trader_id,
                    |m: &mut DisputeResult| &mut m.trader_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<DisputeResult_Winner>,
                >(
                    "winner",
                    |m: &DisputeResult| &m.winner,
                    |m: &mut DisputeResult| &mut m.winner,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "reason_ordinal",
                    |m: &DisputeResult| &m.reason_ordinal,
                    |m: &mut DisputeResult| &mut m.reason_ordinal,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "tamper_proof_evidence",
                    |m: &DisputeResult| &m.tamper_proof_evidence,
                    |m: &mut DisputeResult| &mut m.tamper_proof_evidence,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "id_verification",
                    |m: &DisputeResult| &m.id_verification,
                    |m: &mut DisputeResult| &mut m.id_verification,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "screen_cast",
                    |m: &DisputeResult| &m.screen_cast,
                    |m: &mut DisputeResult| &mut m.screen_cast,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "summary_notes",
                    |m: &DisputeResult| &m.summary_notes,
                    |m: &mut DisputeResult| &mut m.summary_notes,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<ChatMessage>,
                    >(
                        "chat_message",
                        |m: &DisputeResult| &m.chat_message,
                        |m: &mut DisputeResult| &mut m.chat_message,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "arbitrator_signature",
                    |m: &DisputeResult| &m.arbitrator_signature,
                    |m: &mut DisputeResult| &mut m.arbitrator_signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "buyer_payout_amount",
                    |m: &DisputeResult| &m.buyer_payout_amount,
                    |m: &mut DisputeResult| &mut m.buyer_payout_amount,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "seller_payout_amount",
                    |m: &DisputeResult| &m.seller_payout_amount,
                    |m: &mut DisputeResult| &mut m.seller_payout_amount,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "arbitrator_pub_key",
                    |m: &DisputeResult| &m.arbitrator_pub_key,
                    |m: &mut DisputeResult| &mut m.arbitrator_pub_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "close_date",
                    |m: &DisputeResult| &m.close_date,
                    |m: &mut DisputeResult| &mut m.close_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_loser_publisher",
                    |m: &DisputeResult| &m.is_loser_publisher,
                    |m: &mut DisputeResult| &mut m.is_loser_publisher,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DisputeResult>(
                    "DisputeResult",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static DisputeResult {
        static mut instance: ::protobuf::lazy::Lazy<DisputeResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisputeResult,
        };
        unsafe { instance.get(DisputeResult::new) }
    }
}

impl ::protobuf::Clear for DisputeResult {
    fn clear(&mut self) {
        self.trade_id.clear();
        self.trader_id = 0;
        self.winner = DisputeResult_Winner::PB_ERROR_WINNER;
        self.reason_ordinal = 0;
        self.tamper_proof_evidence = false;
        self.id_verification = false;
        self.screen_cast = false;
        self.summary_notes.clear();
        self.chat_message.clear();
        self.arbitrator_signature.clear();
        self.buyer_payout_amount = 0;
        self.seller_payout_amount = 0;
        self.arbitrator_pub_key.clear();
        self.close_date = 0;
        self.is_loser_publisher = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisputeResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisputeResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum DisputeResult_Winner {
    PB_ERROR_WINNER = 0,
    BUYER = 1,
    SELLER = 2,
}

impl ::protobuf::ProtobufEnum for DisputeResult_Winner {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DisputeResult_Winner> {
        match value {
            0 => ::std::option::Option::Some(DisputeResult_Winner::PB_ERROR_WINNER),
            1 => ::std::option::Option::Some(DisputeResult_Winner::BUYER),
            2 => ::std::option::Option::Some(DisputeResult_Winner::SELLER),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DisputeResult_Winner] = &[
            DisputeResult_Winner::PB_ERROR_WINNER,
            DisputeResult_Winner::BUYER,
            DisputeResult_Winner::SELLER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new(
                    "DisputeResult_Winner",
                    file_descriptor_proto(),
                )
            })
        }
    }
}

impl ::std::marker::Copy for DisputeResult_Winner {}

impl ::std::default::Default for DisputeResult_Winner {
    fn default() -> Self {
        DisputeResult_Winner::PB_ERROR_WINNER
    }
}

impl ::protobuf::reflect::ProtobufValue for DisputeResult_Winner {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum DisputeResult_Reason {
    PB_ERROR_REASON = 0,
    OTHER = 1,
    BUG = 2,
    USABILITY = 3,
    SCAM = 4,
    PROTOCOL_VIOLATION = 5,
    NO_REPLY = 6,
    BANK_PROBLEMS = 7,
}

impl ::protobuf::ProtobufEnum for DisputeResult_Reason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DisputeResult_Reason> {
        match value {
            0 => ::std::option::Option::Some(DisputeResult_Reason::PB_ERROR_REASON),
            1 => ::std::option::Option::Some(DisputeResult_Reason::OTHER),
            2 => ::std::option::Option::Some(DisputeResult_Reason::BUG),
            3 => ::std::option::Option::Some(DisputeResult_Reason::USABILITY),
            4 => ::std::option::Option::Some(DisputeResult_Reason::SCAM),
            5 => ::std::option::Option::Some(DisputeResult_Reason::PROTOCOL_VIOLATION),
            6 => ::std::option::Option::Some(DisputeResult_Reason::NO_REPLY),
            7 => ::std::option::Option::Some(DisputeResult_Reason::BANK_PROBLEMS),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DisputeResult_Reason] = &[
            DisputeResult_Reason::PB_ERROR_REASON,
            DisputeResult_Reason::OTHER,
            DisputeResult_Reason::BUG,
            DisputeResult_Reason::USABILITY,
            DisputeResult_Reason::SCAM,
            DisputeResult_Reason::PROTOCOL_VIOLATION,
            DisputeResult_Reason::NO_REPLY,
            DisputeResult_Reason::BANK_PROBLEMS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new(
                    "DisputeResult_Reason",
                    file_descriptor_proto(),
                )
            })
        }
    }
}

impl ::std::marker::Copy for DisputeResult_Reason {}

impl ::std::default::Default for DisputeResult_Reason {
    fn default() -> Self {
        DisputeResult_Reason::PB_ERROR_REASON
    }
}

impl ::protobuf::reflect::ProtobufValue for DisputeResult_Reason {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Contract {
    // message fields
    pub offer_payload: ::protobuf::SingularPtrField<OfferPayload>,
    pub trade_amount: i64,
    pub trade_price: i64,
    pub taker_fee_tx_id: ::std::string::String,
    pub is_buyer_maker_and_seller_taker: bool,
    pub maker_account_id: ::std::string::String,
    pub taker_account_id: ::std::string::String,
    pub maker_payment_account_payload: ::protobuf::SingularPtrField<PaymentAccountPayload>,
    pub taker_payment_account_payload: ::protobuf::SingularPtrField<PaymentAccountPayload>,
    pub maker_pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub taker_pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub buyer_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub seller_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub maker_payout_address_string: ::std::string::String,
    pub taker_payout_address_string: ::std::string::String,
    pub maker_multi_sig_pub_key: ::std::vec::Vec<u8>,
    pub taker_multi_sig_pub_key: ::std::vec::Vec<u8>,
    pub mediator_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub lock_time: i64,
    pub refund_agent_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Contract {
    fn default() -> &'a Contract {
        <Contract as ::protobuf::Message>::default_instance()
    }
}

impl Contract {
    pub fn new() -> Contract {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.OfferPayload offer_payload = 1;

    pub fn get_offer_payload(&self) -> &OfferPayload {
        self.offer_payload
            .as_ref()
            .unwrap_or_else(|| OfferPayload::default_instance())
    }
    pub fn clear_offer_payload(&mut self) {
        self.offer_payload.clear();
    }

    pub fn has_offer_payload(&self) -> bool {
        self.offer_payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offer_payload(&mut self, v: OfferPayload) {
        self.offer_payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer_payload(&mut self) -> &mut OfferPayload {
        if self.offer_payload.is_none() {
            self.offer_payload.set_default();
        }
        self.offer_payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_offer_payload(&mut self) -> OfferPayload {
        self.offer_payload
            .take()
            .unwrap_or_else(|| OfferPayload::new())
    }

    // int64 trade_amount = 2;

    pub fn get_trade_amount(&self) -> i64 {
        self.trade_amount
    }
    pub fn clear_trade_amount(&mut self) {
        self.trade_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_amount(&mut self, v: i64) {
        self.trade_amount = v;
    }

    // int64 trade_price = 3;

    pub fn get_trade_price(&self) -> i64 {
        self.trade_price
    }
    pub fn clear_trade_price(&mut self) {
        self.trade_price = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_price(&mut self, v: i64) {
        self.trade_price = v;
    }

    // string taker_fee_tx_id = 4;

    pub fn get_taker_fee_tx_id(&self) -> &str {
        &self.taker_fee_tx_id
    }
    pub fn clear_taker_fee_tx_id(&mut self) {
        self.taker_fee_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_tx_id(&mut self, v: ::std::string::String) {
        self.taker_fee_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_tx_id
    }

    // Take field
    pub fn take_taker_fee_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_tx_id, ::std::string::String::new())
    }

    // bool is_buyer_maker_and_seller_taker = 6;

    pub fn get_is_buyer_maker_and_seller_taker(&self) -> bool {
        self.is_buyer_maker_and_seller_taker
    }
    pub fn clear_is_buyer_maker_and_seller_taker(&mut self) {
        self.is_buyer_maker_and_seller_taker = false;
    }

    // Param is passed by value, moved
    pub fn set_is_buyer_maker_and_seller_taker(&mut self, v: bool) {
        self.is_buyer_maker_and_seller_taker = v;
    }

    // string maker_account_id = 7;

    pub fn get_maker_account_id(&self) -> &str {
        &self.maker_account_id
    }
    pub fn clear_maker_account_id(&mut self) {
        self.maker_account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_account_id(&mut self, v: ::std::string::String) {
        self.maker_account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.maker_account_id
    }

    // Take field
    pub fn take_maker_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_account_id, ::std::string::String::new())
    }

    // string taker_account_id = 8;

    pub fn get_taker_account_id(&self) -> &str {
        &self.taker_account_id
    }
    pub fn clear_taker_account_id(&mut self) {
        self.taker_account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_account_id(&mut self, v: ::std::string::String) {
        self.taker_account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.taker_account_id
    }

    // Take field
    pub fn take_taker_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_account_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.PaymentAccountPayload maker_payment_account_payload = 9;

    pub fn get_maker_payment_account_payload(&self) -> &PaymentAccountPayload {
        self.maker_payment_account_payload
            .as_ref()
            .unwrap_or_else(|| PaymentAccountPayload::default_instance())
    }
    pub fn clear_maker_payment_account_payload(&mut self) {
        self.maker_payment_account_payload.clear();
    }

    pub fn has_maker_payment_account_payload(&self) -> bool {
        self.maker_payment_account_payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maker_payment_account_payload(&mut self, v: PaymentAccountPayload) {
        self.maker_payment_account_payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_payment_account_payload(&mut self) -> &mut PaymentAccountPayload {
        if self.maker_payment_account_payload.is_none() {
            self.maker_payment_account_payload.set_default();
        }
        self.maker_payment_account_payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_maker_payment_account_payload(&mut self) -> PaymentAccountPayload {
        self.maker_payment_account_payload
            .take()
            .unwrap_or_else(|| PaymentAccountPayload::new())
    }

    // .io.bisq.protobuffer.PaymentAccountPayload taker_payment_account_payload = 10;

    pub fn get_taker_payment_account_payload(&self) -> &PaymentAccountPayload {
        self.taker_payment_account_payload
            .as_ref()
            .unwrap_or_else(|| PaymentAccountPayload::default_instance())
    }
    pub fn clear_taker_payment_account_payload(&mut self) {
        self.taker_payment_account_payload.clear();
    }

    pub fn has_taker_payment_account_payload(&self) -> bool {
        self.taker_payment_account_payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taker_payment_account_payload(&mut self, v: PaymentAccountPayload) {
        self.taker_payment_account_payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_payment_account_payload(&mut self) -> &mut PaymentAccountPayload {
        if self.taker_payment_account_payload.is_none() {
            self.taker_payment_account_payload.set_default();
        }
        self.taker_payment_account_payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_taker_payment_account_payload(&mut self) -> PaymentAccountPayload {
        self.taker_payment_account_payload
            .take()
            .unwrap_or_else(|| PaymentAccountPayload::new())
    }

    // .io.bisq.protobuffer.PubKeyRing maker_pub_key_ring = 11;

    pub fn get_maker_pub_key_ring(&self) -> &PubKeyRing {
        self.maker_pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_maker_pub_key_ring(&mut self) {
        self.maker_pub_key_ring.clear();
    }

    pub fn has_maker_pub_key_ring(&self) -> bool {
        self.maker_pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maker_pub_key_ring(&mut self, v: PubKeyRing) {
        self.maker_pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.maker_pub_key_ring.is_none() {
            self.maker_pub_key_ring.set_default();
        }
        self.maker_pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_maker_pub_key_ring(&mut self) -> PubKeyRing {
        self.maker_pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // .io.bisq.protobuffer.PubKeyRing taker_pub_key_ring = 12;

    pub fn get_taker_pub_key_ring(&self) -> &PubKeyRing {
        self.taker_pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_taker_pub_key_ring(&mut self) {
        self.taker_pub_key_ring.clear();
    }

    pub fn has_taker_pub_key_ring(&self) -> bool {
        self.taker_pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taker_pub_key_ring(&mut self, v: PubKeyRing) {
        self.taker_pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.taker_pub_key_ring.is_none() {
            self.taker_pub_key_ring.set_default();
        }
        self.taker_pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_taker_pub_key_ring(&mut self) -> PubKeyRing {
        self.taker_pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // .io.bisq.protobuffer.NodeAddress buyer_node_address = 13;

    pub fn get_buyer_node_address(&self) -> &NodeAddress {
        self.buyer_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_buyer_node_address(&mut self) {
        self.buyer_node_address.clear();
    }

    pub fn has_buyer_node_address(&self) -> bool {
        self.buyer_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buyer_node_address(&mut self, v: NodeAddress) {
        self.buyer_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buyer_node_address(&mut self) -> &mut NodeAddress {
        if self.buyer_node_address.is_none() {
            self.buyer_node_address.set_default();
        }
        self.buyer_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_buyer_node_address(&mut self) -> NodeAddress {
        self.buyer_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // .io.bisq.protobuffer.NodeAddress seller_node_address = 14;

    pub fn get_seller_node_address(&self) -> &NodeAddress {
        self.seller_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_seller_node_address(&mut self) {
        self.seller_node_address.clear();
    }

    pub fn has_seller_node_address(&self) -> bool {
        self.seller_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seller_node_address(&mut self, v: NodeAddress) {
        self.seller_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seller_node_address(&mut self) -> &mut NodeAddress {
        if self.seller_node_address.is_none() {
            self.seller_node_address.set_default();
        }
        self.seller_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_seller_node_address(&mut self) -> NodeAddress {
        self.seller_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // string maker_payout_address_string = 15;

    pub fn get_maker_payout_address_string(&self) -> &str {
        &self.maker_payout_address_string
    }
    pub fn clear_maker_payout_address_string(&mut self) {
        self.maker_payout_address_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_payout_address_string(&mut self, v: ::std::string::String) {
        self.maker_payout_address_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_payout_address_string(&mut self) -> &mut ::std::string::String {
        &mut self.maker_payout_address_string
    }

    // Take field
    pub fn take_maker_payout_address_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.maker_payout_address_string,
            ::std::string::String::new(),
        )
    }

    // string taker_payout_address_string = 16;

    pub fn get_taker_payout_address_string(&self) -> &str {
        &self.taker_payout_address_string
    }
    pub fn clear_taker_payout_address_string(&mut self) {
        self.taker_payout_address_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_payout_address_string(&mut self, v: ::std::string::String) {
        self.taker_payout_address_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_payout_address_string(&mut self) -> &mut ::std::string::String {
        &mut self.taker_payout_address_string
    }

    // Take field
    pub fn take_taker_payout_address_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.taker_payout_address_string,
            ::std::string::String::new(),
        )
    }

    // bytes maker_multi_sig_pub_key = 17;

    pub fn get_maker_multi_sig_pub_key(&self) -> &[u8] {
        &self.maker_multi_sig_pub_key
    }
    pub fn clear_maker_multi_sig_pub_key(&mut self) {
        self.maker_multi_sig_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_multi_sig_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.maker_multi_sig_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_multi_sig_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.maker_multi_sig_pub_key
    }

    // Take field
    pub fn take_maker_multi_sig_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.maker_multi_sig_pub_key, ::std::vec::Vec::new())
    }

    // bytes taker_multi_sig_pub_key = 18;

    pub fn get_taker_multi_sig_pub_key(&self) -> &[u8] {
        &self.taker_multi_sig_pub_key
    }
    pub fn clear_taker_multi_sig_pub_key(&mut self) {
        self.taker_multi_sig_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_multi_sig_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.taker_multi_sig_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_multi_sig_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.taker_multi_sig_pub_key
    }

    // Take field
    pub fn take_taker_multi_sig_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.taker_multi_sig_pub_key, ::std::vec::Vec::new())
    }

    // .io.bisq.protobuffer.NodeAddress mediator_node_address = 19;

    pub fn get_mediator_node_address(&self) -> &NodeAddress {
        self.mediator_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_mediator_node_address(&mut self) {
        self.mediator_node_address.clear();
    }

    pub fn has_mediator_node_address(&self) -> bool {
        self.mediator_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediator_node_address(&mut self, v: NodeAddress) {
        self.mediator_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediator_node_address(&mut self) -> &mut NodeAddress {
        if self.mediator_node_address.is_none() {
            self.mediator_node_address.set_default();
        }
        self.mediator_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediator_node_address(&mut self) -> NodeAddress {
        self.mediator_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // int64 lock_time = 20;

    pub fn get_lock_time(&self) -> i64 {
        self.lock_time
    }
    pub fn clear_lock_time(&mut self) {
        self.lock_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_lock_time(&mut self, v: i64) {
        self.lock_time = v;
    }

    // .io.bisq.protobuffer.NodeAddress refund_agent_node_address = 21;

    pub fn get_refund_agent_node_address(&self) -> &NodeAddress {
        self.refund_agent_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_refund_agent_node_address(&mut self) {
        self.refund_agent_node_address.clear();
    }

    pub fn has_refund_agent_node_address(&self) -> bool {
        self.refund_agent_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refund_agent_node_address(&mut self, v: NodeAddress) {
        self.refund_agent_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refund_agent_node_address(&mut self) -> &mut NodeAddress {
        if self.refund_agent_node_address.is_none() {
            self.refund_agent_node_address.set_default();
        }
        self.refund_agent_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_refund_agent_node_address(&mut self) -> NodeAddress {
        self.refund_agent_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }
}

impl ::protobuf::Message for Contract {
    fn is_initialized(&self) -> bool {
        for v in &self.offer_payload {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.maker_payment_account_payload {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.taker_payment_account_payload {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.maker_pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.taker_pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.buyer_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.seller_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.mediator_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.refund_agent_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.offer_payload,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.trade_amount = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.trade_price = tmp;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.taker_fee_tx_id,
                    )?;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_buyer_maker_and_seller_taker = tmp;
                }
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.maker_account_id,
                    )?;
                }
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.taker_account_id,
                    )?;
                }
                9 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.maker_payment_account_payload,
                    )?;
                }
                10 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.taker_payment_account_payload,
                    )?;
                }
                11 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.maker_pub_key_ring,
                    )?;
                }
                12 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.taker_pub_key_ring,
                    )?;
                }
                13 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.buyer_node_address,
                    )?;
                }
                14 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.seller_node_address,
                    )?;
                }
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.maker_payout_address_string,
                    )?;
                }
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.taker_payout_address_string,
                    )?;
                }
                17 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.maker_multi_sig_pub_key,
                    )?;
                }
                18 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.taker_multi_sig_pub_key,
                    )?;
                }
                19 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.mediator_node_address,
                    )?;
                }
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.lock_time = tmp;
                }
                21 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.refund_agent_node_address,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.offer_payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.trade_amount != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.trade_amount,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.trade_price != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.trade_price,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.taker_fee_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.taker_fee_tx_id);
        }
        if self.is_buyer_maker_and_seller_taker != false {
            my_size += 2;
        }
        if !self.maker_account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.maker_account_id);
        }
        if !self.taker_account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.taker_account_id);
        }
        if let Some(ref v) = self.maker_payment_account_payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.taker_payment_account_payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.maker_pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.taker_pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.buyer_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.seller_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.maker_payout_address_string.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.maker_payout_address_string);
        }
        if !self.taker_payout_address_string.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.taker_payout_address_string);
        }
        if !self.maker_multi_sig_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(17, &self.maker_multi_sig_pub_key);
        }
        if !self.taker_multi_sig_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(18, &self.taker_multi_sig_pub_key);
        }
        if let Some(ref v) = self.mediator_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.lock_time != 0 {
            my_size += ::protobuf::rt::value_size(
                20,
                self.lock_time,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if let Some(ref v) = self.refund_agent_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.offer_payload.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.trade_amount != 0 {
            os.write_int64(2, self.trade_amount)?;
        }
        if self.trade_price != 0 {
            os.write_int64(3, self.trade_price)?;
        }
        if !self.taker_fee_tx_id.is_empty() {
            os.write_string(4, &self.taker_fee_tx_id)?;
        }
        if self.is_buyer_maker_and_seller_taker != false {
            os.write_bool(6, self.is_buyer_maker_and_seller_taker)?;
        }
        if !self.maker_account_id.is_empty() {
            os.write_string(7, &self.maker_account_id)?;
        }
        if !self.taker_account_id.is_empty() {
            os.write_string(8, &self.taker_account_id)?;
        }
        if let Some(ref v) = self.maker_payment_account_payload.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.taker_payment_account_payload.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.maker_pub_key_ring.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.taker_pub_key_ring.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.buyer_node_address.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.seller_node_address.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.maker_payout_address_string.is_empty() {
            os.write_string(15, &self.maker_payout_address_string)?;
        }
        if !self.taker_payout_address_string.is_empty() {
            os.write_string(16, &self.taker_payout_address_string)?;
        }
        if !self.maker_multi_sig_pub_key.is_empty() {
            os.write_bytes(17, &self.maker_multi_sig_pub_key)?;
        }
        if !self.taker_multi_sig_pub_key.is_empty() {
            os.write_bytes(18, &self.taker_multi_sig_pub_key)?;
        }
        if let Some(ref v) = self.mediator_node_address.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.lock_time != 0 {
            os.write_int64(20, self.lock_time)?;
        }
        if let Some(ref v) = self.refund_agent_node_address.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Contract {
        Contract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<OfferPayload>,
                    >(
                        "offer_payload",
                        |m: &Contract| &m.offer_payload,
                        |m: &mut Contract| &mut m.offer_payload,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "trade_amount",
                    |m: &Contract| &m.trade_amount,
                    |m: &mut Contract| &mut m.trade_amount,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "trade_price",
                    |m: &Contract| &m.trade_price,
                    |m: &mut Contract| &mut m.trade_price,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "taker_fee_tx_id",
                    |m: &Contract| &m.taker_fee_tx_id,
                    |m: &mut Contract| &mut m.taker_fee_tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_buyer_maker_and_seller_taker",
                    |m: &Contract| &m.is_buyer_maker_and_seller_taker,
                    |m: &mut Contract| &mut m.is_buyer_maker_and_seller_taker,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "maker_account_id",
                    |m: &Contract| &m.maker_account_id,
                    |m: &mut Contract| &mut m.maker_account_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "taker_account_id",
                    |m: &Contract| &m.taker_account_id,
                    |m: &mut Contract| &mut m.taker_account_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PaymentAccountPayload>,
                    >(
                        "maker_payment_account_payload",
                        |m: &Contract| &m.maker_payment_account_payload,
                        |m: &mut Contract| &mut m.maker_payment_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PaymentAccountPayload>,
                    >(
                        "taker_payment_account_payload",
                        |m: &Contract| &m.taker_payment_account_payload,
                        |m: &mut Contract| &mut m.taker_payment_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "maker_pub_key_ring",
                        |m: &Contract| &m.maker_pub_key_ring,
                        |m: &mut Contract| &mut m.maker_pub_key_ring,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "taker_pub_key_ring",
                        |m: &Contract| &m.taker_pub_key_ring,
                        |m: &mut Contract| &mut m.taker_pub_key_ring,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "buyer_node_address",
                        |m: &Contract| &m.buyer_node_address,
                        |m: &mut Contract| &mut m.buyer_node_address,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "seller_node_address",
                        |m: &Contract| &m.seller_node_address,
                        |m: &mut Contract| &mut m.seller_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "maker_payout_address_string",
                    |m: &Contract| &m.maker_payout_address_string,
                    |m: &mut Contract| &mut m.maker_payout_address_string,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "taker_payout_address_string",
                    |m: &Contract| &m.taker_payout_address_string,
                    |m: &mut Contract| &mut m.taker_payout_address_string,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "maker_multi_sig_pub_key",
                    |m: &Contract| &m.maker_multi_sig_pub_key,
                    |m: &mut Contract| &mut m.maker_multi_sig_pub_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "taker_multi_sig_pub_key",
                    |m: &Contract| &m.taker_multi_sig_pub_key,
                    |m: &mut Contract| &mut m.taker_multi_sig_pub_key,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "mediator_node_address",
                        |m: &Contract| &m.mediator_node_address,
                        |m: &mut Contract| &mut m.mediator_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "lock_time",
                    |m: &Contract| &m.lock_time,
                    |m: &mut Contract| &mut m.lock_time,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "refund_agent_node_address",
                        |m: &Contract| &m.refund_agent_node_address,
                        |m: &mut Contract| &mut m.refund_agent_node_address,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<Contract>(
                    "Contract",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Contract {
        static mut instance: ::protobuf::lazy::Lazy<Contract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Contract,
        };
        unsafe { instance.get(Contract::new) }
    }
}

impl ::protobuf::Clear for Contract {
    fn clear(&mut self) {
        self.offer_payload.clear();
        self.trade_amount = 0;
        self.trade_price = 0;
        self.taker_fee_tx_id.clear();
        self.is_buyer_maker_and_seller_taker = false;
        self.maker_account_id.clear();
        self.taker_account_id.clear();
        self.maker_payment_account_payload.clear();
        self.taker_payment_account_payload.clear();
        self.maker_pub_key_ring.clear();
        self.taker_pub_key_ring.clear();
        self.buyer_node_address.clear();
        self.seller_node_address.clear();
        self.maker_payout_address_string.clear();
        self.taker_payout_address_string.clear();
        self.maker_multi_sig_pub_key.clear();
        self.taker_multi_sig_pub_key.clear();
        self.mediator_node_address.clear();
        self.lock_time = 0;
        self.refund_agent_node_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Contract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Contract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RawTransactionInput {
    // message fields
    pub index: i64,
    pub parent_transaction: ::std::vec::Vec<u8>,
    pub value: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawTransactionInput {
    fn default() -> &'a RawTransactionInput {
        <RawTransactionInput as ::protobuf::Message>::default_instance()
    }
}

impl RawTransactionInput {
    pub fn new() -> RawTransactionInput {
        ::std::default::Default::default()
    }

    // int64 index = 1;

    pub fn get_index(&self) -> i64 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i64) {
        self.index = v;
    }

    // bytes parent_transaction = 2;

    pub fn get_parent_transaction(&self) -> &[u8] {
        &self.parent_transaction
    }
    pub fn clear_parent_transaction(&mut self) {
        self.parent_transaction.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_transaction(&mut self, v: ::std::vec::Vec<u8>) {
        self.parent_transaction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_transaction(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.parent_transaction
    }

    // Take field
    pub fn take_parent_transaction(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.parent_transaction, ::std::vec::Vec::new())
    }

    // int64 value = 3;

    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }
}

impl ::protobuf::Message for RawTransactionInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.index = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.parent_transaction,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.parent_transaction.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.parent_transaction);
        }
        if self.value != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.index != 0 {
            os.write_int64(1, self.index)?;
        }
        if !self.parent_transaction.is_empty() {
            os.write_bytes(2, &self.parent_transaction)?;
        }
        if self.value != 0 {
            os.write_int64(3, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawTransactionInput {
        RawTransactionInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "index",
                    |m: &RawTransactionInput| &m.index,
                    |m: &mut RawTransactionInput| &mut m.index,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "parent_transaction",
                    |m: &RawTransactionInput| &m.parent_transaction,
                    |m: &mut RawTransactionInput| &mut m.parent_transaction,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "value",
                    |m: &RawTransactionInput| &m.value,
                    |m: &mut RawTransactionInput| &mut m.value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RawTransactionInput>(
                    "RawTransactionInput",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static RawTransactionInput {
        static mut instance: ::protobuf::lazy::Lazy<RawTransactionInput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawTransactionInput,
        };
        unsafe { instance.get(RawTransactionInput::new) }
    }
}

impl ::protobuf::Clear for RawTransactionInput {
    fn clear(&mut self) {
        self.index = 0;
        self.parent_transaction.clear();
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RawTransactionInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawTransactionInput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PaymentAccountPayload {
    // message fields
    pub id: ::std::string::String,
    pub payment_method_id: ::std::string::String,
    pub max_trade_period: i64,
    pub exclude_from_json_data:
        ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // message oneof groups
    pub message: ::std::option::Option<PaymentAccountPayload_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentAccountPayload {
    fn default() -> &'a PaymentAccountPayload {
        <PaymentAccountPayload as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum PaymentAccountPayload_oneof_message {
    ali_pay_account_payload(AliPayAccountPayload),
    chase_quick_pay_account_payload(ChaseQuickPayAccountPayload),
    clear_xchange_account_payload(ClearXchangeAccountPayload),
    country_based_payment_account_payload(CountryBasedPaymentAccountPayload),
    crypto_currency_account_payload(CryptoCurrencyAccountPayload),
    faster_payments_account_payload(FasterPaymentsAccountPayload),
    interac_e_transfer_account_payload(InteracETransferAccountPayload),
    o_k_pay_account_payload(OKPayAccountPayload),
    perfect_money_account_payload(PerfectMoneyAccountPayload),
    swish_account_payload(SwishAccountPayload),
    u_s_postal_money_order_account_payload(USPostalMoneyOrderAccountPayload),
    uphold_account_payload(UpholdAccountPayload),
    cash_app_account_payload(CashAppAccountPayload),
    money_beam_account_payload(MoneyBeamAccountPayload),
    venmo_account_payload(VenmoAccountPayload),
    popmoney_account_payload(PopmoneyAccountPayload),
    revolut_account_payload(RevolutAccountPayload),
    we_chat_pay_account_payload(WeChatPayAccountPayload),
    money_gram_account_payload(MoneyGramAccountPayload),
    hal_cash_account_payload(HalCashAccountPayload),
    prompt_pay_account_payload(PromptPayAccountPayload),
    advanced_cash_account_payload(AdvancedCashAccountPayload),
    instant_crypto_currency_account_payload(InstantCryptoCurrencyAccountPayload),
    japan_bank_account_payload(JapanBankAccountPayload),
}

impl PaymentAccountPayload {
    pub fn new() -> PaymentAccountPayload {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string payment_method_id = 2;

    pub fn get_payment_method_id(&self) -> &str {
        &self.payment_method_id
    }
    pub fn clear_payment_method_id(&mut self) {
        self.payment_method_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_method_id(&mut self, v: ::std::string::String) {
        self.payment_method_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_method_id(&mut self) -> &mut ::std::string::String {
        &mut self.payment_method_id
    }

    // Take field
    pub fn take_payment_method_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_method_id, ::std::string::String::new())
    }

    // int64 max_trade_period = 3;

    pub fn get_max_trade_period(&self) -> i64 {
        self.max_trade_period
    }
    pub fn clear_max_trade_period(&mut self) {
        self.max_trade_period = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_trade_period(&mut self, v: i64) {
        self.max_trade_period = v;
    }

    // .io.bisq.protobuffer.AliPayAccountPayload ali_pay_account_payload = 4;

    pub fn get_ali_pay_account_payload(&self) -> &AliPayAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::ali_pay_account_payload(ref v),
            ) => v,
            _ => AliPayAccountPayload::default_instance(),
        }
    }
    pub fn clear_ali_pay_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_ali_pay_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::ali_pay_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ali_pay_account_payload(&mut self, v: AliPayAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::ali_pay_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_ali_pay_account_payload(&mut self) -> &mut AliPayAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::ali_pay_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::ali_pay_account_payload(
                    AliPayAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::ali_pay_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ali_pay_account_payload(&mut self) -> AliPayAccountPayload {
        if self.has_ali_pay_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::ali_pay_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            AliPayAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.ChaseQuickPayAccountPayload chase_quick_pay_account_payload = 5;

    pub fn get_chase_quick_pay_account_payload(&self) -> &ChaseQuickPayAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::chase_quick_pay_account_payload(ref v),
            ) => v,
            _ => ChaseQuickPayAccountPayload::default_instance(),
        }
    }
    pub fn clear_chase_quick_pay_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_chase_quick_pay_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::chase_quick_pay_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chase_quick_pay_account_payload(&mut self, v: ChaseQuickPayAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::chase_quick_pay_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_chase_quick_pay_account_payload(&mut self) -> &mut ChaseQuickPayAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::chase_quick_pay_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::chase_quick_pay_account_payload(
                    ChaseQuickPayAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::chase_quick_pay_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chase_quick_pay_account_payload(&mut self) -> ChaseQuickPayAccountPayload {
        if self.has_chase_quick_pay_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::chase_quick_pay_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            ChaseQuickPayAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.ClearXchangeAccountPayload clear_xchange_account_payload = 6;

    pub fn get_clear_xchange_account_payload(&self) -> &ClearXchangeAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::clear_xchange_account_payload(ref v),
            ) => v,
            _ => ClearXchangeAccountPayload::default_instance(),
        }
    }
    pub fn clear_clear_xchange_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_clear_xchange_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::clear_xchange_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_clear_xchange_account_payload(&mut self, v: ClearXchangeAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::clear_xchange_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_clear_xchange_account_payload(&mut self) -> &mut ClearXchangeAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::clear_xchange_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::clear_xchange_account_payload(
                    ClearXchangeAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::clear_xchange_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_clear_xchange_account_payload(&mut self) -> ClearXchangeAccountPayload {
        if self.has_clear_xchange_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::clear_xchange_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            ClearXchangeAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.CountryBasedPaymentAccountPayload country_based_payment_account_payload = 7;

    pub fn get_country_based_payment_account_payload(&self) -> &CountryBasedPaymentAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::country_based_payment_account_payload(ref v),
            ) => v,
            _ => CountryBasedPaymentAccountPayload::default_instance(),
        }
    }
    pub fn clear_country_based_payment_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_country_based_payment_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::country_based_payment_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_country_based_payment_account_payload(
        &mut self,
        v: CountryBasedPaymentAccountPayload,
    ) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::country_based_payment_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_country_based_payment_account_payload(
        &mut self,
    ) -> &mut CountryBasedPaymentAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::country_based_payment_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::country_based_payment_account_payload(
                    CountryBasedPaymentAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::country_based_payment_account_payload(
                    ref mut v,
                ),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_country_based_payment_account_payload(
        &mut self,
    ) -> CountryBasedPaymentAccountPayload {
        if self.has_country_based_payment_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::country_based_payment_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            CountryBasedPaymentAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.CryptoCurrencyAccountPayload crypto_currency_account_payload = 8;

    pub fn get_crypto_currency_account_payload(&self) -> &CryptoCurrencyAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::crypto_currency_account_payload(ref v),
            ) => v,
            _ => CryptoCurrencyAccountPayload::default_instance(),
        }
    }
    pub fn clear_crypto_currency_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_crypto_currency_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::crypto_currency_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_crypto_currency_account_payload(&mut self, v: CryptoCurrencyAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::crypto_currency_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_crypto_currency_account_payload(&mut self) -> &mut CryptoCurrencyAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::crypto_currency_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::crypto_currency_account_payload(
                    CryptoCurrencyAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::crypto_currency_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_crypto_currency_account_payload(&mut self) -> CryptoCurrencyAccountPayload {
        if self.has_crypto_currency_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::crypto_currency_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            CryptoCurrencyAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.FasterPaymentsAccountPayload faster_payments_account_payload = 9;

    pub fn get_faster_payments_account_payload(&self) -> &FasterPaymentsAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::faster_payments_account_payload(ref v),
            ) => v,
            _ => FasterPaymentsAccountPayload::default_instance(),
        }
    }
    pub fn clear_faster_payments_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_faster_payments_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::faster_payments_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_faster_payments_account_payload(&mut self, v: FasterPaymentsAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::faster_payments_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_faster_payments_account_payload(&mut self) -> &mut FasterPaymentsAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::faster_payments_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::faster_payments_account_payload(
                    FasterPaymentsAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::faster_payments_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_faster_payments_account_payload(&mut self) -> FasterPaymentsAccountPayload {
        if self.has_faster_payments_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::faster_payments_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            FasterPaymentsAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.InteracETransferAccountPayload interac_e_transfer_account_payload = 10;

    pub fn get_interac_e_transfer_account_payload(&self) -> &InteracETransferAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::interac_e_transfer_account_payload(ref v),
            ) => v,
            _ => InteracETransferAccountPayload::default_instance(),
        }
    }
    pub fn clear_interac_e_transfer_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_interac_e_transfer_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::interac_e_transfer_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_interac_e_transfer_account_payload(&mut self, v: InteracETransferAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::interac_e_transfer_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_interac_e_transfer_account_payload(
        &mut self,
    ) -> &mut InteracETransferAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::interac_e_transfer_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::interac_e_transfer_account_payload(
                    InteracETransferAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::interac_e_transfer_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_interac_e_transfer_account_payload(&mut self) -> InteracETransferAccountPayload {
        if self.has_interac_e_transfer_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::interac_e_transfer_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            InteracETransferAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.OKPayAccountPayload o_k_pay_account_payload = 11;

    pub fn get_o_k_pay_account_payload(&self) -> &OKPayAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::o_k_pay_account_payload(ref v),
            ) => v,
            _ => OKPayAccountPayload::default_instance(),
        }
    }
    pub fn clear_o_k_pay_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_o_k_pay_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::o_k_pay_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_o_k_pay_account_payload(&mut self, v: OKPayAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::o_k_pay_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_o_k_pay_account_payload(&mut self) -> &mut OKPayAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::o_k_pay_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::o_k_pay_account_payload(
                    OKPayAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::o_k_pay_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_o_k_pay_account_payload(&mut self) -> OKPayAccountPayload {
        if self.has_o_k_pay_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::o_k_pay_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            OKPayAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.PerfectMoneyAccountPayload perfect_money_account_payload = 12;

    pub fn get_perfect_money_account_payload(&self) -> &PerfectMoneyAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::perfect_money_account_payload(ref v),
            ) => v,
            _ => PerfectMoneyAccountPayload::default_instance(),
        }
    }
    pub fn clear_perfect_money_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_perfect_money_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::perfect_money_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_perfect_money_account_payload(&mut self, v: PerfectMoneyAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::perfect_money_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_perfect_money_account_payload(&mut self) -> &mut PerfectMoneyAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::perfect_money_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::perfect_money_account_payload(
                    PerfectMoneyAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::perfect_money_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_perfect_money_account_payload(&mut self) -> PerfectMoneyAccountPayload {
        if self.has_perfect_money_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::perfect_money_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            PerfectMoneyAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.SwishAccountPayload swish_account_payload = 13;

    pub fn get_swish_account_payload(&self) -> &SwishAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::swish_account_payload(ref v),
            ) => v,
            _ => SwishAccountPayload::default_instance(),
        }
    }
    pub fn clear_swish_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_swish_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::swish_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_swish_account_payload(&mut self, v: SwishAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::swish_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_swish_account_payload(&mut self) -> &mut SwishAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::swish_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::swish_account_payload(
                    SwishAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::swish_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_swish_account_payload(&mut self) -> SwishAccountPayload {
        if self.has_swish_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::swish_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            SwishAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.USPostalMoneyOrderAccountPayload u_s_postal_money_order_account_payload = 14;

    pub fn get_u_s_postal_money_order_account_payload(&self) -> &USPostalMoneyOrderAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::u_s_postal_money_order_account_payload(ref v),
            ) => v,
            _ => USPostalMoneyOrderAccountPayload::default_instance(),
        }
    }
    pub fn clear_u_s_postal_money_order_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_u_s_postal_money_order_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::u_s_postal_money_order_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_u_s_postal_money_order_account_payload(
        &mut self,
        v: USPostalMoneyOrderAccountPayload,
    ) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::u_s_postal_money_order_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_u_s_postal_money_order_account_payload(
        &mut self,
    ) -> &mut USPostalMoneyOrderAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::u_s_postal_money_order_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::u_s_postal_money_order_account_payload(
                    USPostalMoneyOrderAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::u_s_postal_money_order_account_payload(
                    ref mut v,
                ),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_u_s_postal_money_order_account_payload(
        &mut self,
    ) -> USPostalMoneyOrderAccountPayload {
        if self.has_u_s_postal_money_order_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::u_s_postal_money_order_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            USPostalMoneyOrderAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.UpholdAccountPayload uphold_account_payload = 16;

    pub fn get_uphold_account_payload(&self) -> &UpholdAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::uphold_account_payload(ref v),
            ) => v,
            _ => UpholdAccountPayload::default_instance(),
        }
    }
    pub fn clear_uphold_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_uphold_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::uphold_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uphold_account_payload(&mut self, v: UpholdAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::uphold_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_uphold_account_payload(&mut self) -> &mut UpholdAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::uphold_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::uphold_account_payload(
                    UpholdAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::uphold_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_uphold_account_payload(&mut self) -> UpholdAccountPayload {
        if self.has_uphold_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::uphold_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            UpholdAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.CashAppAccountPayload cash_app_account_payload = 17;

    pub fn get_cash_app_account_payload(&self) -> &CashAppAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::cash_app_account_payload(ref v),
            ) => v,
            _ => CashAppAccountPayload::default_instance(),
        }
    }
    pub fn clear_cash_app_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_cash_app_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::cash_app_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cash_app_account_payload(&mut self, v: CashAppAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::cash_app_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_cash_app_account_payload(&mut self) -> &mut CashAppAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::cash_app_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::cash_app_account_payload(
                    CashAppAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::cash_app_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cash_app_account_payload(&mut self) -> CashAppAccountPayload {
        if self.has_cash_app_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::cash_app_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            CashAppAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.MoneyBeamAccountPayload money_beam_account_payload = 18;

    pub fn get_money_beam_account_payload(&self) -> &MoneyBeamAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::money_beam_account_payload(ref v),
            ) => v,
            _ => MoneyBeamAccountPayload::default_instance(),
        }
    }
    pub fn clear_money_beam_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_money_beam_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::money_beam_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_money_beam_account_payload(&mut self, v: MoneyBeamAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::money_beam_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_money_beam_account_payload(&mut self) -> &mut MoneyBeamAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::money_beam_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::money_beam_account_payload(
                    MoneyBeamAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::money_beam_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_money_beam_account_payload(&mut self) -> MoneyBeamAccountPayload {
        if self.has_money_beam_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::money_beam_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            MoneyBeamAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.VenmoAccountPayload venmo_account_payload = 19;

    pub fn get_venmo_account_payload(&self) -> &VenmoAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::venmo_account_payload(ref v),
            ) => v,
            _ => VenmoAccountPayload::default_instance(),
        }
    }
    pub fn clear_venmo_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_venmo_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::venmo_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_venmo_account_payload(&mut self, v: VenmoAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::venmo_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_venmo_account_payload(&mut self) -> &mut VenmoAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::venmo_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::venmo_account_payload(
                    VenmoAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::venmo_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_venmo_account_payload(&mut self) -> VenmoAccountPayload {
        if self.has_venmo_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::venmo_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            VenmoAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.PopmoneyAccountPayload popmoney_account_payload = 20;

    pub fn get_popmoney_account_payload(&self) -> &PopmoneyAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::popmoney_account_payload(ref v),
            ) => v,
            _ => PopmoneyAccountPayload::default_instance(),
        }
    }
    pub fn clear_popmoney_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_popmoney_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::popmoney_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_popmoney_account_payload(&mut self, v: PopmoneyAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::popmoney_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_popmoney_account_payload(&mut self) -> &mut PopmoneyAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::popmoney_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::popmoney_account_payload(
                    PopmoneyAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::popmoney_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_popmoney_account_payload(&mut self) -> PopmoneyAccountPayload {
        if self.has_popmoney_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::popmoney_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            PopmoneyAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.RevolutAccountPayload revolut_account_payload = 21;

    pub fn get_revolut_account_payload(&self) -> &RevolutAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::revolut_account_payload(ref v),
            ) => v,
            _ => RevolutAccountPayload::default_instance(),
        }
    }
    pub fn clear_revolut_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_revolut_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::revolut_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_revolut_account_payload(&mut self, v: RevolutAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::revolut_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_revolut_account_payload(&mut self) -> &mut RevolutAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::revolut_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::revolut_account_payload(
                    RevolutAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::revolut_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_revolut_account_payload(&mut self) -> RevolutAccountPayload {
        if self.has_revolut_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::revolut_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            RevolutAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.WeChatPayAccountPayload we_chat_pay_account_payload = 22;

    pub fn get_we_chat_pay_account_payload(&self) -> &WeChatPayAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::we_chat_pay_account_payload(ref v),
            ) => v,
            _ => WeChatPayAccountPayload::default_instance(),
        }
    }
    pub fn clear_we_chat_pay_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_we_chat_pay_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::we_chat_pay_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_we_chat_pay_account_payload(&mut self, v: WeChatPayAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::we_chat_pay_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_we_chat_pay_account_payload(&mut self) -> &mut WeChatPayAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::we_chat_pay_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::we_chat_pay_account_payload(
                    WeChatPayAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::we_chat_pay_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_we_chat_pay_account_payload(&mut self) -> WeChatPayAccountPayload {
        if self.has_we_chat_pay_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::we_chat_pay_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            WeChatPayAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.MoneyGramAccountPayload money_gram_account_payload = 23;

    pub fn get_money_gram_account_payload(&self) -> &MoneyGramAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::money_gram_account_payload(ref v),
            ) => v,
            _ => MoneyGramAccountPayload::default_instance(),
        }
    }
    pub fn clear_money_gram_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_money_gram_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::money_gram_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_money_gram_account_payload(&mut self, v: MoneyGramAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::money_gram_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_money_gram_account_payload(&mut self) -> &mut MoneyGramAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::money_gram_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::money_gram_account_payload(
                    MoneyGramAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::money_gram_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_money_gram_account_payload(&mut self) -> MoneyGramAccountPayload {
        if self.has_money_gram_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::money_gram_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            MoneyGramAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.HalCashAccountPayload hal_cash_account_payload = 24;

    pub fn get_hal_cash_account_payload(&self) -> &HalCashAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::hal_cash_account_payload(ref v),
            ) => v,
            _ => HalCashAccountPayload::default_instance(),
        }
    }
    pub fn clear_hal_cash_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_hal_cash_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::hal_cash_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hal_cash_account_payload(&mut self, v: HalCashAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::hal_cash_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_hal_cash_account_payload(&mut self) -> &mut HalCashAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::hal_cash_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::hal_cash_account_payload(
                    HalCashAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::hal_cash_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hal_cash_account_payload(&mut self) -> HalCashAccountPayload {
        if self.has_hal_cash_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::hal_cash_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            HalCashAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.PromptPayAccountPayload prompt_pay_account_payload = 25;

    pub fn get_prompt_pay_account_payload(&self) -> &PromptPayAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::prompt_pay_account_payload(ref v),
            ) => v,
            _ => PromptPayAccountPayload::default_instance(),
        }
    }
    pub fn clear_prompt_pay_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_prompt_pay_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::prompt_pay_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prompt_pay_account_payload(&mut self, v: PromptPayAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::prompt_pay_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_prompt_pay_account_payload(&mut self) -> &mut PromptPayAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::prompt_pay_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::prompt_pay_account_payload(
                    PromptPayAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::prompt_pay_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prompt_pay_account_payload(&mut self) -> PromptPayAccountPayload {
        if self.has_prompt_pay_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::prompt_pay_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            PromptPayAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.AdvancedCashAccountPayload advanced_cash_account_payload = 26;

    pub fn get_advanced_cash_account_payload(&self) -> &AdvancedCashAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::advanced_cash_account_payload(ref v),
            ) => v,
            _ => AdvancedCashAccountPayload::default_instance(),
        }
    }
    pub fn clear_advanced_cash_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_advanced_cash_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::advanced_cash_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_advanced_cash_account_payload(&mut self, v: AdvancedCashAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::advanced_cash_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_advanced_cash_account_payload(&mut self) -> &mut AdvancedCashAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::advanced_cash_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::advanced_cash_account_payload(
                    AdvancedCashAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::advanced_cash_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_advanced_cash_account_payload(&mut self) -> AdvancedCashAccountPayload {
        if self.has_advanced_cash_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::advanced_cash_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            AdvancedCashAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.InstantCryptoCurrencyAccountPayload instant_crypto_currency_account_payload = 27;

    pub fn get_instant_crypto_currency_account_payload(
        &self,
    ) -> &InstantCryptoCurrencyAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::instant_crypto_currency_account_payload(ref v),
            ) => v,
            _ => InstantCryptoCurrencyAccountPayload::default_instance(),
        }
    }
    pub fn clear_instant_crypto_currency_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_instant_crypto_currency_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::instant_crypto_currency_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instant_crypto_currency_account_payload(
        &mut self,
        v: InstantCryptoCurrencyAccountPayload,
    ) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::instant_crypto_currency_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_instant_crypto_currency_account_payload(
        &mut self,
    ) -> &mut InstantCryptoCurrencyAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::instant_crypto_currency_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::instant_crypto_currency_account_payload(
                    InstantCryptoCurrencyAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::instant_crypto_currency_account_payload(
                    ref mut v,
                ),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instant_crypto_currency_account_payload(
        &mut self,
    ) -> InstantCryptoCurrencyAccountPayload {
        if self.has_instant_crypto_currency_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::instant_crypto_currency_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            InstantCryptoCurrencyAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.JapanBankAccountPayload japan_bank_account_payload = 28;

    pub fn get_japan_bank_account_payload(&self) -> &JapanBankAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::japan_bank_account_payload(ref v),
            ) => v,
            _ => JapanBankAccountPayload::default_instance(),
        }
    }
    pub fn clear_japan_bank_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_japan_bank_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::japan_bank_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_japan_bank_account_payload(&mut self, v: JapanBankAccountPayload) {
        self.message = ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::japan_bank_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_japan_bank_account_payload(&mut self) -> &mut JapanBankAccountPayload {
        if let ::std::option::Option::Some(
            PaymentAccountPayload_oneof_message::japan_bank_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::japan_bank_account_payload(
                    JapanBankAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PaymentAccountPayload_oneof_message::japan_bank_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_japan_bank_account_payload(&mut self) -> JapanBankAccountPayload {
        if self.has_japan_bank_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PaymentAccountPayload_oneof_message::japan_bank_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            JapanBankAccountPayload::new()
        }
    }

    // repeated .io.bisq.protobuffer.PaymentAccountPayload.ExcludeFromJsonDataEntry exclude_from_json_data = 15;

    pub fn get_exclude_from_json_data(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.exclude_from_json_data
    }
    pub fn clear_exclude_from_json_data(&mut self) {
        self.exclude_from_json_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_exclude_from_json_data(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ) {
        self.exclude_from_json_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exclude_from_json_data(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.exclude_from_json_data
    }

    // Take field
    pub fn take_exclude_from_json_data(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(
            &mut self.exclude_from_json_data,
            ::std::collections::HashMap::new(),
        )
    }
}

impl ::protobuf::Message for PaymentAccountPayload {
    fn is_initialized(&self) -> bool {
        if let Some(PaymentAccountPayload_oneof_message::ali_pay_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::chase_quick_pay_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::clear_xchange_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::country_based_payment_account_payload(
            ref v,
        )) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::crypto_currency_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::faster_payments_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::interac_e_transfer_account_payload(
            ref v,
        )) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::o_k_pay_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::perfect_money_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::swish_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::u_s_postal_money_order_account_payload(
            ref v,
        )) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::uphold_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::cash_app_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::money_beam_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::venmo_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::popmoney_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::revolut_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::we_chat_pay_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::money_gram_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::hal_cash_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::prompt_pay_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::advanced_cash_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::instant_crypto_currency_account_payload(
            ref v,
        )) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PaymentAccountPayload_oneof_message::japan_bank_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.payment_method_id,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.max_trade_period = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::ali_pay_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::chase_quick_pay_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::clear_xchange_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::country_based_payment_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::crypto_currency_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::faster_payments_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::interac_e_transfer_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::o_k_pay_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::perfect_money_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::swish_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::u_s_postal_money_order_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::uphold_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::cash_app_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::money_beam_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::venmo_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::popmoney_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::revolut_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::we_chat_pay_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::money_gram_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::hal_cash_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::prompt_pay_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::advanced_cash_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(PaymentAccountPayload_oneof_message::instant_crypto_currency_account_payload(is.read_message()?));
                }
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PaymentAccountPayload_oneof_message::japan_bank_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                15 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeString,
                    >(wire_type, is, &mut self.exclude_from_json_data)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.payment_method_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payment_method_id);
        }
        if self.max_trade_period != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.max_trade_period,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(15, &self.exclude_from_json_data);
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &PaymentAccountPayload_oneof_message::ali_pay_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::chase_quick_pay_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::clear_xchange_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::country_based_payment_account_payload(
                    ref v,
                ) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::crypto_currency_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::faster_payments_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::interac_e_transfer_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::o_k_pay_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::perfect_money_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::swish_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::u_s_postal_money_order_account_payload(
                    ref v,
                ) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::uphold_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::cash_app_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::money_beam_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::venmo_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::popmoney_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::revolut_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::we_chat_pay_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::money_gram_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::hal_cash_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::prompt_pay_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::advanced_cash_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::instant_crypto_currency_account_payload(
                    ref v,
                ) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PaymentAccountPayload_oneof_message::japan_bank_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.payment_method_id.is_empty() {
            os.write_string(2, &self.payment_method_id)?;
        }
        if self.max_trade_period != 0 {
            os.write_int64(3, self.max_trade_period)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(15, &self.exclude_from_json_data, os)?;
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &PaymentAccountPayload_oneof_message::ali_pay_account_payload(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::chase_quick_pay_account_payload(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::clear_xchange_account_payload(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::country_based_payment_account_payload(
                    ref v,
                ) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::crypto_currency_account_payload(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::faster_payments_account_payload(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::interac_e_transfer_account_payload(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::o_k_pay_account_payload(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::perfect_money_account_payload(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::swish_account_payload(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::u_s_postal_money_order_account_payload(
                    ref v,
                ) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::uphold_account_payload(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::cash_app_account_payload(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::money_beam_account_payload(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::venmo_account_payload(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::popmoney_account_payload(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::revolut_account_payload(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::we_chat_pay_account_payload(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::money_gram_account_payload(ref v) => {
                    os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::hal_cash_account_payload(ref v) => {
                    os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::prompt_pay_account_payload(ref v) => {
                    os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::advanced_cash_account_payload(ref v) => {
                    os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::instant_crypto_currency_account_payload(
                    ref v,
                ) => {
                    os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PaymentAccountPayload_oneof_message::japan_bank_account_payload(ref v) => {
                    os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaymentAccountPayload {
        PaymentAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "id",
                    |m: &PaymentAccountPayload| &m.id,
                    |m: &mut PaymentAccountPayload| &mut m.id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "payment_method_id",
                    |m: &PaymentAccountPayload| &m.payment_method_id,
                    |m: &mut PaymentAccountPayload| &mut m.payment_method_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "max_trade_period",
                    |m: &PaymentAccountPayload| &m.max_trade_period,
                    |m: &mut PaymentAccountPayload| &mut m.max_trade_period,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        AliPayAccountPayload,
                    >(
                        "ali_pay_account_payload",
                        PaymentAccountPayload::has_ali_pay_account_payload,
                        PaymentAccountPayload::get_ali_pay_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        ChaseQuickPayAccountPayload,
                    >(
                        "chase_quick_pay_account_payload",
                        PaymentAccountPayload::has_chase_quick_pay_account_payload,
                        PaymentAccountPayload::get_chase_quick_pay_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        ClearXchangeAccountPayload,
                    >(
                        "clear_xchange_account_payload",
                        PaymentAccountPayload::has_clear_xchange_account_payload,
                        PaymentAccountPayload::get_clear_xchange_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        CountryBasedPaymentAccountPayload,
                    >(
                        "country_based_payment_account_payload",
                        PaymentAccountPayload::has_country_based_payment_account_payload,
                        PaymentAccountPayload::get_country_based_payment_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        CryptoCurrencyAccountPayload,
                    >(
                        "crypto_currency_account_payload",
                        PaymentAccountPayload::has_crypto_currency_account_payload,
                        PaymentAccountPayload::get_crypto_currency_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        FasterPaymentsAccountPayload,
                    >(
                        "faster_payments_account_payload",
                        PaymentAccountPayload::has_faster_payments_account_payload,
                        PaymentAccountPayload::get_faster_payments_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        InteracETransferAccountPayload,
                    >(
                        "interac_e_transfer_account_payload",
                        PaymentAccountPayload::has_interac_e_transfer_account_payload,
                        PaymentAccountPayload::get_interac_e_transfer_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        OKPayAccountPayload,
                    >(
                        "o_k_pay_account_payload",
                        PaymentAccountPayload::has_o_k_pay_account_payload,
                        PaymentAccountPayload::get_o_k_pay_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        PerfectMoneyAccountPayload,
                    >(
                        "perfect_money_account_payload",
                        PaymentAccountPayload::has_perfect_money_account_payload,
                        PaymentAccountPayload::get_perfect_money_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        SwishAccountPayload,
                    >(
                        "swish_account_payload",
                        PaymentAccountPayload::has_swish_account_payload,
                        PaymentAccountPayload::get_swish_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        USPostalMoneyOrderAccountPayload,
                    >(
                        "u_s_postal_money_order_account_payload",
                        PaymentAccountPayload::has_u_s_postal_money_order_account_payload,
                        PaymentAccountPayload::get_u_s_postal_money_order_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        UpholdAccountPayload,
                    >(
                        "uphold_account_payload",
                        PaymentAccountPayload::has_uphold_account_payload,
                        PaymentAccountPayload::get_uphold_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        CashAppAccountPayload,
                    >(
                        "cash_app_account_payload",
                        PaymentAccountPayload::has_cash_app_account_payload,
                        PaymentAccountPayload::get_cash_app_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        MoneyBeamAccountPayload,
                    >(
                        "money_beam_account_payload",
                        PaymentAccountPayload::has_money_beam_account_payload,
                        PaymentAccountPayload::get_money_beam_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        VenmoAccountPayload,
                    >(
                        "venmo_account_payload",
                        PaymentAccountPayload::has_venmo_account_payload,
                        PaymentAccountPayload::get_venmo_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        PopmoneyAccountPayload,
                    >(
                        "popmoney_account_payload",
                        PaymentAccountPayload::has_popmoney_account_payload,
                        PaymentAccountPayload::get_popmoney_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        RevolutAccountPayload,
                    >(
                        "revolut_account_payload",
                        PaymentAccountPayload::has_revolut_account_payload,
                        PaymentAccountPayload::get_revolut_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        WeChatPayAccountPayload,
                    >(
                        "we_chat_pay_account_payload",
                        PaymentAccountPayload::has_we_chat_pay_account_payload,
                        PaymentAccountPayload::get_we_chat_pay_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        MoneyGramAccountPayload,
                    >(
                        "money_gram_account_payload",
                        PaymentAccountPayload::has_money_gram_account_payload,
                        PaymentAccountPayload::get_money_gram_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        HalCashAccountPayload,
                    >(
                        "hal_cash_account_payload",
                        PaymentAccountPayload::has_hal_cash_account_payload,
                        PaymentAccountPayload::get_hal_cash_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        PromptPayAccountPayload,
                    >(
                        "prompt_pay_account_payload",
                        PaymentAccountPayload::has_prompt_pay_account_payload,
                        PaymentAccountPayload::get_prompt_pay_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        AdvancedCashAccountPayload,
                    >(
                        "advanced_cash_account_payload",
                        PaymentAccountPayload::has_advanced_cash_account_payload,
                        PaymentAccountPayload::get_advanced_cash_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        InstantCryptoCurrencyAccountPayload,
                    >(
                        "instant_crypto_currency_account_payload",
                        PaymentAccountPayload::has_instant_crypto_currency_account_payload,
                        PaymentAccountPayload::get_instant_crypto_currency_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        JapanBankAccountPayload,
                    >(
                        "japan_bank_account_payload",
                        PaymentAccountPayload::has_japan_bank_account_payload,
                        PaymentAccountPayload::get_japan_bank_account_payload,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "exclude_from_json_data",
                    |m: &PaymentAccountPayload| &m.exclude_from_json_data,
                    |m: &mut PaymentAccountPayload| &mut m.exclude_from_json_data,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PaymentAccountPayload>(
                    "PaymentAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PaymentAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<PaymentAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PaymentAccountPayload,
            };
        unsafe { instance.get(PaymentAccountPayload::new) }
    }
}

impl ::protobuf::Clear for PaymentAccountPayload {
    fn clear(&mut self) {
        self.id.clear();
        self.payment_method_id.clear();
        self.max_trade_period = 0;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.exclude_from_json_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct AliPayAccountPayload {
    // message fields
    pub account_nr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AliPayAccountPayload {
    fn default() -> &'a AliPayAccountPayload {
        <AliPayAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl AliPayAccountPayload {
    pub fn new() -> AliPayAccountPayload {
        ::std::default::Default::default()
    }

    // string account_nr = 1;

    pub fn get_account_nr(&self) -> &str {
        &self.account_nr
    }
    pub fn clear_account_nr(&mut self) {
        self.account_nr.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_nr(&mut self, v: ::std::string::String) {
        self.account_nr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_nr(&mut self) -> &mut ::std::string::String {
        &mut self.account_nr
    }

    // Take field
    pub fn take_account_nr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_nr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AliPayAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_nr,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_nr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_nr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.account_nr.is_empty() {
            os.write_string(1, &self.account_nr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AliPayAccountPayload {
        AliPayAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_nr",
                    |m: &AliPayAccountPayload| &m.account_nr,
                    |m: &mut AliPayAccountPayload| &mut m.account_nr,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AliPayAccountPayload>(
                    "AliPayAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static AliPayAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<AliPayAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const AliPayAccountPayload,
            };
        unsafe { instance.get(AliPayAccountPayload::new) }
    }
}

impl ::protobuf::Clear for AliPayAccountPayload {
    fn clear(&mut self) {
        self.account_nr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AliPayAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AliPayAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct WeChatPayAccountPayload {
    // message fields
    pub account_nr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WeChatPayAccountPayload {
    fn default() -> &'a WeChatPayAccountPayload {
        <WeChatPayAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl WeChatPayAccountPayload {
    pub fn new() -> WeChatPayAccountPayload {
        ::std::default::Default::default()
    }

    // string account_nr = 1;

    pub fn get_account_nr(&self) -> &str {
        &self.account_nr
    }
    pub fn clear_account_nr(&mut self) {
        self.account_nr.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_nr(&mut self, v: ::std::string::String) {
        self.account_nr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_nr(&mut self) -> &mut ::std::string::String {
        &mut self.account_nr
    }

    // Take field
    pub fn take_account_nr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_nr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WeChatPayAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_nr,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_nr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_nr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.account_nr.is_empty() {
            os.write_string(1, &self.account_nr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WeChatPayAccountPayload {
        WeChatPayAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_nr",
                    |m: &WeChatPayAccountPayload| &m.account_nr,
                    |m: &mut WeChatPayAccountPayload| &mut m.account_nr,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WeChatPayAccountPayload>(
                    "WeChatPayAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static WeChatPayAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<WeChatPayAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const WeChatPayAccountPayload,
            };
        unsafe { instance.get(WeChatPayAccountPayload::new) }
    }
}

impl ::protobuf::Clear for WeChatPayAccountPayload {
    fn clear(&mut self) {
        self.account_nr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WeChatPayAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WeChatPayAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ChaseQuickPayAccountPayload {
    // message fields
    pub email: ::std::string::String,
    pub holder_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChaseQuickPayAccountPayload {
    fn default() -> &'a ChaseQuickPayAccountPayload {
        <ChaseQuickPayAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl ChaseQuickPayAccountPayload {
    pub fn new() -> ChaseQuickPayAccountPayload {
        ::std::default::Default::default()
    }

    // string email = 1;

    pub fn get_email(&self) -> &str {
        &self.email
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email, ::std::string::String::new())
    }

    // string holder_name = 2;

    pub fn get_holder_name(&self) -> &str {
        &self.holder_name
    }
    pub fn clear_holder_name(&mut self) {
        self.holder_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_name(&mut self, v: ::std::string::String) {
        self.holder_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_name(&mut self) -> &mut ::std::string::String {
        &mut self.holder_name
    }

    // Take field
    pub fn take_holder_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChaseQuickPayAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.email,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.email);
        }
        if !self.holder_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.holder_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.email.is_empty() {
            os.write_string(1, &self.email)?;
        }
        if !self.holder_name.is_empty() {
            os.write_string(2, &self.holder_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChaseQuickPayAccountPayload {
        ChaseQuickPayAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "email",
                    |m: &ChaseQuickPayAccountPayload| &m.email,
                    |m: &mut ChaseQuickPayAccountPayload| &mut m.email,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_name",
                    |m: &ChaseQuickPayAccountPayload| &m.holder_name,
                    |m: &mut ChaseQuickPayAccountPayload| &mut m.holder_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChaseQuickPayAccountPayload>(
                    "ChaseQuickPayAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ChaseQuickPayAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<ChaseQuickPayAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ChaseQuickPayAccountPayload,
            };
        unsafe { instance.get(ChaseQuickPayAccountPayload::new) }
    }
}

impl ::protobuf::Clear for ChaseQuickPayAccountPayload {
    fn clear(&mut self) {
        self.email.clear();
        self.holder_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChaseQuickPayAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChaseQuickPayAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ClearXchangeAccountPayload {
    // message fields
    pub holder_name: ::std::string::String,
    pub email_or_mobile_nr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClearXchangeAccountPayload {
    fn default() -> &'a ClearXchangeAccountPayload {
        <ClearXchangeAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl ClearXchangeAccountPayload {
    pub fn new() -> ClearXchangeAccountPayload {
        ::std::default::Default::default()
    }

    // string holder_name = 1;

    pub fn get_holder_name(&self) -> &str {
        &self.holder_name
    }
    pub fn clear_holder_name(&mut self) {
        self.holder_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_name(&mut self, v: ::std::string::String) {
        self.holder_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_name(&mut self) -> &mut ::std::string::String {
        &mut self.holder_name
    }

    // Take field
    pub fn take_holder_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_name, ::std::string::String::new())
    }

    // string email_or_mobile_nr = 2;

    pub fn get_email_or_mobile_nr(&self) -> &str {
        &self.email_or_mobile_nr
    }
    pub fn clear_email_or_mobile_nr(&mut self) {
        self.email_or_mobile_nr.clear();
    }

    // Param is passed by value, moved
    pub fn set_email_or_mobile_nr(&mut self, v: ::std::string::String) {
        self.email_or_mobile_nr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email_or_mobile_nr(&mut self) -> &mut ::std::string::String {
        &mut self.email_or_mobile_nr
    }

    // Take field
    pub fn take_email_or_mobile_nr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email_or_mobile_nr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClearXchangeAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.email_or_mobile_nr,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.holder_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.holder_name);
        }
        if !self.email_or_mobile_nr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.email_or_mobile_nr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.holder_name.is_empty() {
            os.write_string(1, &self.holder_name)?;
        }
        if !self.email_or_mobile_nr.is_empty() {
            os.write_string(2, &self.email_or_mobile_nr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClearXchangeAccountPayload {
        ClearXchangeAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_name",
                    |m: &ClearXchangeAccountPayload| &m.holder_name,
                    |m: &mut ClearXchangeAccountPayload| &mut m.holder_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "email_or_mobile_nr",
                    |m: &ClearXchangeAccountPayload| &m.email_or_mobile_nr,
                    |m: &mut ClearXchangeAccountPayload| &mut m.email_or_mobile_nr,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClearXchangeAccountPayload>(
                    "ClearXchangeAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ClearXchangeAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<ClearXchangeAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ClearXchangeAccountPayload,
            };
        unsafe { instance.get(ClearXchangeAccountPayload::new) }
    }
}

impl ::protobuf::Clear for ClearXchangeAccountPayload {
    fn clear(&mut self) {
        self.holder_name.clear();
        self.email_or_mobile_nr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClearXchangeAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClearXchangeAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct CountryBasedPaymentAccountPayload {
    // message fields
    pub countryCode: ::std::string::String,
    // message oneof groups
    pub message: ::std::option::Option<CountryBasedPaymentAccountPayload_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CountryBasedPaymentAccountPayload {
    fn default() -> &'a CountryBasedPaymentAccountPayload {
        <CountryBasedPaymentAccountPayload as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum CountryBasedPaymentAccountPayload_oneof_message {
    bank_account_payload(BankAccountPayload),
    cash_deposit_account_payload(CashDepositAccountPayload),
    sepa_account_payload(SepaAccountPayload),
    western_union_account_payload(WesternUnionAccountPayload),
    sepa_instant_account_payload(SepaInstantAccountPayload),
    f2f_account_payload(F2FAccountPayload),
}

impl CountryBasedPaymentAccountPayload {
    pub fn new() -> CountryBasedPaymentAccountPayload {
        ::std::default::Default::default()
    }

    // string countryCode = 1;

    pub fn get_countryCode(&self) -> &str {
        &self.countryCode
    }
    pub fn clear_countryCode(&mut self) {
        self.countryCode.clear();
    }

    // Param is passed by value, moved
    pub fn set_countryCode(&mut self, v: ::std::string::String) {
        self.countryCode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_countryCode(&mut self) -> &mut ::std::string::String {
        &mut self.countryCode
    }

    // Take field
    pub fn take_countryCode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.countryCode, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.BankAccountPayload bank_account_payload = 2;

    pub fn get_bank_account_payload(&self) -> &BankAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::bank_account_payload(ref v),
            ) => v,
            _ => BankAccountPayload::default_instance(),
        }
    }
    pub fn clear_bank_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_bank_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::bank_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bank_account_payload(&mut self, v: BankAccountPayload) {
        self.message = ::std::option::Option::Some(
            CountryBasedPaymentAccountPayload_oneof_message::bank_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_bank_account_payload(&mut self) -> &mut BankAccountPayload {
        if let ::std::option::Option::Some(
            CountryBasedPaymentAccountPayload_oneof_message::bank_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::bank_account_payload(
                    BankAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::bank_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bank_account_payload(&mut self) -> BankAccountPayload {
        if self.has_bank_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    CountryBasedPaymentAccountPayload_oneof_message::bank_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            BankAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.CashDepositAccountPayload cash_deposit_account_payload = 3;

    pub fn get_cash_deposit_account_payload(&self) -> &CashDepositAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::cash_deposit_account_payload(
                    ref v,
                ),
            ) => v,
            _ => CashDepositAccountPayload::default_instance(),
        }
    }
    pub fn clear_cash_deposit_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_cash_deposit_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::cash_deposit_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cash_deposit_account_payload(&mut self, v: CashDepositAccountPayload) {
        self.message = ::std::option::Option::Some(
            CountryBasedPaymentAccountPayload_oneof_message::cash_deposit_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_cash_deposit_account_payload(&mut self) -> &mut CashDepositAccountPayload {
        if let ::std::option::Option::Some(
            CountryBasedPaymentAccountPayload_oneof_message::cash_deposit_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::cash_deposit_account_payload(
                    CashDepositAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::cash_deposit_account_payload(
                    ref mut v,
                ),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cash_deposit_account_payload(&mut self) -> CashDepositAccountPayload {
        if self.has_cash_deposit_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    CountryBasedPaymentAccountPayload_oneof_message::cash_deposit_account_payload(
                        v,
                    ),
                ) => v,
                _ => panic!(),
            }
        } else {
            CashDepositAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.SepaAccountPayload sepa_account_payload = 4;

    pub fn get_sepa_account_payload(&self) -> &SepaAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::sepa_account_payload(ref v),
            ) => v,
            _ => SepaAccountPayload::default_instance(),
        }
    }
    pub fn clear_sepa_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_sepa_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::sepa_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sepa_account_payload(&mut self, v: SepaAccountPayload) {
        self.message = ::std::option::Option::Some(
            CountryBasedPaymentAccountPayload_oneof_message::sepa_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_sepa_account_payload(&mut self) -> &mut SepaAccountPayload {
        if let ::std::option::Option::Some(
            CountryBasedPaymentAccountPayload_oneof_message::sepa_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::sepa_account_payload(
                    SepaAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::sepa_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sepa_account_payload(&mut self) -> SepaAccountPayload {
        if self.has_sepa_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    CountryBasedPaymentAccountPayload_oneof_message::sepa_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            SepaAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.WesternUnionAccountPayload western_union_account_payload = 5;

    pub fn get_western_union_account_payload(&self) -> &WesternUnionAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::western_union_account_payload(
                    ref v,
                ),
            ) => v,
            _ => WesternUnionAccountPayload::default_instance(),
        }
    }
    pub fn clear_western_union_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_western_union_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::western_union_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_western_union_account_payload(&mut self, v: WesternUnionAccountPayload) {
        self.message = ::std::option::Option::Some(
            CountryBasedPaymentAccountPayload_oneof_message::western_union_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_western_union_account_payload(&mut self) -> &mut WesternUnionAccountPayload {
        if let ::std::option::Option::Some(
            CountryBasedPaymentAccountPayload_oneof_message::western_union_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::western_union_account_payload(
                    WesternUnionAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::western_union_account_payload(
                    ref mut v,
                ),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_western_union_account_payload(&mut self) -> WesternUnionAccountPayload {
        if self.has_western_union_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    CountryBasedPaymentAccountPayload_oneof_message::western_union_account_payload(
                        v,
                    ),
                ) => v,
                _ => panic!(),
            }
        } else {
            WesternUnionAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.SepaInstantAccountPayload sepa_instant_account_payload = 6;

    pub fn get_sepa_instant_account_payload(&self) -> &SepaInstantAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::sepa_instant_account_payload(
                    ref v,
                ),
            ) => v,
            _ => SepaInstantAccountPayload::default_instance(),
        }
    }
    pub fn clear_sepa_instant_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_sepa_instant_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::sepa_instant_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sepa_instant_account_payload(&mut self, v: SepaInstantAccountPayload) {
        self.message = ::std::option::Option::Some(
            CountryBasedPaymentAccountPayload_oneof_message::sepa_instant_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_sepa_instant_account_payload(&mut self) -> &mut SepaInstantAccountPayload {
        if let ::std::option::Option::Some(
            CountryBasedPaymentAccountPayload_oneof_message::sepa_instant_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::sepa_instant_account_payload(
                    SepaInstantAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::sepa_instant_account_payload(
                    ref mut v,
                ),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sepa_instant_account_payload(&mut self) -> SepaInstantAccountPayload {
        if self.has_sepa_instant_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    CountryBasedPaymentAccountPayload_oneof_message::sepa_instant_account_payload(
                        v,
                    ),
                ) => v,
                _ => panic!(),
            }
        } else {
            SepaInstantAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.F2FAccountPayload f2f_account_payload = 7;

    pub fn get_f2f_account_payload(&self) -> &F2FAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::f2f_account_payload(ref v),
            ) => v,
            _ => F2FAccountPayload::default_instance(),
        }
    }
    pub fn clear_f2f_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_f2f_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::f2f_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_f2f_account_payload(&mut self, v: F2FAccountPayload) {
        self.message = ::std::option::Option::Some(
            CountryBasedPaymentAccountPayload_oneof_message::f2f_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_f2f_account_payload(&mut self) -> &mut F2FAccountPayload {
        if let ::std::option::Option::Some(
            CountryBasedPaymentAccountPayload_oneof_message::f2f_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::f2f_account_payload(
                    F2FAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                CountryBasedPaymentAccountPayload_oneof_message::f2f_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_f2f_account_payload(&mut self) -> F2FAccountPayload {
        if self.has_f2f_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    CountryBasedPaymentAccountPayload_oneof_message::f2f_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            F2FAccountPayload::new()
        }
    }
}

impl ::protobuf::Message for CountryBasedPaymentAccountPayload {
    fn is_initialized(&self) -> bool {
        if let Some(CountryBasedPaymentAccountPayload_oneof_message::bank_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(
            CountryBasedPaymentAccountPayload_oneof_message::cash_deposit_account_payload(ref v),
        ) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CountryBasedPaymentAccountPayload_oneof_message::sepa_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(
            CountryBasedPaymentAccountPayload_oneof_message::western_union_account_payload(ref v),
        ) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(
            CountryBasedPaymentAccountPayload_oneof_message::sepa_instant_account_payload(ref v),
        ) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CountryBasedPaymentAccountPayload_oneof_message::f2f_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.countryCode,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        CountryBasedPaymentAccountPayload_oneof_message::bank_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(CountryBasedPaymentAccountPayload_oneof_message::cash_deposit_account_payload(is.read_message()?));
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        CountryBasedPaymentAccountPayload_oneof_message::sepa_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(CountryBasedPaymentAccountPayload_oneof_message::western_union_account_payload(is.read_message()?));
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(CountryBasedPaymentAccountPayload_oneof_message::sepa_instant_account_payload(is.read_message()?));
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        CountryBasedPaymentAccountPayload_oneof_message::f2f_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.countryCode.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.countryCode);
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &CountryBasedPaymentAccountPayload_oneof_message::bank_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &CountryBasedPaymentAccountPayload_oneof_message::cash_deposit_account_payload(
                    ref v,
                ) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &CountryBasedPaymentAccountPayload_oneof_message::sepa_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &CountryBasedPaymentAccountPayload_oneof_message::western_union_account_payload(
                    ref v,
                ) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &CountryBasedPaymentAccountPayload_oneof_message::sepa_instant_account_payload(
                    ref v,
                ) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &CountryBasedPaymentAccountPayload_oneof_message::f2f_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.countryCode.is_empty() {
            os.write_string(1, &self.countryCode)?;
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &CountryBasedPaymentAccountPayload_oneof_message::bank_account_payload(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &CountryBasedPaymentAccountPayload_oneof_message::cash_deposit_account_payload(
                    ref v,
                ) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &CountryBasedPaymentAccountPayload_oneof_message::sepa_account_payload(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &CountryBasedPaymentAccountPayload_oneof_message::western_union_account_payload(
                    ref v,
                ) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &CountryBasedPaymentAccountPayload_oneof_message::sepa_instant_account_payload(
                    ref v,
                ) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &CountryBasedPaymentAccountPayload_oneof_message::f2f_account_payload(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CountryBasedPaymentAccountPayload {
        CountryBasedPaymentAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "countryCode",
                    |m: &CountryBasedPaymentAccountPayload| &m.countryCode,
                    |m: &mut CountryBasedPaymentAccountPayload| &mut m.countryCode,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        BankAccountPayload,
                    >(
                        "bank_account_payload",
                        CountryBasedPaymentAccountPayload::has_bank_account_payload,
                        CountryBasedPaymentAccountPayload::get_bank_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        CashDepositAccountPayload,
                    >(
                        "cash_deposit_account_payload",
                        CountryBasedPaymentAccountPayload::has_cash_deposit_account_payload,
                        CountryBasedPaymentAccountPayload::get_cash_deposit_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        SepaAccountPayload,
                    >(
                        "sepa_account_payload",
                        CountryBasedPaymentAccountPayload::has_sepa_account_payload,
                        CountryBasedPaymentAccountPayload::get_sepa_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        WesternUnionAccountPayload,
                    >(
                        "western_union_account_payload",
                        CountryBasedPaymentAccountPayload::has_western_union_account_payload,
                        CountryBasedPaymentAccountPayload::get_western_union_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        SepaInstantAccountPayload,
                    >(
                        "sepa_instant_account_payload",
                        CountryBasedPaymentAccountPayload::has_sepa_instant_account_payload,
                        CountryBasedPaymentAccountPayload::get_sepa_instant_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        F2FAccountPayload,
                    >(
                        "f2f_account_payload",
                        CountryBasedPaymentAccountPayload::has_f2f_account_payload,
                        CountryBasedPaymentAccountPayload::get_f2f_account_payload,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<CountryBasedPaymentAccountPayload>(
                    "CountryBasedPaymentAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static CountryBasedPaymentAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<CountryBasedPaymentAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const CountryBasedPaymentAccountPayload,
            };
        unsafe { instance.get(CountryBasedPaymentAccountPayload::new) }
    }
}

impl ::protobuf::Clear for CountryBasedPaymentAccountPayload {
    fn clear(&mut self) {
        self.countryCode.clear();
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CountryBasedPaymentAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CountryBasedPaymentAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct BankAccountPayload {
    // message fields
    pub holder_name: ::std::string::String,
    pub bank_name: ::std::string::String,
    pub bank_id: ::std::string::String,
    pub branch_id: ::std::string::String,
    pub account_nr: ::std::string::String,
    pub account_type: ::std::string::String,
    pub holder_tax_id: ::std::string::String,
    pub email: ::std::string::String,
    pub national_account_id: ::std::string::String,
    // message oneof groups
    pub message: ::std::option::Option<BankAccountPayload_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BankAccountPayload {
    fn default() -> &'a BankAccountPayload {
        <BankAccountPayload as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum BankAccountPayload_oneof_message {
    national_bank_account_payload(NationalBankAccountPayload),
    same_bank_accont_payload(SameBankAccountPayload),
    specific_banks_account_payload(SpecificBanksAccountPayload),
}

impl BankAccountPayload {
    pub fn new() -> BankAccountPayload {
        ::std::default::Default::default()
    }

    // string holder_name = 1;

    pub fn get_holder_name(&self) -> &str {
        &self.holder_name
    }
    pub fn clear_holder_name(&mut self) {
        self.holder_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_name(&mut self, v: ::std::string::String) {
        self.holder_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_name(&mut self) -> &mut ::std::string::String {
        &mut self.holder_name
    }

    // Take field
    pub fn take_holder_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_name, ::std::string::String::new())
    }

    // string bank_name = 2;

    pub fn get_bank_name(&self) -> &str {
        &self.bank_name
    }
    pub fn clear_bank_name(&mut self) {
        self.bank_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_bank_name(&mut self, v: ::std::string::String) {
        self.bank_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bank_name(&mut self) -> &mut ::std::string::String {
        &mut self.bank_name
    }

    // Take field
    pub fn take_bank_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bank_name, ::std::string::String::new())
    }

    // string bank_id = 3;

    pub fn get_bank_id(&self) -> &str {
        &self.bank_id
    }
    pub fn clear_bank_id(&mut self) {
        self.bank_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_bank_id(&mut self, v: ::std::string::String) {
        self.bank_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bank_id(&mut self) -> &mut ::std::string::String {
        &mut self.bank_id
    }

    // Take field
    pub fn take_bank_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bank_id, ::std::string::String::new())
    }

    // string branch_id = 4;

    pub fn get_branch_id(&self) -> &str {
        &self.branch_id
    }
    pub fn clear_branch_id(&mut self) {
        self.branch_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_branch_id(&mut self, v: ::std::string::String) {
        self.branch_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_branch_id(&mut self) -> &mut ::std::string::String {
        &mut self.branch_id
    }

    // Take field
    pub fn take_branch_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.branch_id, ::std::string::String::new())
    }

    // string account_nr = 5;

    pub fn get_account_nr(&self) -> &str {
        &self.account_nr
    }
    pub fn clear_account_nr(&mut self) {
        self.account_nr.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_nr(&mut self, v: ::std::string::String) {
        self.account_nr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_nr(&mut self) -> &mut ::std::string::String {
        &mut self.account_nr
    }

    // Take field
    pub fn take_account_nr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_nr, ::std::string::String::new())
    }

    // string account_type = 6;

    pub fn get_account_type(&self) -> &str {
        &self.account_type
    }
    pub fn clear_account_type(&mut self) {
        self.account_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_type(&mut self, v: ::std::string::String) {
        self.account_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_type(&mut self) -> &mut ::std::string::String {
        &mut self.account_type
    }

    // Take field
    pub fn take_account_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_type, ::std::string::String::new())
    }

    // string holder_tax_id = 7;

    pub fn get_holder_tax_id(&self) -> &str {
        &self.holder_tax_id
    }
    pub fn clear_holder_tax_id(&mut self) {
        self.holder_tax_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_tax_id(&mut self, v: ::std::string::String) {
        self.holder_tax_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_tax_id(&mut self) -> &mut ::std::string::String {
        &mut self.holder_tax_id
    }

    // Take field
    pub fn take_holder_tax_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_tax_id, ::std::string::String::new())
    }

    // string email = 8;

    pub fn get_email(&self) -> &str {
        &self.email
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.NationalBankAccountPayload national_bank_account_payload = 9;

    pub fn get_national_bank_account_payload(&self) -> &NationalBankAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                BankAccountPayload_oneof_message::national_bank_account_payload(ref v),
            ) => v,
            _ => NationalBankAccountPayload::default_instance(),
        }
    }
    pub fn clear_national_bank_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_national_bank_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                BankAccountPayload_oneof_message::national_bank_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_national_bank_account_payload(&mut self, v: NationalBankAccountPayload) {
        self.message = ::std::option::Option::Some(
            BankAccountPayload_oneof_message::national_bank_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_national_bank_account_payload(&mut self) -> &mut NationalBankAccountPayload {
        if let ::std::option::Option::Some(
            BankAccountPayload_oneof_message::national_bank_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                BankAccountPayload_oneof_message::national_bank_account_payload(
                    NationalBankAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                BankAccountPayload_oneof_message::national_bank_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_national_bank_account_payload(&mut self) -> NationalBankAccountPayload {
        if self.has_national_bank_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    BankAccountPayload_oneof_message::national_bank_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            NationalBankAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.SameBankAccountPayload same_bank_accont_payload = 10;

    pub fn get_same_bank_accont_payload(&self) -> &SameBankAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                BankAccountPayload_oneof_message::same_bank_accont_payload(ref v),
            ) => v,
            _ => SameBankAccountPayload::default_instance(),
        }
    }
    pub fn clear_same_bank_accont_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_same_bank_accont_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                BankAccountPayload_oneof_message::same_bank_accont_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_same_bank_accont_payload(&mut self, v: SameBankAccountPayload) {
        self.message = ::std::option::Option::Some(
            BankAccountPayload_oneof_message::same_bank_accont_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_same_bank_accont_payload(&mut self) -> &mut SameBankAccountPayload {
        if let ::std::option::Option::Some(
            BankAccountPayload_oneof_message::same_bank_accont_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                BankAccountPayload_oneof_message::same_bank_accont_payload(
                    SameBankAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                BankAccountPayload_oneof_message::same_bank_accont_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_same_bank_accont_payload(&mut self) -> SameBankAccountPayload {
        if self.has_same_bank_accont_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    BankAccountPayload_oneof_message::same_bank_accont_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            SameBankAccountPayload::new()
        }
    }

    // .io.bisq.protobuffer.SpecificBanksAccountPayload specific_banks_account_payload = 11;

    pub fn get_specific_banks_account_payload(&self) -> &SpecificBanksAccountPayload {
        match self.message {
            ::std::option::Option::Some(
                BankAccountPayload_oneof_message::specific_banks_account_payload(ref v),
            ) => v,
            _ => SpecificBanksAccountPayload::default_instance(),
        }
    }
    pub fn clear_specific_banks_account_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_specific_banks_account_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                BankAccountPayload_oneof_message::specific_banks_account_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_specific_banks_account_payload(&mut self, v: SpecificBanksAccountPayload) {
        self.message = ::std::option::Option::Some(
            BankAccountPayload_oneof_message::specific_banks_account_payload(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_specific_banks_account_payload(&mut self) -> &mut SpecificBanksAccountPayload {
        if let ::std::option::Option::Some(
            BankAccountPayload_oneof_message::specific_banks_account_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                BankAccountPayload_oneof_message::specific_banks_account_payload(
                    SpecificBanksAccountPayload::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                BankAccountPayload_oneof_message::specific_banks_account_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_specific_banks_account_payload(&mut self) -> SpecificBanksAccountPayload {
        if self.has_specific_banks_account_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    BankAccountPayload_oneof_message::specific_banks_account_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            SpecificBanksAccountPayload::new()
        }
    }

    // string national_account_id = 12;

    pub fn get_national_account_id(&self) -> &str {
        &self.national_account_id
    }
    pub fn clear_national_account_id(&mut self) {
        self.national_account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_national_account_id(&mut self, v: ::std::string::String) {
        self.national_account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_national_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.national_account_id
    }

    // Take field
    pub fn take_national_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.national_account_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BankAccountPayload {
    fn is_initialized(&self) -> bool {
        if let Some(BankAccountPayload_oneof_message::national_bank_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BankAccountPayload_oneof_message::same_bank_accont_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BankAccountPayload_oneof_message::specific_banks_account_payload(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bank_name,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bank_id,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.branch_id,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_nr,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_type,
                    )?;
                }
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_tax_id,
                    )?;
                }
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.email,
                    )?;
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        BankAccountPayload_oneof_message::national_bank_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        BankAccountPayload_oneof_message::same_bank_accont_payload(
                            is.read_message()?,
                        ),
                    );
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        BankAccountPayload_oneof_message::specific_banks_account_payload(
                            is.read_message()?,
                        ),
                    );
                }
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.national_account_id,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.holder_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.holder_name);
        }
        if !self.bank_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bank_name);
        }
        if !self.bank_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.bank_id);
        }
        if !self.branch_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.branch_id);
        }
        if !self.account_nr.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.account_nr);
        }
        if !self.account_type.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.account_type);
        }
        if !self.holder_tax_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.holder_tax_id);
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.email);
        }
        if !self.national_account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.national_account_id);
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &BankAccountPayload_oneof_message::national_bank_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &BankAccountPayload_oneof_message::same_bank_accont_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &BankAccountPayload_oneof_message::specific_banks_account_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.holder_name.is_empty() {
            os.write_string(1, &self.holder_name)?;
        }
        if !self.bank_name.is_empty() {
            os.write_string(2, &self.bank_name)?;
        }
        if !self.bank_id.is_empty() {
            os.write_string(3, &self.bank_id)?;
        }
        if !self.branch_id.is_empty() {
            os.write_string(4, &self.branch_id)?;
        }
        if !self.account_nr.is_empty() {
            os.write_string(5, &self.account_nr)?;
        }
        if !self.account_type.is_empty() {
            os.write_string(6, &self.account_type)?;
        }
        if !self.holder_tax_id.is_empty() {
            os.write_string(7, &self.holder_tax_id)?;
        }
        if !self.email.is_empty() {
            os.write_string(8, &self.email)?;
        }
        if !self.national_account_id.is_empty() {
            os.write_string(12, &self.national_account_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &BankAccountPayload_oneof_message::national_bank_account_payload(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &BankAccountPayload_oneof_message::same_bank_accont_payload(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &BankAccountPayload_oneof_message::specific_banks_account_payload(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BankAccountPayload {
        BankAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_name",
                    |m: &BankAccountPayload| &m.holder_name,
                    |m: &mut BankAccountPayload| &mut m.holder_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bank_name",
                    |m: &BankAccountPayload| &m.bank_name,
                    |m: &mut BankAccountPayload| &mut m.bank_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bank_id",
                    |m: &BankAccountPayload| &m.bank_id,
                    |m: &mut BankAccountPayload| &mut m.bank_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "branch_id",
                    |m: &BankAccountPayload| &m.branch_id,
                    |m: &mut BankAccountPayload| &mut m.branch_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_nr",
                    |m: &BankAccountPayload| &m.account_nr,
                    |m: &mut BankAccountPayload| &mut m.account_nr,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_type",
                    |m: &BankAccountPayload| &m.account_type,
                    |m: &mut BankAccountPayload| &mut m.account_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_tax_id",
                    |m: &BankAccountPayload| &m.holder_tax_id,
                    |m: &mut BankAccountPayload| &mut m.holder_tax_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "email",
                    |m: &BankAccountPayload| &m.email,
                    |m: &mut BankAccountPayload| &mut m.email,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        NationalBankAccountPayload,
                    >(
                        "national_bank_account_payload",
                        BankAccountPayload::has_national_bank_account_payload,
                        BankAccountPayload::get_national_bank_account_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        SameBankAccountPayload,
                    >(
                        "same_bank_accont_payload",
                        BankAccountPayload::has_same_bank_accont_payload,
                        BankAccountPayload::get_same_bank_accont_payload,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        SpecificBanksAccountPayload,
                    >(
                        "specific_banks_account_payload",
                        BankAccountPayload::has_specific_banks_account_payload,
                        BankAccountPayload::get_specific_banks_account_payload,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "national_account_id",
                    |m: &BankAccountPayload| &m.national_account_id,
                    |m: &mut BankAccountPayload| &mut m.national_account_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BankAccountPayload>(
                    "BankAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static BankAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<BankAccountPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BankAccountPayload,
        };
        unsafe { instance.get(BankAccountPayload::new) }
    }
}

impl ::protobuf::Clear for BankAccountPayload {
    fn clear(&mut self) {
        self.holder_name.clear();
        self.bank_name.clear();
        self.bank_id.clear();
        self.branch_id.clear();
        self.account_nr.clear();
        self.account_type.clear();
        self.holder_tax_id.clear();
        self.email.clear();
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.national_account_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BankAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BankAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct NationalBankAccountPayload {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NationalBankAccountPayload {
    fn default() -> &'a NationalBankAccountPayload {
        <NationalBankAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl NationalBankAccountPayload {
    pub fn new() -> NationalBankAccountPayload {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for NationalBankAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NationalBankAccountPayload {
        NationalBankAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<NationalBankAccountPayload>(
                    "NationalBankAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static NationalBankAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<NationalBankAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const NationalBankAccountPayload,
            };
        unsafe { instance.get(NationalBankAccountPayload::new) }
    }
}

impl ::protobuf::Clear for NationalBankAccountPayload {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NationalBankAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NationalBankAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct SameBankAccountPayload {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SameBankAccountPayload {
    fn default() -> &'a SameBankAccountPayload {
        <SameBankAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl SameBankAccountPayload {
    pub fn new() -> SameBankAccountPayload {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SameBankAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SameBankAccountPayload {
        SameBankAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SameBankAccountPayload>(
                    "SameBankAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static SameBankAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<SameBankAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const SameBankAccountPayload,
            };
        unsafe { instance.get(SameBankAccountPayload::new) }
    }
}

impl ::protobuf::Clear for SameBankAccountPayload {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SameBankAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SameBankAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct JapanBankAccountPayload {
    // message fields
    pub bank_name: ::std::string::String,
    pub bank_code: ::std::string::String,
    pub bank_branch_name: ::std::string::String,
    pub bank_branch_code: ::std::string::String,
    pub bank_account_type: ::std::string::String,
    pub bank_account_name: ::std::string::String,
    pub bank_account_number: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JapanBankAccountPayload {
    fn default() -> &'a JapanBankAccountPayload {
        <JapanBankAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl JapanBankAccountPayload {
    pub fn new() -> JapanBankAccountPayload {
        ::std::default::Default::default()
    }

    // string bank_name = 1;

    pub fn get_bank_name(&self) -> &str {
        &self.bank_name
    }
    pub fn clear_bank_name(&mut self) {
        self.bank_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_bank_name(&mut self, v: ::std::string::String) {
        self.bank_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bank_name(&mut self) -> &mut ::std::string::String {
        &mut self.bank_name
    }

    // Take field
    pub fn take_bank_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bank_name, ::std::string::String::new())
    }

    // string bank_code = 2;

    pub fn get_bank_code(&self) -> &str {
        &self.bank_code
    }
    pub fn clear_bank_code(&mut self) {
        self.bank_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_bank_code(&mut self, v: ::std::string::String) {
        self.bank_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bank_code(&mut self) -> &mut ::std::string::String {
        &mut self.bank_code
    }

    // Take field
    pub fn take_bank_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bank_code, ::std::string::String::new())
    }

    // string bank_branch_name = 3;

    pub fn get_bank_branch_name(&self) -> &str {
        &self.bank_branch_name
    }
    pub fn clear_bank_branch_name(&mut self) {
        self.bank_branch_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_bank_branch_name(&mut self, v: ::std::string::String) {
        self.bank_branch_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bank_branch_name(&mut self) -> &mut ::std::string::String {
        &mut self.bank_branch_name
    }

    // Take field
    pub fn take_bank_branch_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bank_branch_name, ::std::string::String::new())
    }

    // string bank_branch_code = 4;

    pub fn get_bank_branch_code(&self) -> &str {
        &self.bank_branch_code
    }
    pub fn clear_bank_branch_code(&mut self) {
        self.bank_branch_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_bank_branch_code(&mut self, v: ::std::string::String) {
        self.bank_branch_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bank_branch_code(&mut self) -> &mut ::std::string::String {
        &mut self.bank_branch_code
    }

    // Take field
    pub fn take_bank_branch_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bank_branch_code, ::std::string::String::new())
    }

    // string bank_account_type = 5;

    pub fn get_bank_account_type(&self) -> &str {
        &self.bank_account_type
    }
    pub fn clear_bank_account_type(&mut self) {
        self.bank_account_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_bank_account_type(&mut self, v: ::std::string::String) {
        self.bank_account_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bank_account_type(&mut self) -> &mut ::std::string::String {
        &mut self.bank_account_type
    }

    // Take field
    pub fn take_bank_account_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bank_account_type, ::std::string::String::new())
    }

    // string bank_account_name = 6;

    pub fn get_bank_account_name(&self) -> &str {
        &self.bank_account_name
    }
    pub fn clear_bank_account_name(&mut self) {
        self.bank_account_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_bank_account_name(&mut self, v: ::std::string::String) {
        self.bank_account_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bank_account_name(&mut self) -> &mut ::std::string::String {
        &mut self.bank_account_name
    }

    // Take field
    pub fn take_bank_account_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bank_account_name, ::std::string::String::new())
    }

    // string bank_account_number = 7;

    pub fn get_bank_account_number(&self) -> &str {
        &self.bank_account_number
    }
    pub fn clear_bank_account_number(&mut self) {
        self.bank_account_number.clear();
    }

    // Param is passed by value, moved
    pub fn set_bank_account_number(&mut self, v: ::std::string::String) {
        self.bank_account_number = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bank_account_number(&mut self) -> &mut ::std::string::String {
        &mut self.bank_account_number
    }

    // Take field
    pub fn take_bank_account_number(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bank_account_number, ::std::string::String::new())
    }
}

impl ::protobuf::Message for JapanBankAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bank_name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bank_code,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bank_branch_name,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bank_branch_code,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bank_account_type,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bank_account_name,
                    )?;
                }
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bank_account_number,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bank_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bank_name);
        }
        if !self.bank_code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bank_code);
        }
        if !self.bank_branch_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.bank_branch_name);
        }
        if !self.bank_branch_code.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.bank_branch_code);
        }
        if !self.bank_account_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.bank_account_type);
        }
        if !self.bank_account_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.bank_account_name);
        }
        if !self.bank_account_number.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.bank_account_number);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.bank_name.is_empty() {
            os.write_string(1, &self.bank_name)?;
        }
        if !self.bank_code.is_empty() {
            os.write_string(2, &self.bank_code)?;
        }
        if !self.bank_branch_name.is_empty() {
            os.write_string(3, &self.bank_branch_name)?;
        }
        if !self.bank_branch_code.is_empty() {
            os.write_string(4, &self.bank_branch_code)?;
        }
        if !self.bank_account_type.is_empty() {
            os.write_string(5, &self.bank_account_type)?;
        }
        if !self.bank_account_name.is_empty() {
            os.write_string(6, &self.bank_account_name)?;
        }
        if !self.bank_account_number.is_empty() {
            os.write_string(7, &self.bank_account_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JapanBankAccountPayload {
        JapanBankAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bank_name",
                    |m: &JapanBankAccountPayload| &m.bank_name,
                    |m: &mut JapanBankAccountPayload| &mut m.bank_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bank_code",
                    |m: &JapanBankAccountPayload| &m.bank_code,
                    |m: &mut JapanBankAccountPayload| &mut m.bank_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bank_branch_name",
                    |m: &JapanBankAccountPayload| &m.bank_branch_name,
                    |m: &mut JapanBankAccountPayload| &mut m.bank_branch_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bank_branch_code",
                    |m: &JapanBankAccountPayload| &m.bank_branch_code,
                    |m: &mut JapanBankAccountPayload| &mut m.bank_branch_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bank_account_type",
                    |m: &JapanBankAccountPayload| &m.bank_account_type,
                    |m: &mut JapanBankAccountPayload| &mut m.bank_account_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bank_account_name",
                    |m: &JapanBankAccountPayload| &m.bank_account_name,
                    |m: &mut JapanBankAccountPayload| &mut m.bank_account_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bank_account_number",
                    |m: &JapanBankAccountPayload| &m.bank_account_number,
                    |m: &mut JapanBankAccountPayload| &mut m.bank_account_number,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<JapanBankAccountPayload>(
                    "JapanBankAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static JapanBankAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<JapanBankAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const JapanBankAccountPayload,
            };
        unsafe { instance.get(JapanBankAccountPayload::new) }
    }
}

impl ::protobuf::Clear for JapanBankAccountPayload {
    fn clear(&mut self) {
        self.bank_name.clear();
        self.bank_code.clear();
        self.bank_branch_name.clear();
        self.bank_branch_code.clear();
        self.bank_account_type.clear();
        self.bank_account_name.clear();
        self.bank_account_number.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JapanBankAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JapanBankAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct SpecificBanksAccountPayload {
    // message fields
    pub accepted_banks: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpecificBanksAccountPayload {
    fn default() -> &'a SpecificBanksAccountPayload {
        <SpecificBanksAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl SpecificBanksAccountPayload {
    pub fn new() -> SpecificBanksAccountPayload {
        ::std::default::Default::default()
    }

    // repeated string accepted_banks = 1;

    pub fn get_accepted_banks(&self) -> &[::std::string::String] {
        &self.accepted_banks
    }
    pub fn clear_accepted_banks(&mut self) {
        self.accepted_banks.clear();
    }

    // Param is passed by value, moved
    pub fn set_accepted_banks(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.accepted_banks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accepted_banks(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accepted_banks
    }

    // Take field
    pub fn take_accepted_banks(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.accepted_banks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SpecificBanksAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.accepted_banks,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.accepted_banks {
            my_size += ::protobuf::rt::string_size(1, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.accepted_banks {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpecificBanksAccountPayload {
        SpecificBanksAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "accepted_banks",
                        |m: &SpecificBanksAccountPayload| &m.accepted_banks,
                        |m: &mut SpecificBanksAccountPayload| &mut m.accepted_banks,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<SpecificBanksAccountPayload>(
                    "SpecificBanksAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static SpecificBanksAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<SpecificBanksAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const SpecificBanksAccountPayload,
            };
        unsafe { instance.get(SpecificBanksAccountPayload::new) }
    }
}

impl ::protobuf::Clear for SpecificBanksAccountPayload {
    fn clear(&mut self) {
        self.accepted_banks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpecificBanksAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpecificBanksAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct CashDepositAccountPayload {
    // message fields
    pub holder_name: ::std::string::String,
    pub holder_email: ::std::string::String,
    pub bank_name: ::std::string::String,
    pub bank_id: ::std::string::String,
    pub branch_id: ::std::string::String,
    pub account_nr: ::std::string::String,
    pub account_type: ::std::string::String,
    pub requirements: ::std::string::String,
    pub holder_tax_id: ::std::string::String,
    pub national_account_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CashDepositAccountPayload {
    fn default() -> &'a CashDepositAccountPayload {
        <CashDepositAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl CashDepositAccountPayload {
    pub fn new() -> CashDepositAccountPayload {
        ::std::default::Default::default()
    }

    // string holder_name = 1;

    pub fn get_holder_name(&self) -> &str {
        &self.holder_name
    }
    pub fn clear_holder_name(&mut self) {
        self.holder_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_name(&mut self, v: ::std::string::String) {
        self.holder_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_name(&mut self) -> &mut ::std::string::String {
        &mut self.holder_name
    }

    // Take field
    pub fn take_holder_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_name, ::std::string::String::new())
    }

    // string holder_email = 2;

    pub fn get_holder_email(&self) -> &str {
        &self.holder_email
    }
    pub fn clear_holder_email(&mut self) {
        self.holder_email.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_email(&mut self, v: ::std::string::String) {
        self.holder_email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_email(&mut self) -> &mut ::std::string::String {
        &mut self.holder_email
    }

    // Take field
    pub fn take_holder_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_email, ::std::string::String::new())
    }

    // string bank_name = 3;

    pub fn get_bank_name(&self) -> &str {
        &self.bank_name
    }
    pub fn clear_bank_name(&mut self) {
        self.bank_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_bank_name(&mut self, v: ::std::string::String) {
        self.bank_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bank_name(&mut self) -> &mut ::std::string::String {
        &mut self.bank_name
    }

    // Take field
    pub fn take_bank_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bank_name, ::std::string::String::new())
    }

    // string bank_id = 4;

    pub fn get_bank_id(&self) -> &str {
        &self.bank_id
    }
    pub fn clear_bank_id(&mut self) {
        self.bank_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_bank_id(&mut self, v: ::std::string::String) {
        self.bank_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bank_id(&mut self) -> &mut ::std::string::String {
        &mut self.bank_id
    }

    // Take field
    pub fn take_bank_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bank_id, ::std::string::String::new())
    }

    // string branch_id = 5;

    pub fn get_branch_id(&self) -> &str {
        &self.branch_id
    }
    pub fn clear_branch_id(&mut self) {
        self.branch_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_branch_id(&mut self, v: ::std::string::String) {
        self.branch_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_branch_id(&mut self) -> &mut ::std::string::String {
        &mut self.branch_id
    }

    // Take field
    pub fn take_branch_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.branch_id, ::std::string::String::new())
    }

    // string account_nr = 6;

    pub fn get_account_nr(&self) -> &str {
        &self.account_nr
    }
    pub fn clear_account_nr(&mut self) {
        self.account_nr.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_nr(&mut self, v: ::std::string::String) {
        self.account_nr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_nr(&mut self) -> &mut ::std::string::String {
        &mut self.account_nr
    }

    // Take field
    pub fn take_account_nr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_nr, ::std::string::String::new())
    }

    // string account_type = 7;

    pub fn get_account_type(&self) -> &str {
        &self.account_type
    }
    pub fn clear_account_type(&mut self) {
        self.account_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_type(&mut self, v: ::std::string::String) {
        self.account_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_type(&mut self) -> &mut ::std::string::String {
        &mut self.account_type
    }

    // Take field
    pub fn take_account_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_type, ::std::string::String::new())
    }

    // string requirements = 8;

    pub fn get_requirements(&self) -> &str {
        &self.requirements
    }
    pub fn clear_requirements(&mut self) {
        self.requirements.clear();
    }

    // Param is passed by value, moved
    pub fn set_requirements(&mut self, v: ::std::string::String) {
        self.requirements = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requirements(&mut self) -> &mut ::std::string::String {
        &mut self.requirements
    }

    // Take field
    pub fn take_requirements(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.requirements, ::std::string::String::new())
    }

    // string holder_tax_id = 9;

    pub fn get_holder_tax_id(&self) -> &str {
        &self.holder_tax_id
    }
    pub fn clear_holder_tax_id(&mut self) {
        self.holder_tax_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_tax_id(&mut self, v: ::std::string::String) {
        self.holder_tax_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_tax_id(&mut self) -> &mut ::std::string::String {
        &mut self.holder_tax_id
    }

    // Take field
    pub fn take_holder_tax_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_tax_id, ::std::string::String::new())
    }

    // string national_account_id = 10;

    pub fn get_national_account_id(&self) -> &str {
        &self.national_account_id
    }
    pub fn clear_national_account_id(&mut self) {
        self.national_account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_national_account_id(&mut self, v: ::std::string::String) {
        self.national_account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_national_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.national_account_id
    }

    // Take field
    pub fn take_national_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.national_account_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CashDepositAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_email,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bank_name,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bank_id,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.branch_id,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_nr,
                    )?;
                }
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_type,
                    )?;
                }
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.requirements,
                    )?;
                }
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_tax_id,
                    )?;
                }
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.national_account_id,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.holder_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.holder_name);
        }
        if !self.holder_email.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.holder_email);
        }
        if !self.bank_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.bank_name);
        }
        if !self.bank_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.bank_id);
        }
        if !self.branch_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.branch_id);
        }
        if !self.account_nr.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.account_nr);
        }
        if !self.account_type.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.account_type);
        }
        if !self.requirements.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.requirements);
        }
        if !self.holder_tax_id.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.holder_tax_id);
        }
        if !self.national_account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.national_account_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.holder_name.is_empty() {
            os.write_string(1, &self.holder_name)?;
        }
        if !self.holder_email.is_empty() {
            os.write_string(2, &self.holder_email)?;
        }
        if !self.bank_name.is_empty() {
            os.write_string(3, &self.bank_name)?;
        }
        if !self.bank_id.is_empty() {
            os.write_string(4, &self.bank_id)?;
        }
        if !self.branch_id.is_empty() {
            os.write_string(5, &self.branch_id)?;
        }
        if !self.account_nr.is_empty() {
            os.write_string(6, &self.account_nr)?;
        }
        if !self.account_type.is_empty() {
            os.write_string(7, &self.account_type)?;
        }
        if !self.requirements.is_empty() {
            os.write_string(8, &self.requirements)?;
        }
        if !self.holder_tax_id.is_empty() {
            os.write_string(9, &self.holder_tax_id)?;
        }
        if !self.national_account_id.is_empty() {
            os.write_string(10, &self.national_account_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CashDepositAccountPayload {
        CashDepositAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_name",
                    |m: &CashDepositAccountPayload| &m.holder_name,
                    |m: &mut CashDepositAccountPayload| &mut m.holder_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_email",
                    |m: &CashDepositAccountPayload| &m.holder_email,
                    |m: &mut CashDepositAccountPayload| &mut m.holder_email,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bank_name",
                    |m: &CashDepositAccountPayload| &m.bank_name,
                    |m: &mut CashDepositAccountPayload| &mut m.bank_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bank_id",
                    |m: &CashDepositAccountPayload| &m.bank_id,
                    |m: &mut CashDepositAccountPayload| &mut m.bank_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "branch_id",
                    |m: &CashDepositAccountPayload| &m.branch_id,
                    |m: &mut CashDepositAccountPayload| &mut m.branch_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_nr",
                    |m: &CashDepositAccountPayload| &m.account_nr,
                    |m: &mut CashDepositAccountPayload| &mut m.account_nr,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_type",
                    |m: &CashDepositAccountPayload| &m.account_type,
                    |m: &mut CashDepositAccountPayload| &mut m.account_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "requirements",
                    |m: &CashDepositAccountPayload| &m.requirements,
                    |m: &mut CashDepositAccountPayload| &mut m.requirements,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_tax_id",
                    |m: &CashDepositAccountPayload| &m.holder_tax_id,
                    |m: &mut CashDepositAccountPayload| &mut m.holder_tax_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "national_account_id",
                    |m: &CashDepositAccountPayload| &m.national_account_id,
                    |m: &mut CashDepositAccountPayload| &mut m.national_account_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CashDepositAccountPayload>(
                    "CashDepositAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static CashDepositAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<CashDepositAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const CashDepositAccountPayload,
            };
        unsafe { instance.get(CashDepositAccountPayload::new) }
    }
}

impl ::protobuf::Clear for CashDepositAccountPayload {
    fn clear(&mut self) {
        self.holder_name.clear();
        self.holder_email.clear();
        self.bank_name.clear();
        self.bank_id.clear();
        self.branch_id.clear();
        self.account_nr.clear();
        self.account_type.clear();
        self.requirements.clear();
        self.holder_tax_id.clear();
        self.national_account_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CashDepositAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CashDepositAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MoneyGramAccountPayload {
    // message fields
    pub holder_name: ::std::string::String,
    pub country_code: ::std::string::String,
    pub state: ::std::string::String,
    pub email: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneyGramAccountPayload {
    fn default() -> &'a MoneyGramAccountPayload {
        <MoneyGramAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl MoneyGramAccountPayload {
    pub fn new() -> MoneyGramAccountPayload {
        ::std::default::Default::default()
    }

    // string holder_name = 1;

    pub fn get_holder_name(&self) -> &str {
        &self.holder_name
    }
    pub fn clear_holder_name(&mut self) {
        self.holder_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_name(&mut self, v: ::std::string::String) {
        self.holder_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_name(&mut self) -> &mut ::std::string::String {
        &mut self.holder_name
    }

    // Take field
    pub fn take_holder_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_name, ::std::string::String::new())
    }

    // string country_code = 2;

    pub fn get_country_code(&self) -> &str {
        &self.country_code
    }
    pub fn clear_country_code(&mut self) {
        self.country_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        &mut self.country_code
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.country_code, ::std::string::String::new())
    }

    // string state = 3;

    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // string email = 4;

    pub fn get_email(&self) -> &str {
        &self.email
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MoneyGramAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.country_code,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.state,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.email,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.holder_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.holder_name);
        }
        if !self.country_code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.country_code);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.state);
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.email);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.holder_name.is_empty() {
            os.write_string(1, &self.holder_name)?;
        }
        if !self.country_code.is_empty() {
            os.write_string(2, &self.country_code)?;
        }
        if !self.state.is_empty() {
            os.write_string(3, &self.state)?;
        }
        if !self.email.is_empty() {
            os.write_string(4, &self.email)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneyGramAccountPayload {
        MoneyGramAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_name",
                    |m: &MoneyGramAccountPayload| &m.holder_name,
                    |m: &mut MoneyGramAccountPayload| &mut m.holder_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "country_code",
                    |m: &MoneyGramAccountPayload| &m.country_code,
                    |m: &mut MoneyGramAccountPayload| &mut m.country_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "state",
                    |m: &MoneyGramAccountPayload| &m.state,
                    |m: &mut MoneyGramAccountPayload| &mut m.state,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "email",
                    |m: &MoneyGramAccountPayload| &m.email,
                    |m: &mut MoneyGramAccountPayload| &mut m.email,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneyGramAccountPayload>(
                    "MoneyGramAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MoneyGramAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<MoneyGramAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const MoneyGramAccountPayload,
            };
        unsafe { instance.get(MoneyGramAccountPayload::new) }
    }
}

impl ::protobuf::Clear for MoneyGramAccountPayload {
    fn clear(&mut self) {
        self.holder_name.clear();
        self.country_code.clear();
        self.state.clear();
        self.email.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneyGramAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneyGramAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct HalCashAccountPayload {
    // message fields
    pub mobile_nr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HalCashAccountPayload {
    fn default() -> &'a HalCashAccountPayload {
        <HalCashAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl HalCashAccountPayload {
    pub fn new() -> HalCashAccountPayload {
        ::std::default::Default::default()
    }

    // string mobile_nr = 1;

    pub fn get_mobile_nr(&self) -> &str {
        &self.mobile_nr
    }
    pub fn clear_mobile_nr(&mut self) {
        self.mobile_nr.clear();
    }

    // Param is passed by value, moved
    pub fn set_mobile_nr(&mut self, v: ::std::string::String) {
        self.mobile_nr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mobile_nr(&mut self) -> &mut ::std::string::String {
        &mut self.mobile_nr
    }

    // Take field
    pub fn take_mobile_nr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mobile_nr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HalCashAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mobile_nr,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mobile_nr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mobile_nr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.mobile_nr.is_empty() {
            os.write_string(1, &self.mobile_nr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HalCashAccountPayload {
        HalCashAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "mobile_nr",
                    |m: &HalCashAccountPayload| &m.mobile_nr,
                    |m: &mut HalCashAccountPayload| &mut m.mobile_nr,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HalCashAccountPayload>(
                    "HalCashAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static HalCashAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<HalCashAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const HalCashAccountPayload,
            };
        unsafe { instance.get(HalCashAccountPayload::new) }
    }
}

impl ::protobuf::Clear for HalCashAccountPayload {
    fn clear(&mut self) {
        self.mobile_nr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HalCashAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HalCashAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct WesternUnionAccountPayload {
    // message fields
    pub holder_name: ::std::string::String,
    pub city: ::std::string::String,
    pub state: ::std::string::String,
    pub email: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WesternUnionAccountPayload {
    fn default() -> &'a WesternUnionAccountPayload {
        <WesternUnionAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl WesternUnionAccountPayload {
    pub fn new() -> WesternUnionAccountPayload {
        ::std::default::Default::default()
    }

    // string holder_name = 1;

    pub fn get_holder_name(&self) -> &str {
        &self.holder_name
    }
    pub fn clear_holder_name(&mut self) {
        self.holder_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_name(&mut self, v: ::std::string::String) {
        self.holder_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_name(&mut self) -> &mut ::std::string::String {
        &mut self.holder_name
    }

    // Take field
    pub fn take_holder_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_name, ::std::string::String::new())
    }

    // string city = 2;

    pub fn get_city(&self) -> &str {
        &self.city
    }
    pub fn clear_city(&mut self) {
        self.city.clear();
    }

    // Param is passed by value, moved
    pub fn set_city(&mut self, v: ::std::string::String) {
        self.city = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_city(&mut self) -> &mut ::std::string::String {
        &mut self.city
    }

    // Take field
    pub fn take_city(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.city, ::std::string::String::new())
    }

    // string state = 3;

    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // string email = 4;

    pub fn get_email(&self) -> &str {
        &self.email
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WesternUnionAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.city,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.state,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.email,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.holder_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.holder_name);
        }
        if !self.city.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.city);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.state);
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.email);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.holder_name.is_empty() {
            os.write_string(1, &self.holder_name)?;
        }
        if !self.city.is_empty() {
            os.write_string(2, &self.city)?;
        }
        if !self.state.is_empty() {
            os.write_string(3, &self.state)?;
        }
        if !self.email.is_empty() {
            os.write_string(4, &self.email)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WesternUnionAccountPayload {
        WesternUnionAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_name",
                    |m: &WesternUnionAccountPayload| &m.holder_name,
                    |m: &mut WesternUnionAccountPayload| &mut m.holder_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "city",
                    |m: &WesternUnionAccountPayload| &m.city,
                    |m: &mut WesternUnionAccountPayload| &mut m.city,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "state",
                    |m: &WesternUnionAccountPayload| &m.state,
                    |m: &mut WesternUnionAccountPayload| &mut m.state,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "email",
                    |m: &WesternUnionAccountPayload| &m.email,
                    |m: &mut WesternUnionAccountPayload| &mut m.email,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WesternUnionAccountPayload>(
                    "WesternUnionAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static WesternUnionAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<WesternUnionAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const WesternUnionAccountPayload,
            };
        unsafe { instance.get(WesternUnionAccountPayload::new) }
    }
}

impl ::protobuf::Clear for WesternUnionAccountPayload {
    fn clear(&mut self) {
        self.holder_name.clear();
        self.city.clear();
        self.state.clear();
        self.email.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WesternUnionAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WesternUnionAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct SepaAccountPayload {
    // message fields
    pub holder_name: ::std::string::String,
    pub iban: ::std::string::String,
    pub bic: ::std::string::String,
    pub email: ::std::string::String,
    pub accepted_country_codes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SepaAccountPayload {
    fn default() -> &'a SepaAccountPayload {
        <SepaAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl SepaAccountPayload {
    pub fn new() -> SepaAccountPayload {
        ::std::default::Default::default()
    }

    // string holder_name = 1;

    pub fn get_holder_name(&self) -> &str {
        &self.holder_name
    }
    pub fn clear_holder_name(&mut self) {
        self.holder_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_name(&mut self, v: ::std::string::String) {
        self.holder_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_name(&mut self) -> &mut ::std::string::String {
        &mut self.holder_name
    }

    // Take field
    pub fn take_holder_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_name, ::std::string::String::new())
    }

    // string iban = 2;

    pub fn get_iban(&self) -> &str {
        &self.iban
    }
    pub fn clear_iban(&mut self) {
        self.iban.clear();
    }

    // Param is passed by value, moved
    pub fn set_iban(&mut self, v: ::std::string::String) {
        self.iban = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iban(&mut self) -> &mut ::std::string::String {
        &mut self.iban
    }

    // Take field
    pub fn take_iban(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.iban, ::std::string::String::new())
    }

    // string bic = 3;

    pub fn get_bic(&self) -> &str {
        &self.bic
    }
    pub fn clear_bic(&mut self) {
        self.bic.clear();
    }

    // Param is passed by value, moved
    pub fn set_bic(&mut self, v: ::std::string::String) {
        self.bic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bic(&mut self) -> &mut ::std::string::String {
        &mut self.bic
    }

    // Take field
    pub fn take_bic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bic, ::std::string::String::new())
    }

    // string email = 4;

    pub fn get_email(&self) -> &str {
        &self.email
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email, ::std::string::String::new())
    }

    // repeated string accepted_country_codes = 5;

    pub fn get_accepted_country_codes(&self) -> &[::std::string::String] {
        &self.accepted_country_codes
    }
    pub fn clear_accepted_country_codes(&mut self) {
        self.accepted_country_codes.clear();
    }

    // Param is passed by value, moved
    pub fn set_accepted_country_codes(
        &mut self,
        v: ::protobuf::RepeatedField<::std::string::String>,
    ) {
        self.accepted_country_codes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accepted_country_codes(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accepted_country_codes
    }

    // Take field
    pub fn take_accepted_country_codes(
        &mut self,
    ) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(
            &mut self.accepted_country_codes,
            ::protobuf::RepeatedField::new(),
        )
    }
}

impl ::protobuf::Message for SepaAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.iban,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bic)?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.email,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.accepted_country_codes,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.holder_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.holder_name);
        }
        if !self.iban.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.iban);
        }
        if !self.bic.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.bic);
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.email);
        }
        for value in &self.accepted_country_codes {
            my_size += ::protobuf::rt::string_size(5, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.holder_name.is_empty() {
            os.write_string(1, &self.holder_name)?;
        }
        if !self.iban.is_empty() {
            os.write_string(2, &self.iban)?;
        }
        if !self.bic.is_empty() {
            os.write_string(3, &self.bic)?;
        }
        if !self.email.is_empty() {
            os.write_string(4, &self.email)?;
        }
        for v in &self.accepted_country_codes {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SepaAccountPayload {
        SepaAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_name",
                    |m: &SepaAccountPayload| &m.holder_name,
                    |m: &mut SepaAccountPayload| &mut m.holder_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "iban",
                    |m: &SepaAccountPayload| &m.iban,
                    |m: &mut SepaAccountPayload| &mut m.iban,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bic",
                    |m: &SepaAccountPayload| &m.bic,
                    |m: &mut SepaAccountPayload| &mut m.bic,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "email",
                    |m: &SepaAccountPayload| &m.email,
                    |m: &mut SepaAccountPayload| &mut m.email,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "accepted_country_codes",
                        |m: &SepaAccountPayload| &m.accepted_country_codes,
                        |m: &mut SepaAccountPayload| &mut m.accepted_country_codes,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<SepaAccountPayload>(
                    "SepaAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static SepaAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<SepaAccountPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SepaAccountPayload,
        };
        unsafe { instance.get(SepaAccountPayload::new) }
    }
}

impl ::protobuf::Clear for SepaAccountPayload {
    fn clear(&mut self) {
        self.holder_name.clear();
        self.iban.clear();
        self.bic.clear();
        self.email.clear();
        self.accepted_country_codes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SepaAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SepaAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct SepaInstantAccountPayload {
    // message fields
    pub holder_name: ::std::string::String,
    pub iban: ::std::string::String,
    pub bic: ::std::string::String,
    pub accepted_country_codes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SepaInstantAccountPayload {
    fn default() -> &'a SepaInstantAccountPayload {
        <SepaInstantAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl SepaInstantAccountPayload {
    pub fn new() -> SepaInstantAccountPayload {
        ::std::default::Default::default()
    }

    // string holder_name = 1;

    pub fn get_holder_name(&self) -> &str {
        &self.holder_name
    }
    pub fn clear_holder_name(&mut self) {
        self.holder_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_name(&mut self, v: ::std::string::String) {
        self.holder_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_name(&mut self) -> &mut ::std::string::String {
        &mut self.holder_name
    }

    // Take field
    pub fn take_holder_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_name, ::std::string::String::new())
    }

    // string iban = 2;

    pub fn get_iban(&self) -> &str {
        &self.iban
    }
    pub fn clear_iban(&mut self) {
        self.iban.clear();
    }

    // Param is passed by value, moved
    pub fn set_iban(&mut self, v: ::std::string::String) {
        self.iban = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iban(&mut self) -> &mut ::std::string::String {
        &mut self.iban
    }

    // Take field
    pub fn take_iban(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.iban, ::std::string::String::new())
    }

    // string bic = 3;

    pub fn get_bic(&self) -> &str {
        &self.bic
    }
    pub fn clear_bic(&mut self) {
        self.bic.clear();
    }

    // Param is passed by value, moved
    pub fn set_bic(&mut self, v: ::std::string::String) {
        self.bic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bic(&mut self) -> &mut ::std::string::String {
        &mut self.bic
    }

    // Take field
    pub fn take_bic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bic, ::std::string::String::new())
    }

    // repeated string accepted_country_codes = 4;

    pub fn get_accepted_country_codes(&self) -> &[::std::string::String] {
        &self.accepted_country_codes
    }
    pub fn clear_accepted_country_codes(&mut self) {
        self.accepted_country_codes.clear();
    }

    // Param is passed by value, moved
    pub fn set_accepted_country_codes(
        &mut self,
        v: ::protobuf::RepeatedField<::std::string::String>,
    ) {
        self.accepted_country_codes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accepted_country_codes(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accepted_country_codes
    }

    // Take field
    pub fn take_accepted_country_codes(
        &mut self,
    ) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(
            &mut self.accepted_country_codes,
            ::protobuf::RepeatedField::new(),
        )
    }
}

impl ::protobuf::Message for SepaInstantAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.iban,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bic)?;
                }
                4 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.accepted_country_codes,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.holder_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.holder_name);
        }
        if !self.iban.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.iban);
        }
        if !self.bic.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.bic);
        }
        for value in &self.accepted_country_codes {
            my_size += ::protobuf::rt::string_size(4, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.holder_name.is_empty() {
            os.write_string(1, &self.holder_name)?;
        }
        if !self.iban.is_empty() {
            os.write_string(2, &self.iban)?;
        }
        if !self.bic.is_empty() {
            os.write_string(3, &self.bic)?;
        }
        for v in &self.accepted_country_codes {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SepaInstantAccountPayload {
        SepaInstantAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_name",
                    |m: &SepaInstantAccountPayload| &m.holder_name,
                    |m: &mut SepaInstantAccountPayload| &mut m.holder_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "iban",
                    |m: &SepaInstantAccountPayload| &m.iban,
                    |m: &mut SepaInstantAccountPayload| &mut m.iban,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bic",
                    |m: &SepaInstantAccountPayload| &m.bic,
                    |m: &mut SepaInstantAccountPayload| &mut m.bic,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "accepted_country_codes",
                        |m: &SepaInstantAccountPayload| &m.accepted_country_codes,
                        |m: &mut SepaInstantAccountPayload| &mut m.accepted_country_codes,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<SepaInstantAccountPayload>(
                    "SepaInstantAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static SepaInstantAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<SepaInstantAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const SepaInstantAccountPayload,
            };
        unsafe { instance.get(SepaInstantAccountPayload::new) }
    }
}

impl ::protobuf::Clear for SepaInstantAccountPayload {
    fn clear(&mut self) {
        self.holder_name.clear();
        self.iban.clear();
        self.bic.clear();
        self.accepted_country_codes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SepaInstantAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SepaInstantAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct CryptoCurrencyAccountPayload {
    // message fields
    pub address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CryptoCurrencyAccountPayload {
    fn default() -> &'a CryptoCurrencyAccountPayload {
        <CryptoCurrencyAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl CryptoCurrencyAccountPayload {
    pub fn new() -> CryptoCurrencyAccountPayload {
        ::std::default::Default::default()
    }

    // string address = 1;

    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CryptoCurrencyAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.address,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CryptoCurrencyAccountPayload {
        CryptoCurrencyAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "address",
                    |m: &CryptoCurrencyAccountPayload| &m.address,
                    |m: &mut CryptoCurrencyAccountPayload| &mut m.address,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CryptoCurrencyAccountPayload>(
                    "CryptoCurrencyAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static CryptoCurrencyAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<CryptoCurrencyAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const CryptoCurrencyAccountPayload,
            };
        unsafe { instance.get(CryptoCurrencyAccountPayload::new) }
    }
}

impl ::protobuf::Clear for CryptoCurrencyAccountPayload {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CryptoCurrencyAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptoCurrencyAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct InstantCryptoCurrencyAccountPayload {
    // message fields
    pub address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstantCryptoCurrencyAccountPayload {
    fn default() -> &'a InstantCryptoCurrencyAccountPayload {
        <InstantCryptoCurrencyAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl InstantCryptoCurrencyAccountPayload {
    pub fn new() -> InstantCryptoCurrencyAccountPayload {
        ::std::default::Default::default()
    }

    // string address = 1;

    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for InstantCryptoCurrencyAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.address,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstantCryptoCurrencyAccountPayload {
        InstantCryptoCurrencyAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "address",
                    |m: &InstantCryptoCurrencyAccountPayload| &m.address,
                    |m: &mut InstantCryptoCurrencyAccountPayload| &mut m.address,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InstantCryptoCurrencyAccountPayload>(
                    "InstantCryptoCurrencyAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static InstantCryptoCurrencyAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<InstantCryptoCurrencyAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const InstantCryptoCurrencyAccountPayload,
            };
        unsafe { instance.get(InstantCryptoCurrencyAccountPayload::new) }
    }
}

impl ::protobuf::Clear for InstantCryptoCurrencyAccountPayload {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstantCryptoCurrencyAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstantCryptoCurrencyAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct FasterPaymentsAccountPayload {
    // message fields
    pub sort_code: ::std::string::String,
    pub account_nr: ::std::string::String,
    pub email: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FasterPaymentsAccountPayload {
    fn default() -> &'a FasterPaymentsAccountPayload {
        <FasterPaymentsAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl FasterPaymentsAccountPayload {
    pub fn new() -> FasterPaymentsAccountPayload {
        ::std::default::Default::default()
    }

    // string sort_code = 1;

    pub fn get_sort_code(&self) -> &str {
        &self.sort_code
    }
    pub fn clear_sort_code(&mut self) {
        self.sort_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_sort_code(&mut self, v: ::std::string::String) {
        self.sort_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sort_code(&mut self) -> &mut ::std::string::String {
        &mut self.sort_code
    }

    // Take field
    pub fn take_sort_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sort_code, ::std::string::String::new())
    }

    // string account_nr = 2;

    pub fn get_account_nr(&self) -> &str {
        &self.account_nr
    }
    pub fn clear_account_nr(&mut self) {
        self.account_nr.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_nr(&mut self, v: ::std::string::String) {
        self.account_nr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_nr(&mut self) -> &mut ::std::string::String {
        &mut self.account_nr
    }

    // Take field
    pub fn take_account_nr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_nr, ::std::string::String::new())
    }

    // string email = 3;

    pub fn get_email(&self) -> &str {
        &self.email
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FasterPaymentsAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.sort_code,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_nr,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.email,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sort_code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sort_code);
        }
        if !self.account_nr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.account_nr);
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.email);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.sort_code.is_empty() {
            os.write_string(1, &self.sort_code)?;
        }
        if !self.account_nr.is_empty() {
            os.write_string(2, &self.account_nr)?;
        }
        if !self.email.is_empty() {
            os.write_string(3, &self.email)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FasterPaymentsAccountPayload {
        FasterPaymentsAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "sort_code",
                    |m: &FasterPaymentsAccountPayload| &m.sort_code,
                    |m: &mut FasterPaymentsAccountPayload| &mut m.sort_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_nr",
                    |m: &FasterPaymentsAccountPayload| &m.account_nr,
                    |m: &mut FasterPaymentsAccountPayload| &mut m.account_nr,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "email",
                    |m: &FasterPaymentsAccountPayload| &m.email,
                    |m: &mut FasterPaymentsAccountPayload| &mut m.email,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FasterPaymentsAccountPayload>(
                    "FasterPaymentsAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static FasterPaymentsAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<FasterPaymentsAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const FasterPaymentsAccountPayload,
            };
        unsafe { instance.get(FasterPaymentsAccountPayload::new) }
    }
}

impl ::protobuf::Clear for FasterPaymentsAccountPayload {
    fn clear(&mut self) {
        self.sort_code.clear();
        self.account_nr.clear();
        self.email.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FasterPaymentsAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FasterPaymentsAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct InteracETransferAccountPayload {
    // message fields
    pub email: ::std::string::String,
    pub holder_name: ::std::string::String,
    pub question: ::std::string::String,
    pub answer: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InteracETransferAccountPayload {
    fn default() -> &'a InteracETransferAccountPayload {
        <InteracETransferAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl InteracETransferAccountPayload {
    pub fn new() -> InteracETransferAccountPayload {
        ::std::default::Default::default()
    }

    // string email = 1;

    pub fn get_email(&self) -> &str {
        &self.email
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email, ::std::string::String::new())
    }

    // string holder_name = 2;

    pub fn get_holder_name(&self) -> &str {
        &self.holder_name
    }
    pub fn clear_holder_name(&mut self) {
        self.holder_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_name(&mut self, v: ::std::string::String) {
        self.holder_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_name(&mut self) -> &mut ::std::string::String {
        &mut self.holder_name
    }

    // Take field
    pub fn take_holder_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_name, ::std::string::String::new())
    }

    // string question = 3;

    pub fn get_question(&self) -> &str {
        &self.question
    }
    pub fn clear_question(&mut self) {
        self.question.clear();
    }

    // Param is passed by value, moved
    pub fn set_question(&mut self, v: ::std::string::String) {
        self.question = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_question(&mut self) -> &mut ::std::string::String {
        &mut self.question
    }

    // Take field
    pub fn take_question(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.question, ::std::string::String::new())
    }

    // string answer = 4;

    pub fn get_answer(&self) -> &str {
        &self.answer
    }
    pub fn clear_answer(&mut self) {
        self.answer.clear();
    }

    // Param is passed by value, moved
    pub fn set_answer(&mut self, v: ::std::string::String) {
        self.answer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_answer(&mut self) -> &mut ::std::string::String {
        &mut self.answer
    }

    // Take field
    pub fn take_answer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.answer, ::std::string::String::new())
    }
}

impl ::protobuf::Message for InteracETransferAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.email,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_name,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.question,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.answer,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.email);
        }
        if !self.holder_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.holder_name);
        }
        if !self.question.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.question);
        }
        if !self.answer.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.answer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.email.is_empty() {
            os.write_string(1, &self.email)?;
        }
        if !self.holder_name.is_empty() {
            os.write_string(2, &self.holder_name)?;
        }
        if !self.question.is_empty() {
            os.write_string(3, &self.question)?;
        }
        if !self.answer.is_empty() {
            os.write_string(4, &self.answer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InteracETransferAccountPayload {
        InteracETransferAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "email",
                    |m: &InteracETransferAccountPayload| &m.email,
                    |m: &mut InteracETransferAccountPayload| &mut m.email,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_name",
                    |m: &InteracETransferAccountPayload| &m.holder_name,
                    |m: &mut InteracETransferAccountPayload| &mut m.holder_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "question",
                    |m: &InteracETransferAccountPayload| &m.question,
                    |m: &mut InteracETransferAccountPayload| &mut m.question,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "answer",
                    |m: &InteracETransferAccountPayload| &m.answer,
                    |m: &mut InteracETransferAccountPayload| &mut m.answer,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InteracETransferAccountPayload>(
                    "InteracETransferAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static InteracETransferAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<InteracETransferAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const InteracETransferAccountPayload,
            };
        unsafe { instance.get(InteracETransferAccountPayload::new) }
    }
}

impl ::protobuf::Clear for InteracETransferAccountPayload {
    fn clear(&mut self) {
        self.email.clear();
        self.holder_name.clear();
        self.question.clear();
        self.answer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InteracETransferAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InteracETransferAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct OKPayAccountPayload {
    // message fields
    pub account_nr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OKPayAccountPayload {
    fn default() -> &'a OKPayAccountPayload {
        <OKPayAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl OKPayAccountPayload {
    pub fn new() -> OKPayAccountPayload {
        ::std::default::Default::default()
    }

    // string account_nr = 1;

    pub fn get_account_nr(&self) -> &str {
        &self.account_nr
    }
    pub fn clear_account_nr(&mut self) {
        self.account_nr.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_nr(&mut self, v: ::std::string::String) {
        self.account_nr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_nr(&mut self) -> &mut ::std::string::String {
        &mut self.account_nr
    }

    // Take field
    pub fn take_account_nr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_nr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OKPayAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_nr,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_nr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_nr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.account_nr.is_empty() {
            os.write_string(1, &self.account_nr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OKPayAccountPayload {
        OKPayAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_nr",
                    |m: &OKPayAccountPayload| &m.account_nr,
                    |m: &mut OKPayAccountPayload| &mut m.account_nr,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OKPayAccountPayload>(
                    "OKPayAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static OKPayAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<OKPayAccountPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OKPayAccountPayload,
        };
        unsafe { instance.get(OKPayAccountPayload::new) }
    }
}

impl ::protobuf::Clear for OKPayAccountPayload {
    fn clear(&mut self) {
        self.account_nr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OKPayAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OKPayAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct UpholdAccountPayload {
    // message fields
    pub account_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpholdAccountPayload {
    fn default() -> &'a UpholdAccountPayload {
        <UpholdAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl UpholdAccountPayload {
    pub fn new() -> UpholdAccountPayload {
        ::std::default::Default::default()
    }

    // string account_id = 1;

    pub fn get_account_id(&self) -> &str {
        &self.account_id
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: ::std::string::String) {
        self.account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.account_id
    }

    // Take field
    pub fn take_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpholdAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_id,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.account_id.is_empty() {
            os.write_string(1, &self.account_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpholdAccountPayload {
        UpholdAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_id",
                    |m: &UpholdAccountPayload| &m.account_id,
                    |m: &mut UpholdAccountPayload| &mut m.account_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpholdAccountPayload>(
                    "UpholdAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static UpholdAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<UpholdAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const UpholdAccountPayload,
            };
        unsafe { instance.get(UpholdAccountPayload::new) }
    }
}

impl ::protobuf::Clear for UpholdAccountPayload {
    fn clear(&mut self) {
        self.account_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpholdAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpholdAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct CashAppAccountPayload {
    // message fields
    pub cash_tag: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CashAppAccountPayload {
    fn default() -> &'a CashAppAccountPayload {
        <CashAppAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl CashAppAccountPayload {
    pub fn new() -> CashAppAccountPayload {
        ::std::default::Default::default()
    }

    // string cash_tag = 1;

    pub fn get_cash_tag(&self) -> &str {
        &self.cash_tag
    }
    pub fn clear_cash_tag(&mut self) {
        self.cash_tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_cash_tag(&mut self, v: ::std::string::String) {
        self.cash_tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cash_tag(&mut self) -> &mut ::std::string::String {
        &mut self.cash_tag
    }

    // Take field
    pub fn take_cash_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cash_tag, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CashAppAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.cash_tag,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cash_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cash_tag);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.cash_tag.is_empty() {
            os.write_string(1, &self.cash_tag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CashAppAccountPayload {
        CashAppAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cash_tag",
                    |m: &CashAppAccountPayload| &m.cash_tag,
                    |m: &mut CashAppAccountPayload| &mut m.cash_tag,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CashAppAccountPayload>(
                    "CashAppAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static CashAppAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<CashAppAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const CashAppAccountPayload,
            };
        unsafe { instance.get(CashAppAccountPayload::new) }
    }
}

impl ::protobuf::Clear for CashAppAccountPayload {
    fn clear(&mut self) {
        self.cash_tag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CashAppAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CashAppAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MoneyBeamAccountPayload {
    // message fields
    pub account_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneyBeamAccountPayload {
    fn default() -> &'a MoneyBeamAccountPayload {
        <MoneyBeamAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl MoneyBeamAccountPayload {
    pub fn new() -> MoneyBeamAccountPayload {
        ::std::default::Default::default()
    }

    // string account_id = 1;

    pub fn get_account_id(&self) -> &str {
        &self.account_id
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: ::std::string::String) {
        self.account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.account_id
    }

    // Take field
    pub fn take_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MoneyBeamAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_id,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.account_id.is_empty() {
            os.write_string(1, &self.account_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneyBeamAccountPayload {
        MoneyBeamAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_id",
                    |m: &MoneyBeamAccountPayload| &m.account_id,
                    |m: &mut MoneyBeamAccountPayload| &mut m.account_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneyBeamAccountPayload>(
                    "MoneyBeamAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MoneyBeamAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<MoneyBeamAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const MoneyBeamAccountPayload,
            };
        unsafe { instance.get(MoneyBeamAccountPayload::new) }
    }
}

impl ::protobuf::Clear for MoneyBeamAccountPayload {
    fn clear(&mut self) {
        self.account_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneyBeamAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneyBeamAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct VenmoAccountPayload {
    // message fields
    pub venmo_user_name: ::std::string::String,
    pub holder_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VenmoAccountPayload {
    fn default() -> &'a VenmoAccountPayload {
        <VenmoAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl VenmoAccountPayload {
    pub fn new() -> VenmoAccountPayload {
        ::std::default::Default::default()
    }

    // string venmo_user_name = 1;

    pub fn get_venmo_user_name(&self) -> &str {
        &self.venmo_user_name
    }
    pub fn clear_venmo_user_name(&mut self) {
        self.venmo_user_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_venmo_user_name(&mut self, v: ::std::string::String) {
        self.venmo_user_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_venmo_user_name(&mut self) -> &mut ::std::string::String {
        &mut self.venmo_user_name
    }

    // Take field
    pub fn take_venmo_user_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.venmo_user_name, ::std::string::String::new())
    }

    // string holder_name = 2;

    pub fn get_holder_name(&self) -> &str {
        &self.holder_name
    }
    pub fn clear_holder_name(&mut self) {
        self.holder_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_name(&mut self, v: ::std::string::String) {
        self.holder_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_name(&mut self) -> &mut ::std::string::String {
        &mut self.holder_name
    }

    // Take field
    pub fn take_holder_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VenmoAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.venmo_user_name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.venmo_user_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.venmo_user_name);
        }
        if !self.holder_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.holder_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.venmo_user_name.is_empty() {
            os.write_string(1, &self.venmo_user_name)?;
        }
        if !self.holder_name.is_empty() {
            os.write_string(2, &self.holder_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VenmoAccountPayload {
        VenmoAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "venmo_user_name",
                    |m: &VenmoAccountPayload| &m.venmo_user_name,
                    |m: &mut VenmoAccountPayload| &mut m.venmo_user_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_name",
                    |m: &VenmoAccountPayload| &m.holder_name,
                    |m: &mut VenmoAccountPayload| &mut m.holder_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VenmoAccountPayload>(
                    "VenmoAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static VenmoAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<VenmoAccountPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VenmoAccountPayload,
        };
        unsafe { instance.get(VenmoAccountPayload::new) }
    }
}

impl ::protobuf::Clear for VenmoAccountPayload {
    fn clear(&mut self) {
        self.venmo_user_name.clear();
        self.holder_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VenmoAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VenmoAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PopmoneyAccountPayload {
    // message fields
    pub account_id: ::std::string::String,
    pub holder_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PopmoneyAccountPayload {
    fn default() -> &'a PopmoneyAccountPayload {
        <PopmoneyAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl PopmoneyAccountPayload {
    pub fn new() -> PopmoneyAccountPayload {
        ::std::default::Default::default()
    }

    // string account_id = 1;

    pub fn get_account_id(&self) -> &str {
        &self.account_id
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: ::std::string::String) {
        self.account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.account_id
    }

    // Take field
    pub fn take_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_id, ::std::string::String::new())
    }

    // string holder_name = 2;

    pub fn get_holder_name(&self) -> &str {
        &self.holder_name
    }
    pub fn clear_holder_name(&mut self) {
        self.holder_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_name(&mut self, v: ::std::string::String) {
        self.holder_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_name(&mut self) -> &mut ::std::string::String {
        &mut self.holder_name
    }

    // Take field
    pub fn take_holder_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PopmoneyAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_id);
        }
        if !self.holder_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.holder_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.account_id.is_empty() {
            os.write_string(1, &self.account_id)?;
        }
        if !self.holder_name.is_empty() {
            os.write_string(2, &self.holder_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PopmoneyAccountPayload {
        PopmoneyAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_id",
                    |m: &PopmoneyAccountPayload| &m.account_id,
                    |m: &mut PopmoneyAccountPayload| &mut m.account_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_name",
                    |m: &PopmoneyAccountPayload| &m.holder_name,
                    |m: &mut PopmoneyAccountPayload| &mut m.holder_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PopmoneyAccountPayload>(
                    "PopmoneyAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PopmoneyAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<PopmoneyAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PopmoneyAccountPayload,
            };
        unsafe { instance.get(PopmoneyAccountPayload::new) }
    }
}

impl ::protobuf::Clear for PopmoneyAccountPayload {
    fn clear(&mut self) {
        self.account_id.clear();
        self.holder_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PopmoneyAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PopmoneyAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RevolutAccountPayload {
    // message fields
    pub account_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RevolutAccountPayload {
    fn default() -> &'a RevolutAccountPayload {
        <RevolutAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl RevolutAccountPayload {
    pub fn new() -> RevolutAccountPayload {
        ::std::default::Default::default()
    }

    // string account_id = 1;

    pub fn get_account_id(&self) -> &str {
        &self.account_id
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: ::std::string::String) {
        self.account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.account_id
    }

    // Take field
    pub fn take_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RevolutAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_id,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.account_id.is_empty() {
            os.write_string(1, &self.account_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RevolutAccountPayload {
        RevolutAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_id",
                    |m: &RevolutAccountPayload| &m.account_id,
                    |m: &mut RevolutAccountPayload| &mut m.account_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RevolutAccountPayload>(
                    "RevolutAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static RevolutAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<RevolutAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const RevolutAccountPayload,
            };
        unsafe { instance.get(RevolutAccountPayload::new) }
    }
}

impl ::protobuf::Clear for RevolutAccountPayload {
    fn clear(&mut self) {
        self.account_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RevolutAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RevolutAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PerfectMoneyAccountPayload {
    // message fields
    pub account_nr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerfectMoneyAccountPayload {
    fn default() -> &'a PerfectMoneyAccountPayload {
        <PerfectMoneyAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl PerfectMoneyAccountPayload {
    pub fn new() -> PerfectMoneyAccountPayload {
        ::std::default::Default::default()
    }

    // string account_nr = 1;

    pub fn get_account_nr(&self) -> &str {
        &self.account_nr
    }
    pub fn clear_account_nr(&mut self) {
        self.account_nr.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_nr(&mut self, v: ::std::string::String) {
        self.account_nr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_nr(&mut self) -> &mut ::std::string::String {
        &mut self.account_nr
    }

    // Take field
    pub fn take_account_nr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_nr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PerfectMoneyAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_nr,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_nr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_nr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.account_nr.is_empty() {
            os.write_string(1, &self.account_nr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PerfectMoneyAccountPayload {
        PerfectMoneyAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_nr",
                    |m: &PerfectMoneyAccountPayload| &m.account_nr,
                    |m: &mut PerfectMoneyAccountPayload| &mut m.account_nr,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PerfectMoneyAccountPayload>(
                    "PerfectMoneyAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PerfectMoneyAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<PerfectMoneyAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PerfectMoneyAccountPayload,
            };
        unsafe { instance.get(PerfectMoneyAccountPayload::new) }
    }
}

impl ::protobuf::Clear for PerfectMoneyAccountPayload {
    fn clear(&mut self) {
        self.account_nr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PerfectMoneyAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PerfectMoneyAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct SwishAccountPayload {
    // message fields
    pub mobile_nr: ::std::string::String,
    pub holder_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwishAccountPayload {
    fn default() -> &'a SwishAccountPayload {
        <SwishAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl SwishAccountPayload {
    pub fn new() -> SwishAccountPayload {
        ::std::default::Default::default()
    }

    // string mobile_nr = 1;

    pub fn get_mobile_nr(&self) -> &str {
        &self.mobile_nr
    }
    pub fn clear_mobile_nr(&mut self) {
        self.mobile_nr.clear();
    }

    // Param is passed by value, moved
    pub fn set_mobile_nr(&mut self, v: ::std::string::String) {
        self.mobile_nr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mobile_nr(&mut self) -> &mut ::std::string::String {
        &mut self.mobile_nr
    }

    // Take field
    pub fn take_mobile_nr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mobile_nr, ::std::string::String::new())
    }

    // string holder_name = 2;

    pub fn get_holder_name(&self) -> &str {
        &self.holder_name
    }
    pub fn clear_holder_name(&mut self) {
        self.holder_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_name(&mut self, v: ::std::string::String) {
        self.holder_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_name(&mut self) -> &mut ::std::string::String {
        &mut self.holder_name
    }

    // Take field
    pub fn take_holder_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SwishAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mobile_nr,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mobile_nr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mobile_nr);
        }
        if !self.holder_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.holder_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.mobile_nr.is_empty() {
            os.write_string(1, &self.mobile_nr)?;
        }
        if !self.holder_name.is_empty() {
            os.write_string(2, &self.holder_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SwishAccountPayload {
        SwishAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "mobile_nr",
                    |m: &SwishAccountPayload| &m.mobile_nr,
                    |m: &mut SwishAccountPayload| &mut m.mobile_nr,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_name",
                    |m: &SwishAccountPayload| &m.holder_name,
                    |m: &mut SwishAccountPayload| &mut m.holder_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SwishAccountPayload>(
                    "SwishAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static SwishAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<SwishAccountPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SwishAccountPayload,
        };
        unsafe { instance.get(SwishAccountPayload::new) }
    }
}

impl ::protobuf::Clear for SwishAccountPayload {
    fn clear(&mut self) {
        self.mobile_nr.clear();
        self.holder_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SwishAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwishAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct USPostalMoneyOrderAccountPayload {
    // message fields
    pub postal_address: ::std::string::String,
    pub holder_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a USPostalMoneyOrderAccountPayload {
    fn default() -> &'a USPostalMoneyOrderAccountPayload {
        <USPostalMoneyOrderAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl USPostalMoneyOrderAccountPayload {
    pub fn new() -> USPostalMoneyOrderAccountPayload {
        ::std::default::Default::default()
    }

    // string postal_address = 1;

    pub fn get_postal_address(&self) -> &str {
        &self.postal_address
    }
    pub fn clear_postal_address(&mut self) {
        self.postal_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_postal_address(&mut self, v: ::std::string::String) {
        self.postal_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postal_address(&mut self) -> &mut ::std::string::String {
        &mut self.postal_address
    }

    // Take field
    pub fn take_postal_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.postal_address, ::std::string::String::new())
    }

    // string holder_name = 2;

    pub fn get_holder_name(&self) -> &str {
        &self.holder_name
    }
    pub fn clear_holder_name(&mut self) {
        self.holder_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_holder_name(&mut self, v: ::std::string::String) {
        self.holder_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder_name(&mut self) -> &mut ::std::string::String {
        &mut self.holder_name
    }

    // Take field
    pub fn take_holder_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.holder_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for USPostalMoneyOrderAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.postal_address,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.holder_name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.postal_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.postal_address);
        }
        if !self.holder_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.holder_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.postal_address.is_empty() {
            os.write_string(1, &self.postal_address)?;
        }
        if !self.holder_name.is_empty() {
            os.write_string(2, &self.holder_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> USPostalMoneyOrderAccountPayload {
        USPostalMoneyOrderAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "postal_address",
                    |m: &USPostalMoneyOrderAccountPayload| &m.postal_address,
                    |m: &mut USPostalMoneyOrderAccountPayload| &mut m.postal_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "holder_name",
                    |m: &USPostalMoneyOrderAccountPayload| &m.holder_name,
                    |m: &mut USPostalMoneyOrderAccountPayload| &mut m.holder_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<USPostalMoneyOrderAccountPayload>(
                    "USPostalMoneyOrderAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static USPostalMoneyOrderAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<USPostalMoneyOrderAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const USPostalMoneyOrderAccountPayload,
            };
        unsafe { instance.get(USPostalMoneyOrderAccountPayload::new) }
    }
}

impl ::protobuf::Clear for USPostalMoneyOrderAccountPayload {
    fn clear(&mut self) {
        self.postal_address.clear();
        self.holder_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for USPostalMoneyOrderAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for USPostalMoneyOrderAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct F2FAccountPayload {
    // message fields
    pub contact: ::std::string::String,
    pub city: ::std::string::String,
    pub extra_info: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a F2FAccountPayload {
    fn default() -> &'a F2FAccountPayload {
        <F2FAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl F2FAccountPayload {
    pub fn new() -> F2FAccountPayload {
        ::std::default::Default::default()
    }

    // string contact = 1;

    pub fn get_contact(&self) -> &str {
        &self.contact
    }
    pub fn clear_contact(&mut self) {
        self.contact.clear();
    }

    // Param is passed by value, moved
    pub fn set_contact(&mut self, v: ::std::string::String) {
        self.contact = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contact(&mut self) -> &mut ::std::string::String {
        &mut self.contact
    }

    // Take field
    pub fn take_contact(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contact, ::std::string::String::new())
    }

    // string city = 2;

    pub fn get_city(&self) -> &str {
        &self.city
    }
    pub fn clear_city(&mut self) {
        self.city.clear();
    }

    // Param is passed by value, moved
    pub fn set_city(&mut self, v: ::std::string::String) {
        self.city = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_city(&mut self) -> &mut ::std::string::String {
        &mut self.city
    }

    // Take field
    pub fn take_city(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.city, ::std::string::String::new())
    }

    // string extra_info = 3;

    pub fn get_extra_info(&self) -> &str {
        &self.extra_info
    }
    pub fn clear_extra_info(&mut self) {
        self.extra_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_info(&mut self, v: ::std::string::String) {
        self.extra_info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_info(&mut self) -> &mut ::std::string::String {
        &mut self.extra_info
    }

    // Take field
    pub fn take_extra_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.extra_info, ::std::string::String::new())
    }
}

impl ::protobuf::Message for F2FAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.contact,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.city,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.extra_info,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.contact.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.contact);
        }
        if !self.city.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.city);
        }
        if !self.extra_info.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.extra_info);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.contact.is_empty() {
            os.write_string(1, &self.contact)?;
        }
        if !self.city.is_empty() {
            os.write_string(2, &self.city)?;
        }
        if !self.extra_info.is_empty() {
            os.write_string(3, &self.extra_info)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> F2FAccountPayload {
        F2FAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "contact",
                    |m: &F2FAccountPayload| &m.contact,
                    |m: &mut F2FAccountPayload| &mut m.contact,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "city",
                    |m: &F2FAccountPayload| &m.city,
                    |m: &mut F2FAccountPayload| &mut m.city,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "extra_info",
                    |m: &F2FAccountPayload| &m.extra_info,
                    |m: &mut F2FAccountPayload| &mut m.extra_info,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<F2FAccountPayload>(
                    "F2FAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static F2FAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<F2FAccountPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const F2FAccountPayload,
        };
        unsafe { instance.get(F2FAccountPayload::new) }
    }
}

impl ::protobuf::Clear for F2FAccountPayload {
    fn clear(&mut self) {
        self.contact.clear();
        self.city.clear();
        self.extra_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for F2FAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for F2FAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PromptPayAccountPayload {
    // message fields
    pub prompt_pay_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PromptPayAccountPayload {
    fn default() -> &'a PromptPayAccountPayload {
        <PromptPayAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl PromptPayAccountPayload {
    pub fn new() -> PromptPayAccountPayload {
        ::std::default::Default::default()
    }

    // string prompt_pay_id = 1;

    pub fn get_prompt_pay_id(&self) -> &str {
        &self.prompt_pay_id
    }
    pub fn clear_prompt_pay_id(&mut self) {
        self.prompt_pay_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_prompt_pay_id(&mut self, v: ::std::string::String) {
        self.prompt_pay_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prompt_pay_id(&mut self) -> &mut ::std::string::String {
        &mut self.prompt_pay_id
    }

    // Take field
    pub fn take_prompt_pay_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prompt_pay_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PromptPayAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.prompt_pay_id,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prompt_pay_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.prompt_pay_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.prompt_pay_id.is_empty() {
            os.write_string(1, &self.prompt_pay_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PromptPayAccountPayload {
        PromptPayAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "prompt_pay_id",
                    |m: &PromptPayAccountPayload| &m.prompt_pay_id,
                    |m: &mut PromptPayAccountPayload| &mut m.prompt_pay_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PromptPayAccountPayload>(
                    "PromptPayAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PromptPayAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<PromptPayAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PromptPayAccountPayload,
            };
        unsafe { instance.get(PromptPayAccountPayload::new) }
    }
}

impl ::protobuf::Clear for PromptPayAccountPayload {
    fn clear(&mut self) {
        self.prompt_pay_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PromptPayAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PromptPayAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct AdvancedCashAccountPayload {
    // message fields
    pub account_nr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdvancedCashAccountPayload {
    fn default() -> &'a AdvancedCashAccountPayload {
        <AdvancedCashAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl AdvancedCashAccountPayload {
    pub fn new() -> AdvancedCashAccountPayload {
        ::std::default::Default::default()
    }

    // string account_nr = 1;

    pub fn get_account_nr(&self) -> &str {
        &self.account_nr
    }
    pub fn clear_account_nr(&mut self) {
        self.account_nr.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_nr(&mut self, v: ::std::string::String) {
        self.account_nr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_nr(&mut self) -> &mut ::std::string::String {
        &mut self.account_nr
    }

    // Take field
    pub fn take_account_nr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_nr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AdvancedCashAccountPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_nr,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_nr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_nr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.account_nr.is_empty() {
            os.write_string(1, &self.account_nr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdvancedCashAccountPayload {
        AdvancedCashAccountPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_nr",
                    |m: &AdvancedCashAccountPayload| &m.account_nr,
                    |m: &mut AdvancedCashAccountPayload| &mut m.account_nr,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AdvancedCashAccountPayload>(
                    "AdvancedCashAccountPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static AdvancedCashAccountPayload {
        static mut instance: ::protobuf::lazy::Lazy<AdvancedCashAccountPayload> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const AdvancedCashAccountPayload,
            };
        unsafe { instance.get(AdvancedCashAccountPayload::new) }
    }
}

impl ::protobuf::Clear for AdvancedCashAccountPayload {
    fn clear(&mut self) {
        self.account_nr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdvancedCashAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdvancedCashAccountPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PersistableEnvelope {
    // message oneof groups
    pub message: ::std::option::Option<PersistableEnvelope_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistableEnvelope {
    fn default() -> &'a PersistableEnvelope {
        <PersistableEnvelope as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum PersistableEnvelope_oneof_message {
    sequence_number_map(SequenceNumberMap),
    persisted_entry_map(PersistedEntryMap),
    peer_list(PeerList),
    address_entry_list(AddressEntryList),
    navigation_path(NavigationPath),
    tradable_list(TradableList),
    trade_statistics_list(TradeStatisticsList),
    arbitration_dispute_list(ArbitrationDisputeList),
    preferences_payload(PreferencesPayload),
    user_payload(UserPayload),
    payment_account_list(PaymentAccountList),
    account_age_witness_store(AccountAgeWitnessStore),
    trade_statistics2_store(TradeStatistics2Store),
    persistable_network_payload_list(PersistableNetworkPayloadList),
    proposal_store(ProposalStore),
    temp_proposal_store(TempProposalStore),
    blind_vote_store(BlindVoteStore),
    my_proposal_list(MyProposalList),
    ballot_list(BallotList),
    my_vote_list(MyVoteList),
    my_blind_vote_list(MyBlindVoteList),
    merit_list(MeritList),
    dao_state_store(DaoStateStore),
    my_reputation_list(MyReputationList),
    my_proof_of_burn_list(MyProofOfBurnList),
    unconfirmed_bsq_change_output_list(UnconfirmedBsqChangeOutputList),
    signed_witness_store(SignedWitnessStore),
    mediation_dispute_list(MediationDisputeList),
    refund_dispute_list(RefundDisputeList),
}

impl PersistableEnvelope {
    pub fn new() -> PersistableEnvelope {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.SequenceNumberMap sequence_number_map = 1;

    pub fn get_sequence_number_map(&self) -> &SequenceNumberMap {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::sequence_number_map(ref v),
            ) => v,
            _ => SequenceNumberMap::default_instance(),
        }
    }
    pub fn clear_sequence_number_map(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_sequence_number_map(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::sequence_number_map(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sequence_number_map(&mut self, v: SequenceNumberMap) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::sequence_number_map(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sequence_number_map(&mut self) -> &mut SequenceNumberMap {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::sequence_number_map(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::sequence_number_map(SequenceNumberMap::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::sequence_number_map(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sequence_number_map(&mut self) -> SequenceNumberMap {
        if self.has_sequence_number_map() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::sequence_number_map(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            SequenceNumberMap::new()
        }
    }

    // .io.bisq.protobuffer.PersistedEntryMap persisted_entry_map = 2;

    pub fn get_persisted_entry_map(&self) -> &PersistedEntryMap {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::persisted_entry_map(ref v),
            ) => v,
            _ => PersistedEntryMap::default_instance(),
        }
    }
    pub fn clear_persisted_entry_map(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_persisted_entry_map(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::persisted_entry_map(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_persisted_entry_map(&mut self, v: PersistedEntryMap) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::persisted_entry_map(v))
    }

    // Mutable pointer to the field.
    pub fn mut_persisted_entry_map(&mut self) -> &mut PersistedEntryMap {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::persisted_entry_map(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::persisted_entry_map(PersistedEntryMap::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::persisted_entry_map(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_persisted_entry_map(&mut self) -> PersistedEntryMap {
        if self.has_persisted_entry_map() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::persisted_entry_map(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            PersistedEntryMap::new()
        }
    }

    // .io.bisq.protobuffer.PeerList peer_list = 3;

    pub fn get_peer_list(&self) -> &PeerList {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::peer_list(ref v)) => v,
            _ => PeerList::default_instance(),
        }
    }
    pub fn clear_peer_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_peer_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::peer_list(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_peer_list(&mut self, v: PeerList) {
        self.message = ::std::option::Option::Some(PersistableEnvelope_oneof_message::peer_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_peer_list(&mut self) -> &mut PeerList {
        if let ::std::option::Option::Some(PersistableEnvelope_oneof_message::peer_list(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::peer_list(PeerList::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::peer_list(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_peer_list(&mut self) -> PeerList {
        if self.has_peer_list() {
            match self.message.take() {
                ::std::option::Option::Some(PersistableEnvelope_oneof_message::peer_list(v)) => v,
                _ => panic!(),
            }
        } else {
            PeerList::new()
        }
    }

    // .io.bisq.protobuffer.AddressEntryList address_entry_list = 4;

    pub fn get_address_entry_list(&self) -> &AddressEntryList {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::address_entry_list(
                ref v,
            )) => v,
            _ => AddressEntryList::default_instance(),
        }
    }
    pub fn clear_address_entry_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_address_entry_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::address_entry_list(
                ..,
            )) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_address_entry_list(&mut self, v: AddressEntryList) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::address_entry_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_address_entry_list(&mut self) -> &mut AddressEntryList {
        if let ::std::option::Option::Some(PersistableEnvelope_oneof_message::address_entry_list(
            _,
        )) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::address_entry_list(AddressEntryList::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::address_entry_list(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_address_entry_list(&mut self) -> AddressEntryList {
        if self.has_address_entry_list() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::address_entry_list(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            AddressEntryList::new()
        }
    }

    // .io.bisq.protobuffer.NavigationPath navigation_path = 5;

    pub fn get_navigation_path(&self) -> &NavigationPath {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::navigation_path(
                ref v,
            )) => v,
            _ => NavigationPath::default_instance(),
        }
    }
    pub fn clear_navigation_path(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_navigation_path(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::navigation_path(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_navigation_path(&mut self, v: NavigationPath) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::navigation_path(v))
    }

    // Mutable pointer to the field.
    pub fn mut_navigation_path(&mut self) -> &mut NavigationPath {
        if let ::std::option::Option::Some(PersistableEnvelope_oneof_message::navigation_path(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::navigation_path(NavigationPath::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::navigation_path(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_navigation_path(&mut self) -> NavigationPath {
        if self.has_navigation_path() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::navigation_path(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            NavigationPath::new()
        }
    }

    // .io.bisq.protobuffer.TradableList tradable_list = 6;

    pub fn get_tradable_list(&self) -> &TradableList {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::tradable_list(
                ref v,
            )) => v,
            _ => TradableList::default_instance(),
        }
    }
    pub fn clear_tradable_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_tradable_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::tradable_list(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tradable_list(&mut self, v: TradableList) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::tradable_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tradable_list(&mut self) -> &mut TradableList {
        if let ::std::option::Option::Some(PersistableEnvelope_oneof_message::tradable_list(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::tradable_list(TradableList::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::tradable_list(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tradable_list(&mut self) -> TradableList {
        if self.has_tradable_list() {
            match self.message.take() {
                ::std::option::Option::Some(PersistableEnvelope_oneof_message::tradable_list(
                    v,
                )) => v,
                _ => panic!(),
            }
        } else {
            TradableList::new()
        }
    }

    // .io.bisq.protobuffer.TradeStatisticsList trade_statistics_list = 7;

    pub fn get_trade_statistics_list(&self) -> &TradeStatisticsList {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::trade_statistics_list(ref v),
            ) => v,
            _ => TradeStatisticsList::default_instance(),
        }
    }
    pub fn clear_trade_statistics_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_trade_statistics_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::trade_statistics_list(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_trade_statistics_list(&mut self, v: TradeStatisticsList) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::trade_statistics_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_trade_statistics_list(&mut self) -> &mut TradeStatisticsList {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::trade_statistics_list(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::trade_statistics_list(TradeStatisticsList::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::trade_statistics_list(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_trade_statistics_list(&mut self) -> TradeStatisticsList {
        if self.has_trade_statistics_list() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::trade_statistics_list(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            TradeStatisticsList::new()
        }
    }

    // .io.bisq.protobuffer.ArbitrationDisputeList arbitration_dispute_list = 8;

    pub fn get_arbitration_dispute_list(&self) -> &ArbitrationDisputeList {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::arbitration_dispute_list(ref v),
            ) => v,
            _ => ArbitrationDisputeList::default_instance(),
        }
    }
    pub fn clear_arbitration_dispute_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_arbitration_dispute_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::arbitration_dispute_list(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_arbitration_dispute_list(&mut self, v: ArbitrationDisputeList) {
        self.message = ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::arbitration_dispute_list(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_arbitration_dispute_list(&mut self) -> &mut ArbitrationDisputeList {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::arbitration_dispute_list(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::arbitration_dispute_list(
                    ArbitrationDisputeList::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::arbitration_dispute_list(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_arbitration_dispute_list(&mut self) -> ArbitrationDisputeList {
        if self.has_arbitration_dispute_list() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::arbitration_dispute_list(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            ArbitrationDisputeList::new()
        }
    }

    // .io.bisq.protobuffer.PreferencesPayload preferences_payload = 9;

    pub fn get_preferences_payload(&self) -> &PreferencesPayload {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::preferences_payload(ref v),
            ) => v,
            _ => PreferencesPayload::default_instance(),
        }
    }
    pub fn clear_preferences_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_preferences_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::preferences_payload(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_preferences_payload(&mut self, v: PreferencesPayload) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::preferences_payload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_preferences_payload(&mut self) -> &mut PreferencesPayload {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::preferences_payload(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::preferences_payload(PreferencesPayload::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::preferences_payload(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_preferences_payload(&mut self) -> PreferencesPayload {
        if self.has_preferences_payload() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::preferences_payload(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            PreferencesPayload::new()
        }
    }

    // .io.bisq.protobuffer.UserPayload user_payload = 10;

    pub fn get_user_payload(&self) -> &UserPayload {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::user_payload(ref v)) => {
                v
            }
            _ => UserPayload::default_instance(),
        }
    }
    pub fn clear_user_payload(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_user_payload(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::user_payload(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user_payload(&mut self, v: UserPayload) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::user_payload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user_payload(&mut self) -> &mut UserPayload {
        if let ::std::option::Option::Some(PersistableEnvelope_oneof_message::user_payload(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::user_payload(UserPayload::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::user_payload(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user_payload(&mut self) -> UserPayload {
        if self.has_user_payload() {
            match self.message.take() {
                ::std::option::Option::Some(PersistableEnvelope_oneof_message::user_payload(v)) => {
                    v
                }
                _ => panic!(),
            }
        } else {
            UserPayload::new()
        }
    }

    // .io.bisq.protobuffer.PaymentAccountList payment_account_list = 11;

    pub fn get_payment_account_list(&self) -> &PaymentAccountList {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::payment_account_list(ref v),
            ) => v,
            _ => PaymentAccountList::default_instance(),
        }
    }
    pub fn clear_payment_account_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_payment_account_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::payment_account_list(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_payment_account_list(&mut self, v: PaymentAccountList) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::payment_account_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_payment_account_list(&mut self) -> &mut PaymentAccountList {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::payment_account_list(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::payment_account_list(PaymentAccountList::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::payment_account_list(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_payment_account_list(&mut self) -> PaymentAccountList {
        if self.has_payment_account_list() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::payment_account_list(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            PaymentAccountList::new()
        }
    }

    // .io.bisq.protobuffer.AccountAgeWitnessStore account_age_witness_store = 13;

    pub fn get_account_age_witness_store(&self) -> &AccountAgeWitnessStore {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::account_age_witness_store(ref v),
            ) => v,
            _ => AccountAgeWitnessStore::default_instance(),
        }
    }
    pub fn clear_account_age_witness_store(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_account_age_witness_store(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::account_age_witness_store(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_account_age_witness_store(&mut self, v: AccountAgeWitnessStore) {
        self.message = ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::account_age_witness_store(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_account_age_witness_store(&mut self) -> &mut AccountAgeWitnessStore {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::account_age_witness_store(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::account_age_witness_store(
                    AccountAgeWitnessStore::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::account_age_witness_store(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_account_age_witness_store(&mut self) -> AccountAgeWitnessStore {
        if self.has_account_age_witness_store() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::account_age_witness_store(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            AccountAgeWitnessStore::new()
        }
    }

    // .io.bisq.protobuffer.TradeStatistics2Store trade_statistics2_store = 14;

    pub fn get_trade_statistics2_store(&self) -> &TradeStatistics2Store {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::trade_statistics2_store(ref v),
            ) => v,
            _ => TradeStatistics2Store::default_instance(),
        }
    }
    pub fn clear_trade_statistics2_store(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_trade_statistics2_store(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::trade_statistics2_store(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_trade_statistics2_store(&mut self, v: TradeStatistics2Store) {
        self.message = ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::trade_statistics2_store(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_trade_statistics2_store(&mut self) -> &mut TradeStatistics2Store {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::trade_statistics2_store(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::trade_statistics2_store(
                    TradeStatistics2Store::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::trade_statistics2_store(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_trade_statistics2_store(&mut self) -> TradeStatistics2Store {
        if self.has_trade_statistics2_store() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::trade_statistics2_store(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            TradeStatistics2Store::new()
        }
    }

    // .io.bisq.protobuffer.PersistableNetworkPayloadList persistable_network_payload_list = 15;

    pub fn get_persistable_network_payload_list(&self) -> &PersistableNetworkPayloadList {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::persistable_network_payload_list(ref v),
            ) => v,
            _ => PersistableNetworkPayloadList::default_instance(),
        }
    }
    pub fn clear_persistable_network_payload_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_persistable_network_payload_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::persistable_network_payload_list(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_persistable_network_payload_list(&mut self, v: PersistableNetworkPayloadList) {
        self.message = ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::persistable_network_payload_list(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_persistable_network_payload_list(&mut self) -> &mut PersistableNetworkPayloadList {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::persistable_network_payload_list(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::persistable_network_payload_list(
                    PersistableNetworkPayloadList::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::persistable_network_payload_list(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_persistable_network_payload_list(&mut self) -> PersistableNetworkPayloadList {
        if self.has_persistable_network_payload_list() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::persistable_network_payload_list(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            PersistableNetworkPayloadList::new()
        }
    }

    // .io.bisq.protobuffer.ProposalStore proposal_store = 16;

    pub fn get_proposal_store(&self) -> &ProposalStore {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::proposal_store(
                ref v,
            )) => v,
            _ => ProposalStore::default_instance(),
        }
    }
    pub fn clear_proposal_store(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_proposal_store(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::proposal_store(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_proposal_store(&mut self, v: ProposalStore) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::proposal_store(v))
    }

    // Mutable pointer to the field.
    pub fn mut_proposal_store(&mut self) -> &mut ProposalStore {
        if let ::std::option::Option::Some(PersistableEnvelope_oneof_message::proposal_store(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::proposal_store(ProposalStore::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::proposal_store(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_proposal_store(&mut self) -> ProposalStore {
        if self.has_proposal_store() {
            match self.message.take() {
                ::std::option::Option::Some(PersistableEnvelope_oneof_message::proposal_store(
                    v,
                )) => v,
                _ => panic!(),
            }
        } else {
            ProposalStore::new()
        }
    }

    // .io.bisq.protobuffer.TempProposalStore temp_proposal_store = 17;

    pub fn get_temp_proposal_store(&self) -> &TempProposalStore {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::temp_proposal_store(ref v),
            ) => v,
            _ => TempProposalStore::default_instance(),
        }
    }
    pub fn clear_temp_proposal_store(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_temp_proposal_store(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::temp_proposal_store(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_temp_proposal_store(&mut self, v: TempProposalStore) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::temp_proposal_store(v))
    }

    // Mutable pointer to the field.
    pub fn mut_temp_proposal_store(&mut self) -> &mut TempProposalStore {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::temp_proposal_store(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::temp_proposal_store(TempProposalStore::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::temp_proposal_store(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_temp_proposal_store(&mut self) -> TempProposalStore {
        if self.has_temp_proposal_store() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::temp_proposal_store(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            TempProposalStore::new()
        }
    }

    // .io.bisq.protobuffer.BlindVoteStore blind_vote_store = 18;

    pub fn get_blind_vote_store(&self) -> &BlindVoteStore {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::blind_vote_store(
                ref v,
            )) => v,
            _ => BlindVoteStore::default_instance(),
        }
    }
    pub fn clear_blind_vote_store(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_blind_vote_store(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::blind_vote_store(
                ..,
            )) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_blind_vote_store(&mut self, v: BlindVoteStore) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::blind_vote_store(v))
    }

    // Mutable pointer to the field.
    pub fn mut_blind_vote_store(&mut self) -> &mut BlindVoteStore {
        if let ::std::option::Option::Some(PersistableEnvelope_oneof_message::blind_vote_store(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::blind_vote_store(BlindVoteStore::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::blind_vote_store(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_blind_vote_store(&mut self) -> BlindVoteStore {
        if self.has_blind_vote_store() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::blind_vote_store(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            BlindVoteStore::new()
        }
    }

    // .io.bisq.protobuffer.MyProposalList my_proposal_list = 19;

    pub fn get_my_proposal_list(&self) -> &MyProposalList {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_proposal_list(
                ref v,
            )) => v,
            _ => MyProposalList::default_instance(),
        }
    }
    pub fn clear_my_proposal_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_my_proposal_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_proposal_list(
                ..,
            )) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_my_proposal_list(&mut self, v: MyProposalList) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_proposal_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_my_proposal_list(&mut self) -> &mut MyProposalList {
        if let ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_proposal_list(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::my_proposal_list(MyProposalList::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_proposal_list(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_my_proposal_list(&mut self) -> MyProposalList {
        if self.has_my_proposal_list() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::my_proposal_list(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            MyProposalList::new()
        }
    }

    // .io.bisq.protobuffer.BallotList ballot_list = 20;

    pub fn get_ballot_list(&self) -> &BallotList {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::ballot_list(ref v)) => v,
            _ => BallotList::default_instance(),
        }
    }
    pub fn clear_ballot_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_ballot_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::ballot_list(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ballot_list(&mut self, v: BallotList) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::ballot_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ballot_list(&mut self) -> &mut BallotList {
        if let ::std::option::Option::Some(PersistableEnvelope_oneof_message::ballot_list(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::ballot_list(BallotList::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::ballot_list(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ballot_list(&mut self) -> BallotList {
        if self.has_ballot_list() {
            match self.message.take() {
                ::std::option::Option::Some(PersistableEnvelope_oneof_message::ballot_list(v)) => v,
                _ => panic!(),
            }
        } else {
            BallotList::new()
        }
    }

    // .io.bisq.protobuffer.MyVoteList my_vote_list = 21;

    pub fn get_my_vote_list(&self) -> &MyVoteList {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_vote_list(ref v)) => {
                v
            }
            _ => MyVoteList::default_instance(),
        }
    }
    pub fn clear_my_vote_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_my_vote_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_vote_list(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_my_vote_list(&mut self, v: MyVoteList) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_vote_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_my_vote_list(&mut self) -> &mut MyVoteList {
        if let ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_vote_list(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::my_vote_list(MyVoteList::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_vote_list(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_my_vote_list(&mut self) -> MyVoteList {
        if self.has_my_vote_list() {
            match self.message.take() {
                ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_vote_list(v)) => {
                    v
                }
                _ => panic!(),
            }
        } else {
            MyVoteList::new()
        }
    }

    // .io.bisq.protobuffer.MyBlindVoteList my_blind_vote_list = 22;

    pub fn get_my_blind_vote_list(&self) -> &MyBlindVoteList {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_blind_vote_list(
                ref v,
            )) => v,
            _ => MyBlindVoteList::default_instance(),
        }
    }
    pub fn clear_my_blind_vote_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_my_blind_vote_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_blind_vote_list(
                ..,
            )) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_my_blind_vote_list(&mut self, v: MyBlindVoteList) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_blind_vote_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_my_blind_vote_list(&mut self) -> &mut MyBlindVoteList {
        if let ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_blind_vote_list(
            _,
        )) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::my_blind_vote_list(MyBlindVoteList::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_blind_vote_list(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_my_blind_vote_list(&mut self) -> MyBlindVoteList {
        if self.has_my_blind_vote_list() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::my_blind_vote_list(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            MyBlindVoteList::new()
        }
    }

    // .io.bisq.protobuffer.MeritList merit_list = 23;

    pub fn get_merit_list(&self) -> &MeritList {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::merit_list(ref v)) => v,
            _ => MeritList::default_instance(),
        }
    }
    pub fn clear_merit_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_merit_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::merit_list(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_merit_list(&mut self, v: MeritList) {
        self.message = ::std::option::Option::Some(PersistableEnvelope_oneof_message::merit_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_merit_list(&mut self) -> &mut MeritList {
        if let ::std::option::Option::Some(PersistableEnvelope_oneof_message::merit_list(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::merit_list(MeritList::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::merit_list(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_merit_list(&mut self) -> MeritList {
        if self.has_merit_list() {
            match self.message.take() {
                ::std::option::Option::Some(PersistableEnvelope_oneof_message::merit_list(v)) => v,
                _ => panic!(),
            }
        } else {
            MeritList::new()
        }
    }

    // .io.bisq.protobuffer.DaoStateStore dao_state_store = 24;

    pub fn get_dao_state_store(&self) -> &DaoStateStore {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::dao_state_store(
                ref v,
            )) => v,
            _ => DaoStateStore::default_instance(),
        }
    }
    pub fn clear_dao_state_store(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_dao_state_store(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::dao_state_store(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dao_state_store(&mut self, v: DaoStateStore) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::dao_state_store(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dao_state_store(&mut self) -> &mut DaoStateStore {
        if let ::std::option::Option::Some(PersistableEnvelope_oneof_message::dao_state_store(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::dao_state_store(DaoStateStore::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::dao_state_store(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dao_state_store(&mut self) -> DaoStateStore {
        if self.has_dao_state_store() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::dao_state_store(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            DaoStateStore::new()
        }
    }

    // .io.bisq.protobuffer.MyReputationList my_reputation_list = 25;

    pub fn get_my_reputation_list(&self) -> &MyReputationList {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_reputation_list(
                ref v,
            )) => v,
            _ => MyReputationList::default_instance(),
        }
    }
    pub fn clear_my_reputation_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_my_reputation_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_reputation_list(
                ..,
            )) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_my_reputation_list(&mut self, v: MyReputationList) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_reputation_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_my_reputation_list(&mut self) -> &mut MyReputationList {
        if let ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_reputation_list(
            _,
        )) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::my_reputation_list(MyReputationList::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_reputation_list(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_my_reputation_list(&mut self) -> MyReputationList {
        if self.has_my_reputation_list() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::my_reputation_list(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            MyReputationList::new()
        }
    }

    // .io.bisq.protobuffer.MyProofOfBurnList my_proof_of_burn_list = 26;

    pub fn get_my_proof_of_burn_list(&self) -> &MyProofOfBurnList {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::my_proof_of_burn_list(ref v),
            ) => v,
            _ => MyProofOfBurnList::default_instance(),
        }
    }
    pub fn clear_my_proof_of_burn_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_my_proof_of_burn_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::my_proof_of_burn_list(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_my_proof_of_burn_list(&mut self, v: MyProofOfBurnList) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::my_proof_of_burn_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_my_proof_of_burn_list(&mut self) -> &mut MyProofOfBurnList {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::my_proof_of_burn_list(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::my_proof_of_burn_list(MyProofOfBurnList::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::my_proof_of_burn_list(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_my_proof_of_burn_list(&mut self) -> MyProofOfBurnList {
        if self.has_my_proof_of_burn_list() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::my_proof_of_burn_list(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            MyProofOfBurnList::new()
        }
    }

    // .io.bisq.protobuffer.UnconfirmedBsqChangeOutputList unconfirmed_bsq_change_output_list = 27;

    pub fn get_unconfirmed_bsq_change_output_list(&self) -> &UnconfirmedBsqChangeOutputList {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::unconfirmed_bsq_change_output_list(ref v),
            ) => v,
            _ => UnconfirmedBsqChangeOutputList::default_instance(),
        }
    }
    pub fn clear_unconfirmed_bsq_change_output_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_unconfirmed_bsq_change_output_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::unconfirmed_bsq_change_output_list(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unconfirmed_bsq_change_output_list(&mut self, v: UnconfirmedBsqChangeOutputList) {
        self.message = ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::unconfirmed_bsq_change_output_list(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_unconfirmed_bsq_change_output_list(
        &mut self,
    ) -> &mut UnconfirmedBsqChangeOutputList {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::unconfirmed_bsq_change_output_list(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::unconfirmed_bsq_change_output_list(
                    UnconfirmedBsqChangeOutputList::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::unconfirmed_bsq_change_output_list(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unconfirmed_bsq_change_output_list(&mut self) -> UnconfirmedBsqChangeOutputList {
        if self.has_unconfirmed_bsq_change_output_list() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::unconfirmed_bsq_change_output_list(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            UnconfirmedBsqChangeOutputList::new()
        }
    }

    // .io.bisq.protobuffer.SignedWitnessStore signed_witness_store = 28;

    pub fn get_signed_witness_store(&self) -> &SignedWitnessStore {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::signed_witness_store(ref v),
            ) => v,
            _ => SignedWitnessStore::default_instance(),
        }
    }
    pub fn clear_signed_witness_store(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_signed_witness_store(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::signed_witness_store(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_witness_store(&mut self, v: SignedWitnessStore) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::signed_witness_store(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_witness_store(&mut self) -> &mut SignedWitnessStore {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::signed_witness_store(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::signed_witness_store(SignedWitnessStore::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::signed_witness_store(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_witness_store(&mut self) -> SignedWitnessStore {
        if self.has_signed_witness_store() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::signed_witness_store(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            SignedWitnessStore::new()
        }
    }

    // .io.bisq.protobuffer.MediationDisputeList mediation_dispute_list = 29;

    pub fn get_mediation_dispute_list(&self) -> &MediationDisputeList {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::mediation_dispute_list(ref v),
            ) => v,
            _ => MediationDisputeList::default_instance(),
        }
    }
    pub fn clear_mediation_dispute_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_mediation_dispute_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::mediation_dispute_list(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mediation_dispute_list(&mut self, v: MediationDisputeList) {
        self.message = ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::mediation_dispute_list(v),
        )
    }

    // Mutable pointer to the field.
    pub fn mut_mediation_dispute_list(&mut self) -> &mut MediationDisputeList {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::mediation_dispute_list(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::mediation_dispute_list(
                    MediationDisputeList::new(),
                ),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::mediation_dispute_list(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mediation_dispute_list(&mut self) -> MediationDisputeList {
        if self.has_mediation_dispute_list() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::mediation_dispute_list(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            MediationDisputeList::new()
        }
    }

    // .io.bisq.protobuffer.RefundDisputeList refund_dispute_list = 30;

    pub fn get_refund_dispute_list(&self) -> &RefundDisputeList {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::refund_dispute_list(ref v),
            ) => v,
            _ => RefundDisputeList::default_instance(),
        }
    }
    pub fn clear_refund_dispute_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_refund_dispute_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::refund_dispute_list(..),
            ) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_refund_dispute_list(&mut self, v: RefundDisputeList) {
        self.message =
            ::std::option::Option::Some(PersistableEnvelope_oneof_message::refund_dispute_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_refund_dispute_list(&mut self) -> &mut RefundDisputeList {
        if let ::std::option::Option::Some(
            PersistableEnvelope_oneof_message::refund_dispute_list(_),
        ) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::refund_dispute_list(RefundDisputeList::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(
                PersistableEnvelope_oneof_message::refund_dispute_list(ref mut v),
            ) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_refund_dispute_list(&mut self) -> RefundDisputeList {
        if self.has_refund_dispute_list() {
            match self.message.take() {
                ::std::option::Option::Some(
                    PersistableEnvelope_oneof_message::refund_dispute_list(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            RefundDisputeList::new()
        }
    }
}

impl ::protobuf::Message for PersistableEnvelope {
    fn is_initialized(&self) -> bool {
        if let Some(PersistableEnvelope_oneof_message::sequence_number_map(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::persisted_entry_map(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::peer_list(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::address_entry_list(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::navigation_path(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::tradable_list(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::trade_statistics_list(ref v)) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::arbitration_dispute_list(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::preferences_payload(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::user_payload(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::payment_account_list(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::account_age_witness_store(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::trade_statistics2_store(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::persistable_network_payload_list(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::proposal_store(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::temp_proposal_store(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::blind_vote_store(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::my_proposal_list(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::ballot_list(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::my_vote_list(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::my_blind_vote_list(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::merit_list(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::dao_state_store(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::my_reputation_list(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::my_proof_of_burn_list(ref v)) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::unconfirmed_bsq_change_output_list(ref v)) =
            self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::signed_witness_store(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::mediation_dispute_list(ref v)) = self.message
        {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PersistableEnvelope_oneof_message::refund_dispute_list(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::sequence_number_map(is.read_message()?),
                    );
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::persisted_entry_map(is.read_message()?),
                    );
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::peer_list(is.read_message()?),
                    );
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::address_entry_list(is.read_message()?),
                    );
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::navigation_path(is.read_message()?),
                    );
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::tradable_list(is.read_message()?),
                    );
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::trade_statistics_list(
                            is.read_message()?,
                        ),
                    );
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::arbitration_dispute_list(
                            is.read_message()?,
                        ),
                    );
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::preferences_payload(is.read_message()?),
                    );
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::user_payload(is.read_message()?),
                    );
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::payment_account_list(is.read_message()?),
                    );
                }
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::account_age_witness_store(
                            is.read_message()?,
                        ),
                    );
                }
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::trade_statistics2_store(
                            is.read_message()?,
                        ),
                    );
                }
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::persistable_network_payload_list(
                            is.read_message()?,
                        ),
                    );
                }
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::proposal_store(is.read_message()?),
                    );
                }
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::temp_proposal_store(is.read_message()?),
                    );
                }
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::blind_vote_store(is.read_message()?),
                    );
                }
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::my_proposal_list(is.read_message()?),
                    );
                }
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::ballot_list(is.read_message()?),
                    );
                }
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::my_vote_list(is.read_message()?),
                    );
                }
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::my_blind_vote_list(is.read_message()?),
                    );
                }
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::merit_list(is.read_message()?),
                    );
                }
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::dao_state_store(is.read_message()?),
                    );
                }
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::my_reputation_list(is.read_message()?),
                    );
                }
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::my_proof_of_burn_list(
                            is.read_message()?,
                        ),
                    );
                }
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::unconfirmed_bsq_change_output_list(
                            is.read_message()?,
                        ),
                    );
                }
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::signed_witness_store(is.read_message()?),
                    );
                }
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::mediation_dispute_list(
                            is.read_message()?,
                        ),
                    );
                }
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        PersistableEnvelope_oneof_message::refund_dispute_list(is.read_message()?),
                    );
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &PersistableEnvelope_oneof_message::sequence_number_map(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::persisted_entry_map(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::peer_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::address_entry_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::navigation_path(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::tradable_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::trade_statistics_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::arbitration_dispute_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::preferences_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::user_payload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::payment_account_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::account_age_witness_store(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::trade_statistics2_store(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::persistable_network_payload_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::proposal_store(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::temp_proposal_store(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::blind_vote_store(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::my_proposal_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::ballot_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::my_vote_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::my_blind_vote_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::merit_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::dao_state_store(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::my_reputation_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::my_proof_of_burn_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::unconfirmed_bsq_change_output_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::signed_witness_store(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::mediation_dispute_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &PersistableEnvelope_oneof_message::refund_dispute_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &PersistableEnvelope_oneof_message::sequence_number_map(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::persisted_entry_map(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::peer_list(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::address_entry_list(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::navigation_path(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::tradable_list(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::trade_statistics_list(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::arbitration_dispute_list(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::preferences_payload(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::user_payload(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::payment_account_list(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::account_age_witness_store(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::trade_statistics2_store(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::persistable_network_payload_list(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::proposal_store(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::temp_proposal_store(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::blind_vote_store(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::my_proposal_list(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::ballot_list(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::my_vote_list(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::my_blind_vote_list(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::merit_list(ref v) => {
                    os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::dao_state_store(ref v) => {
                    os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::my_reputation_list(ref v) => {
                    os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::my_proof_of_burn_list(ref v) => {
                    os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::unconfirmed_bsq_change_output_list(ref v) => {
                    os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::signed_witness_store(ref v) => {
                    os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::mediation_dispute_list(ref v) => {
                    os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &PersistableEnvelope_oneof_message::refund_dispute_list(ref v) => {
                    os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistableEnvelope {
        PersistableEnvelope::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SequenceNumberMap>(
                    "sequence_number_map",
                    PersistableEnvelope::has_sequence_number_map,
                    PersistableEnvelope::get_sequence_number_map,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PersistedEntryMap>(
                    "persisted_entry_map",
                    PersistableEnvelope::has_persisted_entry_map,
                    PersistableEnvelope::get_persisted_entry_map,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PeerList>(
                    "peer_list",
                    PersistableEnvelope::has_peer_list,
                    PersistableEnvelope::get_peer_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AddressEntryList>(
                    "address_entry_list",
                    PersistableEnvelope::has_address_entry_list,
                    PersistableEnvelope::get_address_entry_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, NavigationPath>(
                    "navigation_path",
                    PersistableEnvelope::has_navigation_path,
                    PersistableEnvelope::get_navigation_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TradableList>(
                    "tradable_list",
                    PersistableEnvelope::has_tradable_list,
                    PersistableEnvelope::get_tradable_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TradeStatisticsList>(
                    "trade_statistics_list",
                    PersistableEnvelope::has_trade_statistics_list,
                    PersistableEnvelope::get_trade_statistics_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ArbitrationDisputeList>(
                    "arbitration_dispute_list",
                    PersistableEnvelope::has_arbitration_dispute_list,
                    PersistableEnvelope::get_arbitration_dispute_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PreferencesPayload>(
                    "preferences_payload",
                    PersistableEnvelope::has_preferences_payload,
                    PersistableEnvelope::get_preferences_payload,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, UserPayload>(
                    "user_payload",
                    PersistableEnvelope::has_user_payload,
                    PersistableEnvelope::get_user_payload,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PaymentAccountList>(
                    "payment_account_list",
                    PersistableEnvelope::has_payment_account_list,
                    PersistableEnvelope::get_payment_account_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AccountAgeWitnessStore>(
                    "account_age_witness_store",
                    PersistableEnvelope::has_account_age_witness_store,
                    PersistableEnvelope::get_account_age_witness_store,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TradeStatistics2Store>(
                    "trade_statistics2_store",
                    PersistableEnvelope::has_trade_statistics2_store,
                    PersistableEnvelope::get_trade_statistics2_store,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PersistableNetworkPayloadList>(
                    "persistable_network_payload_list",
                    PersistableEnvelope::has_persistable_network_payload_list,
                    PersistableEnvelope::get_persistable_network_payload_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProposalStore>(
                    "proposal_store",
                    PersistableEnvelope::has_proposal_store,
                    PersistableEnvelope::get_proposal_store,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TempProposalStore>(
                    "temp_proposal_store",
                    PersistableEnvelope::has_temp_proposal_store,
                    PersistableEnvelope::get_temp_proposal_store,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BlindVoteStore>(
                    "blind_vote_store",
                    PersistableEnvelope::has_blind_vote_store,
                    PersistableEnvelope::get_blind_vote_store,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MyProposalList>(
                    "my_proposal_list",
                    PersistableEnvelope::has_my_proposal_list,
                    PersistableEnvelope::get_my_proposal_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BallotList>(
                    "ballot_list",
                    PersistableEnvelope::has_ballot_list,
                    PersistableEnvelope::get_ballot_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MyVoteList>(
                    "my_vote_list",
                    PersistableEnvelope::has_my_vote_list,
                    PersistableEnvelope::get_my_vote_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MyBlindVoteList>(
                    "my_blind_vote_list",
                    PersistableEnvelope::has_my_blind_vote_list,
                    PersistableEnvelope::get_my_blind_vote_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MeritList>(
                    "merit_list",
                    PersistableEnvelope::has_merit_list,
                    PersistableEnvelope::get_merit_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DaoStateStore>(
                    "dao_state_store",
                    PersistableEnvelope::has_dao_state_store,
                    PersistableEnvelope::get_dao_state_store,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MyReputationList>(
                    "my_reputation_list",
                    PersistableEnvelope::has_my_reputation_list,
                    PersistableEnvelope::get_my_reputation_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MyProofOfBurnList>(
                    "my_proof_of_burn_list",
                    PersistableEnvelope::has_my_proof_of_burn_list,
                    PersistableEnvelope::get_my_proof_of_burn_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, UnconfirmedBsqChangeOutputList>(
                    "unconfirmed_bsq_change_output_list",
                    PersistableEnvelope::has_unconfirmed_bsq_change_output_list,
                    PersistableEnvelope::get_unconfirmed_bsq_change_output_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SignedWitnessStore>(
                    "signed_witness_store",
                    PersistableEnvelope::has_signed_witness_store,
                    PersistableEnvelope::get_signed_witness_store,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MediationDisputeList>(
                    "mediation_dispute_list",
                    PersistableEnvelope::has_mediation_dispute_list,
                    PersistableEnvelope::get_mediation_dispute_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RefundDisputeList>(
                    "refund_dispute_list",
                    PersistableEnvelope::has_refund_dispute_list,
                    PersistableEnvelope::get_refund_dispute_list,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistableEnvelope>(
                    "PersistableEnvelope",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PersistableEnvelope {
        static mut instance: ::protobuf::lazy::Lazy<PersistableEnvelope> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistableEnvelope,
        };
        unsafe { instance.get(PersistableEnvelope::new) }
    }
}

impl ::protobuf::Clear for PersistableEnvelope {
    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistableEnvelope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistableEnvelope {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct SequenceNumberMap {
    // message fields
    pub sequence_number_entries: ::protobuf::RepeatedField<SequenceNumberEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SequenceNumberMap {
    fn default() -> &'a SequenceNumberMap {
        <SequenceNumberMap as ::protobuf::Message>::default_instance()
    }
}

impl SequenceNumberMap {
    pub fn new() -> SequenceNumberMap {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.SequenceNumberEntry sequence_number_entries = 1;

    pub fn get_sequence_number_entries(&self) -> &[SequenceNumberEntry] {
        &self.sequence_number_entries
    }
    pub fn clear_sequence_number_entries(&mut self) {
        self.sequence_number_entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_sequence_number_entries(
        &mut self,
        v: ::protobuf::RepeatedField<SequenceNumberEntry>,
    ) {
        self.sequence_number_entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sequence_number_entries(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<SequenceNumberEntry> {
        &mut self.sequence_number_entries
    }

    // Take field
    pub fn take_sequence_number_entries(
        &mut self,
    ) -> ::protobuf::RepeatedField<SequenceNumberEntry> {
        ::std::mem::replace(
            &mut self.sequence_number_entries,
            ::protobuf::RepeatedField::new(),
        )
    }
}

impl ::protobuf::Message for SequenceNumberMap {
    fn is_initialized(&self) -> bool {
        for v in &self.sequence_number_entries {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.sequence_number_entries,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sequence_number_entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sequence_number_entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SequenceNumberMap {
        SequenceNumberMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<SequenceNumberEntry>,
                    >(
                        "sequence_number_entries",
                        |m: &SequenceNumberMap| &m.sequence_number_entries,
                        |m: &mut SequenceNumberMap| &mut m.sequence_number_entries,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<SequenceNumberMap>(
                    "SequenceNumberMap",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static SequenceNumberMap {
        static mut instance: ::protobuf::lazy::Lazy<SequenceNumberMap> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SequenceNumberMap,
        };
        unsafe { instance.get(SequenceNumberMap::new) }
    }
}

impl ::protobuf::Clear for SequenceNumberMap {
    fn clear(&mut self) {
        self.sequence_number_entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SequenceNumberMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SequenceNumberMap {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct SequenceNumberEntry {
    // message fields
    pub bytes: ::protobuf::SingularPtrField<ByteArray>,
    pub map_value: ::protobuf::SingularPtrField<MapValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SequenceNumberEntry {
    fn default() -> &'a SequenceNumberEntry {
        <SequenceNumberEntry as ::protobuf::Message>::default_instance()
    }
}

impl SequenceNumberEntry {
    pub fn new() -> SequenceNumberEntry {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.ByteArray bytes = 1;

    pub fn get_bytes(&self) -> &ByteArray {
        self.bytes
            .as_ref()
            .unwrap_or_else(|| ByteArray::default_instance())
    }
    pub fn clear_bytes(&mut self) {
        self.bytes.clear();
    }

    pub fn has_bytes(&self) -> bool {
        self.bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: ByteArray) {
        self.bytes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes(&mut self) -> &mut ByteArray {
        if self.bytes.is_none() {
            self.bytes.set_default();
        }
        self.bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes(&mut self) -> ByteArray {
        self.bytes.take().unwrap_or_else(|| ByteArray::new())
    }

    // .io.bisq.protobuffer.MapValue map_value = 2;

    pub fn get_map_value(&self) -> &MapValue {
        self.map_value
            .as_ref()
            .unwrap_or_else(|| MapValue::default_instance())
    }
    pub fn clear_map_value(&mut self) {
        self.map_value.clear();
    }

    pub fn has_map_value(&self) -> bool {
        self.map_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_value(&mut self, v: MapValue) {
        self.map_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_value(&mut self) -> &mut MapValue {
        if self.map_value.is_none() {
            self.map_value.set_default();
        }
        self.map_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_value(&mut self) -> MapValue {
        self.map_value.take().unwrap_or_else(|| MapValue::new())
    }
}

impl ::protobuf::Message for SequenceNumberEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.bytes {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.map_value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bytes)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.map_value)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bytes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.map_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bytes.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.map_value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SequenceNumberEntry {
        SequenceNumberEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<ByteArray>,
                    >(
                        "bytes",
                        |m: &SequenceNumberEntry| &m.bytes,
                        |m: &mut SequenceNumberEntry| &mut m.bytes,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<MapValue>,
                    >(
                        "map_value",
                        |m: &SequenceNumberEntry| &m.map_value,
                        |m: &mut SequenceNumberEntry| &mut m.map_value,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<SequenceNumberEntry>(
                    "SequenceNumberEntry",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static SequenceNumberEntry {
        static mut instance: ::protobuf::lazy::Lazy<SequenceNumberEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SequenceNumberEntry,
        };
        unsafe { instance.get(SequenceNumberEntry::new) }
    }
}

impl ::protobuf::Clear for SequenceNumberEntry {
    fn clear(&mut self) {
        self.bytes.clear();
        self.map_value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SequenceNumberEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SequenceNumberEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ByteArray {
    // message fields
    pub bytes: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ByteArray {
    fn default() -> &'a ByteArray {
        <ByteArray as ::protobuf::Message>::default_instance()
    }
}

impl ByteArray {
    pub fn new() -> ByteArray {
        ::std::default::Default::default()
    }

    // bytes bytes = 1;

    pub fn get_bytes(&self) -> &[u8] {
        &self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.bytes
    }

    // Take field
    pub fn take_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.bytes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ByteArray {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.bytes,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.bytes.is_empty() {
            os.write_bytes(1, &self.bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ByteArray {
        ByteArray::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "bytes",
                    |m: &ByteArray| &m.bytes,
                    |m: &mut ByteArray| &mut m.bytes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ByteArray>(
                    "ByteArray",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ByteArray {
        static mut instance: ::protobuf::lazy::Lazy<ByteArray> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ByteArray,
        };
        unsafe { instance.get(ByteArray::new) }
    }
}

impl ::protobuf::Clear for ByteArray {
    fn clear(&mut self) {
        self.bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ByteArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ByteArray {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MapValue {
    // message fields
    pub sequence_nr: i32,
    pub time_stamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MapValue {
    fn default() -> &'a MapValue {
        <MapValue as ::protobuf::Message>::default_instance()
    }
}

impl MapValue {
    pub fn new() -> MapValue {
        ::std::default::Default::default()
    }

    // int32 sequence_nr = 1;

    pub fn get_sequence_nr(&self) -> i32 {
        self.sequence_nr
    }
    pub fn clear_sequence_nr(&mut self) {
        self.sequence_nr = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence_nr(&mut self, v: i32) {
        self.sequence_nr = v;
    }

    // int64 time_stamp = 2;

    pub fn get_time_stamp(&self) -> i64 {
        self.time_stamp
    }
    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: i64) {
        self.time_stamp = v;
    }
}

impl ::protobuf::Message for MapValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.sequence_nr = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.time_stamp = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sequence_nr != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.sequence_nr,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.time_stamp != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.time_stamp,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.sequence_nr != 0 {
            os.write_int32(1, self.sequence_nr)?;
        }
        if self.time_stamp != 0 {
            os.write_int64(2, self.time_stamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MapValue {
        MapValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "sequence_nr",
                    |m: &MapValue| &m.sequence_nr,
                    |m: &mut MapValue| &mut m.sequence_nr,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "time_stamp",
                    |m: &MapValue| &m.time_stamp,
                    |m: &mut MapValue| &mut m.time_stamp,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MapValue>(
                    "MapValue",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MapValue {
        static mut instance: ::protobuf::lazy::Lazy<MapValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MapValue,
        };
        unsafe { instance.get(MapValue::new) }
    }
}

impl ::protobuf::Clear for MapValue {
    fn clear(&mut self) {
        self.sequence_nr = 0;
        self.time_stamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MapValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PersistedEntryMap {
    // message fields
    pub persisted_entry_map:
        ::std::collections::HashMap<::std::string::String, ProtectedStorageEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistedEntryMap {
    fn default() -> &'a PersistedEntryMap {
        <PersistedEntryMap as ::protobuf::Message>::default_instance()
    }
}

impl PersistedEntryMap {
    pub fn new() -> PersistedEntryMap {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.PersistedEntryMap.PersistedEntryMapEntry persisted_entry_map = 1;

    pub fn get_persisted_entry_map(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ProtectedStorageEntry> {
        &self.persisted_entry_map
    }
    pub fn clear_persisted_entry_map(&mut self) {
        self.persisted_entry_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_persisted_entry_map(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ProtectedStorageEntry>,
    ) {
        self.persisted_entry_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_persisted_entry_map(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ProtectedStorageEntry> {
        &mut self.persisted_entry_map
    }

    // Take field
    pub fn take_persisted_entry_map(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ProtectedStorageEntry> {
        ::std::mem::replace(
            &mut self.persisted_entry_map,
            ::std::collections::HashMap::new(),
        )
    }
}

impl ::protobuf::Message for PersistedEntryMap {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeMessage<ProtectedStorageEntry>,
                    >(wire_type, is, &mut self.persisted_entry_map)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<ProtectedStorageEntry>,
        >(1, &self.persisted_entry_map);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<ProtectedStorageEntry>,
        >(1, &self.persisted_entry_map, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistedEntryMap {
        PersistedEntryMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeMessage<ProtectedStorageEntry>,
                >(
                    "persisted_entry_map",
                    |m: &PersistedEntryMap| &m.persisted_entry_map,
                    |m: &mut PersistedEntryMap| &mut m.persisted_entry_map,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistedEntryMap>(
                    "PersistedEntryMap",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PersistedEntryMap {
        static mut instance: ::protobuf::lazy::Lazy<PersistedEntryMap> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistedEntryMap,
        };
        unsafe { instance.get(PersistedEntryMap::new) }
    }
}

impl ::protobuf::Clear for PersistedEntryMap {
    fn clear(&mut self) {
        self.persisted_entry_map.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistedEntryMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistedEntryMap {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PersistableNetworkPayloadList {
    // message fields
    pub items: ::protobuf::RepeatedField<PersistableNetworkPayload>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistableNetworkPayloadList {
    fn default() -> &'a PersistableNetworkPayloadList {
        <PersistableNetworkPayloadList as ::protobuf::Message>::default_instance()
    }
}

impl PersistableNetworkPayloadList {
    pub fn new() -> PersistableNetworkPayloadList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.PersistableNetworkPayload items = 1;

    pub fn get_items(&self) -> &[PersistableNetworkPayload] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<PersistableNetworkPayload>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<PersistableNetworkPayload> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<PersistableNetworkPayload> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PersistableNetworkPayloadList {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistableNetworkPayloadList {
        PersistableNetworkPayloadList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PersistableNetworkPayload>,
                    >(
                        "items",
                        |m: &PersistableNetworkPayloadList| &m.items,
                        |m: &mut PersistableNetworkPayloadList| &mut m.items,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<PersistableNetworkPayloadList>(
                    "PersistableNetworkPayloadList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PersistableNetworkPayloadList {
        static mut instance: ::protobuf::lazy::Lazy<PersistableNetworkPayloadList> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const PersistableNetworkPayloadList,
            };
        unsafe { instance.get(PersistableNetworkPayloadList::new) }
    }
}

impl ::protobuf::Clear for PersistableNetworkPayloadList {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistableNetworkPayloadList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistableNetworkPayloadList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct AccountAgeWitnessStore {
    // message fields
    pub items: ::protobuf::RepeatedField<AccountAgeWitness>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountAgeWitnessStore {
    fn default() -> &'a AccountAgeWitnessStore {
        <AccountAgeWitnessStore as ::protobuf::Message>::default_instance()
    }
}

impl AccountAgeWitnessStore {
    pub fn new() -> AccountAgeWitnessStore {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.AccountAgeWitness items = 1;

    pub fn get_items(&self) -> &[AccountAgeWitness] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<AccountAgeWitness>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<AccountAgeWitness> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<AccountAgeWitness> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AccountAgeWitnessStore {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountAgeWitnessStore {
        AccountAgeWitnessStore::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<AccountAgeWitness>,
                    >(
                        "items",
                        |m: &AccountAgeWitnessStore| &m.items,
                        |m: &mut AccountAgeWitnessStore| &mut m.items,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<AccountAgeWitnessStore>(
                    "AccountAgeWitnessStore",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static AccountAgeWitnessStore {
        static mut instance: ::protobuf::lazy::Lazy<AccountAgeWitnessStore> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const AccountAgeWitnessStore,
            };
        unsafe { instance.get(AccountAgeWitnessStore::new) }
    }
}

impl ::protobuf::Clear for AccountAgeWitnessStore {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountAgeWitnessStore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountAgeWitnessStore {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct SignedWitnessStore {
    // message fields
    pub items: ::protobuf::RepeatedField<SignedWitness>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignedWitnessStore {
    fn default() -> &'a SignedWitnessStore {
        <SignedWitnessStore as ::protobuf::Message>::default_instance()
    }
}

impl SignedWitnessStore {
    pub fn new() -> SignedWitnessStore {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.SignedWitness items = 1;

    pub fn get_items(&self) -> &[SignedWitness] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<SignedWitness>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<SignedWitness> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<SignedWitness> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SignedWitnessStore {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignedWitnessStore {
        SignedWitnessStore::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<SignedWitness>,
                    >(
                        "items",
                        |m: &SignedWitnessStore| &m.items,
                        |m: &mut SignedWitnessStore| &mut m.items,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<SignedWitnessStore>(
                    "SignedWitnessStore",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static SignedWitnessStore {
        static mut instance: ::protobuf::lazy::Lazy<SignedWitnessStore> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SignedWitnessStore,
        };
        unsafe { instance.get(SignedWitnessStore::new) }
    }
}

impl ::protobuf::Clear for SignedWitnessStore {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedWitnessStore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedWitnessStore {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct TradeStatistics2Store {
    // message fields
    pub items: ::protobuf::RepeatedField<TradeStatistics2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradeStatistics2Store {
    fn default() -> &'a TradeStatistics2Store {
        <TradeStatistics2Store as ::protobuf::Message>::default_instance()
    }
}

impl TradeStatistics2Store {
    pub fn new() -> TradeStatistics2Store {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.TradeStatistics2 items = 1;

    pub fn get_items(&self) -> &[TradeStatistics2] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<TradeStatistics2>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<TradeStatistics2> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<TradeStatistics2> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TradeStatistics2Store {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradeStatistics2Store {
        TradeStatistics2Store::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<TradeStatistics2>,
                    >(
                        "items",
                        |m: &TradeStatistics2Store| &m.items,
                        |m: &mut TradeStatistics2Store| &mut m.items,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<TradeStatistics2Store>(
                    "TradeStatistics2Store",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static TradeStatistics2Store {
        static mut instance: ::protobuf::lazy::Lazy<TradeStatistics2Store> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const TradeStatistics2Store,
            };
        unsafe { instance.get(TradeStatistics2Store::new) }
    }
}

impl ::protobuf::Clear for TradeStatistics2Store {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TradeStatistics2Store {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TradeStatistics2Store {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PeerList {
    // message fields
    pub peer: ::protobuf::RepeatedField<Peer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeerList {
    fn default() -> &'a PeerList {
        <PeerList as ::protobuf::Message>::default_instance()
    }
}

impl PeerList {
    pub fn new() -> PeerList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.Peer peer = 1;

    pub fn get_peer(&self) -> &[Peer] {
        &self.peer
    }
    pub fn clear_peer(&mut self) {
        self.peer.clear();
    }

    // Param is passed by value, moved
    pub fn set_peer(&mut self, v: ::protobuf::RepeatedField<Peer>) {
        self.peer = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peer(&mut self) -> &mut ::protobuf::RepeatedField<Peer> {
        &mut self.peer
    }

    // Take field
    pub fn take_peer(&mut self) -> ::protobuf::RepeatedField<Peer> {
        ::std::mem::replace(&mut self.peer, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PeerList {
    fn is_initialized(&self) -> bool {
        for v in &self.peer {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peer)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.peer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.peer {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeerList {
        PeerList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Peer>,
                    >(
                        "peer",
                        |m: &PeerList| &m.peer,
                        |m: &mut PeerList| &mut m.peer,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<PeerList>(
                    "PeerList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PeerList {
        static mut instance: ::protobuf::lazy::Lazy<PeerList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PeerList,
        };
        unsafe { instance.get(PeerList::new) }
    }
}

impl ::protobuf::Clear for PeerList {
    fn clear(&mut self) {
        self.peer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeerList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct AddressEntryList {
    // message fields
    pub address_entry: ::protobuf::RepeatedField<AddressEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressEntryList {
    fn default() -> &'a AddressEntryList {
        <AddressEntryList as ::protobuf::Message>::default_instance()
    }
}

impl AddressEntryList {
    pub fn new() -> AddressEntryList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.AddressEntry address_entry = 1;

    pub fn get_address_entry(&self) -> &[AddressEntry] {
        &self.address_entry
    }
    pub fn clear_address_entry(&mut self) {
        self.address_entry.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_entry(&mut self, v: ::protobuf::RepeatedField<AddressEntry>) {
        self.address_entry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_entry(&mut self) -> &mut ::protobuf::RepeatedField<AddressEntry> {
        &mut self.address_entry
    }

    // Take field
    pub fn take_address_entry(&mut self) -> ::protobuf::RepeatedField<AddressEntry> {
        ::std::mem::replace(&mut self.address_entry, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddressEntryList {
    fn is_initialized(&self) -> bool {
        for v in &self.address_entry {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.address_entry,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_entry {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressEntryList {
        AddressEntryList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<AddressEntry>,
                    >(
                        "address_entry",
                        |m: &AddressEntryList| &m.address_entry,
                        |m: &mut AddressEntryList| &mut m.address_entry,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<AddressEntryList>(
                    "AddressEntryList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static AddressEntryList {
        static mut instance: ::protobuf::lazy::Lazy<AddressEntryList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddressEntryList,
        };
        unsafe { instance.get(AddressEntryList::new) }
    }
}

impl ::protobuf::Clear for AddressEntryList {
    fn clear(&mut self) {
        self.address_entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressEntryList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressEntryList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct AddressEntry {
    // message fields
    pub offer_id: ::std::string::String,
    pub context: AddressEntry_Context,
    pub pub_key: ::std::vec::Vec<u8>,
    pub pub_key_hash: ::std::vec::Vec<u8>,
    pub coin_locked_in_multi_sig: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressEntry {
    fn default() -> &'a AddressEntry {
        <AddressEntry as ::protobuf::Message>::default_instance()
    }
}

impl AddressEntry {
    pub fn new() -> AddressEntry {
        ::std::default::Default::default()
    }

    // string offer_id = 7;

    pub fn get_offer_id(&self) -> &str {
        &self.offer_id
    }
    pub fn clear_offer_id(&mut self) {
        self.offer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_offer_id(&mut self, v: ::std::string::String) {
        self.offer_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer_id(&mut self) -> &mut ::std::string::String {
        &mut self.offer_id
    }

    // Take field
    pub fn take_offer_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.offer_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.AddressEntry.Context context = 8;

    pub fn get_context(&self) -> AddressEntry_Context {
        self.context
    }
    pub fn clear_context(&mut self) {
        self.context = AddressEntry_Context::PB_ERROR;
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: AddressEntry_Context) {
        self.context = v;
    }

    // bytes pub_key = 9;

    pub fn get_pub_key(&self) -> &[u8] {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pub_key, ::std::vec::Vec::new())
    }

    // bytes pub_key_hash = 10;

    pub fn get_pub_key_hash(&self) -> &[u8] {
        &self.pub_key_hash
    }
    pub fn clear_pub_key_hash(&mut self) {
        self.pub_key_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.pub_key_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pub_key_hash
    }

    // Take field
    pub fn take_pub_key_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pub_key_hash, ::std::vec::Vec::new())
    }

    // int64 coin_locked_in_multi_sig = 11;

    pub fn get_coin_locked_in_multi_sig(&self) -> i64 {
        self.coin_locked_in_multi_sig
    }
    pub fn clear_coin_locked_in_multi_sig(&mut self) {
        self.coin_locked_in_multi_sig = 0;
    }

    // Param is passed by value, moved
    pub fn set_coin_locked_in_multi_sig(&mut self, v: i64) {
        self.coin_locked_in_multi_sig = v;
    }
}

impl ::protobuf::Message for AddressEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.offer_id,
                    )?;
                }
                8 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.context,
                    8,
                    &mut self.unknown_fields,
                )?,
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.pub_key,
                    )?;
                }
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.pub_key_hash,
                    )?;
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.coin_locked_in_multi_sig = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.offer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.offer_id);
        }
        if self.context != AddressEntry_Context::PB_ERROR {
            my_size += ::protobuf::rt::enum_size(8, self.context);
        }
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.pub_key);
        }
        if !self.pub_key_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.pub_key_hash);
        }
        if self.coin_locked_in_multi_sig != 0 {
            my_size += ::protobuf::rt::value_size(
                11,
                self.coin_locked_in_multi_sig,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.offer_id.is_empty() {
            os.write_string(7, &self.offer_id)?;
        }
        if self.context != AddressEntry_Context::PB_ERROR {
            os.write_enum(8, self.context.value())?;
        }
        if !self.pub_key.is_empty() {
            os.write_bytes(9, &self.pub_key)?;
        }
        if !self.pub_key_hash.is_empty() {
            os.write_bytes(10, &self.pub_key_hash)?;
        }
        if self.coin_locked_in_multi_sig != 0 {
            os.write_int64(11, self.coin_locked_in_multi_sig)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressEntry {
        AddressEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "offer_id",
                    |m: &AddressEntry| &m.offer_id,
                    |m: &mut AddressEntry| &mut m.offer_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<AddressEntry_Context>,
                >(
                    "context",
                    |m: &AddressEntry| &m.context,
                    |m: &mut AddressEntry| &mut m.context,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "pub_key",
                    |m: &AddressEntry| &m.pub_key,
                    |m: &mut AddressEntry| &mut m.pub_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "pub_key_hash",
                    |m: &AddressEntry| &m.pub_key_hash,
                    |m: &mut AddressEntry| &mut m.pub_key_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "coin_locked_in_multi_sig",
                    |m: &AddressEntry| &m.coin_locked_in_multi_sig,
                    |m: &mut AddressEntry| &mut m.coin_locked_in_multi_sig,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddressEntry>(
                    "AddressEntry",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static AddressEntry {
        static mut instance: ::protobuf::lazy::Lazy<AddressEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddressEntry,
        };
        unsafe { instance.get(AddressEntry::new) }
    }
}

impl ::protobuf::Clear for AddressEntry {
    fn clear(&mut self) {
        self.offer_id.clear();
        self.context = AddressEntry_Context::PB_ERROR;
        self.pub_key.clear();
        self.pub_key_hash.clear();
        self.coin_locked_in_multi_sig = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum AddressEntry_Context {
    PB_ERROR = 0,
    ARBITRATOR = 1,
    AVAILABLE = 2,
    OFFER_FUNDING = 3,
    RESERVED_FOR_TRADE = 4,
    MULTI_SIG = 5,
    TRADE_PAYOUT = 6,
}

impl ::protobuf::ProtobufEnum for AddressEntry_Context {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AddressEntry_Context> {
        match value {
            0 => ::std::option::Option::Some(AddressEntry_Context::PB_ERROR),
            1 => ::std::option::Option::Some(AddressEntry_Context::ARBITRATOR),
            2 => ::std::option::Option::Some(AddressEntry_Context::AVAILABLE),
            3 => ::std::option::Option::Some(AddressEntry_Context::OFFER_FUNDING),
            4 => ::std::option::Option::Some(AddressEntry_Context::RESERVED_FOR_TRADE),
            5 => ::std::option::Option::Some(AddressEntry_Context::MULTI_SIG),
            6 => ::std::option::Option::Some(AddressEntry_Context::TRADE_PAYOUT),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AddressEntry_Context] = &[
            AddressEntry_Context::PB_ERROR,
            AddressEntry_Context::ARBITRATOR,
            AddressEntry_Context::AVAILABLE,
            AddressEntry_Context::OFFER_FUNDING,
            AddressEntry_Context::RESERVED_FOR_TRADE,
            AddressEntry_Context::MULTI_SIG,
            AddressEntry_Context::TRADE_PAYOUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new(
                    "AddressEntry_Context",
                    file_descriptor_proto(),
                )
            })
        }
    }
}

impl ::std::marker::Copy for AddressEntry_Context {}

impl ::std::default::Default for AddressEntry_Context {
    fn default() -> Self {
        AddressEntry_Context::PB_ERROR
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressEntry_Context {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct NavigationPath {
    // message fields
    pub path: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NavigationPath {
    fn default() -> &'a NavigationPath {
        <NavigationPath as ::protobuf::Message>::default_instance()
    }
}

impl NavigationPath {
    pub fn new() -> NavigationPath {
        ::std::default::Default::default()
    }

    // repeated string path = 1;

    pub fn get_path(&self) -> &[::std::string::String] {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NavigationPath {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.path)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.path {
            my_size += ::protobuf::rt::string_size(1, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.path {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NavigationPath {
        NavigationPath::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "path",
                        |m: &NavigationPath| &m.path,
                        |m: &mut NavigationPath| &mut m.path,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<NavigationPath>(
                    "NavigationPath",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static NavigationPath {
        static mut instance: ::protobuf::lazy::Lazy<NavigationPath> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NavigationPath,
        };
        unsafe { instance.get(NavigationPath::new) }
    }
}

impl ::protobuf::Clear for NavigationPath {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NavigationPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationPath {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PaymentAccountList {
    // message fields
    pub payment_account: ::protobuf::RepeatedField<PaymentAccount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentAccountList {
    fn default() -> &'a PaymentAccountList {
        <PaymentAccountList as ::protobuf::Message>::default_instance()
    }
}

impl PaymentAccountList {
    pub fn new() -> PaymentAccountList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.PaymentAccount payment_account = 1;

    pub fn get_payment_account(&self) -> &[PaymentAccount] {
        &self.payment_account
    }
    pub fn clear_payment_account(&mut self) {
        self.payment_account.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_account(&mut self, v: ::protobuf::RepeatedField<PaymentAccount>) {
        self.payment_account = v;
    }

    // Mutable pointer to the field.
    pub fn mut_payment_account(&mut self) -> &mut ::protobuf::RepeatedField<PaymentAccount> {
        &mut self.payment_account
    }

    // Take field
    pub fn take_payment_account(&mut self) -> ::protobuf::RepeatedField<PaymentAccount> {
        ::std::mem::replace(&mut self.payment_account, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PaymentAccountList {
    fn is_initialized(&self) -> bool {
        for v in &self.payment_account {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.payment_account,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.payment_account {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.payment_account {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaymentAccountList {
        PaymentAccountList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PaymentAccount>,
                    >(
                        "payment_account",
                        |m: &PaymentAccountList| &m.payment_account,
                        |m: &mut PaymentAccountList| &mut m.payment_account,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<PaymentAccountList>(
                    "PaymentAccountList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PaymentAccountList {
        static mut instance: ::protobuf::lazy::Lazy<PaymentAccountList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PaymentAccountList,
        };
        unsafe { instance.get(PaymentAccountList::new) }
    }
}

impl ::protobuf::Clear for PaymentAccountList {
    fn clear(&mut self) {
        self.payment_account.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentAccountList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentAccountList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct TradableList {
    // message fields
    pub tradable: ::protobuf::RepeatedField<Tradable>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradableList {
    fn default() -> &'a TradableList {
        <TradableList as ::protobuf::Message>::default_instance()
    }
}

impl TradableList {
    pub fn new() -> TradableList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.Tradable tradable = 1;

    pub fn get_tradable(&self) -> &[Tradable] {
        &self.tradable
    }
    pub fn clear_tradable(&mut self) {
        self.tradable.clear();
    }

    // Param is passed by value, moved
    pub fn set_tradable(&mut self, v: ::protobuf::RepeatedField<Tradable>) {
        self.tradable = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tradable(&mut self) -> &mut ::protobuf::RepeatedField<Tradable> {
        &mut self.tradable
    }

    // Take field
    pub fn take_tradable(&mut self) -> ::protobuf::RepeatedField<Tradable> {
        ::std::mem::replace(&mut self.tradable, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TradableList {
    fn is_initialized(&self) -> bool {
        for v in &self.tradable {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tradable)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tradable {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tradable {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradableList {
        TradableList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Tradable>,
                    >(
                        "tradable",
                        |m: &TradableList| &m.tradable,
                        |m: &mut TradableList| &mut m.tradable,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<TradableList>(
                    "TradableList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static TradableList {
        static mut instance: ::protobuf::lazy::Lazy<TradableList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TradableList,
        };
        unsafe { instance.get(TradableList::new) }
    }
}

impl ::protobuf::Clear for TradableList {
    fn clear(&mut self) {
        self.tradable.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TradableList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TradableList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct TradeStatisticsList {
    // message fields
    pub trade_statistics: ::protobuf::RepeatedField<TradeStatistics>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradeStatisticsList {
    fn default() -> &'a TradeStatisticsList {
        <TradeStatisticsList as ::protobuf::Message>::default_instance()
    }
}

impl TradeStatisticsList {
    pub fn new() -> TradeStatisticsList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.TradeStatistics trade_statistics = 1;

    pub fn get_trade_statistics(&self) -> &[TradeStatistics] {
        &self.trade_statistics
    }
    pub fn clear_trade_statistics(&mut self) {
        self.trade_statistics.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_statistics(&mut self, v: ::protobuf::RepeatedField<TradeStatistics>) {
        self.trade_statistics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trade_statistics(&mut self) -> &mut ::protobuf::RepeatedField<TradeStatistics> {
        &mut self.trade_statistics
    }

    // Take field
    pub fn take_trade_statistics(&mut self) -> ::protobuf::RepeatedField<TradeStatistics> {
        ::std::mem::replace(&mut self.trade_statistics, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TradeStatisticsList {
    fn is_initialized(&self) -> bool {
        for v in &self.trade_statistics {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.trade_statistics,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.trade_statistics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.trade_statistics {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradeStatisticsList {
        TradeStatisticsList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<TradeStatistics>,
                    >(
                        "trade_statistics",
                        |m: &TradeStatisticsList| &m.trade_statistics,
                        |m: &mut TradeStatisticsList| &mut m.trade_statistics,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<TradeStatisticsList>(
                    "TradeStatisticsList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static TradeStatisticsList {
        static mut instance: ::protobuf::lazy::Lazy<TradeStatisticsList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TradeStatisticsList,
        };
        unsafe { instance.get(TradeStatisticsList::new) }
    }
}

impl ::protobuf::Clear for TradeStatisticsList {
    fn clear(&mut self) {
        self.trade_statistics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TradeStatisticsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TradeStatisticsList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Offer {
    // message fields
    pub offer_payload: ::protobuf::SingularPtrField<OfferPayload>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Offer {
    fn default() -> &'a Offer {
        <Offer as ::protobuf::Message>::default_instance()
    }
}

impl Offer {
    pub fn new() -> Offer {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.OfferPayload offer_payload = 1;

    pub fn get_offer_payload(&self) -> &OfferPayload {
        self.offer_payload
            .as_ref()
            .unwrap_or_else(|| OfferPayload::default_instance())
    }
    pub fn clear_offer_payload(&mut self) {
        self.offer_payload.clear();
    }

    pub fn has_offer_payload(&self) -> bool {
        self.offer_payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offer_payload(&mut self, v: OfferPayload) {
        self.offer_payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer_payload(&mut self) -> &mut OfferPayload {
        if self.offer_payload.is_none() {
            self.offer_payload.set_default();
        }
        self.offer_payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_offer_payload(&mut self) -> OfferPayload {
        self.offer_payload
            .take()
            .unwrap_or_else(|| OfferPayload::new())
    }
}

impl ::protobuf::Message for Offer {
    fn is_initialized(&self) -> bool {
        for v in &self.offer_payload {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.offer_payload,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.offer_payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.offer_payload.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Offer {
        Offer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<OfferPayload>,
                    >(
                        "offer_payload",
                        |m: &Offer| &m.offer_payload,
                        |m: &mut Offer| &mut m.offer_payload,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<Offer>(
                    "Offer",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Offer {
        static mut instance: ::protobuf::lazy::Lazy<Offer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer,
        };
        unsafe { instance.get(Offer::new) }
    }
}

impl ::protobuf::Clear for Offer {
    fn clear(&mut self) {
        self.offer_payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum Offer_State {
    PB_ERROR = 0,
    UNKNOWN = 1,
    OFFER_FEE_PAID = 2,
    AVAILABLE = 3,
    NOT_AVAILABLE = 4,
    REMOVED = 5,
    MAKER_OFFLINE = 6,
}

impl ::protobuf::ProtobufEnum for Offer_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Offer_State> {
        match value {
            0 => ::std::option::Option::Some(Offer_State::PB_ERROR),
            1 => ::std::option::Option::Some(Offer_State::UNKNOWN),
            2 => ::std::option::Option::Some(Offer_State::OFFER_FEE_PAID),
            3 => ::std::option::Option::Some(Offer_State::AVAILABLE),
            4 => ::std::option::Option::Some(Offer_State::NOT_AVAILABLE),
            5 => ::std::option::Option::Some(Offer_State::REMOVED),
            6 => ::std::option::Option::Some(Offer_State::MAKER_OFFLINE),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Offer_State] = &[
            Offer_State::PB_ERROR,
            Offer_State::UNKNOWN,
            Offer_State::OFFER_FEE_PAID,
            Offer_State::AVAILABLE,
            Offer_State::NOT_AVAILABLE,
            Offer_State::REMOVED,
            Offer_State::MAKER_OFFLINE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Offer_State", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Offer_State {}

impl ::std::default::Default for Offer_State {
    fn default() -> Self {
        Offer_State::PB_ERROR
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer_State {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct OpenOffer {
    // message fields
    pub offer: ::protobuf::SingularPtrField<Offer>,
    pub state: OpenOffer_State,
    pub arbitrator_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub mediator_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub refund_agent_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpenOffer {
    fn default() -> &'a OpenOffer {
        <OpenOffer as ::protobuf::Message>::default_instance()
    }
}

impl OpenOffer {
    pub fn new() -> OpenOffer {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Offer offer = 1;

    pub fn get_offer(&self) -> &Offer {
        self.offer
            .as_ref()
            .unwrap_or_else(|| Offer::default_instance())
    }
    pub fn clear_offer(&mut self) {
        self.offer.clear();
    }

    pub fn has_offer(&self) -> bool {
        self.offer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offer(&mut self, v: Offer) {
        self.offer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer(&mut self) -> &mut Offer {
        if self.offer.is_none() {
            self.offer.set_default();
        }
        self.offer.as_mut().unwrap()
    }

    // Take field
    pub fn take_offer(&mut self) -> Offer {
        self.offer.take().unwrap_or_else(|| Offer::new())
    }

    // .io.bisq.protobuffer.OpenOffer.State state = 2;

    pub fn get_state(&self) -> OpenOffer_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = OpenOffer_State::PB_ERROR;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: OpenOffer_State) {
        self.state = v;
    }

    // .io.bisq.protobuffer.NodeAddress arbitrator_node_address = 3;

    pub fn get_arbitrator_node_address(&self) -> &NodeAddress {
        self.arbitrator_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_arbitrator_node_address(&mut self) {
        self.arbitrator_node_address.clear();
    }

    pub fn has_arbitrator_node_address(&self) -> bool {
        self.arbitrator_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arbitrator_node_address(&mut self, v: NodeAddress) {
        self.arbitrator_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arbitrator_node_address(&mut self) -> &mut NodeAddress {
        if self.arbitrator_node_address.is_none() {
            self.arbitrator_node_address.set_default();
        }
        self.arbitrator_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_arbitrator_node_address(&mut self) -> NodeAddress {
        self.arbitrator_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // .io.bisq.protobuffer.NodeAddress mediator_node_address = 4;

    pub fn get_mediator_node_address(&self) -> &NodeAddress {
        self.mediator_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_mediator_node_address(&mut self) {
        self.mediator_node_address.clear();
    }

    pub fn has_mediator_node_address(&self) -> bool {
        self.mediator_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediator_node_address(&mut self, v: NodeAddress) {
        self.mediator_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediator_node_address(&mut self) -> &mut NodeAddress {
        if self.mediator_node_address.is_none() {
            self.mediator_node_address.set_default();
        }
        self.mediator_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediator_node_address(&mut self) -> NodeAddress {
        self.mediator_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // .io.bisq.protobuffer.NodeAddress refund_agent_node_address = 5;

    pub fn get_refund_agent_node_address(&self) -> &NodeAddress {
        self.refund_agent_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_refund_agent_node_address(&mut self) {
        self.refund_agent_node_address.clear();
    }

    pub fn has_refund_agent_node_address(&self) -> bool {
        self.refund_agent_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refund_agent_node_address(&mut self, v: NodeAddress) {
        self.refund_agent_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refund_agent_node_address(&mut self) -> &mut NodeAddress {
        if self.refund_agent_node_address.is_none() {
            self.refund_agent_node_address.set_default();
        }
        self.refund_agent_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_refund_agent_node_address(&mut self) -> NodeAddress {
        self.refund_agent_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }
}

impl ::protobuf::Message for OpenOffer {
    fn is_initialized(&self) -> bool {
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.arbitrator_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.mediator_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.refund_agent_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.offer)?;
                }
                2 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.state,
                    2,
                    &mut self.unknown_fields,
                )?,
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.arbitrator_node_address,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.mediator_node_address,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.refund_agent_node_address,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.offer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.state != OpenOffer_State::PB_ERROR {
            my_size += ::protobuf::rt::enum_size(2, self.state);
        }
        if let Some(ref v) = self.arbitrator_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mediator_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.refund_agent_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.offer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.state != OpenOffer_State::PB_ERROR {
            os.write_enum(2, self.state.value())?;
        }
        if let Some(ref v) = self.arbitrator_node_address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mediator_node_address.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.refund_agent_node_address.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenOffer {
        OpenOffer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Offer>,
                    >(
                        "offer",
                        |m: &OpenOffer| &m.offer,
                        |m: &mut OpenOffer| &mut m.offer,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<OpenOffer_State>,
                >(
                    "state",
                    |m: &OpenOffer| &m.state,
                    |m: &mut OpenOffer| &mut m.state,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "arbitrator_node_address",
                        |m: &OpenOffer| &m.arbitrator_node_address,
                        |m: &mut OpenOffer| &mut m.arbitrator_node_address,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "mediator_node_address",
                        |m: &OpenOffer| &m.mediator_node_address,
                        |m: &mut OpenOffer| &mut m.mediator_node_address,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "refund_agent_node_address",
                        |m: &OpenOffer| &m.refund_agent_node_address,
                        |m: &mut OpenOffer| &mut m.refund_agent_node_address,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<OpenOffer>(
                    "OpenOffer",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static OpenOffer {
        static mut instance: ::protobuf::lazy::Lazy<OpenOffer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpenOffer,
        };
        unsafe { instance.get(OpenOffer::new) }
    }
}

impl ::protobuf::Clear for OpenOffer {
    fn clear(&mut self) {
        self.offer.clear();
        self.state = OpenOffer_State::PB_ERROR;
        self.arbitrator_node_address.clear();
        self.mediator_node_address.clear();
        self.refund_agent_node_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenOffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenOffer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum OpenOffer_State {
    PB_ERROR = 0,
    AVAILABLE = 1,
    RESERVED = 2,
    CLOSED = 3,
    CANCELED = 4,
    DEACTIVATED = 5,
}

impl ::protobuf::ProtobufEnum for OpenOffer_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OpenOffer_State> {
        match value {
            0 => ::std::option::Option::Some(OpenOffer_State::PB_ERROR),
            1 => ::std::option::Option::Some(OpenOffer_State::AVAILABLE),
            2 => ::std::option::Option::Some(OpenOffer_State::RESERVED),
            3 => ::std::option::Option::Some(OpenOffer_State::CLOSED),
            4 => ::std::option::Option::Some(OpenOffer_State::CANCELED),
            5 => ::std::option::Option::Some(OpenOffer_State::DEACTIVATED),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OpenOffer_State] = &[
            OpenOffer_State::PB_ERROR,
            OpenOffer_State::AVAILABLE,
            OpenOffer_State::RESERVED,
            OpenOffer_State::CLOSED,
            OpenOffer_State::CANCELED,
            OpenOffer_State::DEACTIVATED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OpenOffer_State", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OpenOffer_State {}

impl ::std::default::Default for OpenOffer_State {
    fn default() -> Self {
        OpenOffer_State::PB_ERROR
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenOffer_State {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Tradable {
    // message oneof groups
    pub message: ::std::option::Option<Tradable_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tradable {
    fn default() -> &'a Tradable {
        <Tradable as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum Tradable_oneof_message {
    open_offer(OpenOffer),
    buyer_as_maker_trade(BuyerAsMakerTrade),
    buyer_as_taker_trade(BuyerAsTakerTrade),
    seller_as_maker_trade(SellerAsMakerTrade),
    seller_as_taker_trade(SellerAsTakerTrade),
}

impl Tradable {
    pub fn new() -> Tradable {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.OpenOffer open_offer = 1;

    pub fn get_open_offer(&self) -> &OpenOffer {
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::open_offer(ref v)) => v,
            _ => OpenOffer::default_instance(),
        }
    }
    pub fn clear_open_offer(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_open_offer(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::open_offer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_open_offer(&mut self, v: OpenOffer) {
        self.message = ::std::option::Option::Some(Tradable_oneof_message::open_offer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_open_offer(&mut self) -> &mut OpenOffer {
        if let ::std::option::Option::Some(Tradable_oneof_message::open_offer(_)) = self.message {
        } else {
            self.message =
                ::std::option::Option::Some(Tradable_oneof_message::open_offer(OpenOffer::new()));
        }
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::open_offer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_open_offer(&mut self) -> OpenOffer {
        if self.has_open_offer() {
            match self.message.take() {
                ::std::option::Option::Some(Tradable_oneof_message::open_offer(v)) => v,
                _ => panic!(),
            }
        } else {
            OpenOffer::new()
        }
    }

    // .io.bisq.protobuffer.BuyerAsMakerTrade buyer_as_maker_trade = 2;

    pub fn get_buyer_as_maker_trade(&self) -> &BuyerAsMakerTrade {
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::buyer_as_maker_trade(ref v)) => v,
            _ => BuyerAsMakerTrade::default_instance(),
        }
    }
    pub fn clear_buyer_as_maker_trade(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_buyer_as_maker_trade(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::buyer_as_maker_trade(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_buyer_as_maker_trade(&mut self, v: BuyerAsMakerTrade) {
        self.message = ::std::option::Option::Some(Tradable_oneof_message::buyer_as_maker_trade(v))
    }

    // Mutable pointer to the field.
    pub fn mut_buyer_as_maker_trade(&mut self) -> &mut BuyerAsMakerTrade {
        if let ::std::option::Option::Some(Tradable_oneof_message::buyer_as_maker_trade(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                Tradable_oneof_message::buyer_as_maker_trade(BuyerAsMakerTrade::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::buyer_as_maker_trade(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_buyer_as_maker_trade(&mut self) -> BuyerAsMakerTrade {
        if self.has_buyer_as_maker_trade() {
            match self.message.take() {
                ::std::option::Option::Some(Tradable_oneof_message::buyer_as_maker_trade(v)) => v,
                _ => panic!(),
            }
        } else {
            BuyerAsMakerTrade::new()
        }
    }

    // .io.bisq.protobuffer.BuyerAsTakerTrade buyer_as_taker_trade = 3;

    pub fn get_buyer_as_taker_trade(&self) -> &BuyerAsTakerTrade {
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::buyer_as_taker_trade(ref v)) => v,
            _ => BuyerAsTakerTrade::default_instance(),
        }
    }
    pub fn clear_buyer_as_taker_trade(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_buyer_as_taker_trade(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::buyer_as_taker_trade(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_buyer_as_taker_trade(&mut self, v: BuyerAsTakerTrade) {
        self.message = ::std::option::Option::Some(Tradable_oneof_message::buyer_as_taker_trade(v))
    }

    // Mutable pointer to the field.
    pub fn mut_buyer_as_taker_trade(&mut self) -> &mut BuyerAsTakerTrade {
        if let ::std::option::Option::Some(Tradable_oneof_message::buyer_as_taker_trade(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                Tradable_oneof_message::buyer_as_taker_trade(BuyerAsTakerTrade::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::buyer_as_taker_trade(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_buyer_as_taker_trade(&mut self) -> BuyerAsTakerTrade {
        if self.has_buyer_as_taker_trade() {
            match self.message.take() {
                ::std::option::Option::Some(Tradable_oneof_message::buyer_as_taker_trade(v)) => v,
                _ => panic!(),
            }
        } else {
            BuyerAsTakerTrade::new()
        }
    }

    // .io.bisq.protobuffer.SellerAsMakerTrade seller_as_maker_trade = 4;

    pub fn get_seller_as_maker_trade(&self) -> &SellerAsMakerTrade {
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::seller_as_maker_trade(ref v)) => v,
            _ => SellerAsMakerTrade::default_instance(),
        }
    }
    pub fn clear_seller_as_maker_trade(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_seller_as_maker_trade(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::seller_as_maker_trade(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_seller_as_maker_trade(&mut self, v: SellerAsMakerTrade) {
        self.message = ::std::option::Option::Some(Tradable_oneof_message::seller_as_maker_trade(v))
    }

    // Mutable pointer to the field.
    pub fn mut_seller_as_maker_trade(&mut self) -> &mut SellerAsMakerTrade {
        if let ::std::option::Option::Some(Tradable_oneof_message::seller_as_maker_trade(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                Tradable_oneof_message::seller_as_maker_trade(SellerAsMakerTrade::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::seller_as_maker_trade(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_seller_as_maker_trade(&mut self) -> SellerAsMakerTrade {
        if self.has_seller_as_maker_trade() {
            match self.message.take() {
                ::std::option::Option::Some(Tradable_oneof_message::seller_as_maker_trade(v)) => v,
                _ => panic!(),
            }
        } else {
            SellerAsMakerTrade::new()
        }
    }

    // .io.bisq.protobuffer.SellerAsTakerTrade seller_as_taker_trade = 5;

    pub fn get_seller_as_taker_trade(&self) -> &SellerAsTakerTrade {
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::seller_as_taker_trade(ref v)) => v,
            _ => SellerAsTakerTrade::default_instance(),
        }
    }
    pub fn clear_seller_as_taker_trade(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_seller_as_taker_trade(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::seller_as_taker_trade(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_seller_as_taker_trade(&mut self, v: SellerAsTakerTrade) {
        self.message = ::std::option::Option::Some(Tradable_oneof_message::seller_as_taker_trade(v))
    }

    // Mutable pointer to the field.
    pub fn mut_seller_as_taker_trade(&mut self) -> &mut SellerAsTakerTrade {
        if let ::std::option::Option::Some(Tradable_oneof_message::seller_as_taker_trade(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                Tradable_oneof_message::seller_as_taker_trade(SellerAsTakerTrade::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(Tradable_oneof_message::seller_as_taker_trade(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_seller_as_taker_trade(&mut self) -> SellerAsTakerTrade {
        if self.has_seller_as_taker_trade() {
            match self.message.take() {
                ::std::option::Option::Some(Tradable_oneof_message::seller_as_taker_trade(v)) => v,
                _ => panic!(),
            }
        } else {
            SellerAsTakerTrade::new()
        }
    }
}

impl ::protobuf::Message for Tradable {
    fn is_initialized(&self) -> bool {
        if let Some(Tradable_oneof_message::open_offer(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Tradable_oneof_message::buyer_as_maker_trade(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Tradable_oneof_message::buyer_as_taker_trade(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Tradable_oneof_message::seller_as_maker_trade(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Tradable_oneof_message::seller_as_taker_trade(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(Tradable_oneof_message::open_offer(
                        is.read_message()?,
                    ));
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        Tradable_oneof_message::buyer_as_maker_trade(is.read_message()?),
                    );
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        Tradable_oneof_message::buyer_as_taker_trade(is.read_message()?),
                    );
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        Tradable_oneof_message::seller_as_maker_trade(is.read_message()?),
                    );
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        Tradable_oneof_message::seller_as_taker_trade(is.read_message()?),
                    );
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &Tradable_oneof_message::open_offer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &Tradable_oneof_message::buyer_as_maker_trade(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &Tradable_oneof_message::buyer_as_taker_trade(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &Tradable_oneof_message::seller_as_maker_trade(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &Tradable_oneof_message::seller_as_taker_trade(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &Tradable_oneof_message::open_offer(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &Tradable_oneof_message::buyer_as_maker_trade(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &Tradable_oneof_message::buyer_as_taker_trade(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &Tradable_oneof_message::seller_as_maker_trade(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &Tradable_oneof_message::seller_as_taker_trade(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tradable {
        Tradable::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<_, OpenOffer>(
                        "open_offer",
                        Tradable::has_open_offer,
                        Tradable::get_open_offer,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        BuyerAsMakerTrade,
                    >(
                        "buyer_as_maker_trade",
                        Tradable::has_buyer_as_maker_trade,
                        Tradable::get_buyer_as_maker_trade,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        BuyerAsTakerTrade,
                    >(
                        "buyer_as_taker_trade",
                        Tradable::has_buyer_as_taker_trade,
                        Tradable::get_buyer_as_taker_trade,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        SellerAsMakerTrade,
                    >(
                        "seller_as_maker_trade",
                        Tradable::has_seller_as_maker_trade,
                        Tradable::get_seller_as_maker_trade,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<
                        _,
                        SellerAsTakerTrade,
                    >(
                        "seller_as_taker_trade",
                        Tradable::has_seller_as_taker_trade,
                        Tradable::get_seller_as_taker_trade,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<Tradable>(
                    "Tradable",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Tradable {
        static mut instance: ::protobuf::lazy::Lazy<Tradable> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Tradable,
        };
        unsafe { instance.get(Tradable::new) }
    }
}

impl ::protobuf::Clear for Tradable {
    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tradable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tradable {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Trade {
    // message fields
    pub offer: ::protobuf::SingularPtrField<Offer>,
    pub process_model: ::protobuf::SingularPtrField<ProcessModel>,
    pub taker_fee_tx_id: ::std::string::String,
    pub deposit_tx_id: ::std::string::String,
    pub payout_tx_id: ::std::string::String,
    pub trade_amount_as_long: i64,
    pub tx_fee_as_long: i64,
    pub taker_fee_as_long: i64,
    pub take_offer_date: i64,
    pub is_currency_for_taker_fee_btc: bool,
    pub trade_price: i64,
    pub trading_peer_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub state: Trade_State,
    pub dispute_state: Trade_DisputeState,
    pub trade_period_state: Trade_TradePeriodState,
    pub contract: ::protobuf::SingularPtrField<Contract>,
    pub contract_as_json: ::std::string::String,
    pub contract_hash: ::std::vec::Vec<u8>,
    pub taker_contract_signature: ::std::string::String,
    pub maker_contract_signature: ::std::string::String,
    pub arbitrator_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub mediator_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub arbitrator_btc_pub_key: ::std::vec::Vec<u8>,
    pub taker_payment_account_id: ::std::string::String,
    pub error_message: ::std::string::String,
    pub arbitrator_pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub mediator_pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub counter_currency_tx_id: ::std::string::String,
    pub chat_message: ::protobuf::RepeatedField<ChatMessage>,
    pub mediation_result_state: MediationResultState,
    pub lock_time: i64,
    pub delayed_payout_tx_bytes: ::std::vec::Vec<u8>,
    pub refund_agent_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub refund_agent_pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub refund_result_state: RefundResultState,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Trade {
    fn default() -> &'a Trade {
        <Trade as ::protobuf::Message>::default_instance()
    }
}

impl Trade {
    pub fn new() -> Trade {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Offer offer = 1;

    pub fn get_offer(&self) -> &Offer {
        self.offer
            .as_ref()
            .unwrap_or_else(|| Offer::default_instance())
    }
    pub fn clear_offer(&mut self) {
        self.offer.clear();
    }

    pub fn has_offer(&self) -> bool {
        self.offer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offer(&mut self, v: Offer) {
        self.offer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer(&mut self) -> &mut Offer {
        if self.offer.is_none() {
            self.offer.set_default();
        }
        self.offer.as_mut().unwrap()
    }

    // Take field
    pub fn take_offer(&mut self) -> Offer {
        self.offer.take().unwrap_or_else(|| Offer::new())
    }

    // .io.bisq.protobuffer.ProcessModel process_model = 2;

    pub fn get_process_model(&self) -> &ProcessModel {
        self.process_model
            .as_ref()
            .unwrap_or_else(|| ProcessModel::default_instance())
    }
    pub fn clear_process_model(&mut self) {
        self.process_model.clear();
    }

    pub fn has_process_model(&self) -> bool {
        self.process_model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process_model(&mut self, v: ProcessModel) {
        self.process_model = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_process_model(&mut self) -> &mut ProcessModel {
        if self.process_model.is_none() {
            self.process_model.set_default();
        }
        self.process_model.as_mut().unwrap()
    }

    // Take field
    pub fn take_process_model(&mut self) -> ProcessModel {
        self.process_model
            .take()
            .unwrap_or_else(|| ProcessModel::new())
    }

    // string taker_fee_tx_id = 3;

    pub fn get_taker_fee_tx_id(&self) -> &str {
        &self.taker_fee_tx_id
    }
    pub fn clear_taker_fee_tx_id(&mut self) {
        self.taker_fee_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_tx_id(&mut self, v: ::std::string::String) {
        self.taker_fee_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_tx_id
    }

    // Take field
    pub fn take_taker_fee_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_tx_id, ::std::string::String::new())
    }

    // string deposit_tx_id = 4;

    pub fn get_deposit_tx_id(&self) -> &str {
        &self.deposit_tx_id
    }
    pub fn clear_deposit_tx_id(&mut self) {
        self.deposit_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_deposit_tx_id(&mut self, v: ::std::string::String) {
        self.deposit_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deposit_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.deposit_tx_id
    }

    // Take field
    pub fn take_deposit_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.deposit_tx_id, ::std::string::String::new())
    }

    // string payout_tx_id = 5;

    pub fn get_payout_tx_id(&self) -> &str {
        &self.payout_tx_id
    }
    pub fn clear_payout_tx_id(&mut self) {
        self.payout_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_payout_tx_id(&mut self, v: ::std::string::String) {
        self.payout_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payout_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.payout_tx_id
    }

    // Take field
    pub fn take_payout_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payout_tx_id, ::std::string::String::new())
    }

    // int64 trade_amount_as_long = 6;

    pub fn get_trade_amount_as_long(&self) -> i64 {
        self.trade_amount_as_long
    }
    pub fn clear_trade_amount_as_long(&mut self) {
        self.trade_amount_as_long = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_amount_as_long(&mut self, v: i64) {
        self.trade_amount_as_long = v;
    }

    // int64 tx_fee_as_long = 7;

    pub fn get_tx_fee_as_long(&self) -> i64 {
        self.tx_fee_as_long
    }
    pub fn clear_tx_fee_as_long(&mut self) {
        self.tx_fee_as_long = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_fee_as_long(&mut self, v: i64) {
        self.tx_fee_as_long = v;
    }

    // int64 taker_fee_as_long = 8;

    pub fn get_taker_fee_as_long(&self) -> i64 {
        self.taker_fee_as_long
    }
    pub fn clear_taker_fee_as_long(&mut self) {
        self.taker_fee_as_long = 0;
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_as_long(&mut self, v: i64) {
        self.taker_fee_as_long = v;
    }

    // int64 take_offer_date = 9;

    pub fn get_take_offer_date(&self) -> i64 {
        self.take_offer_date
    }
    pub fn clear_take_offer_date(&mut self) {
        self.take_offer_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_take_offer_date(&mut self, v: i64) {
        self.take_offer_date = v;
    }

    // bool is_currency_for_taker_fee_btc = 10;

    pub fn get_is_currency_for_taker_fee_btc(&self) -> bool {
        self.is_currency_for_taker_fee_btc
    }
    pub fn clear_is_currency_for_taker_fee_btc(&mut self) {
        self.is_currency_for_taker_fee_btc = false;
    }

    // Param is passed by value, moved
    pub fn set_is_currency_for_taker_fee_btc(&mut self, v: bool) {
        self.is_currency_for_taker_fee_btc = v;
    }

    // int64 trade_price = 11;

    pub fn get_trade_price(&self) -> i64 {
        self.trade_price
    }
    pub fn clear_trade_price(&mut self) {
        self.trade_price = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_price(&mut self, v: i64) {
        self.trade_price = v;
    }

    // .io.bisq.protobuffer.NodeAddress trading_peer_node_address = 12;

    pub fn get_trading_peer_node_address(&self) -> &NodeAddress {
        self.trading_peer_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_trading_peer_node_address(&mut self) {
        self.trading_peer_node_address.clear();
    }

    pub fn has_trading_peer_node_address(&self) -> bool {
        self.trading_peer_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trading_peer_node_address(&mut self, v: NodeAddress) {
        self.trading_peer_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trading_peer_node_address(&mut self) -> &mut NodeAddress {
        if self.trading_peer_node_address.is_none() {
            self.trading_peer_node_address.set_default();
        }
        self.trading_peer_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_trading_peer_node_address(&mut self) -> NodeAddress {
        self.trading_peer_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // .io.bisq.protobuffer.Trade.State state = 13;

    pub fn get_state(&self) -> Trade_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Trade_State::PB_ERROR_STATE;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Trade_State) {
        self.state = v;
    }

    // .io.bisq.protobuffer.Trade.DisputeState dispute_state = 14;

    pub fn get_dispute_state(&self) -> Trade_DisputeState {
        self.dispute_state
    }
    pub fn clear_dispute_state(&mut self) {
        self.dispute_state = Trade_DisputeState::PB_ERROR_DISPUTE_STATE;
    }

    // Param is passed by value, moved
    pub fn set_dispute_state(&mut self, v: Trade_DisputeState) {
        self.dispute_state = v;
    }

    // .io.bisq.protobuffer.Trade.TradePeriodState trade_period_state = 15;

    pub fn get_trade_period_state(&self) -> Trade_TradePeriodState {
        self.trade_period_state
    }
    pub fn clear_trade_period_state(&mut self) {
        self.trade_period_state = Trade_TradePeriodState::PB_ERROR_TRADE_PERIOD_STATE;
    }

    // Param is passed by value, moved
    pub fn set_trade_period_state(&mut self, v: Trade_TradePeriodState) {
        self.trade_period_state = v;
    }

    // .io.bisq.protobuffer.Contract contract = 16;

    pub fn get_contract(&self) -> &Contract {
        self.contract
            .as_ref()
            .unwrap_or_else(|| Contract::default_instance())
    }
    pub fn clear_contract(&mut self) {
        self.contract.clear();
    }

    pub fn has_contract(&self) -> bool {
        self.contract.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract(&mut self, v: Contract) {
        self.contract = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract(&mut self) -> &mut Contract {
        if self.contract.is_none() {
            self.contract.set_default();
        }
        self.contract.as_mut().unwrap()
    }

    // Take field
    pub fn take_contract(&mut self) -> Contract {
        self.contract.take().unwrap_or_else(|| Contract::new())
    }

    // string contract_as_json = 17;

    pub fn get_contract_as_json(&self) -> &str {
        &self.contract_as_json
    }
    pub fn clear_contract_as_json(&mut self) {
        self.contract_as_json.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_as_json(&mut self, v: ::std::string::String) {
        self.contract_as_json = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_as_json(&mut self) -> &mut ::std::string::String {
        &mut self.contract_as_json
    }

    // Take field
    pub fn take_contract_as_json(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contract_as_json, ::std::string::String::new())
    }

    // bytes contract_hash = 18;

    pub fn get_contract_hash(&self) -> &[u8] {
        &self.contract_hash
    }
    pub fn clear_contract_hash(&mut self) {
        self.contract_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract_hash
    }

    // Take field
    pub fn take_contract_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract_hash, ::std::vec::Vec::new())
    }

    // string taker_contract_signature = 19;

    pub fn get_taker_contract_signature(&self) -> &str {
        &self.taker_contract_signature
    }
    pub fn clear_taker_contract_signature(&mut self) {
        self.taker_contract_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_contract_signature(&mut self, v: ::std::string::String) {
        self.taker_contract_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_contract_signature(&mut self) -> &mut ::std::string::String {
        &mut self.taker_contract_signature
    }

    // Take field
    pub fn take_taker_contract_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.taker_contract_signature,
            ::std::string::String::new(),
        )
    }

    // string maker_contract_signature = 20;

    pub fn get_maker_contract_signature(&self) -> &str {
        &self.maker_contract_signature
    }
    pub fn clear_maker_contract_signature(&mut self) {
        self.maker_contract_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_contract_signature(&mut self, v: ::std::string::String) {
        self.maker_contract_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_contract_signature(&mut self) -> &mut ::std::string::String {
        &mut self.maker_contract_signature
    }

    // Take field
    pub fn take_maker_contract_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.maker_contract_signature,
            ::std::string::String::new(),
        )
    }

    // .io.bisq.protobuffer.NodeAddress arbitrator_node_address = 21;

    pub fn get_arbitrator_node_address(&self) -> &NodeAddress {
        self.arbitrator_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_arbitrator_node_address(&mut self) {
        self.arbitrator_node_address.clear();
    }

    pub fn has_arbitrator_node_address(&self) -> bool {
        self.arbitrator_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arbitrator_node_address(&mut self, v: NodeAddress) {
        self.arbitrator_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arbitrator_node_address(&mut self) -> &mut NodeAddress {
        if self.arbitrator_node_address.is_none() {
            self.arbitrator_node_address.set_default();
        }
        self.arbitrator_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_arbitrator_node_address(&mut self) -> NodeAddress {
        self.arbitrator_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // .io.bisq.protobuffer.NodeAddress mediator_node_address = 22;

    pub fn get_mediator_node_address(&self) -> &NodeAddress {
        self.mediator_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_mediator_node_address(&mut self) {
        self.mediator_node_address.clear();
    }

    pub fn has_mediator_node_address(&self) -> bool {
        self.mediator_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediator_node_address(&mut self, v: NodeAddress) {
        self.mediator_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediator_node_address(&mut self) -> &mut NodeAddress {
        if self.mediator_node_address.is_none() {
            self.mediator_node_address.set_default();
        }
        self.mediator_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediator_node_address(&mut self) -> NodeAddress {
        self.mediator_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // bytes arbitrator_btc_pub_key = 23;

    pub fn get_arbitrator_btc_pub_key(&self) -> &[u8] {
        &self.arbitrator_btc_pub_key
    }
    pub fn clear_arbitrator_btc_pub_key(&mut self) {
        self.arbitrator_btc_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_arbitrator_btc_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.arbitrator_btc_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arbitrator_btc_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.arbitrator_btc_pub_key
    }

    // Take field
    pub fn take_arbitrator_btc_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.arbitrator_btc_pub_key, ::std::vec::Vec::new())
    }

    // string taker_payment_account_id = 24;

    pub fn get_taker_payment_account_id(&self) -> &str {
        &self.taker_payment_account_id
    }
    pub fn clear_taker_payment_account_id(&mut self) {
        self.taker_payment_account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_payment_account_id(&mut self, v: ::std::string::String) {
        self.taker_payment_account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_payment_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.taker_payment_account_id
    }

    // Take field
    pub fn take_taker_payment_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.taker_payment_account_id,
            ::std::string::String::new(),
        )
    }

    // string error_message = 25;

    pub fn get_error_message(&self) -> &str {
        &self.error_message
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        &mut self.error_message
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_message, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.PubKeyRing arbitrator_pub_key_ring = 26;

    pub fn get_arbitrator_pub_key_ring(&self) -> &PubKeyRing {
        self.arbitrator_pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_arbitrator_pub_key_ring(&mut self) {
        self.arbitrator_pub_key_ring.clear();
    }

    pub fn has_arbitrator_pub_key_ring(&self) -> bool {
        self.arbitrator_pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arbitrator_pub_key_ring(&mut self, v: PubKeyRing) {
        self.arbitrator_pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arbitrator_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.arbitrator_pub_key_ring.is_none() {
            self.arbitrator_pub_key_ring.set_default();
        }
        self.arbitrator_pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_arbitrator_pub_key_ring(&mut self) -> PubKeyRing {
        self.arbitrator_pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // .io.bisq.protobuffer.PubKeyRing mediator_pub_key_ring = 27;

    pub fn get_mediator_pub_key_ring(&self) -> &PubKeyRing {
        self.mediator_pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_mediator_pub_key_ring(&mut self) {
        self.mediator_pub_key_ring.clear();
    }

    pub fn has_mediator_pub_key_ring(&self) -> bool {
        self.mediator_pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediator_pub_key_ring(&mut self, v: PubKeyRing) {
        self.mediator_pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediator_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.mediator_pub_key_ring.is_none() {
            self.mediator_pub_key_ring.set_default();
        }
        self.mediator_pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediator_pub_key_ring(&mut self) -> PubKeyRing {
        self.mediator_pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // string counter_currency_tx_id = 28;

    pub fn get_counter_currency_tx_id(&self) -> &str {
        &self.counter_currency_tx_id
    }
    pub fn clear_counter_currency_tx_id(&mut self) {
        self.counter_currency_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_counter_currency_tx_id(&mut self, v: ::std::string::String) {
        self.counter_currency_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counter_currency_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.counter_currency_tx_id
    }

    // Take field
    pub fn take_counter_currency_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.counter_currency_tx_id,
            ::std::string::String::new(),
        )
    }

    // repeated .io.bisq.protobuffer.ChatMessage chat_message = 29;

    pub fn get_chat_message(&self) -> &[ChatMessage] {
        &self.chat_message
    }
    pub fn clear_chat_message(&mut self) {
        self.chat_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_message(&mut self, v: ::protobuf::RepeatedField<ChatMessage>) {
        self.chat_message = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_message(&mut self) -> &mut ::protobuf::RepeatedField<ChatMessage> {
        &mut self.chat_message
    }

    // Take field
    pub fn take_chat_message(&mut self) -> ::protobuf::RepeatedField<ChatMessage> {
        ::std::mem::replace(&mut self.chat_message, ::protobuf::RepeatedField::new())
    }

    // .io.bisq.protobuffer.MediationResultState mediation_result_state = 30;

    pub fn get_mediation_result_state(&self) -> MediationResultState {
        self.mediation_result_state
    }
    pub fn clear_mediation_result_state(&mut self) {
        self.mediation_result_state = MediationResultState::PB_ERROR_MEDIATION_RESULT;
    }

    // Param is passed by value, moved
    pub fn set_mediation_result_state(&mut self, v: MediationResultState) {
        self.mediation_result_state = v;
    }

    // int64 lock_time = 31;

    pub fn get_lock_time(&self) -> i64 {
        self.lock_time
    }
    pub fn clear_lock_time(&mut self) {
        self.lock_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_lock_time(&mut self, v: i64) {
        self.lock_time = v;
    }

    // bytes delayed_payout_tx_bytes = 32;

    pub fn get_delayed_payout_tx_bytes(&self) -> &[u8] {
        &self.delayed_payout_tx_bytes
    }
    pub fn clear_delayed_payout_tx_bytes(&mut self) {
        self.delayed_payout_tx_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_delayed_payout_tx_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.delayed_payout_tx_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delayed_payout_tx_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.delayed_payout_tx_bytes
    }

    // Take field
    pub fn take_delayed_payout_tx_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.delayed_payout_tx_bytes, ::std::vec::Vec::new())
    }

    // .io.bisq.protobuffer.NodeAddress refund_agent_node_address = 33;

    pub fn get_refund_agent_node_address(&self) -> &NodeAddress {
        self.refund_agent_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_refund_agent_node_address(&mut self) {
        self.refund_agent_node_address.clear();
    }

    pub fn has_refund_agent_node_address(&self) -> bool {
        self.refund_agent_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refund_agent_node_address(&mut self, v: NodeAddress) {
        self.refund_agent_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refund_agent_node_address(&mut self) -> &mut NodeAddress {
        if self.refund_agent_node_address.is_none() {
            self.refund_agent_node_address.set_default();
        }
        self.refund_agent_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_refund_agent_node_address(&mut self) -> NodeAddress {
        self.refund_agent_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // .io.bisq.protobuffer.PubKeyRing refund_agent_pub_key_ring = 34;

    pub fn get_refund_agent_pub_key_ring(&self) -> &PubKeyRing {
        self.refund_agent_pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_refund_agent_pub_key_ring(&mut self) {
        self.refund_agent_pub_key_ring.clear();
    }

    pub fn has_refund_agent_pub_key_ring(&self) -> bool {
        self.refund_agent_pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refund_agent_pub_key_ring(&mut self, v: PubKeyRing) {
        self.refund_agent_pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refund_agent_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.refund_agent_pub_key_ring.is_none() {
            self.refund_agent_pub_key_ring.set_default();
        }
        self.refund_agent_pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_refund_agent_pub_key_ring(&mut self) -> PubKeyRing {
        self.refund_agent_pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // .io.bisq.protobuffer.RefundResultState refund_result_state = 35;

    pub fn get_refund_result_state(&self) -> RefundResultState {
        self.refund_result_state
    }
    pub fn clear_refund_result_state(&mut self) {
        self.refund_result_state = RefundResultState::PB_ERROR_REFUND_RESULT;
    }

    // Param is passed by value, moved
    pub fn set_refund_result_state(&mut self, v: RefundResultState) {
        self.refund_result_state = v;
    }
}

impl ::protobuf::Message for Trade {
    fn is_initialized(&self) -> bool {
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.process_model {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.trading_peer_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.contract {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.arbitrator_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.mediator_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.arbitrator_pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.mediator_pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.chat_message {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.refund_agent_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.refund_agent_pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.offer)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.process_model,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.taker_fee_tx_id,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.deposit_tx_id,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.payout_tx_id,
                    )?;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.trade_amount_as_long = tmp;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.tx_fee_as_long = tmp;
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.taker_fee_as_long = tmp;
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.take_offer_date = tmp;
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_currency_for_taker_fee_btc = tmp;
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.trade_price = tmp;
                }
                12 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.trading_peer_node_address,
                    )?;
                }
                13 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.state,
                    13,
                    &mut self.unknown_fields,
                )?,
                14 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.dispute_state,
                    14,
                    &mut self.unknown_fields,
                )?,
                15 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.trade_period_state,
                    15,
                    &mut self.unknown_fields,
                )?,
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contract)?;
                }
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.contract_as_json,
                    )?;
                }
                18 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.contract_hash,
                    )?;
                }
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.taker_contract_signature,
                    )?;
                }
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.maker_contract_signature,
                    )?;
                }
                21 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.arbitrator_node_address,
                    )?;
                }
                22 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.mediator_node_address,
                    )?;
                }
                23 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.arbitrator_btc_pub_key,
                    )?;
                }
                24 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.taker_payment_account_id,
                    )?;
                }
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.error_message,
                    )?;
                }
                26 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.arbitrator_pub_key_ring,
                    )?;
                }
                27 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.mediator_pub_key_ring,
                    )?;
                }
                28 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.counter_currency_tx_id,
                    )?;
                }
                29 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.chat_message,
                    )?;
                }
                30 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.mediation_result_state,
                    30,
                    &mut self.unknown_fields,
                )?,
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.lock_time = tmp;
                }
                32 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.delayed_payout_tx_bytes,
                    )?;
                }
                33 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.refund_agent_node_address,
                    )?;
                }
                34 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.refund_agent_pub_key_ring,
                    )?;
                }
                35 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.refund_result_state,
                    35,
                    &mut self.unknown_fields,
                )?,
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.offer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.process_model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.taker_fee_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.taker_fee_tx_id);
        }
        if !self.deposit_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.deposit_tx_id);
        }
        if !self.payout_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.payout_tx_id);
        }
        if self.trade_amount_as_long != 0 {
            my_size += ::protobuf::rt::value_size(
                6,
                self.trade_amount_as_long,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.tx_fee_as_long != 0 {
            my_size += ::protobuf::rt::value_size(
                7,
                self.tx_fee_as_long,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.taker_fee_as_long != 0 {
            my_size += ::protobuf::rt::value_size(
                8,
                self.taker_fee_as_long,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.take_offer_date != 0 {
            my_size += ::protobuf::rt::value_size(
                9,
                self.take_offer_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.is_currency_for_taker_fee_btc != false {
            my_size += 2;
        }
        if self.trade_price != 0 {
            my_size += ::protobuf::rt::value_size(
                11,
                self.trade_price,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if let Some(ref v) = self.trading_peer_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.state != Trade_State::PB_ERROR_STATE {
            my_size += ::protobuf::rt::enum_size(13, self.state);
        }
        if self.dispute_state != Trade_DisputeState::PB_ERROR_DISPUTE_STATE {
            my_size += ::protobuf::rt::enum_size(14, self.dispute_state);
        }
        if self.trade_period_state != Trade_TradePeriodState::PB_ERROR_TRADE_PERIOD_STATE {
            my_size += ::protobuf::rt::enum_size(15, self.trade_period_state);
        }
        if let Some(ref v) = self.contract.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.contract_as_json.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.contract_as_json);
        }
        if !self.contract_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(18, &self.contract_hash);
        }
        if !self.taker_contract_signature.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.taker_contract_signature);
        }
        if !self.maker_contract_signature.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.maker_contract_signature);
        }
        if let Some(ref v) = self.arbitrator_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mediator_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.arbitrator_btc_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(23, &self.arbitrator_btc_pub_key);
        }
        if !self.taker_payment_account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.taker_payment_account_id);
        }
        if !self.error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.error_message);
        }
        if let Some(ref v) = self.arbitrator_pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mediator_pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.counter_currency_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(28, &self.counter_currency_tx_id);
        }
        for value in &self.chat_message {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.mediation_result_state != MediationResultState::PB_ERROR_MEDIATION_RESULT {
            my_size += ::protobuf::rt::enum_size(30, self.mediation_result_state);
        }
        if self.lock_time != 0 {
            my_size += ::protobuf::rt::value_size(
                31,
                self.lock_time,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.delayed_payout_tx_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(32, &self.delayed_payout_tx_bytes);
        }
        if let Some(ref v) = self.refund_agent_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.refund_agent_pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.refund_result_state != RefundResultState::PB_ERROR_REFUND_RESULT {
            my_size += ::protobuf::rt::enum_size(35, self.refund_result_state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.offer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.process_model.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.taker_fee_tx_id.is_empty() {
            os.write_string(3, &self.taker_fee_tx_id)?;
        }
        if !self.deposit_tx_id.is_empty() {
            os.write_string(4, &self.deposit_tx_id)?;
        }
        if !self.payout_tx_id.is_empty() {
            os.write_string(5, &self.payout_tx_id)?;
        }
        if self.trade_amount_as_long != 0 {
            os.write_int64(6, self.trade_amount_as_long)?;
        }
        if self.tx_fee_as_long != 0 {
            os.write_int64(7, self.tx_fee_as_long)?;
        }
        if self.taker_fee_as_long != 0 {
            os.write_int64(8, self.taker_fee_as_long)?;
        }
        if self.take_offer_date != 0 {
            os.write_int64(9, self.take_offer_date)?;
        }
        if self.is_currency_for_taker_fee_btc != false {
            os.write_bool(10, self.is_currency_for_taker_fee_btc)?;
        }
        if self.trade_price != 0 {
            os.write_int64(11, self.trade_price)?;
        }
        if let Some(ref v) = self.trading_peer_node_address.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.state != Trade_State::PB_ERROR_STATE {
            os.write_enum(13, self.state.value())?;
        }
        if self.dispute_state != Trade_DisputeState::PB_ERROR_DISPUTE_STATE {
            os.write_enum(14, self.dispute_state.value())?;
        }
        if self.trade_period_state != Trade_TradePeriodState::PB_ERROR_TRADE_PERIOD_STATE {
            os.write_enum(15, self.trade_period_state.value())?;
        }
        if let Some(ref v) = self.contract.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.contract_as_json.is_empty() {
            os.write_string(17, &self.contract_as_json)?;
        }
        if !self.contract_hash.is_empty() {
            os.write_bytes(18, &self.contract_hash)?;
        }
        if !self.taker_contract_signature.is_empty() {
            os.write_string(19, &self.taker_contract_signature)?;
        }
        if !self.maker_contract_signature.is_empty() {
            os.write_string(20, &self.maker_contract_signature)?;
        }
        if let Some(ref v) = self.arbitrator_node_address.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mediator_node_address.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.arbitrator_btc_pub_key.is_empty() {
            os.write_bytes(23, &self.arbitrator_btc_pub_key)?;
        }
        if !self.taker_payment_account_id.is_empty() {
            os.write_string(24, &self.taker_payment_account_id)?;
        }
        if !self.error_message.is_empty() {
            os.write_string(25, &self.error_message)?;
        }
        if let Some(ref v) = self.arbitrator_pub_key_ring.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mediator_pub_key_ring.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.counter_currency_tx_id.is_empty() {
            os.write_string(28, &self.counter_currency_tx_id)?;
        }
        for v in &self.chat_message {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.mediation_result_state != MediationResultState::PB_ERROR_MEDIATION_RESULT {
            os.write_enum(30, self.mediation_result_state.value())?;
        }
        if self.lock_time != 0 {
            os.write_int64(31, self.lock_time)?;
        }
        if !self.delayed_payout_tx_bytes.is_empty() {
            os.write_bytes(32, &self.delayed_payout_tx_bytes)?;
        }
        if let Some(ref v) = self.refund_agent_node_address.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.refund_agent_pub_key_ring.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.refund_result_state != RefundResultState::PB_ERROR_REFUND_RESULT {
            os.write_enum(35, self.refund_result_state.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Trade {
        Trade::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Offer>,
                    >(
                        "offer", |m: &Trade| &m.offer, |m: &mut Trade| &mut m.offer
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<ProcessModel>,
                    >(
                        "process_model",
                        |m: &Trade| &m.process_model,
                        |m: &mut Trade| &mut m.process_model,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "taker_fee_tx_id",
                    |m: &Trade| &m.taker_fee_tx_id,
                    |m: &mut Trade| &mut m.taker_fee_tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "deposit_tx_id",
                    |m: &Trade| &m.deposit_tx_id,
                    |m: &mut Trade| &mut m.deposit_tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "payout_tx_id",
                    |m: &Trade| &m.payout_tx_id,
                    |m: &mut Trade| &mut m.payout_tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "trade_amount_as_long",
                    |m: &Trade| &m.trade_amount_as_long,
                    |m: &mut Trade| &mut m.trade_amount_as_long,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "tx_fee_as_long",
                    |m: &Trade| &m.tx_fee_as_long,
                    |m: &mut Trade| &mut m.tx_fee_as_long,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "taker_fee_as_long",
                    |m: &Trade| &m.taker_fee_as_long,
                    |m: &mut Trade| &mut m.taker_fee_as_long,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "take_offer_date",
                    |m: &Trade| &m.take_offer_date,
                    |m: &mut Trade| &mut m.take_offer_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_currency_for_taker_fee_btc",
                    |m: &Trade| &m.is_currency_for_taker_fee_btc,
                    |m: &mut Trade| &mut m.is_currency_for_taker_fee_btc,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "trade_price",
                    |m: &Trade| &m.trade_price,
                    |m: &mut Trade| &mut m.trade_price,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "trading_peer_node_address",
                        |m: &Trade| &m.trading_peer_node_address,
                        |m: &mut Trade| &mut m.trading_peer_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<Trade_State>,
                >(
                    "state",
                    |m: &Trade| &m.state,
                    |m: &mut Trade| &mut m.state,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<Trade_DisputeState>,
                >(
                    "dispute_state",
                    |m: &Trade| &m.dispute_state,
                    |m: &mut Trade| &mut m.dispute_state,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<Trade_TradePeriodState>,
                >(
                    "trade_period_state",
                    |m: &Trade| &m.trade_period_state,
                    |m: &mut Trade| &mut m.trade_period_state,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Contract>,
                    >(
                        "contract",
                        |m: &Trade| &m.contract,
                        |m: &mut Trade| &mut m.contract,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "contract_as_json",
                    |m: &Trade| &m.contract_as_json,
                    |m: &mut Trade| &mut m.contract_as_json,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "contract_hash",
                    |m: &Trade| &m.contract_hash,
                    |m: &mut Trade| &mut m.contract_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "taker_contract_signature",
                    |m: &Trade| &m.taker_contract_signature,
                    |m: &mut Trade| &mut m.taker_contract_signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "maker_contract_signature",
                    |m: &Trade| &m.maker_contract_signature,
                    |m: &mut Trade| &mut m.maker_contract_signature,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "arbitrator_node_address",
                        |m: &Trade| &m.arbitrator_node_address,
                        |m: &mut Trade| &mut m.arbitrator_node_address,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "mediator_node_address",
                        |m: &Trade| &m.mediator_node_address,
                        |m: &mut Trade| &mut m.mediator_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "arbitrator_btc_pub_key",
                    |m: &Trade| &m.arbitrator_btc_pub_key,
                    |m: &mut Trade| &mut m.arbitrator_btc_pub_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "taker_payment_account_id",
                    |m: &Trade| &m.taker_payment_account_id,
                    |m: &mut Trade| &mut m.taker_payment_account_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "error_message",
                    |m: &Trade| &m.error_message,
                    |m: &mut Trade| &mut m.error_message,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "arbitrator_pub_key_ring",
                        |m: &Trade| &m.arbitrator_pub_key_ring,
                        |m: &mut Trade| &mut m.arbitrator_pub_key_ring,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "mediator_pub_key_ring",
                        |m: &Trade| &m.mediator_pub_key_ring,
                        |m: &mut Trade| &mut m.mediator_pub_key_ring,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "counter_currency_tx_id",
                    |m: &Trade| &m.counter_currency_tx_id,
                    |m: &mut Trade| &mut m.counter_currency_tx_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<ChatMessage>,
                    >(
                        "chat_message",
                        |m: &Trade| &m.chat_message,
                        |m: &mut Trade| &mut m.chat_message,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<MediationResultState>,
                >(
                    "mediation_result_state",
                    |m: &Trade| &m.mediation_result_state,
                    |m: &mut Trade| &mut m.mediation_result_state,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "lock_time",
                    |m: &Trade| &m.lock_time,
                    |m: &mut Trade| &mut m.lock_time,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "delayed_payout_tx_bytes",
                    |m: &Trade| &m.delayed_payout_tx_bytes,
                    |m: &mut Trade| &mut m.delayed_payout_tx_bytes,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "refund_agent_node_address",
                        |m: &Trade| &m.refund_agent_node_address,
                        |m: &mut Trade| &mut m.refund_agent_node_address,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "refund_agent_pub_key_ring",
                        |m: &Trade| &m.refund_agent_pub_key_ring,
                        |m: &mut Trade| &mut m.refund_agent_pub_key_ring,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<RefundResultState>,
                >(
                    "refund_result_state",
                    |m: &Trade| &m.refund_result_state,
                    |m: &mut Trade| &mut m.refund_result_state,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Trade>(
                    "Trade",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Trade {
        static mut instance: ::protobuf::lazy::Lazy<Trade> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Trade,
        };
        unsafe { instance.get(Trade::new) }
    }
}

impl ::protobuf::Clear for Trade {
    fn clear(&mut self) {
        self.offer.clear();
        self.process_model.clear();
        self.taker_fee_tx_id.clear();
        self.deposit_tx_id.clear();
        self.payout_tx_id.clear();
        self.trade_amount_as_long = 0;
        self.tx_fee_as_long = 0;
        self.taker_fee_as_long = 0;
        self.take_offer_date = 0;
        self.is_currency_for_taker_fee_btc = false;
        self.trade_price = 0;
        self.trading_peer_node_address.clear();
        self.state = Trade_State::PB_ERROR_STATE;
        self.dispute_state = Trade_DisputeState::PB_ERROR_DISPUTE_STATE;
        self.trade_period_state = Trade_TradePeriodState::PB_ERROR_TRADE_PERIOD_STATE;
        self.contract.clear();
        self.contract_as_json.clear();
        self.contract_hash.clear();
        self.taker_contract_signature.clear();
        self.maker_contract_signature.clear();
        self.arbitrator_node_address.clear();
        self.mediator_node_address.clear();
        self.arbitrator_btc_pub_key.clear();
        self.taker_payment_account_id.clear();
        self.error_message.clear();
        self.arbitrator_pub_key_ring.clear();
        self.mediator_pub_key_ring.clear();
        self.counter_currency_tx_id.clear();
        self.chat_message.clear();
        self.mediation_result_state = MediationResultState::PB_ERROR_MEDIATION_RESULT;
        self.lock_time = 0;
        self.delayed_payout_tx_bytes.clear();
        self.refund_agent_node_address.clear();
        self.refund_agent_pub_key_ring.clear();
        self.refund_result_state = RefundResultState::PB_ERROR_REFUND_RESULT;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Trade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Trade {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum Trade_State {
    PB_ERROR_STATE = 0,
    PREPARATION = 1,
    TAKER_PUBLISHED_TAKER_FEE_TX = 2,
    MAKER_SENT_PUBLISH_DEPOSIT_TX_REQUEST = 3,
    MAKER_SAW_ARRIVED_PUBLISH_DEPOSIT_TX_REQUEST = 4,
    MAKER_STORED_IN_MAILBOX_PUBLISH_DEPOSIT_TX_REQUEST = 5,
    MAKER_SEND_FAILED_PUBLISH_DEPOSIT_TX_REQUEST = 6,
    TAKER_RECEIVED_PUBLISH_DEPOSIT_TX_REQUEST = 7,
    SELLER_PUBLISHED_DEPOSIT_TX = 8,
    SELLER_SENT_DEPOSIT_TX_PUBLISHED_MSG = 9,
    SELLER_SAW_ARRIVED_DEPOSIT_TX_PUBLISHED_MSG = 10,
    SELLER_STORED_IN_MAILBOX_DEPOSIT_TX_PUBLISHED_MSG = 11,
    SELLER_SEND_FAILED_DEPOSIT_TX_PUBLISHED_MSG = 12,
    BUYER_RECEIVED_DEPOSIT_TX_PUBLISHED_MSG = 13,
    BUYER_SAW_DEPOSIT_TX_IN_NETWORK = 14,
    DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN = 15,
    BUYER_CONFIRMED_IN_UI_FIAT_PAYMENT_INITIATED = 16,
    BUYER_SENT_FIAT_PAYMENT_INITIATED_MSG = 17,
    BUYER_SAW_ARRIVED_FIAT_PAYMENT_INITIATED_MSG = 18,
    BUYER_STORED_IN_MAILBOX_FIAT_PAYMENT_INITIATED_MSG = 19,
    BUYER_SEND_FAILED_FIAT_PAYMENT_INITIATED_MSG = 20,
    SELLER_RECEIVED_FIAT_PAYMENT_INITIATED_MSG = 21,
    SELLER_CONFIRMED_IN_UI_FIAT_PAYMENT_RECEIPT = 22,
    SELLER_PUBLISHED_PAYOUT_TX = 23,
    SELLER_SENT_PAYOUT_TX_PUBLISHED_MSG = 24,
    SELLER_SAW_ARRIVED_PAYOUT_TX_PUBLISHED_MSG = 25,
    SELLER_STORED_IN_MAILBOX_PAYOUT_TX_PUBLISHED_MSG = 26,
    SELLER_SEND_FAILED_PAYOUT_TX_PUBLISHED_MSG = 27,
    BUYER_RECEIVED_PAYOUT_TX_PUBLISHED_MSG = 28,
    BUYER_SAW_PAYOUT_TX_IN_NETWORK = 29,
    WITHDRAW_COMPLETED = 30,
}

impl ::protobuf::ProtobufEnum for Trade_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Trade_State> {
        match value {
            0 => ::std::option::Option::Some(Trade_State::PB_ERROR_STATE),
            1 => ::std::option::Option::Some(Trade_State::PREPARATION),
            2 => ::std::option::Option::Some(Trade_State::TAKER_PUBLISHED_TAKER_FEE_TX),
            3 => ::std::option::Option::Some(Trade_State::MAKER_SENT_PUBLISH_DEPOSIT_TX_REQUEST),
            4 => ::std::option::Option::Some(
                Trade_State::MAKER_SAW_ARRIVED_PUBLISH_DEPOSIT_TX_REQUEST,
            ),
            5 => ::std::option::Option::Some(
                Trade_State::MAKER_STORED_IN_MAILBOX_PUBLISH_DEPOSIT_TX_REQUEST,
            ),
            6 => ::std::option::Option::Some(
                Trade_State::MAKER_SEND_FAILED_PUBLISH_DEPOSIT_TX_REQUEST,
            ),
            7 => {
                ::std::option::Option::Some(Trade_State::TAKER_RECEIVED_PUBLISH_DEPOSIT_TX_REQUEST)
            }
            8 => ::std::option::Option::Some(Trade_State::SELLER_PUBLISHED_DEPOSIT_TX),
            9 => ::std::option::Option::Some(Trade_State::SELLER_SENT_DEPOSIT_TX_PUBLISHED_MSG),
            10 => ::std::option::Option::Some(
                Trade_State::SELLER_SAW_ARRIVED_DEPOSIT_TX_PUBLISHED_MSG,
            ),
            11 => ::std::option::Option::Some(
                Trade_State::SELLER_STORED_IN_MAILBOX_DEPOSIT_TX_PUBLISHED_MSG,
            ),
            12 => ::std::option::Option::Some(
                Trade_State::SELLER_SEND_FAILED_DEPOSIT_TX_PUBLISHED_MSG,
            ),
            13 => ::std::option::Option::Some(Trade_State::BUYER_RECEIVED_DEPOSIT_TX_PUBLISHED_MSG),
            14 => ::std::option::Option::Some(Trade_State::BUYER_SAW_DEPOSIT_TX_IN_NETWORK),
            15 => ::std::option::Option::Some(Trade_State::DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN),
            16 => ::std::option::Option::Some(
                Trade_State::BUYER_CONFIRMED_IN_UI_FIAT_PAYMENT_INITIATED,
            ),
            17 => ::std::option::Option::Some(Trade_State::BUYER_SENT_FIAT_PAYMENT_INITIATED_MSG),
            18 => ::std::option::Option::Some(
                Trade_State::BUYER_SAW_ARRIVED_FIAT_PAYMENT_INITIATED_MSG,
            ),
            19 => ::std::option::Option::Some(
                Trade_State::BUYER_STORED_IN_MAILBOX_FIAT_PAYMENT_INITIATED_MSG,
            ),
            20 => ::std::option::Option::Some(
                Trade_State::BUYER_SEND_FAILED_FIAT_PAYMENT_INITIATED_MSG,
            ),
            21 => {
                ::std::option::Option::Some(Trade_State::SELLER_RECEIVED_FIAT_PAYMENT_INITIATED_MSG)
            }
            22 => ::std::option::Option::Some(
                Trade_State::SELLER_CONFIRMED_IN_UI_FIAT_PAYMENT_RECEIPT,
            ),
            23 => ::std::option::Option::Some(Trade_State::SELLER_PUBLISHED_PAYOUT_TX),
            24 => ::std::option::Option::Some(Trade_State::SELLER_SENT_PAYOUT_TX_PUBLISHED_MSG),
            25 => {
                ::std::option::Option::Some(Trade_State::SELLER_SAW_ARRIVED_PAYOUT_TX_PUBLISHED_MSG)
            }
            26 => ::std::option::Option::Some(
                Trade_State::SELLER_STORED_IN_MAILBOX_PAYOUT_TX_PUBLISHED_MSG,
            ),
            27 => {
                ::std::option::Option::Some(Trade_State::SELLER_SEND_FAILED_PAYOUT_TX_PUBLISHED_MSG)
            }
            28 => ::std::option::Option::Some(Trade_State::BUYER_RECEIVED_PAYOUT_TX_PUBLISHED_MSG),
            29 => ::std::option::Option::Some(Trade_State::BUYER_SAW_PAYOUT_TX_IN_NETWORK),
            30 => ::std::option::Option::Some(Trade_State::WITHDRAW_COMPLETED),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Trade_State] = &[
            Trade_State::PB_ERROR_STATE,
            Trade_State::PREPARATION,
            Trade_State::TAKER_PUBLISHED_TAKER_FEE_TX,
            Trade_State::MAKER_SENT_PUBLISH_DEPOSIT_TX_REQUEST,
            Trade_State::MAKER_SAW_ARRIVED_PUBLISH_DEPOSIT_TX_REQUEST,
            Trade_State::MAKER_STORED_IN_MAILBOX_PUBLISH_DEPOSIT_TX_REQUEST,
            Trade_State::MAKER_SEND_FAILED_PUBLISH_DEPOSIT_TX_REQUEST,
            Trade_State::TAKER_RECEIVED_PUBLISH_DEPOSIT_TX_REQUEST,
            Trade_State::SELLER_PUBLISHED_DEPOSIT_TX,
            Trade_State::SELLER_SENT_DEPOSIT_TX_PUBLISHED_MSG,
            Trade_State::SELLER_SAW_ARRIVED_DEPOSIT_TX_PUBLISHED_MSG,
            Trade_State::SELLER_STORED_IN_MAILBOX_DEPOSIT_TX_PUBLISHED_MSG,
            Trade_State::SELLER_SEND_FAILED_DEPOSIT_TX_PUBLISHED_MSG,
            Trade_State::BUYER_RECEIVED_DEPOSIT_TX_PUBLISHED_MSG,
            Trade_State::BUYER_SAW_DEPOSIT_TX_IN_NETWORK,
            Trade_State::DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN,
            Trade_State::BUYER_CONFIRMED_IN_UI_FIAT_PAYMENT_INITIATED,
            Trade_State::BUYER_SENT_FIAT_PAYMENT_INITIATED_MSG,
            Trade_State::BUYER_SAW_ARRIVED_FIAT_PAYMENT_INITIATED_MSG,
            Trade_State::BUYER_STORED_IN_MAILBOX_FIAT_PAYMENT_INITIATED_MSG,
            Trade_State::BUYER_SEND_FAILED_FIAT_PAYMENT_INITIATED_MSG,
            Trade_State::SELLER_RECEIVED_FIAT_PAYMENT_INITIATED_MSG,
            Trade_State::SELLER_CONFIRMED_IN_UI_FIAT_PAYMENT_RECEIPT,
            Trade_State::SELLER_PUBLISHED_PAYOUT_TX,
            Trade_State::SELLER_SENT_PAYOUT_TX_PUBLISHED_MSG,
            Trade_State::SELLER_SAW_ARRIVED_PAYOUT_TX_PUBLISHED_MSG,
            Trade_State::SELLER_STORED_IN_MAILBOX_PAYOUT_TX_PUBLISHED_MSG,
            Trade_State::SELLER_SEND_FAILED_PAYOUT_TX_PUBLISHED_MSG,
            Trade_State::BUYER_RECEIVED_PAYOUT_TX_PUBLISHED_MSG,
            Trade_State::BUYER_SAW_PAYOUT_TX_IN_NETWORK,
            Trade_State::WITHDRAW_COMPLETED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Trade_State", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Trade_State {}

impl ::std::default::Default for Trade_State {
    fn default() -> Self {
        Trade_State::PB_ERROR_STATE
    }
}

impl ::protobuf::reflect::ProtobufValue for Trade_State {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum Trade_Phase {
    PB_ERROR_PHASE = 0,
    INIT = 1,
    TAKER_FEE_PUBLISHED = 2,
    DEPOSIT_PUBLISHED = 3,
    DEPOSIT_CONFIRMED = 4,
    FIAT_SENT = 5,
    FIAT_RECEIVED = 6,
    PAYOUT_PUBLISHED = 7,
    WITHDRAWN = 8,
}

impl ::protobuf::ProtobufEnum for Trade_Phase {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Trade_Phase> {
        match value {
            0 => ::std::option::Option::Some(Trade_Phase::PB_ERROR_PHASE),
            1 => ::std::option::Option::Some(Trade_Phase::INIT),
            2 => ::std::option::Option::Some(Trade_Phase::TAKER_FEE_PUBLISHED),
            3 => ::std::option::Option::Some(Trade_Phase::DEPOSIT_PUBLISHED),
            4 => ::std::option::Option::Some(Trade_Phase::DEPOSIT_CONFIRMED),
            5 => ::std::option::Option::Some(Trade_Phase::FIAT_SENT),
            6 => ::std::option::Option::Some(Trade_Phase::FIAT_RECEIVED),
            7 => ::std::option::Option::Some(Trade_Phase::PAYOUT_PUBLISHED),
            8 => ::std::option::Option::Some(Trade_Phase::WITHDRAWN),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Trade_Phase] = &[
            Trade_Phase::PB_ERROR_PHASE,
            Trade_Phase::INIT,
            Trade_Phase::TAKER_FEE_PUBLISHED,
            Trade_Phase::DEPOSIT_PUBLISHED,
            Trade_Phase::DEPOSIT_CONFIRMED,
            Trade_Phase::FIAT_SENT,
            Trade_Phase::FIAT_RECEIVED,
            Trade_Phase::PAYOUT_PUBLISHED,
            Trade_Phase::WITHDRAWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Trade_Phase", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Trade_Phase {}

impl ::std::default::Default for Trade_Phase {
    fn default() -> Self {
        Trade_Phase::PB_ERROR_PHASE
    }
}

impl ::protobuf::reflect::ProtobufValue for Trade_Phase {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum Trade_DisputeState {
    PB_ERROR_DISPUTE_STATE = 0,
    NO_DISPUTE = 1,
    DISPUTE_REQUESTED = 2,
    DISPUTE_STARTED_BY_PEER = 3,
    DISPUTE_CLOSED = 4,
    MEDIATION_REQUESTED = 5,
    MEDIATION_STARTED_BY_PEER = 6,
    MEDIATION_CLOSED = 7,
    REFUND_REQUESTED = 8,
    REFUND_REQUEST_STARTED_BY_PEER = 9,
    REFUND_REQUEST_CLOSED = 10,
}

impl ::protobuf::ProtobufEnum for Trade_DisputeState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Trade_DisputeState> {
        match value {
            0 => ::std::option::Option::Some(Trade_DisputeState::PB_ERROR_DISPUTE_STATE),
            1 => ::std::option::Option::Some(Trade_DisputeState::NO_DISPUTE),
            2 => ::std::option::Option::Some(Trade_DisputeState::DISPUTE_REQUESTED),
            3 => ::std::option::Option::Some(Trade_DisputeState::DISPUTE_STARTED_BY_PEER),
            4 => ::std::option::Option::Some(Trade_DisputeState::DISPUTE_CLOSED),
            5 => ::std::option::Option::Some(Trade_DisputeState::MEDIATION_REQUESTED),
            6 => ::std::option::Option::Some(Trade_DisputeState::MEDIATION_STARTED_BY_PEER),
            7 => ::std::option::Option::Some(Trade_DisputeState::MEDIATION_CLOSED),
            8 => ::std::option::Option::Some(Trade_DisputeState::REFUND_REQUESTED),
            9 => ::std::option::Option::Some(Trade_DisputeState::REFUND_REQUEST_STARTED_BY_PEER),
            10 => ::std::option::Option::Some(Trade_DisputeState::REFUND_REQUEST_CLOSED),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Trade_DisputeState] = &[
            Trade_DisputeState::PB_ERROR_DISPUTE_STATE,
            Trade_DisputeState::NO_DISPUTE,
            Trade_DisputeState::DISPUTE_REQUESTED,
            Trade_DisputeState::DISPUTE_STARTED_BY_PEER,
            Trade_DisputeState::DISPUTE_CLOSED,
            Trade_DisputeState::MEDIATION_REQUESTED,
            Trade_DisputeState::MEDIATION_STARTED_BY_PEER,
            Trade_DisputeState::MEDIATION_CLOSED,
            Trade_DisputeState::REFUND_REQUESTED,
            Trade_DisputeState::REFUND_REQUEST_STARTED_BY_PEER,
            Trade_DisputeState::REFUND_REQUEST_CLOSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new(
                    "Trade_DisputeState",
                    file_descriptor_proto(),
                )
            })
        }
    }
}

impl ::std::marker::Copy for Trade_DisputeState {}

impl ::std::default::Default for Trade_DisputeState {
    fn default() -> Self {
        Trade_DisputeState::PB_ERROR_DISPUTE_STATE
    }
}

impl ::protobuf::reflect::ProtobufValue for Trade_DisputeState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum Trade_TradePeriodState {
    PB_ERROR_TRADE_PERIOD_STATE = 0,
    FIRST_HALF = 1,
    SECOND_HALF = 2,
    TRADE_PERIOD_OVER = 3,
}

impl ::protobuf::ProtobufEnum for Trade_TradePeriodState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Trade_TradePeriodState> {
        match value {
            0 => ::std::option::Option::Some(Trade_TradePeriodState::PB_ERROR_TRADE_PERIOD_STATE),
            1 => ::std::option::Option::Some(Trade_TradePeriodState::FIRST_HALF),
            2 => ::std::option::Option::Some(Trade_TradePeriodState::SECOND_HALF),
            3 => ::std::option::Option::Some(Trade_TradePeriodState::TRADE_PERIOD_OVER),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Trade_TradePeriodState] = &[
            Trade_TradePeriodState::PB_ERROR_TRADE_PERIOD_STATE,
            Trade_TradePeriodState::FIRST_HALF,
            Trade_TradePeriodState::SECOND_HALF,
            Trade_TradePeriodState::TRADE_PERIOD_OVER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new(
                    "Trade_TradePeriodState",
                    file_descriptor_proto(),
                )
            })
        }
    }
}

impl ::std::marker::Copy for Trade_TradePeriodState {}

impl ::std::default::Default for Trade_TradePeriodState {
    fn default() -> Self {
        Trade_TradePeriodState::PB_ERROR_TRADE_PERIOD_STATE
    }
}

impl ::protobuf::reflect::ProtobufValue for Trade_TradePeriodState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct BuyerAsMakerTrade {
    // message fields
    pub trade: ::protobuf::SingularPtrField<Trade>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuyerAsMakerTrade {
    fn default() -> &'a BuyerAsMakerTrade {
        <BuyerAsMakerTrade as ::protobuf::Message>::default_instance()
    }
}

impl BuyerAsMakerTrade {
    pub fn new() -> BuyerAsMakerTrade {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Trade trade = 1;

    pub fn get_trade(&self) -> &Trade {
        self.trade
            .as_ref()
            .unwrap_or_else(|| Trade::default_instance())
    }
    pub fn clear_trade(&mut self) {
        self.trade.clear();
    }

    pub fn has_trade(&self) -> bool {
        self.trade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade(&mut self, v: Trade) {
        self.trade = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade(&mut self) -> &mut Trade {
        if self.trade.is_none() {
            self.trade.set_default();
        }
        self.trade.as_mut().unwrap()
    }

    // Take field
    pub fn take_trade(&mut self) -> Trade {
        self.trade.take().unwrap_or_else(|| Trade::new())
    }
}

impl ::protobuf::Message for BuyerAsMakerTrade {
    fn is_initialized(&self) -> bool {
        for v in &self.trade {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trade)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trade.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trade.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuyerAsMakerTrade {
        BuyerAsMakerTrade::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Trade>,
                    >(
                        "trade",
                        |m: &BuyerAsMakerTrade| &m.trade,
                        |m: &mut BuyerAsMakerTrade| &mut m.trade,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<BuyerAsMakerTrade>(
                    "BuyerAsMakerTrade",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static BuyerAsMakerTrade {
        static mut instance: ::protobuf::lazy::Lazy<BuyerAsMakerTrade> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BuyerAsMakerTrade,
        };
        unsafe { instance.get(BuyerAsMakerTrade::new) }
    }
}

impl ::protobuf::Clear for BuyerAsMakerTrade {
    fn clear(&mut self) {
        self.trade.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuyerAsMakerTrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuyerAsMakerTrade {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct BuyerAsTakerTrade {
    // message fields
    pub trade: ::protobuf::SingularPtrField<Trade>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuyerAsTakerTrade {
    fn default() -> &'a BuyerAsTakerTrade {
        <BuyerAsTakerTrade as ::protobuf::Message>::default_instance()
    }
}

impl BuyerAsTakerTrade {
    pub fn new() -> BuyerAsTakerTrade {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Trade trade = 1;

    pub fn get_trade(&self) -> &Trade {
        self.trade
            .as_ref()
            .unwrap_or_else(|| Trade::default_instance())
    }
    pub fn clear_trade(&mut self) {
        self.trade.clear();
    }

    pub fn has_trade(&self) -> bool {
        self.trade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade(&mut self, v: Trade) {
        self.trade = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade(&mut self) -> &mut Trade {
        if self.trade.is_none() {
            self.trade.set_default();
        }
        self.trade.as_mut().unwrap()
    }

    // Take field
    pub fn take_trade(&mut self) -> Trade {
        self.trade.take().unwrap_or_else(|| Trade::new())
    }
}

impl ::protobuf::Message for BuyerAsTakerTrade {
    fn is_initialized(&self) -> bool {
        for v in &self.trade {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trade)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trade.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trade.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuyerAsTakerTrade {
        BuyerAsTakerTrade::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Trade>,
                    >(
                        "trade",
                        |m: &BuyerAsTakerTrade| &m.trade,
                        |m: &mut BuyerAsTakerTrade| &mut m.trade,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<BuyerAsTakerTrade>(
                    "BuyerAsTakerTrade",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static BuyerAsTakerTrade {
        static mut instance: ::protobuf::lazy::Lazy<BuyerAsTakerTrade> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BuyerAsTakerTrade,
        };
        unsafe { instance.get(BuyerAsTakerTrade::new) }
    }
}

impl ::protobuf::Clear for BuyerAsTakerTrade {
    fn clear(&mut self) {
        self.trade.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuyerAsTakerTrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuyerAsTakerTrade {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct SellerAsMakerTrade {
    // message fields
    pub trade: ::protobuf::SingularPtrField<Trade>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SellerAsMakerTrade {
    fn default() -> &'a SellerAsMakerTrade {
        <SellerAsMakerTrade as ::protobuf::Message>::default_instance()
    }
}

impl SellerAsMakerTrade {
    pub fn new() -> SellerAsMakerTrade {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Trade trade = 1;

    pub fn get_trade(&self) -> &Trade {
        self.trade
            .as_ref()
            .unwrap_or_else(|| Trade::default_instance())
    }
    pub fn clear_trade(&mut self) {
        self.trade.clear();
    }

    pub fn has_trade(&self) -> bool {
        self.trade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade(&mut self, v: Trade) {
        self.trade = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade(&mut self) -> &mut Trade {
        if self.trade.is_none() {
            self.trade.set_default();
        }
        self.trade.as_mut().unwrap()
    }

    // Take field
    pub fn take_trade(&mut self) -> Trade {
        self.trade.take().unwrap_or_else(|| Trade::new())
    }
}

impl ::protobuf::Message for SellerAsMakerTrade {
    fn is_initialized(&self) -> bool {
        for v in &self.trade {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trade)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trade.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trade.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SellerAsMakerTrade {
        SellerAsMakerTrade::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Trade>,
                    >(
                        "trade",
                        |m: &SellerAsMakerTrade| &m.trade,
                        |m: &mut SellerAsMakerTrade| &mut m.trade,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<SellerAsMakerTrade>(
                    "SellerAsMakerTrade",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static SellerAsMakerTrade {
        static mut instance: ::protobuf::lazy::Lazy<SellerAsMakerTrade> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SellerAsMakerTrade,
        };
        unsafe { instance.get(SellerAsMakerTrade::new) }
    }
}

impl ::protobuf::Clear for SellerAsMakerTrade {
    fn clear(&mut self) {
        self.trade.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SellerAsMakerTrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SellerAsMakerTrade {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct SellerAsTakerTrade {
    // message fields
    pub trade: ::protobuf::SingularPtrField<Trade>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SellerAsTakerTrade {
    fn default() -> &'a SellerAsTakerTrade {
        <SellerAsTakerTrade as ::protobuf::Message>::default_instance()
    }
}

impl SellerAsTakerTrade {
    pub fn new() -> SellerAsTakerTrade {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Trade trade = 1;

    pub fn get_trade(&self) -> &Trade {
        self.trade
            .as_ref()
            .unwrap_or_else(|| Trade::default_instance())
    }
    pub fn clear_trade(&mut self) {
        self.trade.clear();
    }

    pub fn has_trade(&self) -> bool {
        self.trade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade(&mut self, v: Trade) {
        self.trade = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade(&mut self) -> &mut Trade {
        if self.trade.is_none() {
            self.trade.set_default();
        }
        self.trade.as_mut().unwrap()
    }

    // Take field
    pub fn take_trade(&mut self) -> Trade {
        self.trade.take().unwrap_or_else(|| Trade::new())
    }
}

impl ::protobuf::Message for SellerAsTakerTrade {
    fn is_initialized(&self) -> bool {
        for v in &self.trade {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trade)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trade.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trade.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SellerAsTakerTrade {
        SellerAsTakerTrade::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Trade>,
                    >(
                        "trade",
                        |m: &SellerAsTakerTrade| &m.trade,
                        |m: &mut SellerAsTakerTrade| &mut m.trade,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<SellerAsTakerTrade>(
                    "SellerAsTakerTrade",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static SellerAsTakerTrade {
        static mut instance: ::protobuf::lazy::Lazy<SellerAsTakerTrade> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SellerAsTakerTrade,
        };
        unsafe { instance.get(SellerAsTakerTrade::new) }
    }
}

impl ::protobuf::Clear for SellerAsTakerTrade {
    fn clear(&mut self) {
        self.trade.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SellerAsTakerTrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SellerAsTakerTrade {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ProcessModel {
    // message fields
    pub trading_peer: ::protobuf::SingularPtrField<TradingPeer>,
    pub offer_id: ::std::string::String,
    pub account_id: ::std::string::String,
    pub pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub take_offer_fee_tx_id: ::std::string::String,
    pub payout_tx_signature: ::std::vec::Vec<u8>,
    pub prepared_deposit_tx: ::std::vec::Vec<u8>,
    pub raw_transaction_inputs: ::protobuf::RepeatedField<RawTransactionInput>,
    pub change_output_value: i64,
    pub change_output_address: ::std::string::String,
    pub use_savings_wallet: bool,
    pub funds_needed_for_trade_as_long: i64,
    pub my_multi_sig_pub_key: ::std::vec::Vec<u8>,
    pub temp_trading_peer_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub payment_started_message_state: ::std::string::String,
    pub mediated_payout_tx_signature: ::std::vec::Vec<u8>,
    pub buyer_payout_amount_from_mediation: i64,
    pub seller_payout_amount_from_mediation: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProcessModel {
    fn default() -> &'a ProcessModel {
        <ProcessModel as ::protobuf::Message>::default_instance()
    }
}

impl ProcessModel {
    pub fn new() -> ProcessModel {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.TradingPeer trading_peer = 1;

    pub fn get_trading_peer(&self) -> &TradingPeer {
        self.trading_peer
            .as_ref()
            .unwrap_or_else(|| TradingPeer::default_instance())
    }
    pub fn clear_trading_peer(&mut self) {
        self.trading_peer.clear();
    }

    pub fn has_trading_peer(&self) -> bool {
        self.trading_peer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trading_peer(&mut self, v: TradingPeer) {
        self.trading_peer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trading_peer(&mut self) -> &mut TradingPeer {
        if self.trading_peer.is_none() {
            self.trading_peer.set_default();
        }
        self.trading_peer.as_mut().unwrap()
    }

    // Take field
    pub fn take_trading_peer(&mut self) -> TradingPeer {
        self.trading_peer
            .take()
            .unwrap_or_else(|| TradingPeer::new())
    }

    // string offer_id = 2;

    pub fn get_offer_id(&self) -> &str {
        &self.offer_id
    }
    pub fn clear_offer_id(&mut self) {
        self.offer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_offer_id(&mut self, v: ::std::string::String) {
        self.offer_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer_id(&mut self) -> &mut ::std::string::String {
        &mut self.offer_id
    }

    // Take field
    pub fn take_offer_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.offer_id, ::std::string::String::new())
    }

    // string account_id = 3;

    pub fn get_account_id(&self) -> &str {
        &self.account_id
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: ::std::string::String) {
        self.account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.account_id
    }

    // Take field
    pub fn take_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.PubKeyRing pub_key_ring = 4;

    pub fn get_pub_key_ring(&self) -> &PubKeyRing {
        self.pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_pub_key_ring(&mut self) {
        self.pub_key_ring.clear();
    }

    pub fn has_pub_key_ring(&self) -> bool {
        self.pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pub_key_ring(&mut self, v: PubKeyRing) {
        self.pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.pub_key_ring.is_none() {
            self.pub_key_ring.set_default();
        }
        self.pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_pub_key_ring(&mut self) -> PubKeyRing {
        self.pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // string take_offer_fee_tx_id = 5;

    pub fn get_take_offer_fee_tx_id(&self) -> &str {
        &self.take_offer_fee_tx_id
    }
    pub fn clear_take_offer_fee_tx_id(&mut self) {
        self.take_offer_fee_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_take_offer_fee_tx_id(&mut self, v: ::std::string::String) {
        self.take_offer_fee_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_take_offer_fee_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.take_offer_fee_tx_id
    }

    // Take field
    pub fn take_take_offer_fee_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.take_offer_fee_tx_id, ::std::string::String::new())
    }

    // bytes payout_tx_signature = 6;

    pub fn get_payout_tx_signature(&self) -> &[u8] {
        &self.payout_tx_signature
    }
    pub fn clear_payout_tx_signature(&mut self) {
        self.payout_tx_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_payout_tx_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.payout_tx_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payout_tx_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payout_tx_signature
    }

    // Take field
    pub fn take_payout_tx_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payout_tx_signature, ::std::vec::Vec::new())
    }

    // bytes prepared_deposit_tx = 9;

    pub fn get_prepared_deposit_tx(&self) -> &[u8] {
        &self.prepared_deposit_tx
    }
    pub fn clear_prepared_deposit_tx(&mut self) {
        self.prepared_deposit_tx.clear();
    }

    // Param is passed by value, moved
    pub fn set_prepared_deposit_tx(&mut self, v: ::std::vec::Vec<u8>) {
        self.prepared_deposit_tx = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prepared_deposit_tx(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prepared_deposit_tx
    }

    // Take field
    pub fn take_prepared_deposit_tx(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prepared_deposit_tx, ::std::vec::Vec::new())
    }

    // repeated .io.bisq.protobuffer.RawTransactionInput raw_transaction_inputs = 10;

    pub fn get_raw_transaction_inputs(&self) -> &[RawTransactionInput] {
        &self.raw_transaction_inputs
    }
    pub fn clear_raw_transaction_inputs(&mut self) {
        self.raw_transaction_inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_transaction_inputs(
        &mut self,
        v: ::protobuf::RepeatedField<RawTransactionInput>,
    ) {
        self.raw_transaction_inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_raw_transaction_inputs(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<RawTransactionInput> {
        &mut self.raw_transaction_inputs
    }

    // Take field
    pub fn take_raw_transaction_inputs(
        &mut self,
    ) -> ::protobuf::RepeatedField<RawTransactionInput> {
        ::std::mem::replace(
            &mut self.raw_transaction_inputs,
            ::protobuf::RepeatedField::new(),
        )
    }

    // int64 change_output_value = 11;

    pub fn get_change_output_value(&self) -> i64 {
        self.change_output_value
    }
    pub fn clear_change_output_value(&mut self) {
        self.change_output_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_change_output_value(&mut self, v: i64) {
        self.change_output_value = v;
    }

    // string change_output_address = 12;

    pub fn get_change_output_address(&self) -> &str {
        &self.change_output_address
    }
    pub fn clear_change_output_address(&mut self) {
        self.change_output_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_change_output_address(&mut self, v: ::std::string::String) {
        self.change_output_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_output_address(&mut self) -> &mut ::std::string::String {
        &mut self.change_output_address
    }

    // Take field
    pub fn take_change_output_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.change_output_address,
            ::std::string::String::new(),
        )
    }

    // bool use_savings_wallet = 13;

    pub fn get_use_savings_wallet(&self) -> bool {
        self.use_savings_wallet
    }
    pub fn clear_use_savings_wallet(&mut self) {
        self.use_savings_wallet = false;
    }

    // Param is passed by value, moved
    pub fn set_use_savings_wallet(&mut self, v: bool) {
        self.use_savings_wallet = v;
    }

    // int64 funds_needed_for_trade_as_long = 14;

    pub fn get_funds_needed_for_trade_as_long(&self) -> i64 {
        self.funds_needed_for_trade_as_long
    }
    pub fn clear_funds_needed_for_trade_as_long(&mut self) {
        self.funds_needed_for_trade_as_long = 0;
    }

    // Param is passed by value, moved
    pub fn set_funds_needed_for_trade_as_long(&mut self, v: i64) {
        self.funds_needed_for_trade_as_long = v;
    }

    // bytes my_multi_sig_pub_key = 15;

    pub fn get_my_multi_sig_pub_key(&self) -> &[u8] {
        &self.my_multi_sig_pub_key
    }
    pub fn clear_my_multi_sig_pub_key(&mut self) {
        self.my_multi_sig_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_my_multi_sig_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.my_multi_sig_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_my_multi_sig_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.my_multi_sig_pub_key
    }

    // Take field
    pub fn take_my_multi_sig_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.my_multi_sig_pub_key, ::std::vec::Vec::new())
    }

    // .io.bisq.protobuffer.NodeAddress temp_trading_peer_node_address = 16;

    pub fn get_temp_trading_peer_node_address(&self) -> &NodeAddress {
        self.temp_trading_peer_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_temp_trading_peer_node_address(&mut self) {
        self.temp_trading_peer_node_address.clear();
    }

    pub fn has_temp_trading_peer_node_address(&self) -> bool {
        self.temp_trading_peer_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temp_trading_peer_node_address(&mut self, v: NodeAddress) {
        self.temp_trading_peer_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_temp_trading_peer_node_address(&mut self) -> &mut NodeAddress {
        if self.temp_trading_peer_node_address.is_none() {
            self.temp_trading_peer_node_address.set_default();
        }
        self.temp_trading_peer_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_temp_trading_peer_node_address(&mut self) -> NodeAddress {
        self.temp_trading_peer_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // string payment_started_message_state = 17;

    pub fn get_payment_started_message_state(&self) -> &str {
        &self.payment_started_message_state
    }
    pub fn clear_payment_started_message_state(&mut self) {
        self.payment_started_message_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_started_message_state(&mut self, v: ::std::string::String) {
        self.payment_started_message_state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_started_message_state(&mut self) -> &mut ::std::string::String {
        &mut self.payment_started_message_state
    }

    // Take field
    pub fn take_payment_started_message_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.payment_started_message_state,
            ::std::string::String::new(),
        )
    }

    // bytes mediated_payout_tx_signature = 18;

    pub fn get_mediated_payout_tx_signature(&self) -> &[u8] {
        &self.mediated_payout_tx_signature
    }
    pub fn clear_mediated_payout_tx_signature(&mut self) {
        self.mediated_payout_tx_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_mediated_payout_tx_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediated_payout_tx_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediated_payout_tx_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.mediated_payout_tx_signature
    }

    // Take field
    pub fn take_mediated_payout_tx_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(
            &mut self.mediated_payout_tx_signature,
            ::std::vec::Vec::new(),
        )
    }

    // int64 buyer_payout_amount_from_mediation = 19;

    pub fn get_buyer_payout_amount_from_mediation(&self) -> i64 {
        self.buyer_payout_amount_from_mediation
    }
    pub fn clear_buyer_payout_amount_from_mediation(&mut self) {
        self.buyer_payout_amount_from_mediation = 0;
    }

    // Param is passed by value, moved
    pub fn set_buyer_payout_amount_from_mediation(&mut self, v: i64) {
        self.buyer_payout_amount_from_mediation = v;
    }

    // int64 seller_payout_amount_from_mediation = 20;

    pub fn get_seller_payout_amount_from_mediation(&self) -> i64 {
        self.seller_payout_amount_from_mediation
    }
    pub fn clear_seller_payout_amount_from_mediation(&mut self) {
        self.seller_payout_amount_from_mediation = 0;
    }

    // Param is passed by value, moved
    pub fn set_seller_payout_amount_from_mediation(&mut self, v: i64) {
        self.seller_payout_amount_from_mediation = v;
    }
}

impl ::protobuf::Message for ProcessModel {
    fn is_initialized(&self) -> bool {
        for v in &self.trading_peer {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.raw_transaction_inputs {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.temp_trading_peer_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.trading_peer,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.offer_id,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_id,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.pub_key_ring,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.take_offer_fee_tx_id,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.payout_tx_signature,
                    )?;
                }
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.prepared_deposit_tx,
                    )?;
                }
                10 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.raw_transaction_inputs,
                    )?;
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.change_output_value = tmp;
                }
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.change_output_address,
                    )?;
                }
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.use_savings_wallet = tmp;
                }
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.funds_needed_for_trade_as_long = tmp;
                }
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.my_multi_sig_pub_key,
                    )?;
                }
                16 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.temp_trading_peer_node_address,
                    )?;
                }
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.payment_started_message_state,
                    )?;
                }
                18 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.mediated_payout_tx_signature,
                    )?;
                }
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.buyer_payout_amount_from_mediation = tmp;
                }
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.seller_payout_amount_from_mediation = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trading_peer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.offer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.offer_id);
        }
        if !self.account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.account_id);
        }
        if let Some(ref v) = self.pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.take_offer_fee_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.take_offer_fee_tx_id);
        }
        if !self.payout_tx_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.payout_tx_signature);
        }
        if !self.prepared_deposit_tx.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.prepared_deposit_tx);
        }
        for value in &self.raw_transaction_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.change_output_value != 0 {
            my_size += ::protobuf::rt::value_size(
                11,
                self.change_output_value,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.change_output_address.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.change_output_address);
        }
        if self.use_savings_wallet != false {
            my_size += 2;
        }
        if self.funds_needed_for_trade_as_long != 0 {
            my_size += ::protobuf::rt::value_size(
                14,
                self.funds_needed_for_trade_as_long,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.my_multi_sig_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.my_multi_sig_pub_key);
        }
        if let Some(ref v) = self.temp_trading_peer_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.payment_started_message_state.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.payment_started_message_state);
        }
        if !self.mediated_payout_tx_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(18, &self.mediated_payout_tx_signature);
        }
        if self.buyer_payout_amount_from_mediation != 0 {
            my_size += ::protobuf::rt::value_size(
                19,
                self.buyer_payout_amount_from_mediation,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.seller_payout_amount_from_mediation != 0 {
            my_size += ::protobuf::rt::value_size(
                20,
                self.seller_payout_amount_from_mediation,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trading_peer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.offer_id.is_empty() {
            os.write_string(2, &self.offer_id)?;
        }
        if !self.account_id.is_empty() {
            os.write_string(3, &self.account_id)?;
        }
        if let Some(ref v) = self.pub_key_ring.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.take_offer_fee_tx_id.is_empty() {
            os.write_string(5, &self.take_offer_fee_tx_id)?;
        }
        if !self.payout_tx_signature.is_empty() {
            os.write_bytes(6, &self.payout_tx_signature)?;
        }
        if !self.prepared_deposit_tx.is_empty() {
            os.write_bytes(9, &self.prepared_deposit_tx)?;
        }
        for v in &self.raw_transaction_inputs {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.change_output_value != 0 {
            os.write_int64(11, self.change_output_value)?;
        }
        if !self.change_output_address.is_empty() {
            os.write_string(12, &self.change_output_address)?;
        }
        if self.use_savings_wallet != false {
            os.write_bool(13, self.use_savings_wallet)?;
        }
        if self.funds_needed_for_trade_as_long != 0 {
            os.write_int64(14, self.funds_needed_for_trade_as_long)?;
        }
        if !self.my_multi_sig_pub_key.is_empty() {
            os.write_bytes(15, &self.my_multi_sig_pub_key)?;
        }
        if let Some(ref v) = self.temp_trading_peer_node_address.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.payment_started_message_state.is_empty() {
            os.write_string(17, &self.payment_started_message_state)?;
        }
        if !self.mediated_payout_tx_signature.is_empty() {
            os.write_bytes(18, &self.mediated_payout_tx_signature)?;
        }
        if self.buyer_payout_amount_from_mediation != 0 {
            os.write_int64(19, self.buyer_payout_amount_from_mediation)?;
        }
        if self.seller_payout_amount_from_mediation != 0 {
            os.write_int64(20, self.seller_payout_amount_from_mediation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProcessModel {
        ProcessModel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<TradingPeer>,
                    >(
                        "trading_peer",
                        |m: &ProcessModel| &m.trading_peer,
                        |m: &mut ProcessModel| &mut m.trading_peer,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "offer_id",
                    |m: &ProcessModel| &m.offer_id,
                    |m: &mut ProcessModel| &mut m.offer_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_id",
                    |m: &ProcessModel| &m.account_id,
                    |m: &mut ProcessModel| &mut m.account_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "pub_key_ring",
                        |m: &ProcessModel| &m.pub_key_ring,
                        |m: &mut ProcessModel| &mut m.pub_key_ring,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "take_offer_fee_tx_id",
                    |m: &ProcessModel| &m.take_offer_fee_tx_id,
                    |m: &mut ProcessModel| &mut m.take_offer_fee_tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "payout_tx_signature",
                    |m: &ProcessModel| &m.payout_tx_signature,
                    |m: &mut ProcessModel| &mut m.payout_tx_signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "prepared_deposit_tx",
                    |m: &ProcessModel| &m.prepared_deposit_tx,
                    |m: &mut ProcessModel| &mut m.prepared_deposit_tx,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<RawTransactionInput>,
                    >(
                        "raw_transaction_inputs",
                        |m: &ProcessModel| &m.raw_transaction_inputs,
                        |m: &mut ProcessModel| &mut m.raw_transaction_inputs,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "change_output_value",
                    |m: &ProcessModel| &m.change_output_value,
                    |m: &mut ProcessModel| &mut m.change_output_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "change_output_address",
                    |m: &ProcessModel| &m.change_output_address,
                    |m: &mut ProcessModel| &mut m.change_output_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "use_savings_wallet",
                    |m: &ProcessModel| &m.use_savings_wallet,
                    |m: &mut ProcessModel| &mut m.use_savings_wallet,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "funds_needed_for_trade_as_long",
                    |m: &ProcessModel| &m.funds_needed_for_trade_as_long,
                    |m: &mut ProcessModel| &mut m.funds_needed_for_trade_as_long,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "my_multi_sig_pub_key",
                    |m: &ProcessModel| &m.my_multi_sig_pub_key,
                    |m: &mut ProcessModel| &mut m.my_multi_sig_pub_key,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "temp_trading_peer_node_address",
                        |m: &ProcessModel| &m.temp_trading_peer_node_address,
                        |m: &mut ProcessModel| &mut m.temp_trading_peer_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "payment_started_message_state",
                    |m: &ProcessModel| &m.payment_started_message_state,
                    |m: &mut ProcessModel| &mut m.payment_started_message_state,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "mediated_payout_tx_signature",
                    |m: &ProcessModel| &m.mediated_payout_tx_signature,
                    |m: &mut ProcessModel| &mut m.mediated_payout_tx_signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "buyer_payout_amount_from_mediation",
                    |m: &ProcessModel| &m.buyer_payout_amount_from_mediation,
                    |m: &mut ProcessModel| &mut m.buyer_payout_amount_from_mediation,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "seller_payout_amount_from_mediation",
                    |m: &ProcessModel| &m.seller_payout_amount_from_mediation,
                    |m: &mut ProcessModel| &mut m.seller_payout_amount_from_mediation,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProcessModel>(
                    "ProcessModel",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ProcessModel {
        static mut instance: ::protobuf::lazy::Lazy<ProcessModel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProcessModel,
        };
        unsafe { instance.get(ProcessModel::new) }
    }
}

impl ::protobuf::Clear for ProcessModel {
    fn clear(&mut self) {
        self.trading_peer.clear();
        self.offer_id.clear();
        self.account_id.clear();
        self.pub_key_ring.clear();
        self.take_offer_fee_tx_id.clear();
        self.payout_tx_signature.clear();
        self.prepared_deposit_tx.clear();
        self.raw_transaction_inputs.clear();
        self.change_output_value = 0;
        self.change_output_address.clear();
        self.use_savings_wallet = false;
        self.funds_needed_for_trade_as_long = 0;
        self.my_multi_sig_pub_key.clear();
        self.temp_trading_peer_node_address.clear();
        self.payment_started_message_state.clear();
        self.mediated_payout_tx_signature.clear();
        self.buyer_payout_amount_from_mediation = 0;
        self.seller_payout_amount_from_mediation = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProcessModel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessModel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct TradingPeer {
    // message fields
    pub account_id: ::std::string::String,
    pub payment_account_payload: ::protobuf::SingularPtrField<PaymentAccountPayload>,
    pub payout_address_string: ::std::string::String,
    pub contract_as_json: ::std::string::String,
    pub contract_signature: ::std::string::String,
    pub signature: ::std::vec::Vec<u8>,
    pub pub_key_ring: ::protobuf::SingularPtrField<PubKeyRing>,
    pub multi_sig_pub_key: ::std::vec::Vec<u8>,
    pub raw_transaction_inputs: ::protobuf::RepeatedField<RawTransactionInput>,
    pub change_output_value: i64,
    pub change_output_address: ::std::string::String,
    pub account_age_witness_nonce: ::std::vec::Vec<u8>,
    pub account_age_witness_signature: ::std::vec::Vec<u8>,
    pub current_date: i64,
    pub mediated_payout_tx_signature: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradingPeer {
    fn default() -> &'a TradingPeer {
        <TradingPeer as ::protobuf::Message>::default_instance()
    }
}

impl TradingPeer {
    pub fn new() -> TradingPeer {
        ::std::default::Default::default()
    }

    // string account_id = 1;

    pub fn get_account_id(&self) -> &str {
        &self.account_id
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: ::std::string::String) {
        self.account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.account_id
    }

    // Take field
    pub fn take_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.PaymentAccountPayload payment_account_payload = 2;

    pub fn get_payment_account_payload(&self) -> &PaymentAccountPayload {
        self.payment_account_payload
            .as_ref()
            .unwrap_or_else(|| PaymentAccountPayload::default_instance())
    }
    pub fn clear_payment_account_payload(&mut self) {
        self.payment_account_payload.clear();
    }

    pub fn has_payment_account_payload(&self) -> bool {
        self.payment_account_payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_account_payload(&mut self, v: PaymentAccountPayload) {
        self.payment_account_payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_account_payload(&mut self) -> &mut PaymentAccountPayload {
        if self.payment_account_payload.is_none() {
            self.payment_account_payload.set_default();
        }
        self.payment_account_payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment_account_payload(&mut self) -> PaymentAccountPayload {
        self.payment_account_payload
            .take()
            .unwrap_or_else(|| PaymentAccountPayload::new())
    }

    // string payout_address_string = 3;

    pub fn get_payout_address_string(&self) -> &str {
        &self.payout_address_string
    }
    pub fn clear_payout_address_string(&mut self) {
        self.payout_address_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_payout_address_string(&mut self, v: ::std::string::String) {
        self.payout_address_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payout_address_string(&mut self) -> &mut ::std::string::String {
        &mut self.payout_address_string
    }

    // Take field
    pub fn take_payout_address_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.payout_address_string,
            ::std::string::String::new(),
        )
    }

    // string contract_as_json = 4;

    pub fn get_contract_as_json(&self) -> &str {
        &self.contract_as_json
    }
    pub fn clear_contract_as_json(&mut self) {
        self.contract_as_json.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_as_json(&mut self, v: ::std::string::String) {
        self.contract_as_json = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_as_json(&mut self) -> &mut ::std::string::String {
        &mut self.contract_as_json
    }

    // Take field
    pub fn take_contract_as_json(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contract_as_json, ::std::string::String::new())
    }

    // string contract_signature = 5;

    pub fn get_contract_signature(&self) -> &str {
        &self.contract_signature
    }
    pub fn clear_contract_signature(&mut self) {
        self.contract_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_signature(&mut self, v: ::std::string::String) {
        self.contract_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_signature(&mut self) -> &mut ::std::string::String {
        &mut self.contract_signature
    }

    // Take field
    pub fn take_contract_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contract_signature, ::std::string::String::new())
    }

    // bytes signature = 6;

    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // .io.bisq.protobuffer.PubKeyRing pub_key_ring = 7;

    pub fn get_pub_key_ring(&self) -> &PubKeyRing {
        self.pub_key_ring
            .as_ref()
            .unwrap_or_else(|| PubKeyRing::default_instance())
    }
    pub fn clear_pub_key_ring(&mut self) {
        self.pub_key_ring.clear();
    }

    pub fn has_pub_key_ring(&self) -> bool {
        self.pub_key_ring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pub_key_ring(&mut self, v: PubKeyRing) {
        self.pub_key_ring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key_ring(&mut self) -> &mut PubKeyRing {
        if self.pub_key_ring.is_none() {
            self.pub_key_ring.set_default();
        }
        self.pub_key_ring.as_mut().unwrap()
    }

    // Take field
    pub fn take_pub_key_ring(&mut self) -> PubKeyRing {
        self.pub_key_ring
            .take()
            .unwrap_or_else(|| PubKeyRing::new())
    }

    // bytes multi_sig_pub_key = 8;

    pub fn get_multi_sig_pub_key(&self) -> &[u8] {
        &self.multi_sig_pub_key
    }
    pub fn clear_multi_sig_pub_key(&mut self) {
        self.multi_sig_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_multi_sig_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.multi_sig_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multi_sig_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.multi_sig_pub_key
    }

    // Take field
    pub fn take_multi_sig_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.multi_sig_pub_key, ::std::vec::Vec::new())
    }

    // repeated .io.bisq.protobuffer.RawTransactionInput raw_transaction_inputs = 9;

    pub fn get_raw_transaction_inputs(&self) -> &[RawTransactionInput] {
        &self.raw_transaction_inputs
    }
    pub fn clear_raw_transaction_inputs(&mut self) {
        self.raw_transaction_inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_transaction_inputs(
        &mut self,
        v: ::protobuf::RepeatedField<RawTransactionInput>,
    ) {
        self.raw_transaction_inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_raw_transaction_inputs(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<RawTransactionInput> {
        &mut self.raw_transaction_inputs
    }

    // Take field
    pub fn take_raw_transaction_inputs(
        &mut self,
    ) -> ::protobuf::RepeatedField<RawTransactionInput> {
        ::std::mem::replace(
            &mut self.raw_transaction_inputs,
            ::protobuf::RepeatedField::new(),
        )
    }

    // int64 change_output_value = 10;

    pub fn get_change_output_value(&self) -> i64 {
        self.change_output_value
    }
    pub fn clear_change_output_value(&mut self) {
        self.change_output_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_change_output_value(&mut self, v: i64) {
        self.change_output_value = v;
    }

    // string change_output_address = 11;

    pub fn get_change_output_address(&self) -> &str {
        &self.change_output_address
    }
    pub fn clear_change_output_address(&mut self) {
        self.change_output_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_change_output_address(&mut self, v: ::std::string::String) {
        self.change_output_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_output_address(&mut self) -> &mut ::std::string::String {
        &mut self.change_output_address
    }

    // Take field
    pub fn take_change_output_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.change_output_address,
            ::std::string::String::new(),
        )
    }

    // bytes account_age_witness_nonce = 12;

    pub fn get_account_age_witness_nonce(&self) -> &[u8] {
        &self.account_age_witness_nonce
    }
    pub fn clear_account_age_witness_nonce(&mut self) {
        self.account_age_witness_nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_age_witness_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_age_witness_nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_age_witness_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_age_witness_nonce
    }

    // Take field
    pub fn take_account_age_witness_nonce(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account_age_witness_nonce, ::std::vec::Vec::new())
    }

    // bytes account_age_witness_signature = 13;

    pub fn get_account_age_witness_signature(&self) -> &[u8] {
        &self.account_age_witness_signature
    }
    pub fn clear_account_age_witness_signature(&mut self) {
        self.account_age_witness_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_age_witness_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_age_witness_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_age_witness_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_age_witness_signature
    }

    // Take field
    pub fn take_account_age_witness_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(
            &mut self.account_age_witness_signature,
            ::std::vec::Vec::new(),
        )
    }

    // int64 current_date = 14;

    pub fn get_current_date(&self) -> i64 {
        self.current_date
    }
    pub fn clear_current_date(&mut self) {
        self.current_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_date(&mut self, v: i64) {
        self.current_date = v;
    }

    // bytes mediated_payout_tx_signature = 15;

    pub fn get_mediated_payout_tx_signature(&self) -> &[u8] {
        &self.mediated_payout_tx_signature
    }
    pub fn clear_mediated_payout_tx_signature(&mut self) {
        self.mediated_payout_tx_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_mediated_payout_tx_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediated_payout_tx_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediated_payout_tx_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.mediated_payout_tx_signature
    }

    // Take field
    pub fn take_mediated_payout_tx_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(
            &mut self.mediated_payout_tx_signature,
            ::std::vec::Vec::new(),
        )
    }
}

impl ::protobuf::Message for TradingPeer {
    fn is_initialized(&self) -> bool {
        for v in &self.payment_account_payload {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.pub_key_ring {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.raw_transaction_inputs {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.payment_account_payload,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.payout_address_string,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.contract_as_json,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.contract_signature,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.signature,
                    )?;
                }
                7 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.pub_key_ring,
                    )?;
                }
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.multi_sig_pub_key,
                    )?;
                }
                9 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.raw_transaction_inputs,
                    )?;
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.change_output_value = tmp;
                }
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.change_output_address,
                    )?;
                }
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.account_age_witness_nonce,
                    )?;
                }
                13 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.account_age_witness_signature,
                    )?;
                }
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.current_date = tmp;
                }
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.mediated_payout_tx_signature,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_id);
        }
        if let Some(ref v) = self.payment_account_payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.payout_address_string.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.payout_address_string);
        }
        if !self.contract_as_json.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.contract_as_json);
        }
        if !self.contract_signature.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.contract_signature);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.signature);
        }
        if let Some(ref v) = self.pub_key_ring.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.multi_sig_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.multi_sig_pub_key);
        }
        for value in &self.raw_transaction_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.change_output_value != 0 {
            my_size += ::protobuf::rt::value_size(
                10,
                self.change_output_value,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.change_output_address.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.change_output_address);
        }
        if !self.account_age_witness_nonce.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.account_age_witness_nonce);
        }
        if !self.account_age_witness_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.account_age_witness_signature);
        }
        if self.current_date != 0 {
            my_size += ::protobuf::rt::value_size(
                14,
                self.current_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.mediated_payout_tx_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.mediated_payout_tx_signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.account_id.is_empty() {
            os.write_string(1, &self.account_id)?;
        }
        if let Some(ref v) = self.payment_account_payload.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.payout_address_string.is_empty() {
            os.write_string(3, &self.payout_address_string)?;
        }
        if !self.contract_as_json.is_empty() {
            os.write_string(4, &self.contract_as_json)?;
        }
        if !self.contract_signature.is_empty() {
            os.write_string(5, &self.contract_signature)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(6, &self.signature)?;
        }
        if let Some(ref v) = self.pub_key_ring.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.multi_sig_pub_key.is_empty() {
            os.write_bytes(8, &self.multi_sig_pub_key)?;
        }
        for v in &self.raw_transaction_inputs {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.change_output_value != 0 {
            os.write_int64(10, self.change_output_value)?;
        }
        if !self.change_output_address.is_empty() {
            os.write_string(11, &self.change_output_address)?;
        }
        if !self.account_age_witness_nonce.is_empty() {
            os.write_bytes(12, &self.account_age_witness_nonce)?;
        }
        if !self.account_age_witness_signature.is_empty() {
            os.write_bytes(13, &self.account_age_witness_signature)?;
        }
        if self.current_date != 0 {
            os.write_int64(14, self.current_date)?;
        }
        if !self.mediated_payout_tx_signature.is_empty() {
            os.write_bytes(15, &self.mediated_payout_tx_signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradingPeer {
        TradingPeer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_id",
                    |m: &TradingPeer| &m.account_id,
                    |m: &mut TradingPeer| &mut m.account_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PaymentAccountPayload>,
                    >(
                        "payment_account_payload",
                        |m: &TradingPeer| &m.payment_account_payload,
                        |m: &mut TradingPeer| &mut m.payment_account_payload,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "payout_address_string",
                    |m: &TradingPeer| &m.payout_address_string,
                    |m: &mut TradingPeer| &mut m.payout_address_string,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "contract_as_json",
                    |m: &TradingPeer| &m.contract_as_json,
                    |m: &mut TradingPeer| &mut m.contract_as_json,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "contract_signature",
                    |m: &TradingPeer| &m.contract_signature,
                    |m: &mut TradingPeer| &mut m.contract_signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "signature",
                    |m: &TradingPeer| &m.signature,
                    |m: &mut TradingPeer| &mut m.signature,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyRing>,
                    >(
                        "pub_key_ring",
                        |m: &TradingPeer| &m.pub_key_ring,
                        |m: &mut TradingPeer| &mut m.pub_key_ring,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "multi_sig_pub_key",
                    |m: &TradingPeer| &m.multi_sig_pub_key,
                    |m: &mut TradingPeer| &mut m.multi_sig_pub_key,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<RawTransactionInput>,
                    >(
                        "raw_transaction_inputs",
                        |m: &TradingPeer| &m.raw_transaction_inputs,
                        |m: &mut TradingPeer| &mut m.raw_transaction_inputs,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "change_output_value",
                    |m: &TradingPeer| &m.change_output_value,
                    |m: &mut TradingPeer| &mut m.change_output_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "change_output_address",
                    |m: &TradingPeer| &m.change_output_address,
                    |m: &mut TradingPeer| &mut m.change_output_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "account_age_witness_nonce",
                    |m: &TradingPeer| &m.account_age_witness_nonce,
                    |m: &mut TradingPeer| &mut m.account_age_witness_nonce,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "account_age_witness_signature",
                    |m: &TradingPeer| &m.account_age_witness_signature,
                    |m: &mut TradingPeer| &mut m.account_age_witness_signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "current_date",
                    |m: &TradingPeer| &m.current_date,
                    |m: &mut TradingPeer| &mut m.current_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "mediated_payout_tx_signature",
                    |m: &TradingPeer| &m.mediated_payout_tx_signature,
                    |m: &mut TradingPeer| &mut m.mediated_payout_tx_signature,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TradingPeer>(
                    "TradingPeer",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static TradingPeer {
        static mut instance: ::protobuf::lazy::Lazy<TradingPeer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TradingPeer,
        };
        unsafe { instance.get(TradingPeer::new) }
    }
}

impl ::protobuf::Clear for TradingPeer {
    fn clear(&mut self) {
        self.account_id.clear();
        self.payment_account_payload.clear();
        self.payout_address_string.clear();
        self.contract_as_json.clear();
        self.contract_signature.clear();
        self.signature.clear();
        self.pub_key_ring.clear();
        self.multi_sig_pub_key.clear();
        self.raw_transaction_inputs.clear();
        self.change_output_value = 0;
        self.change_output_address.clear();
        self.account_age_witness_nonce.clear();
        self.account_age_witness_signature.clear();
        self.current_date = 0;
        self.mediated_payout_tx_signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TradingPeer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TradingPeer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ArbitrationDisputeList {
    // message fields
    pub dispute: ::protobuf::RepeatedField<Dispute>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArbitrationDisputeList {
    fn default() -> &'a ArbitrationDisputeList {
        <ArbitrationDisputeList as ::protobuf::Message>::default_instance()
    }
}

impl ArbitrationDisputeList {
    pub fn new() -> ArbitrationDisputeList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.Dispute dispute = 1;

    pub fn get_dispute(&self) -> &[Dispute] {
        &self.dispute
    }
    pub fn clear_dispute(&mut self) {
        self.dispute.clear();
    }

    // Param is passed by value, moved
    pub fn set_dispute(&mut self, v: ::protobuf::RepeatedField<Dispute>) {
        self.dispute = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dispute(&mut self) -> &mut ::protobuf::RepeatedField<Dispute> {
        &mut self.dispute
    }

    // Take field
    pub fn take_dispute(&mut self) -> ::protobuf::RepeatedField<Dispute> {
        ::std::mem::replace(&mut self.dispute, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ArbitrationDisputeList {
    fn is_initialized(&self) -> bool {
        for v in &self.dispute {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dispute)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dispute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dispute {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArbitrationDisputeList {
        ArbitrationDisputeList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Dispute>,
                    >(
                        "dispute",
                        |m: &ArbitrationDisputeList| &m.dispute,
                        |m: &mut ArbitrationDisputeList| &mut m.dispute,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<ArbitrationDisputeList>(
                    "ArbitrationDisputeList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ArbitrationDisputeList {
        static mut instance: ::protobuf::lazy::Lazy<ArbitrationDisputeList> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ArbitrationDisputeList,
            };
        unsafe { instance.get(ArbitrationDisputeList::new) }
    }
}

impl ::protobuf::Clear for ArbitrationDisputeList {
    fn clear(&mut self) {
        self.dispute.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArbitrationDisputeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArbitrationDisputeList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MediationDisputeList {
    // message fields
    pub dispute: ::protobuf::RepeatedField<Dispute>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MediationDisputeList {
    fn default() -> &'a MediationDisputeList {
        <MediationDisputeList as ::protobuf::Message>::default_instance()
    }
}

impl MediationDisputeList {
    pub fn new() -> MediationDisputeList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.Dispute dispute = 1;

    pub fn get_dispute(&self) -> &[Dispute] {
        &self.dispute
    }
    pub fn clear_dispute(&mut self) {
        self.dispute.clear();
    }

    // Param is passed by value, moved
    pub fn set_dispute(&mut self, v: ::protobuf::RepeatedField<Dispute>) {
        self.dispute = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dispute(&mut self) -> &mut ::protobuf::RepeatedField<Dispute> {
        &mut self.dispute
    }

    // Take field
    pub fn take_dispute(&mut self) -> ::protobuf::RepeatedField<Dispute> {
        ::std::mem::replace(&mut self.dispute, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MediationDisputeList {
    fn is_initialized(&self) -> bool {
        for v in &self.dispute {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dispute)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dispute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dispute {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MediationDisputeList {
        MediationDisputeList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Dispute>,
                    >(
                        "dispute",
                        |m: &MediationDisputeList| &m.dispute,
                        |m: &mut MediationDisputeList| &mut m.dispute,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<MediationDisputeList>(
                    "MediationDisputeList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MediationDisputeList {
        static mut instance: ::protobuf::lazy::Lazy<MediationDisputeList> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const MediationDisputeList,
            };
        unsafe { instance.get(MediationDisputeList::new) }
    }
}

impl ::protobuf::Clear for MediationDisputeList {
    fn clear(&mut self) {
        self.dispute.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MediationDisputeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediationDisputeList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RefundDisputeList {
    // message fields
    pub dispute: ::protobuf::RepeatedField<Dispute>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RefundDisputeList {
    fn default() -> &'a RefundDisputeList {
        <RefundDisputeList as ::protobuf::Message>::default_instance()
    }
}

impl RefundDisputeList {
    pub fn new() -> RefundDisputeList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.Dispute dispute = 1;

    pub fn get_dispute(&self) -> &[Dispute] {
        &self.dispute
    }
    pub fn clear_dispute(&mut self) {
        self.dispute.clear();
    }

    // Param is passed by value, moved
    pub fn set_dispute(&mut self, v: ::protobuf::RepeatedField<Dispute>) {
        self.dispute = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dispute(&mut self) -> &mut ::protobuf::RepeatedField<Dispute> {
        &mut self.dispute
    }

    // Take field
    pub fn take_dispute(&mut self) -> ::protobuf::RepeatedField<Dispute> {
        ::std::mem::replace(&mut self.dispute, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RefundDisputeList {
    fn is_initialized(&self) -> bool {
        for v in &self.dispute {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dispute)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dispute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dispute {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RefundDisputeList {
        RefundDisputeList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Dispute>,
                    >(
                        "dispute",
                        |m: &RefundDisputeList| &m.dispute,
                        |m: &mut RefundDisputeList| &mut m.dispute,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<RefundDisputeList>(
                    "RefundDisputeList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static RefundDisputeList {
        static mut instance: ::protobuf::lazy::Lazy<RefundDisputeList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RefundDisputeList,
        };
        unsafe { instance.get(RefundDisputeList::new) }
    }
}

impl ::protobuf::Clear for RefundDisputeList {
    fn clear(&mut self) {
        self.dispute.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefundDisputeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefundDisputeList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PreferencesPayload {
    // message fields
    pub user_language: ::std::string::String,
    pub user_country: ::protobuf::SingularPtrField<Country>,
    pub fiat_currencies: ::protobuf::RepeatedField<TradeCurrency>,
    pub crypto_currencies: ::protobuf::RepeatedField<TradeCurrency>,
    pub block_chain_explorer_main_net: ::protobuf::SingularPtrField<BlockChainExplorer>,
    pub block_chain_explorer_test_net: ::protobuf::SingularPtrField<BlockChainExplorer>,
    pub bsq_block_chain_explorer: ::protobuf::SingularPtrField<BlockChainExplorer>,
    pub backup_directory: ::std::string::String,
    pub auto_select_arbitrators: bool,
    pub dont_show_again_map: ::std::collections::HashMap<::std::string::String, bool>,
    pub tac_accepted: bool,
    pub use_tor_for_bitcoin_j: bool,
    pub show_own_offers_in_offer_book: bool,
    pub preferred_trade_currency: ::protobuf::SingularPtrField<TradeCurrency>,
    pub withdrawal_tx_fee_in_bytes: i64,
    pub use_custom_withdrawal_tx_fee: bool,
    pub max_price_distance_in_percent: f64,
    pub offer_book_chart_screen_currency_code: ::std::string::String,
    pub trade_charts_screen_currency_code: ::std::string::String,
    pub buy_screen_currency_code: ::std::string::String,
    pub sell_screen_currency_code: ::std::string::String,
    pub trade_statistics_tick_unit_index: i32,
    pub resync_Spv_requested: bool,
    pub sort_market_currencies_numerically: bool,
    pub use_percentage_based_price: bool,
    pub peer_tag_map: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub bitcoin_nodes: ::std::string::String,
    pub ignore_traders_list: ::protobuf::RepeatedField<::std::string::String>,
    pub directory_chooser_path: ::std::string::String,
    pub buyer_security_deposit_as_long: i64,
    pub use_animations: bool,
    pub selectedPayment_account_for_createOffer: ::protobuf::SingularPtrField<PaymentAccount>,
    pub pay_fee_in_Btc: bool,
    pub bridge_addresses: ::protobuf::RepeatedField<::std::string::String>,
    pub bridge_option_ordinal: i32,
    pub tor_transport_ordinal: i32,
    pub custom_bridges: ::std::string::String,
    pub bitcoin_nodes_option_ordinal: i32,
    pub referral_id: ::std::string::String,
    pub phone_key_and_token: ::std::string::String,
    pub use_sound_for_mobile_notifications: bool,
    pub use_trade_notifications: bool,
    pub use_market_notifications: bool,
    pub use_price_notifications: bool,
    pub use_standby_mode: bool,
    pub is_dao_full_node: bool,
    pub rpc_user: ::std::string::String,
    pub rpc_pw: ::std::string::String,
    pub take_offer_selected_payment_account_id: ::std::string::String,
    pub buyer_security_deposit_as_percent: f64,
    pub ignore_dust_threshold: i32,
    pub buyer_security_deposit_as_percent_for_crypto: f64,
    pub block_notify_port: i32,
    pub css_theme: i32,
    pub tac_accepted_v120: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreferencesPayload {
    fn default() -> &'a PreferencesPayload {
        <PreferencesPayload as ::protobuf::Message>::default_instance()
    }
}

impl PreferencesPayload {
    pub fn new() -> PreferencesPayload {
        ::std::default::Default::default()
    }

    // string user_language = 1;

    pub fn get_user_language(&self) -> &str {
        &self.user_language
    }
    pub fn clear_user_language(&mut self) {
        self.user_language.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_language(&mut self, v: ::std::string::String) {
        self.user_language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_language(&mut self) -> &mut ::std::string::String {
        &mut self.user_language
    }

    // Take field
    pub fn take_user_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_language, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.Country user_country = 2;

    pub fn get_user_country(&self) -> &Country {
        self.user_country
            .as_ref()
            .unwrap_or_else(|| Country::default_instance())
    }
    pub fn clear_user_country(&mut self) {
        self.user_country.clear();
    }

    pub fn has_user_country(&self) -> bool {
        self.user_country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_country(&mut self, v: Country) {
        self.user_country = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_country(&mut self) -> &mut Country {
        if self.user_country.is_none() {
            self.user_country.set_default();
        }
        self.user_country.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_country(&mut self) -> Country {
        self.user_country.take().unwrap_or_else(|| Country::new())
    }

    // repeated .io.bisq.protobuffer.TradeCurrency fiat_currencies = 3;

    pub fn get_fiat_currencies(&self) -> &[TradeCurrency] {
        &self.fiat_currencies
    }
    pub fn clear_fiat_currencies(&mut self) {
        self.fiat_currencies.clear();
    }

    // Param is passed by value, moved
    pub fn set_fiat_currencies(&mut self, v: ::protobuf::RepeatedField<TradeCurrency>) {
        self.fiat_currencies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fiat_currencies(&mut self) -> &mut ::protobuf::RepeatedField<TradeCurrency> {
        &mut self.fiat_currencies
    }

    // Take field
    pub fn take_fiat_currencies(&mut self) -> ::protobuf::RepeatedField<TradeCurrency> {
        ::std::mem::replace(&mut self.fiat_currencies, ::protobuf::RepeatedField::new())
    }

    // repeated .io.bisq.protobuffer.TradeCurrency crypto_currencies = 4;

    pub fn get_crypto_currencies(&self) -> &[TradeCurrency] {
        &self.crypto_currencies
    }
    pub fn clear_crypto_currencies(&mut self) {
        self.crypto_currencies.clear();
    }

    // Param is passed by value, moved
    pub fn set_crypto_currencies(&mut self, v: ::protobuf::RepeatedField<TradeCurrency>) {
        self.crypto_currencies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_crypto_currencies(&mut self) -> &mut ::protobuf::RepeatedField<TradeCurrency> {
        &mut self.crypto_currencies
    }

    // Take field
    pub fn take_crypto_currencies(&mut self) -> ::protobuf::RepeatedField<TradeCurrency> {
        ::std::mem::replace(
            &mut self.crypto_currencies,
            ::protobuf::RepeatedField::new(),
        )
    }

    // .io.bisq.protobuffer.BlockChainExplorer block_chain_explorer_main_net = 5;

    pub fn get_block_chain_explorer_main_net(&self) -> &BlockChainExplorer {
        self.block_chain_explorer_main_net
            .as_ref()
            .unwrap_or_else(|| BlockChainExplorer::default_instance())
    }
    pub fn clear_block_chain_explorer_main_net(&mut self) {
        self.block_chain_explorer_main_net.clear();
    }

    pub fn has_block_chain_explorer_main_net(&self) -> bool {
        self.block_chain_explorer_main_net.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_chain_explorer_main_net(&mut self, v: BlockChainExplorer) {
        self.block_chain_explorer_main_net = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_chain_explorer_main_net(&mut self) -> &mut BlockChainExplorer {
        if self.block_chain_explorer_main_net.is_none() {
            self.block_chain_explorer_main_net.set_default();
        }
        self.block_chain_explorer_main_net.as_mut().unwrap()
    }

    // Take field
    pub fn take_block_chain_explorer_main_net(&mut self) -> BlockChainExplorer {
        self.block_chain_explorer_main_net
            .take()
            .unwrap_or_else(|| BlockChainExplorer::new())
    }

    // .io.bisq.protobuffer.BlockChainExplorer block_chain_explorer_test_net = 6;

    pub fn get_block_chain_explorer_test_net(&self) -> &BlockChainExplorer {
        self.block_chain_explorer_test_net
            .as_ref()
            .unwrap_or_else(|| BlockChainExplorer::default_instance())
    }
    pub fn clear_block_chain_explorer_test_net(&mut self) {
        self.block_chain_explorer_test_net.clear();
    }

    pub fn has_block_chain_explorer_test_net(&self) -> bool {
        self.block_chain_explorer_test_net.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_chain_explorer_test_net(&mut self, v: BlockChainExplorer) {
        self.block_chain_explorer_test_net = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_chain_explorer_test_net(&mut self) -> &mut BlockChainExplorer {
        if self.block_chain_explorer_test_net.is_none() {
            self.block_chain_explorer_test_net.set_default();
        }
        self.block_chain_explorer_test_net.as_mut().unwrap()
    }

    // Take field
    pub fn take_block_chain_explorer_test_net(&mut self) -> BlockChainExplorer {
        self.block_chain_explorer_test_net
            .take()
            .unwrap_or_else(|| BlockChainExplorer::new())
    }

    // .io.bisq.protobuffer.BlockChainExplorer bsq_block_chain_explorer = 7;

    pub fn get_bsq_block_chain_explorer(&self) -> &BlockChainExplorer {
        self.bsq_block_chain_explorer
            .as_ref()
            .unwrap_or_else(|| BlockChainExplorer::default_instance())
    }
    pub fn clear_bsq_block_chain_explorer(&mut self) {
        self.bsq_block_chain_explorer.clear();
    }

    pub fn has_bsq_block_chain_explorer(&self) -> bool {
        self.bsq_block_chain_explorer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bsq_block_chain_explorer(&mut self, v: BlockChainExplorer) {
        self.bsq_block_chain_explorer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bsq_block_chain_explorer(&mut self) -> &mut BlockChainExplorer {
        if self.bsq_block_chain_explorer.is_none() {
            self.bsq_block_chain_explorer.set_default();
        }
        self.bsq_block_chain_explorer.as_mut().unwrap()
    }

    // Take field
    pub fn take_bsq_block_chain_explorer(&mut self) -> BlockChainExplorer {
        self.bsq_block_chain_explorer
            .take()
            .unwrap_or_else(|| BlockChainExplorer::new())
    }

    // string backup_directory = 8;

    pub fn get_backup_directory(&self) -> &str {
        &self.backup_directory
    }
    pub fn clear_backup_directory(&mut self) {
        self.backup_directory.clear();
    }

    // Param is passed by value, moved
    pub fn set_backup_directory(&mut self, v: ::std::string::String) {
        self.backup_directory = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backup_directory(&mut self) -> &mut ::std::string::String {
        &mut self.backup_directory
    }

    // Take field
    pub fn take_backup_directory(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backup_directory, ::std::string::String::new())
    }

    // bool auto_select_arbitrators = 9;

    pub fn get_auto_select_arbitrators(&self) -> bool {
        self.auto_select_arbitrators
    }
    pub fn clear_auto_select_arbitrators(&mut self) {
        self.auto_select_arbitrators = false;
    }

    // Param is passed by value, moved
    pub fn set_auto_select_arbitrators(&mut self, v: bool) {
        self.auto_select_arbitrators = v;
    }

    // repeated .io.bisq.protobuffer.PreferencesPayload.DontShowAgainMapEntry dont_show_again_map = 10;

    pub fn get_dont_show_again_map(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, bool> {
        &self.dont_show_again_map
    }
    pub fn clear_dont_show_again_map(&mut self) {
        self.dont_show_again_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_dont_show_again_map(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, bool>,
    ) {
        self.dont_show_again_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dont_show_again_map(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, bool> {
        &mut self.dont_show_again_map
    }

    // Take field
    pub fn take_dont_show_again_map(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, bool> {
        ::std::mem::replace(
            &mut self.dont_show_again_map,
            ::std::collections::HashMap::new(),
        )
    }

    // bool tac_accepted = 11;

    pub fn get_tac_accepted(&self) -> bool {
        self.tac_accepted
    }
    pub fn clear_tac_accepted(&mut self) {
        self.tac_accepted = false;
    }

    // Param is passed by value, moved
    pub fn set_tac_accepted(&mut self, v: bool) {
        self.tac_accepted = v;
    }

    // bool use_tor_for_bitcoin_j = 12;

    pub fn get_use_tor_for_bitcoin_j(&self) -> bool {
        self.use_tor_for_bitcoin_j
    }
    pub fn clear_use_tor_for_bitcoin_j(&mut self) {
        self.use_tor_for_bitcoin_j = false;
    }

    // Param is passed by value, moved
    pub fn set_use_tor_for_bitcoin_j(&mut self, v: bool) {
        self.use_tor_for_bitcoin_j = v;
    }

    // bool show_own_offers_in_offer_book = 13;

    pub fn get_show_own_offers_in_offer_book(&self) -> bool {
        self.show_own_offers_in_offer_book
    }
    pub fn clear_show_own_offers_in_offer_book(&mut self) {
        self.show_own_offers_in_offer_book = false;
    }

    // Param is passed by value, moved
    pub fn set_show_own_offers_in_offer_book(&mut self, v: bool) {
        self.show_own_offers_in_offer_book = v;
    }

    // .io.bisq.protobuffer.TradeCurrency preferred_trade_currency = 14;

    pub fn get_preferred_trade_currency(&self) -> &TradeCurrency {
        self.preferred_trade_currency
            .as_ref()
            .unwrap_or_else(|| TradeCurrency::default_instance())
    }
    pub fn clear_preferred_trade_currency(&mut self) {
        self.preferred_trade_currency.clear();
    }

    pub fn has_preferred_trade_currency(&self) -> bool {
        self.preferred_trade_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferred_trade_currency(&mut self, v: TradeCurrency) {
        self.preferred_trade_currency = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferred_trade_currency(&mut self) -> &mut TradeCurrency {
        if self.preferred_trade_currency.is_none() {
            self.preferred_trade_currency.set_default();
        }
        self.preferred_trade_currency.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferred_trade_currency(&mut self) -> TradeCurrency {
        self.preferred_trade_currency
            .take()
            .unwrap_or_else(|| TradeCurrency::new())
    }

    // int64 withdrawal_tx_fee_in_bytes = 15;

    pub fn get_withdrawal_tx_fee_in_bytes(&self) -> i64 {
        self.withdrawal_tx_fee_in_bytes
    }
    pub fn clear_withdrawal_tx_fee_in_bytes(&mut self) {
        self.withdrawal_tx_fee_in_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_withdrawal_tx_fee_in_bytes(&mut self, v: i64) {
        self.withdrawal_tx_fee_in_bytes = v;
    }

    // bool use_custom_withdrawal_tx_fee = 16;

    pub fn get_use_custom_withdrawal_tx_fee(&self) -> bool {
        self.use_custom_withdrawal_tx_fee
    }
    pub fn clear_use_custom_withdrawal_tx_fee(&mut self) {
        self.use_custom_withdrawal_tx_fee = false;
    }

    // Param is passed by value, moved
    pub fn set_use_custom_withdrawal_tx_fee(&mut self, v: bool) {
        self.use_custom_withdrawal_tx_fee = v;
    }

    // double max_price_distance_in_percent = 17;

    pub fn get_max_price_distance_in_percent(&self) -> f64 {
        self.max_price_distance_in_percent
    }
    pub fn clear_max_price_distance_in_percent(&mut self) {
        self.max_price_distance_in_percent = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_price_distance_in_percent(&mut self, v: f64) {
        self.max_price_distance_in_percent = v;
    }

    // string offer_book_chart_screen_currency_code = 18;

    pub fn get_offer_book_chart_screen_currency_code(&self) -> &str {
        &self.offer_book_chart_screen_currency_code
    }
    pub fn clear_offer_book_chart_screen_currency_code(&mut self) {
        self.offer_book_chart_screen_currency_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_offer_book_chart_screen_currency_code(&mut self, v: ::std::string::String) {
        self.offer_book_chart_screen_currency_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer_book_chart_screen_currency_code(&mut self) -> &mut ::std::string::String {
        &mut self.offer_book_chart_screen_currency_code
    }

    // Take field
    pub fn take_offer_book_chart_screen_currency_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.offer_book_chart_screen_currency_code,
            ::std::string::String::new(),
        )
    }

    // string trade_charts_screen_currency_code = 19;

    pub fn get_trade_charts_screen_currency_code(&self) -> &str {
        &self.trade_charts_screen_currency_code
    }
    pub fn clear_trade_charts_screen_currency_code(&mut self) {
        self.trade_charts_screen_currency_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_charts_screen_currency_code(&mut self, v: ::std::string::String) {
        self.trade_charts_screen_currency_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_charts_screen_currency_code(&mut self) -> &mut ::std::string::String {
        &mut self.trade_charts_screen_currency_code
    }

    // Take field
    pub fn take_trade_charts_screen_currency_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.trade_charts_screen_currency_code,
            ::std::string::String::new(),
        )
    }

    // string buy_screen_currency_code = 20;

    pub fn get_buy_screen_currency_code(&self) -> &str {
        &self.buy_screen_currency_code
    }
    pub fn clear_buy_screen_currency_code(&mut self) {
        self.buy_screen_currency_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_buy_screen_currency_code(&mut self, v: ::std::string::String) {
        self.buy_screen_currency_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buy_screen_currency_code(&mut self) -> &mut ::std::string::String {
        &mut self.buy_screen_currency_code
    }

    // Take field
    pub fn take_buy_screen_currency_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.buy_screen_currency_code,
            ::std::string::String::new(),
        )
    }

    // string sell_screen_currency_code = 21;

    pub fn get_sell_screen_currency_code(&self) -> &str {
        &self.sell_screen_currency_code
    }
    pub fn clear_sell_screen_currency_code(&mut self) {
        self.sell_screen_currency_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_sell_screen_currency_code(&mut self, v: ::std::string::String) {
        self.sell_screen_currency_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sell_screen_currency_code(&mut self) -> &mut ::std::string::String {
        &mut self.sell_screen_currency_code
    }

    // Take field
    pub fn take_sell_screen_currency_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.sell_screen_currency_code,
            ::std::string::String::new(),
        )
    }

    // int32 trade_statistics_tick_unit_index = 22;

    pub fn get_trade_statistics_tick_unit_index(&self) -> i32 {
        self.trade_statistics_tick_unit_index
    }
    pub fn clear_trade_statistics_tick_unit_index(&mut self) {
        self.trade_statistics_tick_unit_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_statistics_tick_unit_index(&mut self, v: i32) {
        self.trade_statistics_tick_unit_index = v;
    }

    // bool resync_Spv_requested = 23;

    pub fn get_resync_Spv_requested(&self) -> bool {
        self.resync_Spv_requested
    }
    pub fn clear_resync_Spv_requested(&mut self) {
        self.resync_Spv_requested = false;
    }

    // Param is passed by value, moved
    pub fn set_resync_Spv_requested(&mut self, v: bool) {
        self.resync_Spv_requested = v;
    }

    // bool sort_market_currencies_numerically = 24;

    pub fn get_sort_market_currencies_numerically(&self) -> bool {
        self.sort_market_currencies_numerically
    }
    pub fn clear_sort_market_currencies_numerically(&mut self) {
        self.sort_market_currencies_numerically = false;
    }

    // Param is passed by value, moved
    pub fn set_sort_market_currencies_numerically(&mut self, v: bool) {
        self.sort_market_currencies_numerically = v;
    }

    // bool use_percentage_based_price = 25;

    pub fn get_use_percentage_based_price(&self) -> bool {
        self.use_percentage_based_price
    }
    pub fn clear_use_percentage_based_price(&mut self) {
        self.use_percentage_based_price = false;
    }

    // Param is passed by value, moved
    pub fn set_use_percentage_based_price(&mut self, v: bool) {
        self.use_percentage_based_price = v;
    }

    // repeated .io.bisq.protobuffer.PreferencesPayload.PeerTagMapEntry peer_tag_map = 26;

    pub fn get_peer_tag_map(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.peer_tag_map
    }
    pub fn clear_peer_tag_map(&mut self) {
        self.peer_tag_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_peer_tag_map(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ) {
        self.peer_tag_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peer_tag_map(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.peer_tag_map
    }

    // Take field
    pub fn take_peer_tag_map(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.peer_tag_map, ::std::collections::HashMap::new())
    }

    // string bitcoin_nodes = 27;

    pub fn get_bitcoin_nodes(&self) -> &str {
        &self.bitcoin_nodes
    }
    pub fn clear_bitcoin_nodes(&mut self) {
        self.bitcoin_nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_bitcoin_nodes(&mut self, v: ::std::string::String) {
        self.bitcoin_nodes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bitcoin_nodes(&mut self) -> &mut ::std::string::String {
        &mut self.bitcoin_nodes
    }

    // Take field
    pub fn take_bitcoin_nodes(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bitcoin_nodes, ::std::string::String::new())
    }

    // repeated string ignore_traders_list = 28;

    pub fn get_ignore_traders_list(&self) -> &[::std::string::String] {
        &self.ignore_traders_list
    }
    pub fn clear_ignore_traders_list(&mut self) {
        self.ignore_traders_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_ignore_traders_list(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ignore_traders_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ignore_traders_list(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ignore_traders_list
    }

    // Take field
    pub fn take_ignore_traders_list(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(
            &mut self.ignore_traders_list,
            ::protobuf::RepeatedField::new(),
        )
    }

    // string directory_chooser_path = 29;

    pub fn get_directory_chooser_path(&self) -> &str {
        &self.directory_chooser_path
    }
    pub fn clear_directory_chooser_path(&mut self) {
        self.directory_chooser_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_directory_chooser_path(&mut self, v: ::std::string::String) {
        self.directory_chooser_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directory_chooser_path(&mut self) -> &mut ::std::string::String {
        &mut self.directory_chooser_path
    }

    // Take field
    pub fn take_directory_chooser_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.directory_chooser_path,
            ::std::string::String::new(),
        )
    }

    // int64 buyer_security_deposit_as_long = 30;

    pub fn get_buyer_security_deposit_as_long(&self) -> i64 {
        self.buyer_security_deposit_as_long
    }
    pub fn clear_buyer_security_deposit_as_long(&mut self) {
        self.buyer_security_deposit_as_long = 0;
    }

    // Param is passed by value, moved
    pub fn set_buyer_security_deposit_as_long(&mut self, v: i64) {
        self.buyer_security_deposit_as_long = v;
    }

    // bool use_animations = 31;

    pub fn get_use_animations(&self) -> bool {
        self.use_animations
    }
    pub fn clear_use_animations(&mut self) {
        self.use_animations = false;
    }

    // Param is passed by value, moved
    pub fn set_use_animations(&mut self, v: bool) {
        self.use_animations = v;
    }

    // .io.bisq.protobuffer.PaymentAccount selectedPayment_account_for_createOffer = 32;

    pub fn get_selectedPayment_account_for_createOffer(&self) -> &PaymentAccount {
        self.selectedPayment_account_for_createOffer
            .as_ref()
            .unwrap_or_else(|| PaymentAccount::default_instance())
    }
    pub fn clear_selectedPayment_account_for_createOffer(&mut self) {
        self.selectedPayment_account_for_createOffer.clear();
    }

    pub fn has_selectedPayment_account_for_createOffer(&self) -> bool {
        self.selectedPayment_account_for_createOffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectedPayment_account_for_createOffer(&mut self, v: PaymentAccount) {
        self.selectedPayment_account_for_createOffer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selectedPayment_account_for_createOffer(&mut self) -> &mut PaymentAccount {
        if self.selectedPayment_account_for_createOffer.is_none() {
            self.selectedPayment_account_for_createOffer.set_default();
        }
        self.selectedPayment_account_for_createOffer
            .as_mut()
            .unwrap()
    }

    // Take field
    pub fn take_selectedPayment_account_for_createOffer(&mut self) -> PaymentAccount {
        self.selectedPayment_account_for_createOffer
            .take()
            .unwrap_or_else(|| PaymentAccount::new())
    }

    // bool pay_fee_in_Btc = 33;

    pub fn get_pay_fee_in_Btc(&self) -> bool {
        self.pay_fee_in_Btc
    }
    pub fn clear_pay_fee_in_Btc(&mut self) {
        self.pay_fee_in_Btc = false;
    }

    // Param is passed by value, moved
    pub fn set_pay_fee_in_Btc(&mut self, v: bool) {
        self.pay_fee_in_Btc = v;
    }

    // repeated string bridge_addresses = 34;

    pub fn get_bridge_addresses(&self) -> &[::std::string::String] {
        &self.bridge_addresses
    }
    pub fn clear_bridge_addresses(&mut self) {
        self.bridge_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_bridge_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.bridge_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bridge_addresses(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.bridge_addresses
    }

    // Take field
    pub fn take_bridge_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.bridge_addresses, ::protobuf::RepeatedField::new())
    }

    // int32 bridge_option_ordinal = 35;

    pub fn get_bridge_option_ordinal(&self) -> i32 {
        self.bridge_option_ordinal
    }
    pub fn clear_bridge_option_ordinal(&mut self) {
        self.bridge_option_ordinal = 0;
    }

    // Param is passed by value, moved
    pub fn set_bridge_option_ordinal(&mut self, v: i32) {
        self.bridge_option_ordinal = v;
    }

    // int32 tor_transport_ordinal = 36;

    pub fn get_tor_transport_ordinal(&self) -> i32 {
        self.tor_transport_ordinal
    }
    pub fn clear_tor_transport_ordinal(&mut self) {
        self.tor_transport_ordinal = 0;
    }

    // Param is passed by value, moved
    pub fn set_tor_transport_ordinal(&mut self, v: i32) {
        self.tor_transport_ordinal = v;
    }

    // string custom_bridges = 37;

    pub fn get_custom_bridges(&self) -> &str {
        &self.custom_bridges
    }
    pub fn clear_custom_bridges(&mut self) {
        self.custom_bridges.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_bridges(&mut self, v: ::std::string::String) {
        self.custom_bridges = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_bridges(&mut self) -> &mut ::std::string::String {
        &mut self.custom_bridges
    }

    // Take field
    pub fn take_custom_bridges(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.custom_bridges, ::std::string::String::new())
    }

    // int32 bitcoin_nodes_option_ordinal = 38;

    pub fn get_bitcoin_nodes_option_ordinal(&self) -> i32 {
        self.bitcoin_nodes_option_ordinal
    }
    pub fn clear_bitcoin_nodes_option_ordinal(&mut self) {
        self.bitcoin_nodes_option_ordinal = 0;
    }

    // Param is passed by value, moved
    pub fn set_bitcoin_nodes_option_ordinal(&mut self, v: i32) {
        self.bitcoin_nodes_option_ordinal = v;
    }

    // string referral_id = 39;

    pub fn get_referral_id(&self) -> &str {
        &self.referral_id
    }
    pub fn clear_referral_id(&mut self) {
        self.referral_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_referral_id(&mut self, v: ::std::string::String) {
        self.referral_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_referral_id(&mut self) -> &mut ::std::string::String {
        &mut self.referral_id
    }

    // Take field
    pub fn take_referral_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.referral_id, ::std::string::String::new())
    }

    // string phone_key_and_token = 40;

    pub fn get_phone_key_and_token(&self) -> &str {
        &self.phone_key_and_token
    }
    pub fn clear_phone_key_and_token(&mut self) {
        self.phone_key_and_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_phone_key_and_token(&mut self, v: ::std::string::String) {
        self.phone_key_and_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phone_key_and_token(&mut self) -> &mut ::std::string::String {
        &mut self.phone_key_and_token
    }

    // Take field
    pub fn take_phone_key_and_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.phone_key_and_token, ::std::string::String::new())
    }

    // bool use_sound_for_mobile_notifications = 41;

    pub fn get_use_sound_for_mobile_notifications(&self) -> bool {
        self.use_sound_for_mobile_notifications
    }
    pub fn clear_use_sound_for_mobile_notifications(&mut self) {
        self.use_sound_for_mobile_notifications = false;
    }

    // Param is passed by value, moved
    pub fn set_use_sound_for_mobile_notifications(&mut self, v: bool) {
        self.use_sound_for_mobile_notifications = v;
    }

    // bool use_trade_notifications = 42;

    pub fn get_use_trade_notifications(&self) -> bool {
        self.use_trade_notifications
    }
    pub fn clear_use_trade_notifications(&mut self) {
        self.use_trade_notifications = false;
    }

    // Param is passed by value, moved
    pub fn set_use_trade_notifications(&mut self, v: bool) {
        self.use_trade_notifications = v;
    }

    // bool use_market_notifications = 43;

    pub fn get_use_market_notifications(&self) -> bool {
        self.use_market_notifications
    }
    pub fn clear_use_market_notifications(&mut self) {
        self.use_market_notifications = false;
    }

    // Param is passed by value, moved
    pub fn set_use_market_notifications(&mut self, v: bool) {
        self.use_market_notifications = v;
    }

    // bool use_price_notifications = 44;

    pub fn get_use_price_notifications(&self) -> bool {
        self.use_price_notifications
    }
    pub fn clear_use_price_notifications(&mut self) {
        self.use_price_notifications = false;
    }

    // Param is passed by value, moved
    pub fn set_use_price_notifications(&mut self, v: bool) {
        self.use_price_notifications = v;
    }

    // bool use_standby_mode = 45;

    pub fn get_use_standby_mode(&self) -> bool {
        self.use_standby_mode
    }
    pub fn clear_use_standby_mode(&mut self) {
        self.use_standby_mode = false;
    }

    // Param is passed by value, moved
    pub fn set_use_standby_mode(&mut self, v: bool) {
        self.use_standby_mode = v;
    }

    // bool is_dao_full_node = 46;

    pub fn get_is_dao_full_node(&self) -> bool {
        self.is_dao_full_node
    }
    pub fn clear_is_dao_full_node(&mut self) {
        self.is_dao_full_node = false;
    }

    // Param is passed by value, moved
    pub fn set_is_dao_full_node(&mut self, v: bool) {
        self.is_dao_full_node = v;
    }

    // string rpc_user = 47;

    pub fn get_rpc_user(&self) -> &str {
        &self.rpc_user
    }
    pub fn clear_rpc_user(&mut self) {
        self.rpc_user.clear();
    }

    // Param is passed by value, moved
    pub fn set_rpc_user(&mut self, v: ::std::string::String) {
        self.rpc_user = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rpc_user(&mut self) -> &mut ::std::string::String {
        &mut self.rpc_user
    }

    // Take field
    pub fn take_rpc_user(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rpc_user, ::std::string::String::new())
    }

    // string rpc_pw = 48;

    pub fn get_rpc_pw(&self) -> &str {
        &self.rpc_pw
    }
    pub fn clear_rpc_pw(&mut self) {
        self.rpc_pw.clear();
    }

    // Param is passed by value, moved
    pub fn set_rpc_pw(&mut self, v: ::std::string::String) {
        self.rpc_pw = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rpc_pw(&mut self) -> &mut ::std::string::String {
        &mut self.rpc_pw
    }

    // Take field
    pub fn take_rpc_pw(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rpc_pw, ::std::string::String::new())
    }

    // string take_offer_selected_payment_account_id = 49;

    pub fn get_take_offer_selected_payment_account_id(&self) -> &str {
        &self.take_offer_selected_payment_account_id
    }
    pub fn clear_take_offer_selected_payment_account_id(&mut self) {
        self.take_offer_selected_payment_account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_take_offer_selected_payment_account_id(&mut self, v: ::std::string::String) {
        self.take_offer_selected_payment_account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_take_offer_selected_payment_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.take_offer_selected_payment_account_id
    }

    // Take field
    pub fn take_take_offer_selected_payment_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.take_offer_selected_payment_account_id,
            ::std::string::String::new(),
        )
    }

    // double buyer_security_deposit_as_percent = 50;

    pub fn get_buyer_security_deposit_as_percent(&self) -> f64 {
        self.buyer_security_deposit_as_percent
    }
    pub fn clear_buyer_security_deposit_as_percent(&mut self) {
        self.buyer_security_deposit_as_percent = 0.;
    }

    // Param is passed by value, moved
    pub fn set_buyer_security_deposit_as_percent(&mut self, v: f64) {
        self.buyer_security_deposit_as_percent = v;
    }

    // int32 ignore_dust_threshold = 51;

    pub fn get_ignore_dust_threshold(&self) -> i32 {
        self.ignore_dust_threshold
    }
    pub fn clear_ignore_dust_threshold(&mut self) {
        self.ignore_dust_threshold = 0;
    }

    // Param is passed by value, moved
    pub fn set_ignore_dust_threshold(&mut self, v: i32) {
        self.ignore_dust_threshold = v;
    }

    // double buyer_security_deposit_as_percent_for_crypto = 52;

    pub fn get_buyer_security_deposit_as_percent_for_crypto(&self) -> f64 {
        self.buyer_security_deposit_as_percent_for_crypto
    }
    pub fn clear_buyer_security_deposit_as_percent_for_crypto(&mut self) {
        self.buyer_security_deposit_as_percent_for_crypto = 0.;
    }

    // Param is passed by value, moved
    pub fn set_buyer_security_deposit_as_percent_for_crypto(&mut self, v: f64) {
        self.buyer_security_deposit_as_percent_for_crypto = v;
    }

    // int32 block_notify_port = 53;

    pub fn get_block_notify_port(&self) -> i32 {
        self.block_notify_port
    }
    pub fn clear_block_notify_port(&mut self) {
        self.block_notify_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_notify_port(&mut self, v: i32) {
        self.block_notify_port = v;
    }

    // int32 css_theme = 54;

    pub fn get_css_theme(&self) -> i32 {
        self.css_theme
    }
    pub fn clear_css_theme(&mut self) {
        self.css_theme = 0;
    }

    // Param is passed by value, moved
    pub fn set_css_theme(&mut self, v: i32) {
        self.css_theme = v;
    }

    // bool tac_accepted_v120 = 55;

    pub fn get_tac_accepted_v120(&self) -> bool {
        self.tac_accepted_v120
    }
    pub fn clear_tac_accepted_v120(&mut self) {
        self.tac_accepted_v120 = false;
    }

    // Param is passed by value, moved
    pub fn set_tac_accepted_v120(&mut self, v: bool) {
        self.tac_accepted_v120 = v;
    }
}

impl ::protobuf::Message for PreferencesPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.user_country {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.fiat_currencies {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.crypto_currencies {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.block_chain_explorer_main_net {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.block_chain_explorer_test_net {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.bsq_block_chain_explorer {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.preferred_trade_currency {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.selectedPayment_account_for_createOffer {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.user_language,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.user_country,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.fiat_currencies,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.crypto_currencies,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.block_chain_explorer_main_net,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.block_chain_explorer_test_net,
                    )?;
                }
                7 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.bsq_block_chain_explorer,
                    )?;
                }
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.backup_directory,
                    )?;
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.auto_select_arbitrators = tmp;
                }
                10 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeBool,
                    >(wire_type, is, &mut self.dont_show_again_map)?;
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.tac_accepted = tmp;
                }
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.use_tor_for_bitcoin_j = tmp;
                }
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.show_own_offers_in_offer_book = tmp;
                }
                14 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.preferred_trade_currency,
                    )?;
                }
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.withdrawal_tx_fee_in_bytes = tmp;
                }
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.use_custom_withdrawal_tx_fee = tmp;
                }
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.max_price_distance_in_percent = tmp;
                }
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.offer_book_chart_screen_currency_code,
                    )?;
                }
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_charts_screen_currency_code,
                    )?;
                }
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.buy_screen_currency_code,
                    )?;
                }
                21 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.sell_screen_currency_code,
                    )?;
                }
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.trade_statistics_tick_unit_index = tmp;
                }
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.resync_Spv_requested = tmp;
                }
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.sort_market_currencies_numerically = tmp;
                }
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.use_percentage_based_price = tmp;
                }
                26 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeString,
                    >(wire_type, is, &mut self.peer_tag_map)?;
                }
                27 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bitcoin_nodes,
                    )?;
                }
                28 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.ignore_traders_list,
                    )?;
                }
                29 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.directory_chooser_path,
                    )?;
                }
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.buyer_security_deposit_as_long = tmp;
                }
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.use_animations = tmp;
                }
                32 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.selectedPayment_account_for_createOffer,
                    )?;
                }
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.pay_fee_in_Btc = tmp;
                }
                34 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.bridge_addresses,
                    )?;
                }
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.bridge_option_ordinal = tmp;
                }
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.tor_transport_ordinal = tmp;
                }
                37 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.custom_bridges,
                    )?;
                }
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.bitcoin_nodes_option_ordinal = tmp;
                }
                39 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.referral_id,
                    )?;
                }
                40 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.phone_key_and_token,
                    )?;
                }
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.use_sound_for_mobile_notifications = tmp;
                }
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.use_trade_notifications = tmp;
                }
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.use_market_notifications = tmp;
                }
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.use_price_notifications = tmp;
                }
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.use_standby_mode = tmp;
                }
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_dao_full_node = tmp;
                }
                47 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.rpc_user,
                    )?;
                }
                48 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.rpc_pw,
                    )?;
                }
                49 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.take_offer_selected_payment_account_id,
                    )?;
                }
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.buyer_security_deposit_as_percent = tmp;
                }
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.ignore_dust_threshold = tmp;
                }
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.buyer_security_deposit_as_percent_for_crypto = tmp;
                }
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.block_notify_port = tmp;
                }
                54 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.css_theme = tmp;
                }
                55 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.tac_accepted_v120 = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_language.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_language);
        }
        if let Some(ref v) = self.user_country.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.fiat_currencies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.crypto_currencies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.block_chain_explorer_main_net.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.block_chain_explorer_test_net.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bsq_block_chain_explorer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.backup_directory.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.backup_directory);
        }
        if self.auto_select_arbitrators != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeBool,
        >(10, &self.dont_show_again_map);
        if self.tac_accepted != false {
            my_size += 2;
        }
        if self.use_tor_for_bitcoin_j != false {
            my_size += 2;
        }
        if self.show_own_offers_in_offer_book != false {
            my_size += 2;
        }
        if let Some(ref v) = self.preferred_trade_currency.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.withdrawal_tx_fee_in_bytes != 0 {
            my_size += ::protobuf::rt::value_size(
                15,
                self.withdrawal_tx_fee_in_bytes,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.use_custom_withdrawal_tx_fee != false {
            my_size += 3;
        }
        if self.max_price_distance_in_percent != 0. {
            my_size += 10;
        }
        if !self.offer_book_chart_screen_currency_code.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.offer_book_chart_screen_currency_code);
        }
        if !self.trade_charts_screen_currency_code.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.trade_charts_screen_currency_code);
        }
        if !self.buy_screen_currency_code.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.buy_screen_currency_code);
        }
        if !self.sell_screen_currency_code.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.sell_screen_currency_code);
        }
        if self.trade_statistics_tick_unit_index != 0 {
            my_size += ::protobuf::rt::value_size(
                22,
                self.trade_statistics_tick_unit_index,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.resync_Spv_requested != false {
            my_size += 3;
        }
        if self.sort_market_currencies_numerically != false {
            my_size += 3;
        }
        if self.use_percentage_based_price != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(26, &self.peer_tag_map);
        if !self.bitcoin_nodes.is_empty() {
            my_size += ::protobuf::rt::string_size(27, &self.bitcoin_nodes);
        }
        for value in &self.ignore_traders_list {
            my_size += ::protobuf::rt::string_size(28, &value);
        }
        if !self.directory_chooser_path.is_empty() {
            my_size += ::protobuf::rt::string_size(29, &self.directory_chooser_path);
        }
        if self.buyer_security_deposit_as_long != 0 {
            my_size += ::protobuf::rt::value_size(
                30,
                self.buyer_security_deposit_as_long,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.use_animations != false {
            my_size += 3;
        }
        if let Some(ref v) = self.selectedPayment_account_for_createOffer.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.pay_fee_in_Btc != false {
            my_size += 3;
        }
        for value in &self.bridge_addresses {
            my_size += ::protobuf::rt::string_size(34, &value);
        }
        if self.bridge_option_ordinal != 0 {
            my_size += ::protobuf::rt::value_size(
                35,
                self.bridge_option_ordinal,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.tor_transport_ordinal != 0 {
            my_size += ::protobuf::rt::value_size(
                36,
                self.tor_transport_ordinal,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.custom_bridges.is_empty() {
            my_size += ::protobuf::rt::string_size(37, &self.custom_bridges);
        }
        if self.bitcoin_nodes_option_ordinal != 0 {
            my_size += ::protobuf::rt::value_size(
                38,
                self.bitcoin_nodes_option_ordinal,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.referral_id.is_empty() {
            my_size += ::protobuf::rt::string_size(39, &self.referral_id);
        }
        if !self.phone_key_and_token.is_empty() {
            my_size += ::protobuf::rt::string_size(40, &self.phone_key_and_token);
        }
        if self.use_sound_for_mobile_notifications != false {
            my_size += 3;
        }
        if self.use_trade_notifications != false {
            my_size += 3;
        }
        if self.use_market_notifications != false {
            my_size += 3;
        }
        if self.use_price_notifications != false {
            my_size += 3;
        }
        if self.use_standby_mode != false {
            my_size += 3;
        }
        if self.is_dao_full_node != false {
            my_size += 3;
        }
        if !self.rpc_user.is_empty() {
            my_size += ::protobuf::rt::string_size(47, &self.rpc_user);
        }
        if !self.rpc_pw.is_empty() {
            my_size += ::protobuf::rt::string_size(48, &self.rpc_pw);
        }
        if !self.take_offer_selected_payment_account_id.is_empty() {
            my_size +=
                ::protobuf::rt::string_size(49, &self.take_offer_selected_payment_account_id);
        }
        if self.buyer_security_deposit_as_percent != 0. {
            my_size += 10;
        }
        if self.ignore_dust_threshold != 0 {
            my_size += ::protobuf::rt::value_size(
                51,
                self.ignore_dust_threshold,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.buyer_security_deposit_as_percent_for_crypto != 0. {
            my_size += 10;
        }
        if self.block_notify_port != 0 {
            my_size += ::protobuf::rt::value_size(
                53,
                self.block_notify_port,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.css_theme != 0 {
            my_size += ::protobuf::rt::value_size(
                54,
                self.css_theme,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.tac_accepted_v120 != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.user_language.is_empty() {
            os.write_string(1, &self.user_language)?;
        }
        if let Some(ref v) = self.user_country.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.fiat_currencies {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.crypto_currencies {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.block_chain_explorer_main_net.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.block_chain_explorer_test_net.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bsq_block_chain_explorer.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.backup_directory.is_empty() {
            os.write_string(8, &self.backup_directory)?;
        }
        if self.auto_select_arbitrators != false {
            os.write_bool(9, self.auto_select_arbitrators)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeBool,
        >(10, &self.dont_show_again_map, os)?;
        if self.tac_accepted != false {
            os.write_bool(11, self.tac_accepted)?;
        }
        if self.use_tor_for_bitcoin_j != false {
            os.write_bool(12, self.use_tor_for_bitcoin_j)?;
        }
        if self.show_own_offers_in_offer_book != false {
            os.write_bool(13, self.show_own_offers_in_offer_book)?;
        }
        if let Some(ref v) = self.preferred_trade_currency.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.withdrawal_tx_fee_in_bytes != 0 {
            os.write_int64(15, self.withdrawal_tx_fee_in_bytes)?;
        }
        if self.use_custom_withdrawal_tx_fee != false {
            os.write_bool(16, self.use_custom_withdrawal_tx_fee)?;
        }
        if self.max_price_distance_in_percent != 0. {
            os.write_double(17, self.max_price_distance_in_percent)?;
        }
        if !self.offer_book_chart_screen_currency_code.is_empty() {
            os.write_string(18, &self.offer_book_chart_screen_currency_code)?;
        }
        if !self.trade_charts_screen_currency_code.is_empty() {
            os.write_string(19, &self.trade_charts_screen_currency_code)?;
        }
        if !self.buy_screen_currency_code.is_empty() {
            os.write_string(20, &self.buy_screen_currency_code)?;
        }
        if !self.sell_screen_currency_code.is_empty() {
            os.write_string(21, &self.sell_screen_currency_code)?;
        }
        if self.trade_statistics_tick_unit_index != 0 {
            os.write_int32(22, self.trade_statistics_tick_unit_index)?;
        }
        if self.resync_Spv_requested != false {
            os.write_bool(23, self.resync_Spv_requested)?;
        }
        if self.sort_market_currencies_numerically != false {
            os.write_bool(24, self.sort_market_currencies_numerically)?;
        }
        if self.use_percentage_based_price != false {
            os.write_bool(25, self.use_percentage_based_price)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(26, &self.peer_tag_map, os)?;
        if !self.bitcoin_nodes.is_empty() {
            os.write_string(27, &self.bitcoin_nodes)?;
        }
        for v in &self.ignore_traders_list {
            os.write_string(28, &v)?;
        }
        if !self.directory_chooser_path.is_empty() {
            os.write_string(29, &self.directory_chooser_path)?;
        }
        if self.buyer_security_deposit_as_long != 0 {
            os.write_int64(30, self.buyer_security_deposit_as_long)?;
        }
        if self.use_animations != false {
            os.write_bool(31, self.use_animations)?;
        }
        if let Some(ref v) = self.selectedPayment_account_for_createOffer.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.pay_fee_in_Btc != false {
            os.write_bool(33, self.pay_fee_in_Btc)?;
        }
        for v in &self.bridge_addresses {
            os.write_string(34, &v)?;
        }
        if self.bridge_option_ordinal != 0 {
            os.write_int32(35, self.bridge_option_ordinal)?;
        }
        if self.tor_transport_ordinal != 0 {
            os.write_int32(36, self.tor_transport_ordinal)?;
        }
        if !self.custom_bridges.is_empty() {
            os.write_string(37, &self.custom_bridges)?;
        }
        if self.bitcoin_nodes_option_ordinal != 0 {
            os.write_int32(38, self.bitcoin_nodes_option_ordinal)?;
        }
        if !self.referral_id.is_empty() {
            os.write_string(39, &self.referral_id)?;
        }
        if !self.phone_key_and_token.is_empty() {
            os.write_string(40, &self.phone_key_and_token)?;
        }
        if self.use_sound_for_mobile_notifications != false {
            os.write_bool(41, self.use_sound_for_mobile_notifications)?;
        }
        if self.use_trade_notifications != false {
            os.write_bool(42, self.use_trade_notifications)?;
        }
        if self.use_market_notifications != false {
            os.write_bool(43, self.use_market_notifications)?;
        }
        if self.use_price_notifications != false {
            os.write_bool(44, self.use_price_notifications)?;
        }
        if self.use_standby_mode != false {
            os.write_bool(45, self.use_standby_mode)?;
        }
        if self.is_dao_full_node != false {
            os.write_bool(46, self.is_dao_full_node)?;
        }
        if !self.rpc_user.is_empty() {
            os.write_string(47, &self.rpc_user)?;
        }
        if !self.rpc_pw.is_empty() {
            os.write_string(48, &self.rpc_pw)?;
        }
        if !self.take_offer_selected_payment_account_id.is_empty() {
            os.write_string(49, &self.take_offer_selected_payment_account_id)?;
        }
        if self.buyer_security_deposit_as_percent != 0. {
            os.write_double(50, self.buyer_security_deposit_as_percent)?;
        }
        if self.ignore_dust_threshold != 0 {
            os.write_int32(51, self.ignore_dust_threshold)?;
        }
        if self.buyer_security_deposit_as_percent_for_crypto != 0. {
            os.write_double(52, self.buyer_security_deposit_as_percent_for_crypto)?;
        }
        if self.block_notify_port != 0 {
            os.write_int32(53, self.block_notify_port)?;
        }
        if self.css_theme != 0 {
            os.write_int32(54, self.css_theme)?;
        }
        if self.tac_accepted_v120 != false {
            os.write_bool(55, self.tac_accepted_v120)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreferencesPayload {
        PreferencesPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "user_language",
                    |m: &PreferencesPayload| &m.user_language,
                    |m: &mut PreferencesPayload| &mut m.user_language,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Country>,
                    >(
                        "user_country",
                        |m: &PreferencesPayload| &m.user_country,
                        |m: &mut PreferencesPayload| &mut m.user_country,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<TradeCurrency>,
                    >(
                        "fiat_currencies",
                        |m: &PreferencesPayload| &m.fiat_currencies,
                        |m: &mut PreferencesPayload| &mut m.fiat_currencies,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<TradeCurrency>,
                    >(
                        "crypto_currencies",
                        |m: &PreferencesPayload| &m.crypto_currencies,
                        |m: &mut PreferencesPayload| &mut m.crypto_currencies,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BlockChainExplorer>,
                    >(
                        "block_chain_explorer_main_net",
                        |m: &PreferencesPayload| &m.block_chain_explorer_main_net,
                        |m: &mut PreferencesPayload| &mut m.block_chain_explorer_main_net,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BlockChainExplorer>,
                    >(
                        "block_chain_explorer_test_net",
                        |m: &PreferencesPayload| &m.block_chain_explorer_test_net,
                        |m: &mut PreferencesPayload| &mut m.block_chain_explorer_test_net,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BlockChainExplorer>,
                    >(
                        "bsq_block_chain_explorer",
                        |m: &PreferencesPayload| &m.bsq_block_chain_explorer,
                        |m: &mut PreferencesPayload| &mut m.bsq_block_chain_explorer,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "backup_directory",
                    |m: &PreferencesPayload| &m.backup_directory,
                    |m: &mut PreferencesPayload| &mut m.backup_directory,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "auto_select_arbitrators",
                    |m: &PreferencesPayload| &m.auto_select_arbitrators,
                    |m: &mut PreferencesPayload| &mut m.auto_select_arbitrators,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "dont_show_again_map",
                    |m: &PreferencesPayload| &m.dont_show_again_map,
                    |m: &mut PreferencesPayload| &mut m.dont_show_again_map,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "tac_accepted",
                    |m: &PreferencesPayload| &m.tac_accepted,
                    |m: &mut PreferencesPayload| &mut m.tac_accepted,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "use_tor_for_bitcoin_j",
                    |m: &PreferencesPayload| &m.use_tor_for_bitcoin_j,
                    |m: &mut PreferencesPayload| &mut m.use_tor_for_bitcoin_j,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "show_own_offers_in_offer_book",
                    |m: &PreferencesPayload| &m.show_own_offers_in_offer_book,
                    |m: &mut PreferencesPayload| &mut m.show_own_offers_in_offer_book,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<TradeCurrency>,
                    >(
                        "preferred_trade_currency",
                        |m: &PreferencesPayload| &m.preferred_trade_currency,
                        |m: &mut PreferencesPayload| &mut m.preferred_trade_currency,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "withdrawal_tx_fee_in_bytes",
                    |m: &PreferencesPayload| &m.withdrawal_tx_fee_in_bytes,
                    |m: &mut PreferencesPayload| &mut m.withdrawal_tx_fee_in_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "use_custom_withdrawal_tx_fee",
                    |m: &PreferencesPayload| &m.use_custom_withdrawal_tx_fee,
                    |m: &mut PreferencesPayload| &mut m.use_custom_withdrawal_tx_fee,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "max_price_distance_in_percent",
                    |m: &PreferencesPayload| &m.max_price_distance_in_percent,
                    |m: &mut PreferencesPayload| &mut m.max_price_distance_in_percent,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "offer_book_chart_screen_currency_code",
                    |m: &PreferencesPayload| &m.offer_book_chart_screen_currency_code,
                    |m: &mut PreferencesPayload| &mut m.offer_book_chart_screen_currency_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_charts_screen_currency_code",
                    |m: &PreferencesPayload| &m.trade_charts_screen_currency_code,
                    |m: &mut PreferencesPayload| &mut m.trade_charts_screen_currency_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "buy_screen_currency_code",
                    |m: &PreferencesPayload| &m.buy_screen_currency_code,
                    |m: &mut PreferencesPayload| &mut m.buy_screen_currency_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "sell_screen_currency_code",
                    |m: &PreferencesPayload| &m.sell_screen_currency_code,
                    |m: &mut PreferencesPayload| &mut m.sell_screen_currency_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "trade_statistics_tick_unit_index",
                    |m: &PreferencesPayload| &m.trade_statistics_tick_unit_index,
                    |m: &mut PreferencesPayload| &mut m.trade_statistics_tick_unit_index,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "resync_Spv_requested",
                    |m: &PreferencesPayload| &m.resync_Spv_requested,
                    |m: &mut PreferencesPayload| &mut m.resync_Spv_requested,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "sort_market_currencies_numerically",
                    |m: &PreferencesPayload| &m.sort_market_currencies_numerically,
                    |m: &mut PreferencesPayload| &mut m.sort_market_currencies_numerically,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "use_percentage_based_price",
                    |m: &PreferencesPayload| &m.use_percentage_based_price,
                    |m: &mut PreferencesPayload| &mut m.use_percentage_based_price,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "peer_tag_map",
                    |m: &PreferencesPayload| &m.peer_tag_map,
                    |m: &mut PreferencesPayload| &mut m.peer_tag_map,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bitcoin_nodes",
                    |m: &PreferencesPayload| &m.bitcoin_nodes,
                    |m: &mut PreferencesPayload| &mut m.bitcoin_nodes,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "ignore_traders_list",
                        |m: &PreferencesPayload| &m.ignore_traders_list,
                        |m: &mut PreferencesPayload| &mut m.ignore_traders_list,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "directory_chooser_path",
                    |m: &PreferencesPayload| &m.directory_chooser_path,
                    |m: &mut PreferencesPayload| &mut m.directory_chooser_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "buyer_security_deposit_as_long",
                    |m: &PreferencesPayload| &m.buyer_security_deposit_as_long,
                    |m: &mut PreferencesPayload| &mut m.buyer_security_deposit_as_long,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "use_animations",
                    |m: &PreferencesPayload| &m.use_animations,
                    |m: &mut PreferencesPayload| &mut m.use_animations,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PaymentAccount>,
                    >(
                        "selectedPayment_account_for_createOffer",
                        |m: &PreferencesPayload| &m.selectedPayment_account_for_createOffer,
                        |m: &mut PreferencesPayload| &mut m.selectedPayment_account_for_createOffer,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "pay_fee_in_Btc",
                    |m: &PreferencesPayload| &m.pay_fee_in_Btc,
                    |m: &mut PreferencesPayload| &mut m.pay_fee_in_Btc,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "bridge_addresses",
                        |m: &PreferencesPayload| &m.bridge_addresses,
                        |m: &mut PreferencesPayload| &mut m.bridge_addresses,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "bridge_option_ordinal",
                    |m: &PreferencesPayload| &m.bridge_option_ordinal,
                    |m: &mut PreferencesPayload| &mut m.bridge_option_ordinal,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "tor_transport_ordinal",
                    |m: &PreferencesPayload| &m.tor_transport_ordinal,
                    |m: &mut PreferencesPayload| &mut m.tor_transport_ordinal,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "custom_bridges",
                    |m: &PreferencesPayload| &m.custom_bridges,
                    |m: &mut PreferencesPayload| &mut m.custom_bridges,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "bitcoin_nodes_option_ordinal",
                    |m: &PreferencesPayload| &m.bitcoin_nodes_option_ordinal,
                    |m: &mut PreferencesPayload| &mut m.bitcoin_nodes_option_ordinal,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "referral_id",
                    |m: &PreferencesPayload| &m.referral_id,
                    |m: &mut PreferencesPayload| &mut m.referral_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "phone_key_and_token",
                    |m: &PreferencesPayload| &m.phone_key_and_token,
                    |m: &mut PreferencesPayload| &mut m.phone_key_and_token,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "use_sound_for_mobile_notifications",
                    |m: &PreferencesPayload| &m.use_sound_for_mobile_notifications,
                    |m: &mut PreferencesPayload| &mut m.use_sound_for_mobile_notifications,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "use_trade_notifications",
                    |m: &PreferencesPayload| &m.use_trade_notifications,
                    |m: &mut PreferencesPayload| &mut m.use_trade_notifications,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "use_market_notifications",
                    |m: &PreferencesPayload| &m.use_market_notifications,
                    |m: &mut PreferencesPayload| &mut m.use_market_notifications,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "use_price_notifications",
                    |m: &PreferencesPayload| &m.use_price_notifications,
                    |m: &mut PreferencesPayload| &mut m.use_price_notifications,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "use_standby_mode",
                    |m: &PreferencesPayload| &m.use_standby_mode,
                    |m: &mut PreferencesPayload| &mut m.use_standby_mode,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_dao_full_node",
                    |m: &PreferencesPayload| &m.is_dao_full_node,
                    |m: &mut PreferencesPayload| &mut m.is_dao_full_node,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "rpc_user",
                    |m: &PreferencesPayload| &m.rpc_user,
                    |m: &mut PreferencesPayload| &mut m.rpc_user,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "rpc_pw",
                    |m: &PreferencesPayload| &m.rpc_pw,
                    |m: &mut PreferencesPayload| &mut m.rpc_pw,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "take_offer_selected_payment_account_id",
                    |m: &PreferencesPayload| &m.take_offer_selected_payment_account_id,
                    |m: &mut PreferencesPayload| &mut m.take_offer_selected_payment_account_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "buyer_security_deposit_as_percent",
                    |m: &PreferencesPayload| &m.buyer_security_deposit_as_percent,
                    |m: &mut PreferencesPayload| &mut m.buyer_security_deposit_as_percent,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "ignore_dust_threshold",
                    |m: &PreferencesPayload| &m.ignore_dust_threshold,
                    |m: &mut PreferencesPayload| &mut m.ignore_dust_threshold,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "buyer_security_deposit_as_percent_for_crypto",
                    |m: &PreferencesPayload| &m.buyer_security_deposit_as_percent_for_crypto,
                    |m: &mut PreferencesPayload| {
                        &mut m.buyer_security_deposit_as_percent_for_crypto
                    },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "block_notify_port",
                    |m: &PreferencesPayload| &m.block_notify_port,
                    |m: &mut PreferencesPayload| &mut m.block_notify_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "css_theme",
                    |m: &PreferencesPayload| &m.css_theme,
                    |m: &mut PreferencesPayload| &mut m.css_theme,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "tac_accepted_v120",
                    |m: &PreferencesPayload| &m.tac_accepted_v120,
                    |m: &mut PreferencesPayload| &mut m.tac_accepted_v120,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PreferencesPayload>(
                    "PreferencesPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PreferencesPayload {
        static mut instance: ::protobuf::lazy::Lazy<PreferencesPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PreferencesPayload,
        };
        unsafe { instance.get(PreferencesPayload::new) }
    }
}

impl ::protobuf::Clear for PreferencesPayload {
    fn clear(&mut self) {
        self.user_language.clear();
        self.user_country.clear();
        self.fiat_currencies.clear();
        self.crypto_currencies.clear();
        self.block_chain_explorer_main_net.clear();
        self.block_chain_explorer_test_net.clear();
        self.bsq_block_chain_explorer.clear();
        self.backup_directory.clear();
        self.auto_select_arbitrators = false;
        self.dont_show_again_map.clear();
        self.tac_accepted = false;
        self.use_tor_for_bitcoin_j = false;
        self.show_own_offers_in_offer_book = false;
        self.preferred_trade_currency.clear();
        self.withdrawal_tx_fee_in_bytes = 0;
        self.use_custom_withdrawal_tx_fee = false;
        self.max_price_distance_in_percent = 0.;
        self.offer_book_chart_screen_currency_code.clear();
        self.trade_charts_screen_currency_code.clear();
        self.buy_screen_currency_code.clear();
        self.sell_screen_currency_code.clear();
        self.trade_statistics_tick_unit_index = 0;
        self.resync_Spv_requested = false;
        self.sort_market_currencies_numerically = false;
        self.use_percentage_based_price = false;
        self.peer_tag_map.clear();
        self.bitcoin_nodes.clear();
        self.ignore_traders_list.clear();
        self.directory_chooser_path.clear();
        self.buyer_security_deposit_as_long = 0;
        self.use_animations = false;
        self.selectedPayment_account_for_createOffer.clear();
        self.pay_fee_in_Btc = false;
        self.bridge_addresses.clear();
        self.bridge_option_ordinal = 0;
        self.tor_transport_ordinal = 0;
        self.custom_bridges.clear();
        self.bitcoin_nodes_option_ordinal = 0;
        self.referral_id.clear();
        self.phone_key_and_token.clear();
        self.use_sound_for_mobile_notifications = false;
        self.use_trade_notifications = false;
        self.use_market_notifications = false;
        self.use_price_notifications = false;
        self.use_standby_mode = false;
        self.is_dao_full_node = false;
        self.rpc_user.clear();
        self.rpc_pw.clear();
        self.take_offer_selected_payment_account_id.clear();
        self.buyer_security_deposit_as_percent = 0.;
        self.ignore_dust_threshold = 0;
        self.buyer_security_deposit_as_percent_for_crypto = 0.;
        self.block_notify_port = 0;
        self.css_theme = 0;
        self.tac_accepted_v120 = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreferencesPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreferencesPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct UserPayload {
    // message fields
    pub account_id: ::std::string::String,
    pub payment_accounts: ::protobuf::RepeatedField<PaymentAccount>,
    pub current_payment_account: ::protobuf::SingularPtrField<PaymentAccount>,
    pub accepted_language_locale_codes: ::protobuf::RepeatedField<::std::string::String>,
    pub developers_alert: ::protobuf::SingularPtrField<Alert>,
    pub displayed_alert: ::protobuf::SingularPtrField<Alert>,
    pub developers_filter: ::protobuf::SingularPtrField<Filter>,
    pub accepted_arbitrators: ::protobuf::RepeatedField<Arbitrator>,
    pub accepted_mediators: ::protobuf::RepeatedField<Mediator>,
    pub registered_arbitrator: ::protobuf::SingularPtrField<Arbitrator>,
    pub registered_mediator: ::protobuf::SingularPtrField<Mediator>,
    pub price_alert_filter: ::protobuf::SingularPtrField<PriceAlertFilter>,
    pub market_alert_filters: ::protobuf::RepeatedField<MarketAlertFilter>,
    pub accepted_refund_agents: ::protobuf::RepeatedField<RefundAgent>,
    pub registered_refund_agent: ::protobuf::SingularPtrField<RefundAgent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserPayload {
    fn default() -> &'a UserPayload {
        <UserPayload as ::protobuf::Message>::default_instance()
    }
}

impl UserPayload {
    pub fn new() -> UserPayload {
        ::std::default::Default::default()
    }

    // string account_id = 1;

    pub fn get_account_id(&self) -> &str {
        &self.account_id
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: ::std::string::String) {
        self.account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut ::std::string::String {
        &mut self.account_id
    }

    // Take field
    pub fn take_account_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_id, ::std::string::String::new())
    }

    // repeated .io.bisq.protobuffer.PaymentAccount payment_accounts = 2;

    pub fn get_payment_accounts(&self) -> &[PaymentAccount] {
        &self.payment_accounts
    }
    pub fn clear_payment_accounts(&mut self) {
        self.payment_accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_accounts(&mut self, v: ::protobuf::RepeatedField<PaymentAccount>) {
        self.payment_accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_payment_accounts(&mut self) -> &mut ::protobuf::RepeatedField<PaymentAccount> {
        &mut self.payment_accounts
    }

    // Take field
    pub fn take_payment_accounts(&mut self) -> ::protobuf::RepeatedField<PaymentAccount> {
        ::std::mem::replace(&mut self.payment_accounts, ::protobuf::RepeatedField::new())
    }

    // .io.bisq.protobuffer.PaymentAccount current_payment_account = 3;

    pub fn get_current_payment_account(&self) -> &PaymentAccount {
        self.current_payment_account
            .as_ref()
            .unwrap_or_else(|| PaymentAccount::default_instance())
    }
    pub fn clear_current_payment_account(&mut self) {
        self.current_payment_account.clear();
    }

    pub fn has_current_payment_account(&self) -> bool {
        self.current_payment_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_payment_account(&mut self, v: PaymentAccount) {
        self.current_payment_account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_payment_account(&mut self) -> &mut PaymentAccount {
        if self.current_payment_account.is_none() {
            self.current_payment_account.set_default();
        }
        self.current_payment_account.as_mut().unwrap()
    }

    // Take field
    pub fn take_current_payment_account(&mut self) -> PaymentAccount {
        self.current_payment_account
            .take()
            .unwrap_or_else(|| PaymentAccount::new())
    }

    // repeated string accepted_language_locale_codes = 4;

    pub fn get_accepted_language_locale_codes(&self) -> &[::std::string::String] {
        &self.accepted_language_locale_codes
    }
    pub fn clear_accepted_language_locale_codes(&mut self) {
        self.accepted_language_locale_codes.clear();
    }

    // Param is passed by value, moved
    pub fn set_accepted_language_locale_codes(
        &mut self,
        v: ::protobuf::RepeatedField<::std::string::String>,
    ) {
        self.accepted_language_locale_codes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accepted_language_locale_codes(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accepted_language_locale_codes
    }

    // Take field
    pub fn take_accepted_language_locale_codes(
        &mut self,
    ) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(
            &mut self.accepted_language_locale_codes,
            ::protobuf::RepeatedField::new(),
        )
    }

    // .io.bisq.protobuffer.Alert developers_alert = 5;

    pub fn get_developers_alert(&self) -> &Alert {
        self.developers_alert
            .as_ref()
            .unwrap_or_else(|| Alert::default_instance())
    }
    pub fn clear_developers_alert(&mut self) {
        self.developers_alert.clear();
    }

    pub fn has_developers_alert(&self) -> bool {
        self.developers_alert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_developers_alert(&mut self, v: Alert) {
        self.developers_alert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_developers_alert(&mut self) -> &mut Alert {
        if self.developers_alert.is_none() {
            self.developers_alert.set_default();
        }
        self.developers_alert.as_mut().unwrap()
    }

    // Take field
    pub fn take_developers_alert(&mut self) -> Alert {
        self.developers_alert.take().unwrap_or_else(|| Alert::new())
    }

    // .io.bisq.protobuffer.Alert displayed_alert = 6;

    pub fn get_displayed_alert(&self) -> &Alert {
        self.displayed_alert
            .as_ref()
            .unwrap_or_else(|| Alert::default_instance())
    }
    pub fn clear_displayed_alert(&mut self) {
        self.displayed_alert.clear();
    }

    pub fn has_displayed_alert(&self) -> bool {
        self.displayed_alert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayed_alert(&mut self, v: Alert) {
        self.displayed_alert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayed_alert(&mut self) -> &mut Alert {
        if self.displayed_alert.is_none() {
            self.displayed_alert.set_default();
        }
        self.displayed_alert.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayed_alert(&mut self) -> Alert {
        self.displayed_alert.take().unwrap_or_else(|| Alert::new())
    }

    // .io.bisq.protobuffer.Filter developers_filter = 7;

    pub fn get_developers_filter(&self) -> &Filter {
        self.developers_filter
            .as_ref()
            .unwrap_or_else(|| Filter::default_instance())
    }
    pub fn clear_developers_filter(&mut self) {
        self.developers_filter.clear();
    }

    pub fn has_developers_filter(&self) -> bool {
        self.developers_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_developers_filter(&mut self, v: Filter) {
        self.developers_filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_developers_filter(&mut self) -> &mut Filter {
        if self.developers_filter.is_none() {
            self.developers_filter.set_default();
        }
        self.developers_filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_developers_filter(&mut self) -> Filter {
        self.developers_filter
            .take()
            .unwrap_or_else(|| Filter::new())
    }

    // repeated .io.bisq.protobuffer.Arbitrator accepted_arbitrators = 8;

    pub fn get_accepted_arbitrators(&self) -> &[Arbitrator] {
        &self.accepted_arbitrators
    }
    pub fn clear_accepted_arbitrators(&mut self) {
        self.accepted_arbitrators.clear();
    }

    // Param is passed by value, moved
    pub fn set_accepted_arbitrators(&mut self, v: ::protobuf::RepeatedField<Arbitrator>) {
        self.accepted_arbitrators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accepted_arbitrators(&mut self) -> &mut ::protobuf::RepeatedField<Arbitrator> {
        &mut self.accepted_arbitrators
    }

    // Take field
    pub fn take_accepted_arbitrators(&mut self) -> ::protobuf::RepeatedField<Arbitrator> {
        ::std::mem::replace(
            &mut self.accepted_arbitrators,
            ::protobuf::RepeatedField::new(),
        )
    }

    // repeated .io.bisq.protobuffer.Mediator accepted_mediators = 9;

    pub fn get_accepted_mediators(&self) -> &[Mediator] {
        &self.accepted_mediators
    }
    pub fn clear_accepted_mediators(&mut self) {
        self.accepted_mediators.clear();
    }

    // Param is passed by value, moved
    pub fn set_accepted_mediators(&mut self, v: ::protobuf::RepeatedField<Mediator>) {
        self.accepted_mediators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accepted_mediators(&mut self) -> &mut ::protobuf::RepeatedField<Mediator> {
        &mut self.accepted_mediators
    }

    // Take field
    pub fn take_accepted_mediators(&mut self) -> ::protobuf::RepeatedField<Mediator> {
        ::std::mem::replace(
            &mut self.accepted_mediators,
            ::protobuf::RepeatedField::new(),
        )
    }

    // .io.bisq.protobuffer.Arbitrator registered_arbitrator = 10;

    pub fn get_registered_arbitrator(&self) -> &Arbitrator {
        self.registered_arbitrator
            .as_ref()
            .unwrap_or_else(|| Arbitrator::default_instance())
    }
    pub fn clear_registered_arbitrator(&mut self) {
        self.registered_arbitrator.clear();
    }

    pub fn has_registered_arbitrator(&self) -> bool {
        self.registered_arbitrator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registered_arbitrator(&mut self, v: Arbitrator) {
        self.registered_arbitrator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registered_arbitrator(&mut self) -> &mut Arbitrator {
        if self.registered_arbitrator.is_none() {
            self.registered_arbitrator.set_default();
        }
        self.registered_arbitrator.as_mut().unwrap()
    }

    // Take field
    pub fn take_registered_arbitrator(&mut self) -> Arbitrator {
        self.registered_arbitrator
            .take()
            .unwrap_or_else(|| Arbitrator::new())
    }

    // .io.bisq.protobuffer.Mediator registered_mediator = 11;

    pub fn get_registered_mediator(&self) -> &Mediator {
        self.registered_mediator
            .as_ref()
            .unwrap_or_else(|| Mediator::default_instance())
    }
    pub fn clear_registered_mediator(&mut self) {
        self.registered_mediator.clear();
    }

    pub fn has_registered_mediator(&self) -> bool {
        self.registered_mediator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registered_mediator(&mut self, v: Mediator) {
        self.registered_mediator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registered_mediator(&mut self) -> &mut Mediator {
        if self.registered_mediator.is_none() {
            self.registered_mediator.set_default();
        }
        self.registered_mediator.as_mut().unwrap()
    }

    // Take field
    pub fn take_registered_mediator(&mut self) -> Mediator {
        self.registered_mediator
            .take()
            .unwrap_or_else(|| Mediator::new())
    }

    // .io.bisq.protobuffer.PriceAlertFilter price_alert_filter = 12;

    pub fn get_price_alert_filter(&self) -> &PriceAlertFilter {
        self.price_alert_filter
            .as_ref()
            .unwrap_or_else(|| PriceAlertFilter::default_instance())
    }
    pub fn clear_price_alert_filter(&mut self) {
        self.price_alert_filter.clear();
    }

    pub fn has_price_alert_filter(&self) -> bool {
        self.price_alert_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_alert_filter(&mut self, v: PriceAlertFilter) {
        self.price_alert_filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price_alert_filter(&mut self) -> &mut PriceAlertFilter {
        if self.price_alert_filter.is_none() {
            self.price_alert_filter.set_default();
        }
        self.price_alert_filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_price_alert_filter(&mut self) -> PriceAlertFilter {
        self.price_alert_filter
            .take()
            .unwrap_or_else(|| PriceAlertFilter::new())
    }

    // repeated .io.bisq.protobuffer.MarketAlertFilter market_alert_filters = 13;

    pub fn get_market_alert_filters(&self) -> &[MarketAlertFilter] {
        &self.market_alert_filters
    }
    pub fn clear_market_alert_filters(&mut self) {
        self.market_alert_filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_alert_filters(&mut self, v: ::protobuf::RepeatedField<MarketAlertFilter>) {
        self.market_alert_filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_alert_filters(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<MarketAlertFilter> {
        &mut self.market_alert_filters
    }

    // Take field
    pub fn take_market_alert_filters(&mut self) -> ::protobuf::RepeatedField<MarketAlertFilter> {
        ::std::mem::replace(
            &mut self.market_alert_filters,
            ::protobuf::RepeatedField::new(),
        )
    }

    // repeated .io.bisq.protobuffer.RefundAgent accepted_refund_agents = 14;

    pub fn get_accepted_refund_agents(&self) -> &[RefundAgent] {
        &self.accepted_refund_agents
    }
    pub fn clear_accepted_refund_agents(&mut self) {
        self.accepted_refund_agents.clear();
    }

    // Param is passed by value, moved
    pub fn set_accepted_refund_agents(&mut self, v: ::protobuf::RepeatedField<RefundAgent>) {
        self.accepted_refund_agents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accepted_refund_agents(&mut self) -> &mut ::protobuf::RepeatedField<RefundAgent> {
        &mut self.accepted_refund_agents
    }

    // Take field
    pub fn take_accepted_refund_agents(&mut self) -> ::protobuf::RepeatedField<RefundAgent> {
        ::std::mem::replace(
            &mut self.accepted_refund_agents,
            ::protobuf::RepeatedField::new(),
        )
    }

    // .io.bisq.protobuffer.RefundAgent registered_refund_agent = 15;

    pub fn get_registered_refund_agent(&self) -> &RefundAgent {
        self.registered_refund_agent
            .as_ref()
            .unwrap_or_else(|| RefundAgent::default_instance())
    }
    pub fn clear_registered_refund_agent(&mut self) {
        self.registered_refund_agent.clear();
    }

    pub fn has_registered_refund_agent(&self) -> bool {
        self.registered_refund_agent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registered_refund_agent(&mut self, v: RefundAgent) {
        self.registered_refund_agent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registered_refund_agent(&mut self) -> &mut RefundAgent {
        if self.registered_refund_agent.is_none() {
            self.registered_refund_agent.set_default();
        }
        self.registered_refund_agent.as_mut().unwrap()
    }

    // Take field
    pub fn take_registered_refund_agent(&mut self) -> RefundAgent {
        self.registered_refund_agent
            .take()
            .unwrap_or_else(|| RefundAgent::new())
    }
}

impl ::protobuf::Message for UserPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.payment_accounts {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.current_payment_account {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.developers_alert {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.displayed_alert {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.developers_filter {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.accepted_arbitrators {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.accepted_mediators {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.registered_arbitrator {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.registered_mediator {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.price_alert_filter {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.market_alert_filters {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.accepted_refund_agents {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.registered_refund_agent {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.payment_accounts,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.current_payment_account,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.accepted_language_locale_codes,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.developers_alert,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.displayed_alert,
                    )?;
                }
                7 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.developers_filter,
                    )?;
                }
                8 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.accepted_arbitrators,
                    )?;
                }
                9 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.accepted_mediators,
                    )?;
                }
                10 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.registered_arbitrator,
                    )?;
                }
                11 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.registered_mediator,
                    )?;
                }
                12 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.price_alert_filter,
                    )?;
                }
                13 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.market_alert_filters,
                    )?;
                }
                14 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.accepted_refund_agents,
                    )?;
                }
                15 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.registered_refund_agent,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_id);
        }
        for value in &self.payment_accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.current_payment_account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.accepted_language_locale_codes {
            my_size += ::protobuf::rt::string_size(4, &value);
        }
        if let Some(ref v) = self.developers_alert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.displayed_alert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.developers_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.accepted_arbitrators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.accepted_mediators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.registered_arbitrator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.registered_mediator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.price_alert_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.market_alert_filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.accepted_refund_agents {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.registered_refund_agent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.account_id.is_empty() {
            os.write_string(1, &self.account_id)?;
        }
        for v in &self.payment_accounts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.current_payment_account.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.accepted_language_locale_codes {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.developers_alert.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.displayed_alert.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.developers_filter.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.accepted_arbitrators {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.accepted_mediators {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.registered_arbitrator.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.registered_mediator.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.price_alert_filter.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.market_alert_filters {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.accepted_refund_agents {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.registered_refund_agent.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserPayload {
        UserPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_id",
                    |m: &UserPayload| &m.account_id,
                    |m: &mut UserPayload| &mut m.account_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PaymentAccount>,
                    >(
                        "payment_accounts",
                        |m: &UserPayload| &m.payment_accounts,
                        |m: &mut UserPayload| &mut m.payment_accounts,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PaymentAccount>,
                    >(
                        "current_payment_account",
                        |m: &UserPayload| &m.current_payment_account,
                        |m: &mut UserPayload| &mut m.current_payment_account,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "accepted_language_locale_codes",
                        |m: &UserPayload| &m.accepted_language_locale_codes,
                        |m: &mut UserPayload| &mut m.accepted_language_locale_codes,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Alert>,
                    >(
                        "developers_alert",
                        |m: &UserPayload| &m.developers_alert,
                        |m: &mut UserPayload| &mut m.developers_alert,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Alert>,
                    >(
                        "displayed_alert",
                        |m: &UserPayload| &m.displayed_alert,
                        |m: &mut UserPayload| &mut m.displayed_alert,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Filter>,
                    >(
                        "developers_filter",
                        |m: &UserPayload| &m.developers_filter,
                        |m: &mut UserPayload| &mut m.developers_filter,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Arbitrator>,
                    >(
                        "accepted_arbitrators",
                        |m: &UserPayload| &m.accepted_arbitrators,
                        |m: &mut UserPayload| &mut m.accepted_arbitrators,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Mediator>,
                    >(
                        "accepted_mediators",
                        |m: &UserPayload| &m.accepted_mediators,
                        |m: &mut UserPayload| &mut m.accepted_mediators,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Arbitrator>,
                    >(
                        "registered_arbitrator",
                        |m: &UserPayload| &m.registered_arbitrator,
                        |m: &mut UserPayload| &mut m.registered_arbitrator,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Mediator>,
                    >(
                        "registered_mediator",
                        |m: &UserPayload| &m.registered_mediator,
                        |m: &mut UserPayload| &mut m.registered_mediator,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PriceAlertFilter>,
                    >(
                        "price_alert_filter",
                        |m: &UserPayload| &m.price_alert_filter,
                        |m: &mut UserPayload| &mut m.price_alert_filter,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<MarketAlertFilter>,
                    >(
                        "market_alert_filters",
                        |m: &UserPayload| &m.market_alert_filters,
                        |m: &mut UserPayload| &mut m.market_alert_filters,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<RefundAgent>,
                    >(
                        "accepted_refund_agents",
                        |m: &UserPayload| &m.accepted_refund_agents,
                        |m: &mut UserPayload| &mut m.accepted_refund_agents,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<RefundAgent>,
                    >(
                        "registered_refund_agent",
                        |m: &UserPayload| &m.registered_refund_agent,
                        |m: &mut UserPayload| &mut m.registered_refund_agent,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<UserPayload>(
                    "UserPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static UserPayload {
        static mut instance: ::protobuf::lazy::Lazy<UserPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UserPayload,
        };
        unsafe { instance.get(UserPayload::new) }
    }
}

impl ::protobuf::Clear for UserPayload {
    fn clear(&mut self) {
        self.account_id.clear();
        self.payment_accounts.clear();
        self.current_payment_account.clear();
        self.accepted_language_locale_codes.clear();
        self.developers_alert.clear();
        self.displayed_alert.clear();
        self.developers_filter.clear();
        self.accepted_arbitrators.clear();
        self.accepted_mediators.clear();
        self.registered_arbitrator.clear();
        self.registered_mediator.clear();
        self.price_alert_filter.clear();
        self.market_alert_filters.clear();
        self.accepted_refund_agents.clear();
        self.registered_refund_agent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct BaseBlock {
    // message fields
    pub height: i32,
    pub time: i64,
    pub hash: ::std::string::String,
    pub previous_block_hash: ::std::string::String,
    // message oneof groups
    pub message: ::std::option::Option<BaseBlock_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BaseBlock {
    fn default() -> &'a BaseBlock {
        <BaseBlock as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum BaseBlock_oneof_message {
    raw_block(RawBlock),
    block(Block),
}

impl BaseBlock {
    pub fn new() -> BaseBlock {
        ::std::default::Default::default()
    }

    // int32 height = 1;

    pub fn get_height(&self) -> i32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = v;
    }

    // int64 time = 2;

    pub fn get_time(&self) -> i64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i64) {
        self.time = v;
    }

    // string hash = 3;

    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    // string previous_block_hash = 4;

    pub fn get_previous_block_hash(&self) -> &str {
        &self.previous_block_hash
    }
    pub fn clear_previous_block_hash(&mut self) {
        self.previous_block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_previous_block_hash(&mut self, v: ::std::string::String) {
        self.previous_block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_previous_block_hash(&mut self) -> &mut ::std::string::String {
        &mut self.previous_block_hash
    }

    // Take field
    pub fn take_previous_block_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.previous_block_hash, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.RawBlock raw_block = 5;

    pub fn get_raw_block(&self) -> &RawBlock {
        match self.message {
            ::std::option::Option::Some(BaseBlock_oneof_message::raw_block(ref v)) => v,
            _ => RawBlock::default_instance(),
        }
    }
    pub fn clear_raw_block(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_raw_block(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(BaseBlock_oneof_message::raw_block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_raw_block(&mut self, v: RawBlock) {
        self.message = ::std::option::Option::Some(BaseBlock_oneof_message::raw_block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_raw_block(&mut self) -> &mut RawBlock {
        if let ::std::option::Option::Some(BaseBlock_oneof_message::raw_block(_)) = self.message {
        } else {
            self.message =
                ::std::option::Option::Some(BaseBlock_oneof_message::raw_block(RawBlock::new()));
        }
        match self.message {
            ::std::option::Option::Some(BaseBlock_oneof_message::raw_block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_raw_block(&mut self) -> RawBlock {
        if self.has_raw_block() {
            match self.message.take() {
                ::std::option::Option::Some(BaseBlock_oneof_message::raw_block(v)) => v,
                _ => panic!(),
            }
        } else {
            RawBlock::new()
        }
    }

    // .io.bisq.protobuffer.Block block = 6;

    pub fn get_block(&self) -> &Block {
        match self.message {
            ::std::option::Option::Some(BaseBlock_oneof_message::block(ref v)) => v,
            _ => Block::default_instance(),
        }
    }
    pub fn clear_block(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_block(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(BaseBlock_oneof_message::block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: Block) {
        self.message = ::std::option::Option::Some(BaseBlock_oneof_message::block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block(&mut self) -> &mut Block {
        if let ::std::option::Option::Some(BaseBlock_oneof_message::block(_)) = self.message {
        } else {
            self.message =
                ::std::option::Option::Some(BaseBlock_oneof_message::block(Block::new()));
        }
        match self.message {
            ::std::option::Option::Some(BaseBlock_oneof_message::block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block(&mut self) -> Block {
        if self.has_block() {
            match self.message.take() {
                ::std::option::Option::Some(BaseBlock_oneof_message::block(v)) => v,
                _ => panic!(),
            }
        } else {
            Block::new()
        }
    }
}

impl ::protobuf::Message for BaseBlock {
    fn is_initialized(&self) -> bool {
        if let Some(BaseBlock_oneof_message::raw_block(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BaseBlock_oneof_message::block(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.height = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.time = tmp;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.hash,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.previous_block_hash,
                    )?;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(BaseBlock_oneof_message::raw_block(
                        is.read_message()?,
                    ));
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(BaseBlock_oneof_message::block(
                        is.read_message()?,
                    ));
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.hash);
        }
        if !self.previous_block_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.previous_block_hash);
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &BaseBlock_oneof_message::raw_block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &BaseBlock_oneof_message::block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_int32(1, self.height)?;
        }
        if self.time != 0 {
            os.write_int64(2, self.time)?;
        }
        if !self.hash.is_empty() {
            os.write_string(3, &self.hash)?;
        }
        if !self.previous_block_hash.is_empty() {
            os.write_string(4, &self.previous_block_hash)?;
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &BaseBlock_oneof_message::raw_block(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &BaseBlock_oneof_message::block(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BaseBlock {
        BaseBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "height",
                    |m: &BaseBlock| &m.height,
                    |m: &mut BaseBlock| &mut m.height,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "time",
                    |m: &BaseBlock| &m.time,
                    |m: &mut BaseBlock| &mut m.time,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "hash",
                    |m: &BaseBlock| &m.hash,
                    |m: &mut BaseBlock| &mut m.hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "previous_block_hash",
                    |m: &BaseBlock| &m.previous_block_hash,
                    |m: &mut BaseBlock| &mut m.previous_block_hash,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<_, RawBlock>(
                        "raw_block",
                        BaseBlock::has_raw_block,
                        BaseBlock::get_raw_block,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<_, Block>(
                        "block",
                        BaseBlock::has_block,
                        BaseBlock::get_block,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<BaseBlock>(
                    "BaseBlock",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static BaseBlock {
        static mut instance: ::protobuf::lazy::Lazy<BaseBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BaseBlock,
        };
        unsafe { instance.get(BaseBlock::new) }
    }
}

impl ::protobuf::Clear for BaseBlock {
    fn clear(&mut self) {
        self.height = 0;
        self.time = 0;
        self.hash.clear();
        self.previous_block_hash.clear();
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BaseBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BaseBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RawBlock {
    // message fields
    pub raw_txs: ::protobuf::RepeatedField<BaseTx>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawBlock {
    fn default() -> &'a RawBlock {
        <RawBlock as ::protobuf::Message>::default_instance()
    }
}

impl RawBlock {
    pub fn new() -> RawBlock {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.BaseTx raw_txs = 1;

    pub fn get_raw_txs(&self) -> &[BaseTx] {
        &self.raw_txs
    }
    pub fn clear_raw_txs(&mut self) {
        self.raw_txs.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_txs(&mut self, v: ::protobuf::RepeatedField<BaseTx>) {
        self.raw_txs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_raw_txs(&mut self) -> &mut ::protobuf::RepeatedField<BaseTx> {
        &mut self.raw_txs
    }

    // Take field
    pub fn take_raw_txs(&mut self) -> ::protobuf::RepeatedField<BaseTx> {
        ::std::mem::replace(&mut self.raw_txs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RawBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.raw_txs {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.raw_txs)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.raw_txs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.raw_txs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawBlock {
        RawBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BaseTx>,
                    >(
                        "raw_txs",
                        |m: &RawBlock| &m.raw_txs,
                        |m: &mut RawBlock| &mut m.raw_txs,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<RawBlock>(
                    "RawBlock",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static RawBlock {
        static mut instance: ::protobuf::lazy::Lazy<RawBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawBlock,
        };
        unsafe { instance.get(RawBlock::new) }
    }
}

impl ::protobuf::Clear for RawBlock {
    fn clear(&mut self) {
        self.raw_txs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RawBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Block {
    // message fields
    pub txs: ::protobuf::RepeatedField<BaseTx>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.BaseTx txs = 1;

    pub fn get_txs(&self) -> &[BaseTx] {
        &self.txs
    }
    pub fn clear_txs(&mut self) {
        self.txs.clear();
    }

    // Param is passed by value, moved
    pub fn set_txs(&mut self, v: ::protobuf::RepeatedField<BaseTx>) {
        self.txs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txs(&mut self) -> &mut ::protobuf::RepeatedField<BaseTx> {
        &mut self.txs
    }

    // Take field
    pub fn take_txs(&mut self) -> ::protobuf::RepeatedField<BaseTx> {
        ::std::mem::replace(&mut self.txs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        for v in &self.txs {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txs)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.txs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.txs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BaseTx>,
                    >("txs", |m: &Block| &m.txs, |m: &mut Block| &mut m.txs),
                );
                ::protobuf::reflect::MessageDescriptor::new::<Block>(
                    "Block",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Block {
        static mut instance: ::protobuf::lazy::Lazy<Block> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Block,
        };
        unsafe { instance.get(Block::new) }
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.txs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct BaseTx {
    // message fields
    pub tx_version: ::std::string::String,
    pub id: ::std::string::String,
    pub block_height: i32,
    pub block_hash: ::std::string::String,
    pub time: i64,
    pub tx_inputs: ::protobuf::RepeatedField<TxInput>,
    // message oneof groups
    pub message: ::std::option::Option<BaseTx_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BaseTx {
    fn default() -> &'a BaseTx {
        <BaseTx as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum BaseTx_oneof_message {
    raw_tx(RawTx),
    tx(Tx),
}

impl BaseTx {
    pub fn new() -> BaseTx {
        ::std::default::Default::default()
    }

    // string tx_version = 1;

    pub fn get_tx_version(&self) -> &str {
        &self.tx_version
    }
    pub fn clear_tx_version(&mut self) {
        self.tx_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_version(&mut self, v: ::std::string::String) {
        self.tx_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_version(&mut self) -> &mut ::std::string::String {
        &mut self.tx_version
    }

    // Take field
    pub fn take_tx_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_version, ::std::string::String::new())
    }

    // string id = 2;

    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // int32 block_height = 3;

    pub fn get_block_height(&self) -> i32 {
        self.block_height
    }
    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: i32) {
        self.block_height = v;
    }

    // string block_hash = 4;

    pub fn get_block_hash(&self) -> &str {
        &self.block_hash
    }
    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::string::String) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::string::String {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_hash, ::std::string::String::new())
    }

    // int64 time = 5;

    pub fn get_time(&self) -> i64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i64) {
        self.time = v;
    }

    // repeated .io.bisq.protobuffer.TxInput tx_inputs = 6;

    pub fn get_tx_inputs(&self) -> &[TxInput] {
        &self.tx_inputs
    }
    pub fn clear_tx_inputs(&mut self) {
        self.tx_inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_inputs(&mut self, v: ::protobuf::RepeatedField<TxInput>) {
        self.tx_inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tx_inputs(&mut self) -> &mut ::protobuf::RepeatedField<TxInput> {
        &mut self.tx_inputs
    }

    // Take field
    pub fn take_tx_inputs(&mut self) -> ::protobuf::RepeatedField<TxInput> {
        ::std::mem::replace(&mut self.tx_inputs, ::protobuf::RepeatedField::new())
    }

    // .io.bisq.protobuffer.RawTx raw_tx = 7;

    pub fn get_raw_tx(&self) -> &RawTx {
        match self.message {
            ::std::option::Option::Some(BaseTx_oneof_message::raw_tx(ref v)) => v,
            _ => RawTx::default_instance(),
        }
    }
    pub fn clear_raw_tx(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_raw_tx(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(BaseTx_oneof_message::raw_tx(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_raw_tx(&mut self, v: RawTx) {
        self.message = ::std::option::Option::Some(BaseTx_oneof_message::raw_tx(v))
    }

    // Mutable pointer to the field.
    pub fn mut_raw_tx(&mut self) -> &mut RawTx {
        if let ::std::option::Option::Some(BaseTx_oneof_message::raw_tx(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(BaseTx_oneof_message::raw_tx(RawTx::new()));
        }
        match self.message {
            ::std::option::Option::Some(BaseTx_oneof_message::raw_tx(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_raw_tx(&mut self) -> RawTx {
        if self.has_raw_tx() {
            match self.message.take() {
                ::std::option::Option::Some(BaseTx_oneof_message::raw_tx(v)) => v,
                _ => panic!(),
            }
        } else {
            RawTx::new()
        }
    }

    // .io.bisq.protobuffer.Tx tx = 8;

    pub fn get_tx(&self) -> &Tx {
        match self.message {
            ::std::option::Option::Some(BaseTx_oneof_message::tx(ref v)) => v,
            _ => Tx::default_instance(),
        }
    }
    pub fn clear_tx(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_tx(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(BaseTx_oneof_message::tx(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tx(&mut self, v: Tx) {
        self.message = ::std::option::Option::Some(BaseTx_oneof_message::tx(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tx(&mut self) -> &mut Tx {
        if let ::std::option::Option::Some(BaseTx_oneof_message::tx(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(BaseTx_oneof_message::tx(Tx::new()));
        }
        match self.message {
            ::std::option::Option::Some(BaseTx_oneof_message::tx(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tx(&mut self) -> Tx {
        if self.has_tx() {
            match self.message.take() {
                ::std::option::Option::Some(BaseTx_oneof_message::tx(v)) => v,
                _ => panic!(),
            }
        } else {
            Tx::new()
        }
    }
}

impl ::protobuf::Message for BaseTx {
    fn is_initialized(&self) -> bool {
        for v in &self.tx_inputs {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BaseTx_oneof_message::raw_tx(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BaseTx_oneof_message::tx(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.tx_version,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.block_height = tmp;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.block_hash,
                    )?;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.time = tmp;
                }
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tx_inputs)?;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(BaseTx_oneof_message::raw_tx(
                        is.read_message()?,
                    ));
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message =
                        ::std::option::Option::Some(BaseTx_oneof_message::tx(is.read_message()?));
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tx_version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tx_version);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.block_height,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.block_hash);
        }
        if self.time != 0 {
            my_size +=
                ::protobuf::rt::value_size(5, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tx_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &BaseTx_oneof_message::raw_tx(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &BaseTx_oneof_message::tx(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.tx_version.is_empty() {
            os.write_string(1, &self.tx_version)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if self.block_height != 0 {
            os.write_int32(3, self.block_height)?;
        }
        if !self.block_hash.is_empty() {
            os.write_string(4, &self.block_hash)?;
        }
        if self.time != 0 {
            os.write_int64(5, self.time)?;
        }
        for v in &self.tx_inputs {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &BaseTx_oneof_message::raw_tx(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &BaseTx_oneof_message::tx(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BaseTx {
        BaseTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "tx_version",
                    |m: &BaseTx| &m.tx_version,
                    |m: &mut BaseTx| &mut m.tx_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "id", |m: &BaseTx| &m.id, |m: &mut BaseTx| &mut m.id
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "block_height",
                    |m: &BaseTx| &m.block_height,
                    |m: &mut BaseTx| &mut m.block_height,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "block_hash",
                    |m: &BaseTx| &m.block_hash,
                    |m: &mut BaseTx| &mut m.block_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "time", |m: &BaseTx| &m.time, |m: &mut BaseTx| &mut m.time
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<TxInput>,
                    >(
                        "tx_inputs",
                        |m: &BaseTx| &m.tx_inputs,
                        |m: &mut BaseTx| &mut m.tx_inputs,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<_, RawTx>(
                        "raw_tx",
                        BaseTx::has_raw_tx,
                        BaseTx::get_raw_tx,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<_, Tx>(
                        "tx",
                        BaseTx::has_tx,
                        BaseTx::get_tx,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<BaseTx>(
                    "BaseTx",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static BaseTx {
        static mut instance: ::protobuf::lazy::Lazy<BaseTx> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BaseTx,
        };
        unsafe { instance.get(BaseTx::new) }
    }
}

impl ::protobuf::Clear for BaseTx {
    fn clear(&mut self) {
        self.tx_version.clear();
        self.id.clear();
        self.block_height = 0;
        self.block_hash.clear();
        self.time = 0;
        self.tx_inputs.clear();
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BaseTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BaseTx {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RawTx {
    // message fields
    pub raw_tx_outputs: ::protobuf::RepeatedField<BaseTxOutput>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawTx {
    fn default() -> &'a RawTx {
        <RawTx as ::protobuf::Message>::default_instance()
    }
}

impl RawTx {
    pub fn new() -> RawTx {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.BaseTxOutput raw_tx_outputs = 1;

    pub fn get_raw_tx_outputs(&self) -> &[BaseTxOutput] {
        &self.raw_tx_outputs
    }
    pub fn clear_raw_tx_outputs(&mut self) {
        self.raw_tx_outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_tx_outputs(&mut self, v: ::protobuf::RepeatedField<BaseTxOutput>) {
        self.raw_tx_outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_raw_tx_outputs(&mut self) -> &mut ::protobuf::RepeatedField<BaseTxOutput> {
        &mut self.raw_tx_outputs
    }

    // Take field
    pub fn take_raw_tx_outputs(&mut self) -> ::protobuf::RepeatedField<BaseTxOutput> {
        ::std::mem::replace(&mut self.raw_tx_outputs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RawTx {
    fn is_initialized(&self) -> bool {
        for v in &self.raw_tx_outputs {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.raw_tx_outputs,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.raw_tx_outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.raw_tx_outputs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawTx {
        RawTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BaseTxOutput>,
                    >(
                        "raw_tx_outputs",
                        |m: &RawTx| &m.raw_tx_outputs,
                        |m: &mut RawTx| &mut m.raw_tx_outputs,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<RawTx>(
                    "RawTx",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static RawTx {
        static mut instance: ::protobuf::lazy::Lazy<RawTx> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawTx,
        };
        unsafe { instance.get(RawTx::new) }
    }
}

impl ::protobuf::Clear for RawTx {
    fn clear(&mut self) {
        self.raw_tx_outputs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RawTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawTx {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Tx {
    // message fields
    pub tx_outputs: ::protobuf::RepeatedField<BaseTxOutput>,
    pub txType: TxType,
    pub burnt_bsq: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tx {
    fn default() -> &'a Tx {
        <Tx as ::protobuf::Message>::default_instance()
    }
}

impl Tx {
    pub fn new() -> Tx {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.BaseTxOutput tx_outputs = 1;

    pub fn get_tx_outputs(&self) -> &[BaseTxOutput] {
        &self.tx_outputs
    }
    pub fn clear_tx_outputs(&mut self) {
        self.tx_outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_outputs(&mut self, v: ::protobuf::RepeatedField<BaseTxOutput>) {
        self.tx_outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tx_outputs(&mut self) -> &mut ::protobuf::RepeatedField<BaseTxOutput> {
        &mut self.tx_outputs
    }

    // Take field
    pub fn take_tx_outputs(&mut self) -> ::protobuf::RepeatedField<BaseTxOutput> {
        ::std::mem::replace(&mut self.tx_outputs, ::protobuf::RepeatedField::new())
    }

    // .io.bisq.protobuffer.TxType txType = 2;

    pub fn get_txType(&self) -> TxType {
        self.txType
    }
    pub fn clear_txType(&mut self) {
        self.txType = TxType::PB_ERROR_TX_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_txType(&mut self, v: TxType) {
        self.txType = v;
    }

    // int64 burnt_bsq = 3;

    pub fn get_burnt_bsq(&self) -> i64 {
        self.burnt_bsq
    }
    pub fn clear_burnt_bsq(&mut self) {
        self.burnt_bsq = 0;
    }

    // Param is passed by value, moved
    pub fn set_burnt_bsq(&mut self, v: i64) {
        self.burnt_bsq = v;
    }
}

impl ::protobuf::Message for Tx {
    fn is_initialized(&self) -> bool {
        for v in &self.tx_outputs {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.tx_outputs,
                    )?;
                }
                2 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.txType,
                    2,
                    &mut self.unknown_fields,
                )?,
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.burnt_bsq = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tx_outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.txType != TxType::PB_ERROR_TX_TYPE {
            my_size += ::protobuf::rt::enum_size(2, self.txType);
        }
        if self.burnt_bsq != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.burnt_bsq,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tx_outputs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.txType != TxType::PB_ERROR_TX_TYPE {
            os.write_enum(2, self.txType.value())?;
        }
        if self.burnt_bsq != 0 {
            os.write_int64(3, self.burnt_bsq)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tx {
        Tx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BaseTxOutput>,
                    >(
                        "tx_outputs",
                        |m: &Tx| &m.tx_outputs,
                        |m: &mut Tx| &mut m.tx_outputs,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<TxType>,
                >(
                    "txType", |m: &Tx| &m.txType, |m: &mut Tx| &mut m.txType
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "burnt_bsq",
                    |m: &Tx| &m.burnt_bsq,
                    |m: &mut Tx| &mut m.burnt_bsq,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Tx>(
                    "Tx",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Tx {
        static mut instance: ::protobuf::lazy::Lazy<Tx> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Tx,
        };
        unsafe { instance.get(Tx::new) }
    }
}

impl ::protobuf::Clear for Tx {
    fn clear(&mut self) {
        self.tx_outputs.clear();
        self.txType = TxType::PB_ERROR_TX_TYPE;
        self.burnt_bsq = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tx {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct TxInput {
    // message fields
    pub connected_tx_output_tx_id: ::std::string::String,
    pub connected_tx_output_index: i32,
    pub pub_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxInput {
    fn default() -> &'a TxInput {
        <TxInput as ::protobuf::Message>::default_instance()
    }
}

impl TxInput {
    pub fn new() -> TxInput {
        ::std::default::Default::default()
    }

    // string connected_tx_output_tx_id = 1;

    pub fn get_connected_tx_output_tx_id(&self) -> &str {
        &self.connected_tx_output_tx_id
    }
    pub fn clear_connected_tx_output_tx_id(&mut self) {
        self.connected_tx_output_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_connected_tx_output_tx_id(&mut self, v: ::std::string::String) {
        self.connected_tx_output_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connected_tx_output_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.connected_tx_output_tx_id
    }

    // Take field
    pub fn take_connected_tx_output_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.connected_tx_output_tx_id,
            ::std::string::String::new(),
        )
    }

    // int32 connected_tx_output_index = 2;

    pub fn get_connected_tx_output_index(&self) -> i32 {
        self.connected_tx_output_index
    }
    pub fn clear_connected_tx_output_index(&mut self) {
        self.connected_tx_output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_connected_tx_output_index(&mut self, v: i32) {
        self.connected_tx_output_index = v;
    }

    // string pub_key = 3;

    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TxInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.connected_tx_output_tx_id,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.connected_tx_output_index = tmp;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.pub_key,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.connected_tx_output_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.connected_tx_output_tx_id);
        }
        if self.connected_tx_output_index != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.connected_tx_output_index,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.pub_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.connected_tx_output_tx_id.is_empty() {
            os.write_string(1, &self.connected_tx_output_tx_id)?;
        }
        if self.connected_tx_output_index != 0 {
            os.write_int32(2, self.connected_tx_output_index)?;
        }
        if !self.pub_key.is_empty() {
            os.write_string(3, &self.pub_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxInput {
        TxInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "connected_tx_output_tx_id",
                    |m: &TxInput| &m.connected_tx_output_tx_id,
                    |m: &mut TxInput| &mut m.connected_tx_output_tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "connected_tx_output_index",
                    |m: &TxInput| &m.connected_tx_output_index,
                    |m: &mut TxInput| &mut m.connected_tx_output_index,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "pub_key",
                    |m: &TxInput| &m.pub_key,
                    |m: &mut TxInput| &mut m.pub_key,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TxInput>(
                    "TxInput",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static TxInput {
        static mut instance: ::protobuf::lazy::Lazy<TxInput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TxInput,
        };
        unsafe { instance.get(TxInput::new) }
    }
}

impl ::protobuf::Clear for TxInput {
    fn clear(&mut self) {
        self.connected_tx_output_tx_id.clear();
        self.connected_tx_output_index = 0;
        self.pub_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxInput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct BaseTxOutput {
    // message fields
    pub index: i32,
    pub value: i64,
    pub tx_id: ::std::string::String,
    pub pub_key_script: ::protobuf::SingularPtrField<PubKeyScript>,
    pub address: ::std::string::String,
    pub op_return_data: ::std::vec::Vec<u8>,
    pub block_height: i32,
    // message oneof groups
    pub message: ::std::option::Option<BaseTxOutput_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BaseTxOutput {
    fn default() -> &'a BaseTxOutput {
        <BaseTxOutput as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum BaseTxOutput_oneof_message {
    raw_tx_output(RawTxOutput),
    tx_output(TxOutput),
}

impl BaseTxOutput {
    pub fn new() -> BaseTxOutput {
        ::std::default::Default::default()
    }

    // int32 index = 1;

    pub fn get_index(&self) -> i32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = v;
    }

    // int64 value = 2;

    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }

    // string tx_id = 3;

    pub fn get_tx_id(&self) -> &str {
        &self.tx_id
    }
    pub fn clear_tx_id(&mut self) {
        self.tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_id(&mut self, v: ::std::string::String) {
        self.tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.tx_id
    }

    // Take field
    pub fn take_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.PubKeyScript pub_key_script = 4;

    pub fn get_pub_key_script(&self) -> &PubKeyScript {
        self.pub_key_script
            .as_ref()
            .unwrap_or_else(|| PubKeyScript::default_instance())
    }
    pub fn clear_pub_key_script(&mut self) {
        self.pub_key_script.clear();
    }

    pub fn has_pub_key_script(&self) -> bool {
        self.pub_key_script.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pub_key_script(&mut self, v: PubKeyScript) {
        self.pub_key_script = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key_script(&mut self) -> &mut PubKeyScript {
        if self.pub_key_script.is_none() {
            self.pub_key_script.set_default();
        }
        self.pub_key_script.as_mut().unwrap()
    }

    // Take field
    pub fn take_pub_key_script(&mut self) -> PubKeyScript {
        self.pub_key_script
            .take()
            .unwrap_or_else(|| PubKeyScript::new())
    }

    // string address = 5;

    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // bytes op_return_data = 6;

    pub fn get_op_return_data(&self) -> &[u8] {
        &self.op_return_data
    }
    pub fn clear_op_return_data(&mut self) {
        self.op_return_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_op_return_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.op_return_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op_return_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.op_return_data
    }

    // Take field
    pub fn take_op_return_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.op_return_data, ::std::vec::Vec::new())
    }

    // int32 block_height = 7;

    pub fn get_block_height(&self) -> i32 {
        self.block_height
    }
    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: i32) {
        self.block_height = v;
    }

    // .io.bisq.protobuffer.RawTxOutput raw_tx_output = 8;

    pub fn get_raw_tx_output(&self) -> &RawTxOutput {
        match self.message {
            ::std::option::Option::Some(BaseTxOutput_oneof_message::raw_tx_output(ref v)) => v,
            _ => RawTxOutput::default_instance(),
        }
    }
    pub fn clear_raw_tx_output(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_raw_tx_output(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(BaseTxOutput_oneof_message::raw_tx_output(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_raw_tx_output(&mut self, v: RawTxOutput) {
        self.message = ::std::option::Option::Some(BaseTxOutput_oneof_message::raw_tx_output(v))
    }

    // Mutable pointer to the field.
    pub fn mut_raw_tx_output(&mut self) -> &mut RawTxOutput {
        if let ::std::option::Option::Some(BaseTxOutput_oneof_message::raw_tx_output(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(BaseTxOutput_oneof_message::raw_tx_output(
                RawTxOutput::new(),
            ));
        }
        match self.message {
            ::std::option::Option::Some(BaseTxOutput_oneof_message::raw_tx_output(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_raw_tx_output(&mut self) -> RawTxOutput {
        if self.has_raw_tx_output() {
            match self.message.take() {
                ::std::option::Option::Some(BaseTxOutput_oneof_message::raw_tx_output(v)) => v,
                _ => panic!(),
            }
        } else {
            RawTxOutput::new()
        }
    }

    // .io.bisq.protobuffer.TxOutput tx_output = 9;

    pub fn get_tx_output(&self) -> &TxOutput {
        match self.message {
            ::std::option::Option::Some(BaseTxOutput_oneof_message::tx_output(ref v)) => v,
            _ => TxOutput::default_instance(),
        }
    }
    pub fn clear_tx_output(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_tx_output(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(BaseTxOutput_oneof_message::tx_output(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tx_output(&mut self, v: TxOutput) {
        self.message = ::std::option::Option::Some(BaseTxOutput_oneof_message::tx_output(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tx_output(&mut self) -> &mut TxOutput {
        if let ::std::option::Option::Some(BaseTxOutput_oneof_message::tx_output(_)) = self.message
        {
        } else {
            self.message =
                ::std::option::Option::Some(BaseTxOutput_oneof_message::tx_output(TxOutput::new()));
        }
        match self.message {
            ::std::option::Option::Some(BaseTxOutput_oneof_message::tx_output(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tx_output(&mut self) -> TxOutput {
        if self.has_tx_output() {
            match self.message.take() {
                ::std::option::Option::Some(BaseTxOutput_oneof_message::tx_output(v)) => v,
                _ => panic!(),
            }
        } else {
            TxOutput::new()
        }
    }
}

impl ::protobuf::Message for BaseTxOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.pub_key_script {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BaseTxOutput_oneof_message::raw_tx_output(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BaseTxOutput_oneof_message::tx_output(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.index = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.tx_id,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.pub_key_script,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.address,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.op_return_data,
                    )?;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.block_height = tmp;
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        BaseTxOutput_oneof_message::raw_tx_output(is.read_message()?),
                    );
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        BaseTxOutput_oneof_message::tx_output(is.read_message()?),
                    );
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.tx_id);
        }
        if let Some(ref v) = self.pub_key_script.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.address);
        }
        if !self.op_return_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.op_return_data);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(
                7,
                self.block_height,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &BaseTxOutput_oneof_message::raw_tx_output(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &BaseTxOutput_oneof_message::tx_output(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.index != 0 {
            os.write_int32(1, self.index)?;
        }
        if self.value != 0 {
            os.write_int64(2, self.value)?;
        }
        if !self.tx_id.is_empty() {
            os.write_string(3, &self.tx_id)?;
        }
        if let Some(ref v) = self.pub_key_script.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.address.is_empty() {
            os.write_string(5, &self.address)?;
        }
        if !self.op_return_data.is_empty() {
            os.write_bytes(6, &self.op_return_data)?;
        }
        if self.block_height != 0 {
            os.write_int32(7, self.block_height)?;
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &BaseTxOutput_oneof_message::raw_tx_output(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &BaseTxOutput_oneof_message::tx_output(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BaseTxOutput {
        BaseTxOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "index",
                    |m: &BaseTxOutput| &m.index,
                    |m: &mut BaseTxOutput| &mut m.index,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "value",
                    |m: &BaseTxOutput| &m.value,
                    |m: &mut BaseTxOutput| &mut m.value,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "tx_id",
                    |m: &BaseTxOutput| &m.tx_id,
                    |m: &mut BaseTxOutput| &mut m.tx_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PubKeyScript>,
                    >(
                        "pub_key_script",
                        |m: &BaseTxOutput| &m.pub_key_script,
                        |m: &mut BaseTxOutput| &mut m.pub_key_script,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "address",
                    |m: &BaseTxOutput| &m.address,
                    |m: &mut BaseTxOutput| &mut m.address,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "op_return_data",
                    |m: &BaseTxOutput| &m.op_return_data,
                    |m: &mut BaseTxOutput| &mut m.op_return_data,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "block_height",
                    |m: &BaseTxOutput| &m.block_height,
                    |m: &mut BaseTxOutput| &mut m.block_height,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<_, RawTxOutput>(
                        "raw_tx_output",
                        BaseTxOutput::has_raw_tx_output,
                        BaseTxOutput::get_raw_tx_output,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_message_accessor::<_, TxOutput>(
                        "tx_output",
                        BaseTxOutput::has_tx_output,
                        BaseTxOutput::get_tx_output,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<BaseTxOutput>(
                    "BaseTxOutput",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static BaseTxOutput {
        static mut instance: ::protobuf::lazy::Lazy<BaseTxOutput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BaseTxOutput,
        };
        unsafe { instance.get(BaseTxOutput::new) }
    }
}

impl ::protobuf::Clear for BaseTxOutput {
    fn clear(&mut self) {
        self.index = 0;
        self.value = 0;
        self.tx_id.clear();
        self.pub_key_script.clear();
        self.address.clear();
        self.op_return_data.clear();
        self.block_height = 0;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BaseTxOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BaseTxOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct UnconfirmedTxOutput {
    // message fields
    pub index: i32,
    pub value: i64,
    pub tx_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnconfirmedTxOutput {
    fn default() -> &'a UnconfirmedTxOutput {
        <UnconfirmedTxOutput as ::protobuf::Message>::default_instance()
    }
}

impl UnconfirmedTxOutput {
    pub fn new() -> UnconfirmedTxOutput {
        ::std::default::Default::default()
    }

    // int32 index = 1;

    pub fn get_index(&self) -> i32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = v;
    }

    // int64 value = 2;

    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }

    // string tx_id = 3;

    pub fn get_tx_id(&self) -> &str {
        &self.tx_id
    }
    pub fn clear_tx_id(&mut self) {
        self.tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_id(&mut self, v: ::std::string::String) {
        self.tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.tx_id
    }

    // Take field
    pub fn take_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UnconfirmedTxOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.index = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.tx_id,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.tx_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.index != 0 {
            os.write_int32(1, self.index)?;
        }
        if self.value != 0 {
            os.write_int64(2, self.value)?;
        }
        if !self.tx_id.is_empty() {
            os.write_string(3, &self.tx_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnconfirmedTxOutput {
        UnconfirmedTxOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "index",
                    |m: &UnconfirmedTxOutput| &m.index,
                    |m: &mut UnconfirmedTxOutput| &mut m.index,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "value",
                    |m: &UnconfirmedTxOutput| &m.value,
                    |m: &mut UnconfirmedTxOutput| &mut m.value,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "tx_id",
                    |m: &UnconfirmedTxOutput| &m.tx_id,
                    |m: &mut UnconfirmedTxOutput| &mut m.tx_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnconfirmedTxOutput>(
                    "UnconfirmedTxOutput",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static UnconfirmedTxOutput {
        static mut instance: ::protobuf::lazy::Lazy<UnconfirmedTxOutput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnconfirmedTxOutput,
        };
        unsafe { instance.get(UnconfirmedTxOutput::new) }
    }
}

impl ::protobuf::Clear for UnconfirmedTxOutput {
    fn clear(&mut self) {
        self.index = 0;
        self.value = 0;
        self.tx_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnconfirmedTxOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnconfirmedTxOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RawTxOutput {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawTxOutput {
    fn default() -> &'a RawTxOutput {
        <RawTxOutput as ::protobuf::Message>::default_instance()
    }
}

impl RawTxOutput {
    pub fn new() -> RawTxOutput {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RawTxOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawTxOutput {
        RawTxOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RawTxOutput>(
                    "RawTxOutput",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static RawTxOutput {
        static mut instance: ::protobuf::lazy::Lazy<RawTxOutput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawTxOutput,
        };
        unsafe { instance.get(RawTxOutput::new) }
    }
}

impl ::protobuf::Clear for RawTxOutput {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RawTxOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawTxOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct TxOutput {
    // message fields
    pub tx_output_type: TxOutputType,
    pub lock_time: i32,
    pub unlock_block_height: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxOutput {
    fn default() -> &'a TxOutput {
        <TxOutput as ::protobuf::Message>::default_instance()
    }
}

impl TxOutput {
    pub fn new() -> TxOutput {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.TxOutputType tx_output_type = 1;

    pub fn get_tx_output_type(&self) -> TxOutputType {
        self.tx_output_type
    }
    pub fn clear_tx_output_type(&mut self) {
        self.tx_output_type = TxOutputType::PB_ERROR_TX_OUTPUT_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_tx_output_type(&mut self, v: TxOutputType) {
        self.tx_output_type = v;
    }

    // int32 lock_time = 2;

    pub fn get_lock_time(&self) -> i32 {
        self.lock_time
    }
    pub fn clear_lock_time(&mut self) {
        self.lock_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_lock_time(&mut self, v: i32) {
        self.lock_time = v;
    }

    // int32 unlock_block_height = 3;

    pub fn get_unlock_block_height(&self) -> i32 {
        self.unlock_block_height
    }
    pub fn clear_unlock_block_height(&mut self) {
        self.unlock_block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_unlock_block_height(&mut self, v: i32) {
        self.unlock_block_height = v;
    }
}

impl ::protobuf::Message for TxOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.tx_output_type,
                    1,
                    &mut self.unknown_fields,
                )?,
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.lock_time = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.unlock_block_height = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tx_output_type != TxOutputType::PB_ERROR_TX_OUTPUT_TYPE {
            my_size += ::protobuf::rt::enum_size(1, self.tx_output_type);
        }
        if self.lock_time != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.lock_time,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.unlock_block_height != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.unlock_block_height,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.tx_output_type != TxOutputType::PB_ERROR_TX_OUTPUT_TYPE {
            os.write_enum(1, self.tx_output_type.value())?;
        }
        if self.lock_time != 0 {
            os.write_int32(2, self.lock_time)?;
        }
        if self.unlock_block_height != 0 {
            os.write_int32(3, self.unlock_block_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxOutput {
        TxOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<TxOutputType>,
                >(
                    "tx_output_type",
                    |m: &TxOutput| &m.tx_output_type,
                    |m: &mut TxOutput| &mut m.tx_output_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "lock_time",
                    |m: &TxOutput| &m.lock_time,
                    |m: &mut TxOutput| &mut m.lock_time,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "unlock_block_height",
                    |m: &TxOutput| &m.unlock_block_height,
                    |m: &mut TxOutput| &mut m.unlock_block_height,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TxOutput>(
                    "TxOutput",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static TxOutput {
        static mut instance: ::protobuf::lazy::Lazy<TxOutput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TxOutput,
        };
        unsafe { instance.get(TxOutput::new) }
    }
}

impl ::protobuf::Clear for TxOutput {
    fn clear(&mut self) {
        self.tx_output_type = TxOutputType::PB_ERROR_TX_OUTPUT_TYPE;
        self.lock_time = 0;
        self.unlock_block_height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct SpentInfo {
    // message fields
    pub block_height: i64,
    pub tx_id: ::std::string::String,
    pub input_index: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpentInfo {
    fn default() -> &'a SpentInfo {
        <SpentInfo as ::protobuf::Message>::default_instance()
    }
}

impl SpentInfo {
    pub fn new() -> SpentInfo {
        ::std::default::Default::default()
    }

    // int64 block_height = 1;

    pub fn get_block_height(&self) -> i64 {
        self.block_height
    }
    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: i64) {
        self.block_height = v;
    }

    // string tx_id = 2;

    pub fn get_tx_id(&self) -> &str {
        &self.tx_id
    }
    pub fn clear_tx_id(&mut self) {
        self.tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_id(&mut self, v: ::std::string::String) {
        self.tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.tx_id
    }

    // Take field
    pub fn take_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_id, ::std::string::String::new())
    }

    // int32 input_index = 3;

    pub fn get_input_index(&self) -> i32 {
        self.input_index
    }
    pub fn clear_input_index(&mut self) {
        self.input_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_input_index(&mut self, v: i32) {
        self.input_index = v;
    }
}

impl ::protobuf::Message for SpentInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.block_height = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.tx_id,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.input_index = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.block_height,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tx_id);
        }
        if self.input_index != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.input_index,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.block_height != 0 {
            os.write_int64(1, self.block_height)?;
        }
        if !self.tx_id.is_empty() {
            os.write_string(2, &self.tx_id)?;
        }
        if self.input_index != 0 {
            os.write_int32(3, self.input_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpentInfo {
        SpentInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "block_height",
                    |m: &SpentInfo| &m.block_height,
                    |m: &mut SpentInfo| &mut m.block_height,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "tx_id",
                    |m: &SpentInfo| &m.tx_id,
                    |m: &mut SpentInfo| &mut m.tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "input_index",
                    |m: &SpentInfo| &m.input_index,
                    |m: &mut SpentInfo| &mut m.input_index,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SpentInfo>(
                    "SpentInfo",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static SpentInfo {
        static mut instance: ::protobuf::lazy::Lazy<SpentInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SpentInfo,
        };
        unsafe { instance.get(SpentInfo::new) }
    }
}

impl ::protobuf::Clear for SpentInfo {
    fn clear(&mut self) {
        self.block_height = 0;
        self.tx_id.clear();
        self.input_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpentInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PubKeyScript {
    // message fields
    pub req_sigs: i32,
    pub script_type: ScriptType,
    pub addresses: ::protobuf::RepeatedField<::std::string::String>,
    pub asm: ::std::string::String,
    pub hex: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PubKeyScript {
    fn default() -> &'a PubKeyScript {
        <PubKeyScript as ::protobuf::Message>::default_instance()
    }
}

impl PubKeyScript {
    pub fn new() -> PubKeyScript {
        ::std::default::Default::default()
    }

    // int32 req_sigs = 1;

    pub fn get_req_sigs(&self) -> i32 {
        self.req_sigs
    }
    pub fn clear_req_sigs(&mut self) {
        self.req_sigs = 0;
    }

    // Param is passed by value, moved
    pub fn set_req_sigs(&mut self, v: i32) {
        self.req_sigs = v;
    }

    // .io.bisq.protobuffer.ScriptType script_type = 2;

    pub fn get_script_type(&self) -> ScriptType {
        self.script_type
    }
    pub fn clear_script_type(&mut self) {
        self.script_type = ScriptType::PB_ERROR_SCRIPT_TYPES;
    }

    // Param is passed by value, moved
    pub fn set_script_type(&mut self, v: ScriptType) {
        self.script_type = v;
    }

    // repeated string addresses = 3;

    pub fn get_addresses(&self) -> &[::std::string::String] {
        &self.addresses
    }
    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    // string asm = 4;

    pub fn get_asm(&self) -> &str {
        &self.asm
    }
    pub fn clear_asm(&mut self) {
        self.asm.clear();
    }

    // Param is passed by value, moved
    pub fn set_asm(&mut self, v: ::std::string::String) {
        self.asm = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asm(&mut self) -> &mut ::std::string::String {
        &mut self.asm
    }

    // Take field
    pub fn take_asm(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.asm, ::std::string::String::new())
    }

    // string hex = 5;

    pub fn get_hex(&self) -> &str {
        &self.hex
    }
    pub fn clear_hex(&mut self) {
        self.hex.clear();
    }

    // Param is passed by value, moved
    pub fn set_hex(&mut self, v: ::std::string::String) {
        self.hex = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hex(&mut self) -> &mut ::std::string::String {
        &mut self.hex
    }

    // Take field
    pub fn take_hex(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hex, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PubKeyScript {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.req_sigs = tmp;
                }
                2 => ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.script_type,
                    2,
                    &mut self.unknown_fields,
                )?,
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.addresses)?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.asm)?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hex)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.req_sigs != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.req_sigs,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.script_type != ScriptType::PB_ERROR_SCRIPT_TYPES {
            my_size += ::protobuf::rt::enum_size(2, self.script_type);
        }
        for value in &self.addresses {
            my_size += ::protobuf::rt::string_size(3, &value);
        }
        if !self.asm.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.asm);
        }
        if !self.hex.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.hex);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.req_sigs != 0 {
            os.write_int32(1, self.req_sigs)?;
        }
        if self.script_type != ScriptType::PB_ERROR_SCRIPT_TYPES {
            os.write_enum(2, self.script_type.value())?;
        }
        for v in &self.addresses {
            os.write_string(3, &v)?;
        }
        if !self.asm.is_empty() {
            os.write_string(4, &self.asm)?;
        }
        if !self.hex.is_empty() {
            os.write_string(5, &self.hex)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PubKeyScript {
        PubKeyScript::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "req_sigs",
                    |m: &PubKeyScript| &m.req_sigs,
                    |m: &mut PubKeyScript| &mut m.req_sigs,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeEnum<ScriptType>,
                >(
                    "script_type",
                    |m: &PubKeyScript| &m.script_type,
                    |m: &mut PubKeyScript| &mut m.script_type,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "addresses",
                        |m: &PubKeyScript| &m.addresses,
                        |m: &mut PubKeyScript| &mut m.addresses,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "asm",
                    |m: &PubKeyScript| &m.asm,
                    |m: &mut PubKeyScript| &mut m.asm,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "hex",
                    |m: &PubKeyScript| &m.hex,
                    |m: &mut PubKeyScript| &mut m.hex,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PubKeyScript>(
                    "PubKeyScript",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PubKeyScript {
        static mut instance: ::protobuf::lazy::Lazy<PubKeyScript> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PubKeyScript,
        };
        unsafe { instance.get(PubKeyScript::new) }
    }
}

impl ::protobuf::Clear for PubKeyScript {
    fn clear(&mut self) {
        self.req_sigs = 0;
        self.script_type = ScriptType::PB_ERROR_SCRIPT_TYPES;
        self.addresses.clear();
        self.asm.clear();
        self.hex.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PubKeyScript {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubKeyScript {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct DaoPhase {
    // message fields
    pub phase_ordinal: i32,
    pub duration: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DaoPhase {
    fn default() -> &'a DaoPhase {
        <DaoPhase as ::protobuf::Message>::default_instance()
    }
}

impl DaoPhase {
    pub fn new() -> DaoPhase {
        ::std::default::Default::default()
    }

    // int32 phase_ordinal = 1;

    pub fn get_phase_ordinal(&self) -> i32 {
        self.phase_ordinal
    }
    pub fn clear_phase_ordinal(&mut self) {
        self.phase_ordinal = 0;
    }

    // Param is passed by value, moved
    pub fn set_phase_ordinal(&mut self, v: i32) {
        self.phase_ordinal = v;
    }

    // int32 duration = 2;

    pub fn get_duration(&self) -> i32 {
        self.duration
    }
    pub fn clear_duration(&mut self) {
        self.duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = v;
    }
}

impl ::protobuf::Message for DaoPhase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.phase_ordinal = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.duration = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.phase_ordinal != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.phase_ordinal,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.duration != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.duration,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.phase_ordinal != 0 {
            os.write_int32(1, self.phase_ordinal)?;
        }
        if self.duration != 0 {
            os.write_int32(2, self.duration)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DaoPhase {
        DaoPhase::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "phase_ordinal",
                    |m: &DaoPhase| &m.phase_ordinal,
                    |m: &mut DaoPhase| &mut m.phase_ordinal,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "duration",
                    |m: &DaoPhase| &m.duration,
                    |m: &mut DaoPhase| &mut m.duration,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DaoPhase>(
                    "DaoPhase",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static DaoPhase {
        static mut instance: ::protobuf::lazy::Lazy<DaoPhase> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DaoPhase,
        };
        unsafe { instance.get(DaoPhase::new) }
    }
}

impl ::protobuf::Clear for DaoPhase {
    fn clear(&mut self) {
        self.phase_ordinal = 0;
        self.duration = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DaoPhase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaoPhase {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Cycle {
    // message fields
    pub height_of_first_lock: i32,
    pub dao_phase: ::protobuf::RepeatedField<DaoPhase>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cycle {
    fn default() -> &'a Cycle {
        <Cycle as ::protobuf::Message>::default_instance()
    }
}

impl Cycle {
    pub fn new() -> Cycle {
        ::std::default::Default::default()
    }

    // int32 height_of_first_lock = 1;

    pub fn get_height_of_first_lock(&self) -> i32 {
        self.height_of_first_lock
    }
    pub fn clear_height_of_first_lock(&mut self) {
        self.height_of_first_lock = 0;
    }

    // Param is passed by value, moved
    pub fn set_height_of_first_lock(&mut self, v: i32) {
        self.height_of_first_lock = v;
    }

    // repeated .io.bisq.protobuffer.DaoPhase dao_phase = 2;

    pub fn get_dao_phase(&self) -> &[DaoPhase] {
        &self.dao_phase
    }
    pub fn clear_dao_phase(&mut self) {
        self.dao_phase.clear();
    }

    // Param is passed by value, moved
    pub fn set_dao_phase(&mut self, v: ::protobuf::RepeatedField<DaoPhase>) {
        self.dao_phase = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dao_phase(&mut self) -> &mut ::protobuf::RepeatedField<DaoPhase> {
        &mut self.dao_phase
    }

    // Take field
    pub fn take_dao_phase(&mut self) -> ::protobuf::RepeatedField<DaoPhase> {
        ::std::mem::replace(&mut self.dao_phase, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Cycle {
    fn is_initialized(&self) -> bool {
        for v in &self.dao_phase {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.height_of_first_lock = tmp;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dao_phase)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height_of_first_lock != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.height_of_first_lock,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        for value in &self.dao_phase {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.height_of_first_lock != 0 {
            os.write_int32(1, self.height_of_first_lock)?;
        }
        for v in &self.dao_phase {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cycle {
        Cycle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "height_of_first_lock",
                    |m: &Cycle| &m.height_of_first_lock,
                    |m: &mut Cycle| &mut m.height_of_first_lock,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<DaoPhase>,
                    >(
                        "dao_phase",
                        |m: &Cycle| &m.dao_phase,
                        |m: &mut Cycle| &mut m.dao_phase,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<Cycle>(
                    "Cycle",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Cycle {
        static mut instance: ::protobuf::lazy::Lazy<Cycle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Cycle,
        };
        unsafe { instance.get(Cycle::new) }
    }
}

impl ::protobuf::Clear for Cycle {
    fn clear(&mut self) {
        self.height_of_first_lock = 0;
        self.dao_phase.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cycle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cycle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct DaoState {
    // message fields
    pub chain_height: i32,
    pub blocks: ::protobuf::RepeatedField<BaseBlock>,
    pub cycles: ::protobuf::RepeatedField<Cycle>,
    pub unspent_tx_output_map: ::std::collections::HashMap<::std::string::String, BaseTxOutput>,
    pub issuance_map: ::std::collections::HashMap<::std::string::String, Issuance>,
    pub confiscated_lockup_tx_list: ::protobuf::RepeatedField<::std::string::String>,
    pub spent_info_map: ::std::collections::HashMap<::std::string::String, SpentInfo>,
    pub param_change_list: ::protobuf::RepeatedField<ParamChange>,
    pub evaluated_proposal_list: ::protobuf::RepeatedField<EvaluatedProposal>,
    pub decrypted_ballots_with_merits_list: ::protobuf::RepeatedField<DecryptedBallotsWithMerits>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DaoState {
    fn default() -> &'a DaoState {
        <DaoState as ::protobuf::Message>::default_instance()
    }
}

impl DaoState {
    pub fn new() -> DaoState {
        ::std::default::Default::default()
    }

    // int32 chain_height = 1;

    pub fn get_chain_height(&self) -> i32 {
        self.chain_height
    }
    pub fn clear_chain_height(&mut self) {
        self.chain_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_chain_height(&mut self, v: i32) {
        self.chain_height = v;
    }

    // repeated .io.bisq.protobuffer.BaseBlock blocks = 2;

    pub fn get_blocks(&self) -> &[BaseBlock] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<BaseBlock>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<BaseBlock> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<BaseBlock> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    // repeated .io.bisq.protobuffer.Cycle cycles = 3;

    pub fn get_cycles(&self) -> &[Cycle] {
        &self.cycles
    }
    pub fn clear_cycles(&mut self) {
        self.cycles.clear();
    }

    // Param is passed by value, moved
    pub fn set_cycles(&mut self, v: ::protobuf::RepeatedField<Cycle>) {
        self.cycles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cycles(&mut self) -> &mut ::protobuf::RepeatedField<Cycle> {
        &mut self.cycles
    }

    // Take field
    pub fn take_cycles(&mut self) -> ::protobuf::RepeatedField<Cycle> {
        ::std::mem::replace(&mut self.cycles, ::protobuf::RepeatedField::new())
    }

    // repeated .io.bisq.protobuffer.DaoState.UnspentTxOutputMapEntry unspent_tx_output_map = 4;

    pub fn get_unspent_tx_output_map(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, BaseTxOutput> {
        &self.unspent_tx_output_map
    }
    pub fn clear_unspent_tx_output_map(&mut self) {
        self.unspent_tx_output_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_unspent_tx_output_map(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, BaseTxOutput>,
    ) {
        self.unspent_tx_output_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unspent_tx_output_map(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, BaseTxOutput> {
        &mut self.unspent_tx_output_map
    }

    // Take field
    pub fn take_unspent_tx_output_map(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, BaseTxOutput> {
        ::std::mem::replace(
            &mut self.unspent_tx_output_map,
            ::std::collections::HashMap::new(),
        )
    }

    // repeated .io.bisq.protobuffer.DaoState.IssuanceMapEntry issuance_map = 5;

    pub fn get_issuance_map(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, Issuance> {
        &self.issuance_map
    }
    pub fn clear_issuance_map(&mut self) {
        self.issuance_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_issuance_map(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, Issuance>,
    ) {
        self.issuance_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_issuance_map(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, Issuance> {
        &mut self.issuance_map
    }

    // Take field
    pub fn take_issuance_map(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, Issuance> {
        ::std::mem::replace(&mut self.issuance_map, ::std::collections::HashMap::new())
    }

    // repeated string confiscated_lockup_tx_list = 6;

    pub fn get_confiscated_lockup_tx_list(&self) -> &[::std::string::String] {
        &self.confiscated_lockup_tx_list
    }
    pub fn clear_confiscated_lockup_tx_list(&mut self) {
        self.confiscated_lockup_tx_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_confiscated_lockup_tx_list(
        &mut self,
        v: ::protobuf::RepeatedField<::std::string::String>,
    ) {
        self.confiscated_lockup_tx_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_confiscated_lockup_tx_list(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.confiscated_lockup_tx_list
    }

    // Take field
    pub fn take_confiscated_lockup_tx_list(
        &mut self,
    ) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(
            &mut self.confiscated_lockup_tx_list,
            ::protobuf::RepeatedField::new(),
        )
    }

    // repeated .io.bisq.protobuffer.DaoState.SpentInfoMapEntry spent_info_map = 7;

    pub fn get_spent_info_map(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, SpentInfo> {
        &self.spent_info_map
    }
    pub fn clear_spent_info_map(&mut self) {
        self.spent_info_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_spent_info_map(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, SpentInfo>,
    ) {
        self.spent_info_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spent_info_map(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, SpentInfo> {
        &mut self.spent_info_map
    }

    // Take field
    pub fn take_spent_info_map(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, SpentInfo> {
        ::std::mem::replace(&mut self.spent_info_map, ::std::collections::HashMap::new())
    }

    // repeated .io.bisq.protobuffer.ParamChange param_change_list = 8;

    pub fn get_param_change_list(&self) -> &[ParamChange] {
        &self.param_change_list
    }
    pub fn clear_param_change_list(&mut self) {
        self.param_change_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_param_change_list(&mut self, v: ::protobuf::RepeatedField<ParamChange>) {
        self.param_change_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_param_change_list(&mut self) -> &mut ::protobuf::RepeatedField<ParamChange> {
        &mut self.param_change_list
    }

    // Take field
    pub fn take_param_change_list(&mut self) -> ::protobuf::RepeatedField<ParamChange> {
        ::std::mem::replace(
            &mut self.param_change_list,
            ::protobuf::RepeatedField::new(),
        )
    }

    // repeated .io.bisq.protobuffer.EvaluatedProposal evaluated_proposal_list = 9;

    pub fn get_evaluated_proposal_list(&self) -> &[EvaluatedProposal] {
        &self.evaluated_proposal_list
    }
    pub fn clear_evaluated_proposal_list(&mut self) {
        self.evaluated_proposal_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_evaluated_proposal_list(&mut self, v: ::protobuf::RepeatedField<EvaluatedProposal>) {
        self.evaluated_proposal_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_evaluated_proposal_list(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<EvaluatedProposal> {
        &mut self.evaluated_proposal_list
    }

    // Take field
    pub fn take_evaluated_proposal_list(&mut self) -> ::protobuf::RepeatedField<EvaluatedProposal> {
        ::std::mem::replace(
            &mut self.evaluated_proposal_list,
            ::protobuf::RepeatedField::new(),
        )
    }

    // repeated .io.bisq.protobuffer.DecryptedBallotsWithMerits decrypted_ballots_with_merits_list = 10;

    pub fn get_decrypted_ballots_with_merits_list(&self) -> &[DecryptedBallotsWithMerits] {
        &self.decrypted_ballots_with_merits_list
    }
    pub fn clear_decrypted_ballots_with_merits_list(&mut self) {
        self.decrypted_ballots_with_merits_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_decrypted_ballots_with_merits_list(
        &mut self,
        v: ::protobuf::RepeatedField<DecryptedBallotsWithMerits>,
    ) {
        self.decrypted_ballots_with_merits_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_decrypted_ballots_with_merits_list(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<DecryptedBallotsWithMerits> {
        &mut self.decrypted_ballots_with_merits_list
    }

    // Take field
    pub fn take_decrypted_ballots_with_merits_list(
        &mut self,
    ) -> ::protobuf::RepeatedField<DecryptedBallotsWithMerits> {
        ::std::mem::replace(
            &mut self.decrypted_ballots_with_merits_list,
            ::protobuf::RepeatedField::new(),
        )
    }
}

impl ::protobuf::Message for DaoState {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.cycles {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.param_change_list {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.evaluated_proposal_list {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.decrypted_ballots_with_merits_list {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.chain_height = tmp;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                }
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cycles)?;
                }
                4 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeMessage<BaseTxOutput>,
                    >(wire_type, is, &mut self.unspent_tx_output_map)?;
                }
                5 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeMessage<Issuance>,
                    >(wire_type, is, &mut self.issuance_map)?;
                }
                6 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.confiscated_lockup_tx_list,
                    )?;
                }
                7 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeMessage<SpentInfo>,
                    >(wire_type, is, &mut self.spent_info_map)?;
                }
                8 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.param_change_list,
                    )?;
                }
                9 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.evaluated_proposal_list,
                    )?;
                }
                10 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.decrypted_ballots_with_merits_list,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chain_height != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.chain_height,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.cycles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<BaseTxOutput>,
        >(4, &self.unspent_tx_output_map);
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<Issuance>,
        >(5, &self.issuance_map);
        for value in &self.confiscated_lockup_tx_list {
            my_size += ::protobuf::rt::string_size(6, &value);
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<SpentInfo>,
        >(7, &self.spent_info_map);
        for value in &self.param_change_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.evaluated_proposal_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.decrypted_ballots_with_merits_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.chain_height != 0 {
            os.write_int32(1, self.chain_height)?;
        }
        for v in &self.blocks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.cycles {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<BaseTxOutput>,
        >(4, &self.unspent_tx_output_map, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<Issuance>,
        >(5, &self.issuance_map, os)?;
        for v in &self.confiscated_lockup_tx_list {
            os.write_string(6, &v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<SpentInfo>,
        >(7, &self.spent_info_map, os)?;
        for v in &self.param_change_list {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.evaluated_proposal_list {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.decrypted_ballots_with_merits_list {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DaoState {
        DaoState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "chain_height",
                    |m: &DaoState| &m.chain_height,
                    |m: &mut DaoState| &mut m.chain_height,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BaseBlock>,
                    >(
                        "blocks",
                        |m: &DaoState| &m.blocks,
                        |m: &mut DaoState| &mut m.blocks,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Cycle>,
                    >(
                        "cycles",
                        |m: &DaoState| &m.cycles,
                        |m: &mut DaoState| &mut m.cycles,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeMessage<BaseTxOutput>,
                >(
                    "unspent_tx_output_map",
                    |m: &DaoState| &m.unspent_tx_output_map,
                    |m: &mut DaoState| &mut m.unspent_tx_output_map,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeMessage<Issuance>,
                >(
                    "issuance_map",
                    |m: &DaoState| &m.issuance_map,
                    |m: &mut DaoState| &mut m.issuance_map,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "confiscated_lockup_tx_list",
                        |m: &DaoState| &m.confiscated_lockup_tx_list,
                        |m: &mut DaoState| &mut m.confiscated_lockup_tx_list,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeMessage<SpentInfo>,
                >(
                    "spent_info_map",
                    |m: &DaoState| &m.spent_info_map,
                    |m: &mut DaoState| &mut m.spent_info_map,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<ParamChange>,
                    >(
                        "param_change_list",
                        |m: &DaoState| &m.param_change_list,
                        |m: &mut DaoState| &mut m.param_change_list,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<EvaluatedProposal>,
                    >(
                        "evaluated_proposal_list",
                        |m: &DaoState| &m.evaluated_proposal_list,
                        |m: &mut DaoState| &mut m.evaluated_proposal_list,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<DecryptedBallotsWithMerits>,
                    >(
                        "decrypted_ballots_with_merits_list",
                        |m: &DaoState| &m.decrypted_ballots_with_merits_list,
                        |m: &mut DaoState| &mut m.decrypted_ballots_with_merits_list,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<DaoState>(
                    "DaoState",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static DaoState {
        static mut instance: ::protobuf::lazy::Lazy<DaoState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DaoState,
        };
        unsafe { instance.get(DaoState::new) }
    }
}

impl ::protobuf::Clear for DaoState {
    fn clear(&mut self) {
        self.chain_height = 0;
        self.blocks.clear();
        self.cycles.clear();
        self.unspent_tx_output_map.clear();
        self.issuance_map.clear();
        self.confiscated_lockup_tx_list.clear();
        self.spent_info_map.clear();
        self.param_change_list.clear();
        self.evaluated_proposal_list.clear();
        self.decrypted_ballots_with_merits_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DaoState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaoState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Issuance {
    // message fields
    pub tx_id: ::std::string::String,
    pub chain_height: i32,
    pub amount: i64,
    pub pub_key: ::std::string::String,
    pub issuance_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Issuance {
    fn default() -> &'a Issuance {
        <Issuance as ::protobuf::Message>::default_instance()
    }
}

impl Issuance {
    pub fn new() -> Issuance {
        ::std::default::Default::default()
    }

    // string tx_id = 1;

    pub fn get_tx_id(&self) -> &str {
        &self.tx_id
    }
    pub fn clear_tx_id(&mut self) {
        self.tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_id(&mut self, v: ::std::string::String) {
        self.tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.tx_id
    }

    // Take field
    pub fn take_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_id, ::std::string::String::new())
    }

    // int32 chain_height = 2;

    pub fn get_chain_height(&self) -> i32 {
        self.chain_height
    }
    pub fn clear_chain_height(&mut self) {
        self.chain_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_chain_height(&mut self, v: i32) {
        self.chain_height = v;
    }

    // int64 amount = 3;

    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }

    // string pub_key = 4;

    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // string issuance_type = 5;

    pub fn get_issuance_type(&self) -> &str {
        &self.issuance_type
    }
    pub fn clear_issuance_type(&mut self) {
        self.issuance_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_issuance_type(&mut self, v: ::std::string::String) {
        self.issuance_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuance_type(&mut self) -> &mut ::std::string::String {
        &mut self.issuance_type
    }

    // Take field
    pub fn take_issuance_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.issuance_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Issuance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.tx_id,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.chain_height = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.pub_key,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.issuance_type,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tx_id);
        }
        if self.chain_height != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.chain_height,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.amount != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.pub_key);
        }
        if !self.issuance_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.issuance_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.tx_id.is_empty() {
            os.write_string(1, &self.tx_id)?;
        }
        if self.chain_height != 0 {
            os.write_int32(2, self.chain_height)?;
        }
        if self.amount != 0 {
            os.write_int64(3, self.amount)?;
        }
        if !self.pub_key.is_empty() {
            os.write_string(4, &self.pub_key)?;
        }
        if !self.issuance_type.is_empty() {
            os.write_string(5, &self.issuance_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Issuance {
        Issuance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "tx_id",
                    |m: &Issuance| &m.tx_id,
                    |m: &mut Issuance| &mut m.tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "chain_height",
                    |m: &Issuance| &m.chain_height,
                    |m: &mut Issuance| &mut m.chain_height,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "amount",
                    |m: &Issuance| &m.amount,
                    |m: &mut Issuance| &mut m.amount,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "pub_key",
                    |m: &Issuance| &m.pub_key,
                    |m: &mut Issuance| &mut m.pub_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "issuance_type",
                    |m: &Issuance| &m.issuance_type,
                    |m: &mut Issuance| &mut m.issuance_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Issuance>(
                    "Issuance",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Issuance {
        static mut instance: ::protobuf::lazy::Lazy<Issuance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Issuance,
        };
        unsafe { instance.get(Issuance::new) }
    }
}

impl ::protobuf::Clear for Issuance {
    fn clear(&mut self) {
        self.tx_id.clear();
        self.chain_height = 0;
        self.amount = 0;
        self.pub_key.clear();
        self.issuance_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Issuance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Issuance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Proposal {
    // message fields
    pub name: ::std::string::String,
    pub link: ::std::string::String,
    pub version: u32,
    pub creation_date: i64,
    pub tx_id: ::std::string::String,
    pub extra_data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // message oneof groups
    pub message: ::std::option::Option<Proposal_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Proposal {
    fn default() -> &'a Proposal {
        <Proposal as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum Proposal_oneof_message {
    compensation_proposal(CompensationProposal),
    reimbursement_proposal(ReimbursementProposal),
    change_param_proposal(ChangeParamProposal),
    role_proposal(RoleProposal),
    confiscate_bond_proposal(ConfiscateBondProposal),
    generic_proposal(GenericProposal),
    remove_asset_proposal(RemoveAssetProposal),
}

impl Proposal {
    pub fn new() -> Proposal {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string link = 2;

    pub fn get_link(&self) -> &str {
        &self.link
    }
    pub fn clear_link(&mut self) {
        self.link.clear();
    }

    // Param is passed by value, moved
    pub fn set_link(&mut self, v: ::std::string::String) {
        self.link = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link(&mut self) -> &mut ::std::string::String {
        &mut self.link
    }

    // Take field
    pub fn take_link(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link, ::std::string::String::new())
    }

    // uint32 version = 3;

    pub fn get_version(&self) -> u32 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = v;
    }

    // int64 creation_date = 4;

    pub fn get_creation_date(&self) -> i64 {
        self.creation_date
    }
    pub fn clear_creation_date(&mut self) {
        self.creation_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_date(&mut self, v: i64) {
        self.creation_date = v;
    }

    // string tx_id = 5;

    pub fn get_tx_id(&self) -> &str {
        &self.tx_id
    }
    pub fn clear_tx_id(&mut self) {
        self.tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_id(&mut self, v: ::std::string::String) {
        self.tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.tx_id
    }

    // Take field
    pub fn take_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.CompensationProposal compensation_proposal = 6;

    pub fn get_compensation_proposal(&self) -> &CompensationProposal {
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::compensation_proposal(ref v)) => v,
            _ => CompensationProposal::default_instance(),
        }
    }
    pub fn clear_compensation_proposal(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_compensation_proposal(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::compensation_proposal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_compensation_proposal(&mut self, v: CompensationProposal) {
        self.message = ::std::option::Option::Some(Proposal_oneof_message::compensation_proposal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_compensation_proposal(&mut self) -> &mut CompensationProposal {
        if let ::std::option::Option::Some(Proposal_oneof_message::compensation_proposal(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                Proposal_oneof_message::compensation_proposal(CompensationProposal::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::compensation_proposal(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_compensation_proposal(&mut self) -> CompensationProposal {
        if self.has_compensation_proposal() {
            match self.message.take() {
                ::std::option::Option::Some(Proposal_oneof_message::compensation_proposal(v)) => v,
                _ => panic!(),
            }
        } else {
            CompensationProposal::new()
        }
    }

    // .io.bisq.protobuffer.ReimbursementProposal reimbursement_proposal = 7;

    pub fn get_reimbursement_proposal(&self) -> &ReimbursementProposal {
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::reimbursement_proposal(ref v)) => v,
            _ => ReimbursementProposal::default_instance(),
        }
    }
    pub fn clear_reimbursement_proposal(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_reimbursement_proposal(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::reimbursement_proposal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reimbursement_proposal(&mut self, v: ReimbursementProposal) {
        self.message =
            ::std::option::Option::Some(Proposal_oneof_message::reimbursement_proposal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reimbursement_proposal(&mut self) -> &mut ReimbursementProposal {
        if let ::std::option::Option::Some(Proposal_oneof_message::reimbursement_proposal(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                Proposal_oneof_message::reimbursement_proposal(ReimbursementProposal::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::reimbursement_proposal(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reimbursement_proposal(&mut self) -> ReimbursementProposal {
        if self.has_reimbursement_proposal() {
            match self.message.take() {
                ::std::option::Option::Some(Proposal_oneof_message::reimbursement_proposal(v)) => v,
                _ => panic!(),
            }
        } else {
            ReimbursementProposal::new()
        }
    }

    // .io.bisq.protobuffer.ChangeParamProposal change_param_proposal = 8;

    pub fn get_change_param_proposal(&self) -> &ChangeParamProposal {
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::change_param_proposal(ref v)) => v,
            _ => ChangeParamProposal::default_instance(),
        }
    }
    pub fn clear_change_param_proposal(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_change_param_proposal(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::change_param_proposal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_change_param_proposal(&mut self, v: ChangeParamProposal) {
        self.message = ::std::option::Option::Some(Proposal_oneof_message::change_param_proposal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_change_param_proposal(&mut self) -> &mut ChangeParamProposal {
        if let ::std::option::Option::Some(Proposal_oneof_message::change_param_proposal(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                Proposal_oneof_message::change_param_proposal(ChangeParamProposal::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::change_param_proposal(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_change_param_proposal(&mut self) -> ChangeParamProposal {
        if self.has_change_param_proposal() {
            match self.message.take() {
                ::std::option::Option::Some(Proposal_oneof_message::change_param_proposal(v)) => v,
                _ => panic!(),
            }
        } else {
            ChangeParamProposal::new()
        }
    }

    // .io.bisq.protobuffer.RoleProposal role_proposal = 9;

    pub fn get_role_proposal(&self) -> &RoleProposal {
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::role_proposal(ref v)) => v,
            _ => RoleProposal::default_instance(),
        }
    }
    pub fn clear_role_proposal(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_role_proposal(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::role_proposal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_role_proposal(&mut self, v: RoleProposal) {
        self.message = ::std::option::Option::Some(Proposal_oneof_message::role_proposal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_role_proposal(&mut self) -> &mut RoleProposal {
        if let ::std::option::Option::Some(Proposal_oneof_message::role_proposal(_)) = self.message
        {
        } else {
            self.message = ::std::option::Option::Some(Proposal_oneof_message::role_proposal(
                RoleProposal::new(),
            ));
        }
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::role_proposal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_role_proposal(&mut self) -> RoleProposal {
        if self.has_role_proposal() {
            match self.message.take() {
                ::std::option::Option::Some(Proposal_oneof_message::role_proposal(v)) => v,
                _ => panic!(),
            }
        } else {
            RoleProposal::new()
        }
    }

    // .io.bisq.protobuffer.ConfiscateBondProposal confiscate_bond_proposal = 10;

    pub fn get_confiscate_bond_proposal(&self) -> &ConfiscateBondProposal {
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::confiscate_bond_proposal(
                ref v,
            )) => v,
            _ => ConfiscateBondProposal::default_instance(),
        }
    }
    pub fn clear_confiscate_bond_proposal(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_confiscate_bond_proposal(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::confiscate_bond_proposal(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_confiscate_bond_proposal(&mut self, v: ConfiscateBondProposal) {
        self.message =
            ::std::option::Option::Some(Proposal_oneof_message::confiscate_bond_proposal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_confiscate_bond_proposal(&mut self) -> &mut ConfiscateBondProposal {
        if let ::std::option::Option::Some(Proposal_oneof_message::confiscate_bond_proposal(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                Proposal_oneof_message::confiscate_bond_proposal(ConfiscateBondProposal::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::confiscate_bond_proposal(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_confiscate_bond_proposal(&mut self) -> ConfiscateBondProposal {
        if self.has_confiscate_bond_proposal() {
            match self.message.take() {
                ::std::option::Option::Some(Proposal_oneof_message::confiscate_bond_proposal(
                    v,
                )) => v,
                _ => panic!(),
            }
        } else {
            ConfiscateBondProposal::new()
        }
    }

    // .io.bisq.protobuffer.GenericProposal generic_proposal = 11;

    pub fn get_generic_proposal(&self) -> &GenericProposal {
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::generic_proposal(ref v)) => v,
            _ => GenericProposal::default_instance(),
        }
    }
    pub fn clear_generic_proposal(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_generic_proposal(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::generic_proposal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_generic_proposal(&mut self, v: GenericProposal) {
        self.message = ::std::option::Option::Some(Proposal_oneof_message::generic_proposal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_generic_proposal(&mut self) -> &mut GenericProposal {
        if let ::std::option::Option::Some(Proposal_oneof_message::generic_proposal(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(Proposal_oneof_message::generic_proposal(
                GenericProposal::new(),
            ));
        }
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::generic_proposal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_generic_proposal(&mut self) -> GenericProposal {
        if self.has_generic_proposal() {
            match self.message.take() {
                ::std::option::Option::Some(Proposal_oneof_message::generic_proposal(v)) => v,
                _ => panic!(),
            }
        } else {
            GenericProposal::new()
        }
    }

    // .io.bisq.protobuffer.RemoveAssetProposal remove_asset_proposal = 12;

    pub fn get_remove_asset_proposal(&self) -> &RemoveAssetProposal {
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::remove_asset_proposal(ref v)) => v,
            _ => RemoveAssetProposal::default_instance(),
        }
    }
    pub fn clear_remove_asset_proposal(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_remove_asset_proposal(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::remove_asset_proposal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_asset_proposal(&mut self, v: RemoveAssetProposal) {
        self.message = ::std::option::Option::Some(Proposal_oneof_message::remove_asset_proposal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_asset_proposal(&mut self) -> &mut RemoveAssetProposal {
        if let ::std::option::Option::Some(Proposal_oneof_message::remove_asset_proposal(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                Proposal_oneof_message::remove_asset_proposal(RemoveAssetProposal::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(Proposal_oneof_message::remove_asset_proposal(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_asset_proposal(&mut self) -> RemoveAssetProposal {
        if self.has_remove_asset_proposal() {
            match self.message.take() {
                ::std::option::Option::Some(Proposal_oneof_message::remove_asset_proposal(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveAssetProposal::new()
        }
    }

    // repeated .io.bisq.protobuffer.Proposal.ExtraDataEntry extra_data = 20;

    pub fn get_extra_data(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.extra_data
    }
    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_data(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ) {
        self.extra_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_data(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.extra_data
    }

    // Take field
    pub fn take_extra_data(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.extra_data, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Proposal {
    fn is_initialized(&self) -> bool {
        if let Some(Proposal_oneof_message::compensation_proposal(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Proposal_oneof_message::reimbursement_proposal(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Proposal_oneof_message::change_param_proposal(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Proposal_oneof_message::role_proposal(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Proposal_oneof_message::confiscate_bond_proposal(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Proposal_oneof_message::generic_proposal(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Proposal_oneof_message::remove_asset_proposal(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.link,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_date = tmp;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.tx_id,
                    )?;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        Proposal_oneof_message::compensation_proposal(is.read_message()?),
                    );
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        Proposal_oneof_message::reimbursement_proposal(is.read_message()?),
                    );
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        Proposal_oneof_message::change_param_proposal(is.read_message()?),
                    );
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        Proposal_oneof_message::role_proposal(is.read_message()?),
                    );
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        Proposal_oneof_message::confiscate_bond_proposal(is.read_message()?),
                    );
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        Proposal_oneof_message::generic_proposal(is.read_message()?),
                    );
                }
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        Proposal_oneof_message::remove_asset_proposal(is.read_message()?),
                    );
                }
                20 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeString,
                    >(wire_type, is, &mut self.extra_data)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.link.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.link);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.version,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.creation_date != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.creation_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.tx_id);
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(20, &self.extra_data);
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &Proposal_oneof_message::compensation_proposal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &Proposal_oneof_message::reimbursement_proposal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &Proposal_oneof_message::change_param_proposal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &Proposal_oneof_message::role_proposal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &Proposal_oneof_message::confiscate_bond_proposal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &Proposal_oneof_message::generic_proposal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &Proposal_oneof_message::remove_asset_proposal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.link.is_empty() {
            os.write_string(2, &self.link)?;
        }
        if self.version != 0 {
            os.write_uint32(3, self.version)?;
        }
        if self.creation_date != 0 {
            os.write_int64(4, self.creation_date)?;
        }
        if !self.tx_id.is_empty() {
            os.write_string(5, &self.tx_id)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(20, &self.extra_data, os)?;
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &Proposal_oneof_message::compensation_proposal(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &Proposal_oneof_message::reimbursement_proposal(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &Proposal_oneof_message::change_param_proposal(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &Proposal_oneof_message::role_proposal(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &Proposal_oneof_message::confiscate_bond_proposal(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &Proposal_oneof_message::generic_proposal(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &Proposal_oneof_message::remove_asset_proposal(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Proposal {
        Proposal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Proposal| { &m.name },
                    |m: &mut Proposal| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "link",
                    |m: &Proposal| { &m.link },
                    |m: &mut Proposal| { &mut m.link },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    |m: &Proposal| { &m.version },
                    |m: &mut Proposal| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "creation_date",
                    |m: &Proposal| { &m.creation_date },
                    |m: &mut Proposal| { &mut m.creation_date },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tx_id",
                    |m: &Proposal| { &m.tx_id },
                    |m: &mut Proposal| { &mut m.tx_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CompensationProposal>(
                    "compensation_proposal",
                    Proposal::has_compensation_proposal,
                    Proposal::get_compensation_proposal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReimbursementProposal>(
                    "reimbursement_proposal",
                    Proposal::has_reimbursement_proposal,
                    Proposal::get_reimbursement_proposal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChangeParamProposal>(
                    "change_param_proposal",
                    Proposal::has_change_param_proposal,
                    Proposal::get_change_param_proposal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RoleProposal>(
                    "role_proposal",
                    Proposal::has_role_proposal,
                    Proposal::get_role_proposal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConfiscateBondProposal>(
                    "confiscate_bond_proposal",
                    Proposal::has_confiscate_bond_proposal,
                    Proposal::get_confiscate_bond_proposal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GenericProposal>(
                    "generic_proposal",
                    Proposal::has_generic_proposal,
                    Proposal::get_generic_proposal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveAssetProposal>(
                    "remove_asset_proposal",
                    Proposal::has_remove_asset_proposal,
                    Proposal::get_remove_asset_proposal,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "extra_data",
                    |m: &Proposal| { &m.extra_data },
                    |m: &mut Proposal| { &mut m.extra_data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Proposal>(
                    "Proposal",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Proposal {
        static mut instance: ::protobuf::lazy::Lazy<Proposal> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Proposal,
        };
        unsafe { instance.get(Proposal::new) }
    }
}

impl ::protobuf::Clear for Proposal {
    fn clear(&mut self) {
        self.name.clear();
        self.link.clear();
        self.version = 0;
        self.creation_date = 0;
        self.tx_id.clear();
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.extra_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Proposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Proposal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct CompensationProposal {
    // message fields
    pub requested_bsq: i64,
    pub bsq_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompensationProposal {
    fn default() -> &'a CompensationProposal {
        <CompensationProposal as ::protobuf::Message>::default_instance()
    }
}

impl CompensationProposal {
    pub fn new() -> CompensationProposal {
        ::std::default::Default::default()
    }

    // int64 requested_bsq = 1;

    pub fn get_requested_bsq(&self) -> i64 {
        self.requested_bsq
    }
    pub fn clear_requested_bsq(&mut self) {
        self.requested_bsq = 0;
    }

    // Param is passed by value, moved
    pub fn set_requested_bsq(&mut self, v: i64) {
        self.requested_bsq = v;
    }

    // string bsq_address = 2;

    pub fn get_bsq_address(&self) -> &str {
        &self.bsq_address
    }
    pub fn clear_bsq_address(&mut self) {
        self.bsq_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_bsq_address(&mut self, v: ::std::string::String) {
        self.bsq_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bsq_address(&mut self) -> &mut ::std::string::String {
        &mut self.bsq_address
    }

    // Take field
    pub fn take_bsq_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bsq_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CompensationProposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.requested_bsq = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bsq_address,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requested_bsq != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.requested_bsq,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.bsq_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bsq_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.requested_bsq != 0 {
            os.write_int64(1, self.requested_bsq)?;
        }
        if !self.bsq_address.is_empty() {
            os.write_string(2, &self.bsq_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompensationProposal {
        CompensationProposal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "requested_bsq",
                    |m: &CompensationProposal| &m.requested_bsq,
                    |m: &mut CompensationProposal| &mut m.requested_bsq,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bsq_address",
                    |m: &CompensationProposal| &m.bsq_address,
                    |m: &mut CompensationProposal| &mut m.bsq_address,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompensationProposal>(
                    "CompensationProposal",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static CompensationProposal {
        static mut instance: ::protobuf::lazy::Lazy<CompensationProposal> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const CompensationProposal,
            };
        unsafe { instance.get(CompensationProposal::new) }
    }
}

impl ::protobuf::Clear for CompensationProposal {
    fn clear(&mut self) {
        self.requested_bsq = 0;
        self.bsq_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompensationProposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompensationProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ReimbursementProposal {
    // message fields
    pub requested_bsq: i64,
    pub bsq_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReimbursementProposal {
    fn default() -> &'a ReimbursementProposal {
        <ReimbursementProposal as ::protobuf::Message>::default_instance()
    }
}

impl ReimbursementProposal {
    pub fn new() -> ReimbursementProposal {
        ::std::default::Default::default()
    }

    // int64 requested_bsq = 1;

    pub fn get_requested_bsq(&self) -> i64 {
        self.requested_bsq
    }
    pub fn clear_requested_bsq(&mut self) {
        self.requested_bsq = 0;
    }

    // Param is passed by value, moved
    pub fn set_requested_bsq(&mut self, v: i64) {
        self.requested_bsq = v;
    }

    // string bsq_address = 2;

    pub fn get_bsq_address(&self) -> &str {
        &self.bsq_address
    }
    pub fn clear_bsq_address(&mut self) {
        self.bsq_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_bsq_address(&mut self, v: ::std::string::String) {
        self.bsq_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bsq_address(&mut self) -> &mut ::std::string::String {
        &mut self.bsq_address
    }

    // Take field
    pub fn take_bsq_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bsq_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReimbursementProposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.requested_bsq = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bsq_address,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requested_bsq != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.requested_bsq,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.bsq_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bsq_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.requested_bsq != 0 {
            os.write_int64(1, self.requested_bsq)?;
        }
        if !self.bsq_address.is_empty() {
            os.write_string(2, &self.bsq_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReimbursementProposal {
        ReimbursementProposal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "requested_bsq",
                    |m: &ReimbursementProposal| &m.requested_bsq,
                    |m: &mut ReimbursementProposal| &mut m.requested_bsq,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bsq_address",
                    |m: &ReimbursementProposal| &m.bsq_address,
                    |m: &mut ReimbursementProposal| &mut m.bsq_address,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReimbursementProposal>(
                    "ReimbursementProposal",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ReimbursementProposal {
        static mut instance: ::protobuf::lazy::Lazy<ReimbursementProposal> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ReimbursementProposal,
            };
        unsafe { instance.get(ReimbursementProposal::new) }
    }
}

impl ::protobuf::Clear for ReimbursementProposal {
    fn clear(&mut self) {
        self.requested_bsq = 0;
        self.bsq_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReimbursementProposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReimbursementProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ChangeParamProposal {
    // message fields
    pub param: ::std::string::String,
    pub param_value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeParamProposal {
    fn default() -> &'a ChangeParamProposal {
        <ChangeParamProposal as ::protobuf::Message>::default_instance()
    }
}

impl ChangeParamProposal {
    pub fn new() -> ChangeParamProposal {
        ::std::default::Default::default()
    }

    // string param = 1;

    pub fn get_param(&self) -> &str {
        &self.param
    }
    pub fn clear_param(&mut self) {
        self.param.clear();
    }

    // Param is passed by value, moved
    pub fn set_param(&mut self, v: ::std::string::String) {
        self.param = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param(&mut self) -> &mut ::std::string::String {
        &mut self.param
    }

    // Take field
    pub fn take_param(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.param, ::std::string::String::new())
    }

    // string param_value = 2;

    pub fn get_param_value(&self) -> &str {
        &self.param_value
    }
    pub fn clear_param_value(&mut self) {
        self.param_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_param_value(&mut self, v: ::std::string::String) {
        self.param_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param_value(&mut self) -> &mut ::std::string::String {
        &mut self.param_value
    }

    // Take field
    pub fn take_param_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.param_value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChangeParamProposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.param,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.param_value,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.param.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.param);
        }
        if !self.param_value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.param_value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.param.is_empty() {
            os.write_string(1, &self.param)?;
        }
        if !self.param_value.is_empty() {
            os.write_string(2, &self.param_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeParamProposal {
        ChangeParamProposal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "param",
                    |m: &ChangeParamProposal| &m.param,
                    |m: &mut ChangeParamProposal| &mut m.param,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "param_value",
                    |m: &ChangeParamProposal| &m.param_value,
                    |m: &mut ChangeParamProposal| &mut m.param_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChangeParamProposal>(
                    "ChangeParamProposal",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ChangeParamProposal {
        static mut instance: ::protobuf::lazy::Lazy<ChangeParamProposal> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangeParamProposal,
        };
        unsafe { instance.get(ChangeParamProposal::new) }
    }
}

impl ::protobuf::Clear for ChangeParamProposal {
    fn clear(&mut self) {
        self.param.clear();
        self.param_value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangeParamProposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeParamProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RoleProposal {
    // message fields
    pub role: ::protobuf::SingularPtrField<Role>,
    pub required_bond_unit: i64,
    pub unlock_time: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoleProposal {
    fn default() -> &'a RoleProposal {
        <RoleProposal as ::protobuf::Message>::default_instance()
    }
}

impl RoleProposal {
    pub fn new() -> RoleProposal {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Role role = 1;

    pub fn get_role(&self) -> &Role {
        self.role
            .as_ref()
            .unwrap_or_else(|| Role::default_instance())
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: Role) {
        self.role = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut Role {
        if self.role.is_none() {
            self.role.set_default();
        }
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> Role {
        self.role.take().unwrap_or_else(|| Role::new())
    }

    // int64 required_bond_unit = 2;

    pub fn get_required_bond_unit(&self) -> i64 {
        self.required_bond_unit
    }
    pub fn clear_required_bond_unit(&mut self) {
        self.required_bond_unit = 0;
    }

    // Param is passed by value, moved
    pub fn set_required_bond_unit(&mut self, v: i64) {
        self.required_bond_unit = v;
    }

    // int32 unlock_time = 3;

    pub fn get_unlock_time(&self) -> i32 {
        self.unlock_time
    }
    pub fn clear_unlock_time(&mut self) {
        self.unlock_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_unlock_time(&mut self, v: i32) {
        self.unlock_time = v;
    }
}

impl ::protobuf::Message for RoleProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.role {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.role)?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.required_bond_unit = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.unlock_time = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.role.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.required_bond_unit != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.required_bond_unit,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.unlock_time != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.unlock_time,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.role.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.required_bond_unit != 0 {
            os.write_int64(2, self.required_bond_unit)?;
        }
        if self.unlock_time != 0 {
            os.write_int32(3, self.unlock_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoleProposal {
        RoleProposal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Role>,
                    >(
                        "role",
                        |m: &RoleProposal| &m.role,
                        |m: &mut RoleProposal| &mut m.role,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "required_bond_unit",
                    |m: &RoleProposal| &m.required_bond_unit,
                    |m: &mut RoleProposal| &mut m.required_bond_unit,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "unlock_time",
                    |m: &RoleProposal| &m.unlock_time,
                    |m: &mut RoleProposal| &mut m.unlock_time,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RoleProposal>(
                    "RoleProposal",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static RoleProposal {
        static mut instance: ::protobuf::lazy::Lazy<RoleProposal> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoleProposal,
        };
        unsafe { instance.get(RoleProposal::new) }
    }
}

impl ::protobuf::Clear for RoleProposal {
    fn clear(&mut self) {
        self.role.clear();
        self.required_bond_unit = 0;
        self.unlock_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoleProposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoleProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ConfiscateBondProposal {
    // message fields
    pub lockup_tx_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfiscateBondProposal {
    fn default() -> &'a ConfiscateBondProposal {
        <ConfiscateBondProposal as ::protobuf::Message>::default_instance()
    }
}

impl ConfiscateBondProposal {
    pub fn new() -> ConfiscateBondProposal {
        ::std::default::Default::default()
    }

    // string lockup_tx_id = 1;

    pub fn get_lockup_tx_id(&self) -> &str {
        &self.lockup_tx_id
    }
    pub fn clear_lockup_tx_id(&mut self) {
        self.lockup_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_lockup_tx_id(&mut self, v: ::std::string::String) {
        self.lockup_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lockup_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.lockup_tx_id
    }

    // Take field
    pub fn take_lockup_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lockup_tx_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConfiscateBondProposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.lockup_tx_id,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.lockup_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.lockup_tx_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.lockup_tx_id.is_empty() {
            os.write_string(1, &self.lockup_tx_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfiscateBondProposal {
        ConfiscateBondProposal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "lockup_tx_id",
                    |m: &ConfiscateBondProposal| &m.lockup_tx_id,
                    |m: &mut ConfiscateBondProposal| &mut m.lockup_tx_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfiscateBondProposal>(
                    "ConfiscateBondProposal",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ConfiscateBondProposal {
        static mut instance: ::protobuf::lazy::Lazy<ConfiscateBondProposal> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ConfiscateBondProposal,
            };
        unsafe { instance.get(ConfiscateBondProposal::new) }
    }
}

impl ::protobuf::Clear for ConfiscateBondProposal {
    fn clear(&mut self) {
        self.lockup_tx_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfiscateBondProposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfiscateBondProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct GenericProposal {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenericProposal {
    fn default() -> &'a GenericProposal {
        <GenericProposal as ::protobuf::Message>::default_instance()
    }
}

impl GenericProposal {
    pub fn new() -> GenericProposal {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GenericProposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenericProposal {
        GenericProposal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GenericProposal>(
                    "GenericProposal",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static GenericProposal {
        static mut instance: ::protobuf::lazy::Lazy<GenericProposal> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GenericProposal,
        };
        unsafe { instance.get(GenericProposal::new) }
    }
}

impl ::protobuf::Clear for GenericProposal {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenericProposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RemoveAssetProposal {
    // message fields
    pub ticker_symbol: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveAssetProposal {
    fn default() -> &'a RemoveAssetProposal {
        <RemoveAssetProposal as ::protobuf::Message>::default_instance()
    }
}

impl RemoveAssetProposal {
    pub fn new() -> RemoveAssetProposal {
        ::std::default::Default::default()
    }

    // string ticker_symbol = 1;

    pub fn get_ticker_symbol(&self) -> &str {
        &self.ticker_symbol
    }
    pub fn clear_ticker_symbol(&mut self) {
        self.ticker_symbol.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker_symbol(&mut self, v: ::std::string::String) {
        self.ticker_symbol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker_symbol(&mut self) -> &mut ::std::string::String {
        &mut self.ticker_symbol
    }

    // Take field
    pub fn take_ticker_symbol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker_symbol, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemoveAssetProposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.ticker_symbol,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ticker_symbol.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ticker_symbol);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.ticker_symbol.is_empty() {
            os.write_string(1, &self.ticker_symbol)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveAssetProposal {
        RemoveAssetProposal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "ticker_symbol",
                    |m: &RemoveAssetProposal| &m.ticker_symbol,
                    |m: &mut RemoveAssetProposal| &mut m.ticker_symbol,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveAssetProposal>(
                    "RemoveAssetProposal",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveAssetProposal {
        static mut instance: ::protobuf::lazy::Lazy<RemoveAssetProposal> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveAssetProposal,
        };
        unsafe { instance.get(RemoveAssetProposal::new) }
    }
}

impl ::protobuf::Clear for RemoveAssetProposal {
    fn clear(&mut self) {
        self.ticker_symbol.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveAssetProposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveAssetProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Role {
    // message fields
    pub uid: ::std::string::String,
    pub name: ::std::string::String,
    pub link: ::std::string::String,
    pub bonded_role_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Role {
    fn default() -> &'a Role {
        <Role as ::protobuf::Message>::default_instance()
    }
}

impl Role {
    pub fn new() -> Role {
        ::std::default::Default::default()
    }

    // string uid = 1;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // string name = 2;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string link = 3;

    pub fn get_link(&self) -> &str {
        &self.link
    }
    pub fn clear_link(&mut self) {
        self.link.clear();
    }

    // Param is passed by value, moved
    pub fn set_link(&mut self, v: ::std::string::String) {
        self.link = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link(&mut self) -> &mut ::std::string::String {
        &mut self.link
    }

    // Take field
    pub fn take_link(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link, ::std::string::String::new())
    }

    // string bonded_role_type = 4;

    pub fn get_bonded_role_type(&self) -> &str {
        &self.bonded_role_type
    }
    pub fn clear_bonded_role_type(&mut self) {
        self.bonded_role_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_bonded_role_type(&mut self, v: ::std::string::String) {
        self.bonded_role_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bonded_role_type(&mut self) -> &mut ::std::string::String {
        &mut self.bonded_role_type
    }

    // Take field
    pub fn take_bonded_role_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bonded_role_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Role {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.link,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bonded_role_type,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.link.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.link);
        }
        if !self.bonded_role_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.bonded_role_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.link.is_empty() {
            os.write_string(3, &self.link)?;
        }
        if !self.bonded_role_type.is_empty() {
            os.write_string(4, &self.bonded_role_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Role {
        Role::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid", |m: &Role| &m.uid, |m: &mut Role| &mut m.uid
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "name", |m: &Role| &m.name, |m: &mut Role| &mut m.name
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "link", |m: &Role| &m.link, |m: &mut Role| &mut m.link
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bonded_role_type",
                    |m: &Role| &m.bonded_role_type,
                    |m: &mut Role| &mut m.bonded_role_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Role>(
                    "Role",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Role {
        static mut instance: ::protobuf::lazy::Lazy<Role> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Role,
        };
        unsafe { instance.get(Role::new) }
    }
}

impl ::protobuf::Clear for Role {
    fn clear(&mut self) {
        self.uid.clear();
        self.name.clear();
        self.link.clear();
        self.bonded_role_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Role {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Role {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MyReputation {
    // message fields
    pub uid: ::std::string::String,
    pub salt: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MyReputation {
    fn default() -> &'a MyReputation {
        <MyReputation as ::protobuf::Message>::default_instance()
    }
}

impl MyReputation {
    pub fn new() -> MyReputation {
        ::std::default::Default::default()
    }

    // string uid = 1;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // bytes salt = 2;

    pub fn get_salt(&self) -> &[u8] {
        &self.salt
    }
    pub fn clear_salt(&mut self) {
        self.salt.clear();
    }

    // Param is passed by value, moved
    pub fn set_salt(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.salt
    }

    // Take field
    pub fn take_salt(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.salt, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MyReputation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.salt)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if !self.salt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.salt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if !self.salt.is_empty() {
            os.write_bytes(2, &self.salt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MyReputation {
        MyReputation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &MyReputation| &m.uid,
                    |m: &mut MyReputation| &mut m.uid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "salt",
                    |m: &MyReputation| &m.salt,
                    |m: &mut MyReputation| &mut m.salt,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MyReputation>(
                    "MyReputation",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MyReputation {
        static mut instance: ::protobuf::lazy::Lazy<MyReputation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MyReputation,
        };
        unsafe { instance.get(MyReputation::new) }
    }
}

impl ::protobuf::Clear for MyReputation {
    fn clear(&mut self) {
        self.uid.clear();
        self.salt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MyReputation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyReputation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MyReputationList {
    // message fields
    pub my_reputation: ::protobuf::RepeatedField<MyReputation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MyReputationList {
    fn default() -> &'a MyReputationList {
        <MyReputationList as ::protobuf::Message>::default_instance()
    }
}

impl MyReputationList {
    pub fn new() -> MyReputationList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.MyReputation my_reputation = 1;

    pub fn get_my_reputation(&self) -> &[MyReputation] {
        &self.my_reputation
    }
    pub fn clear_my_reputation(&mut self) {
        self.my_reputation.clear();
    }

    // Param is passed by value, moved
    pub fn set_my_reputation(&mut self, v: ::protobuf::RepeatedField<MyReputation>) {
        self.my_reputation = v;
    }

    // Mutable pointer to the field.
    pub fn mut_my_reputation(&mut self) -> &mut ::protobuf::RepeatedField<MyReputation> {
        &mut self.my_reputation
    }

    // Take field
    pub fn take_my_reputation(&mut self) -> ::protobuf::RepeatedField<MyReputation> {
        ::std::mem::replace(&mut self.my_reputation, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MyReputationList {
    fn is_initialized(&self) -> bool {
        for v in &self.my_reputation {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.my_reputation,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.my_reputation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.my_reputation {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MyReputationList {
        MyReputationList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<MyReputation>,
                    >(
                        "my_reputation",
                        |m: &MyReputationList| &m.my_reputation,
                        |m: &mut MyReputationList| &mut m.my_reputation,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<MyReputationList>(
                    "MyReputationList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MyReputationList {
        static mut instance: ::protobuf::lazy::Lazy<MyReputationList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MyReputationList,
        };
        unsafe { instance.get(MyReputationList::new) }
    }
}

impl ::protobuf::Clear for MyReputationList {
    fn clear(&mut self) {
        self.my_reputation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MyReputationList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyReputationList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MyProofOfBurn {
    // message fields
    pub tx_id: ::std::string::String,
    pub pre_image: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MyProofOfBurn {
    fn default() -> &'a MyProofOfBurn {
        <MyProofOfBurn as ::protobuf::Message>::default_instance()
    }
}

impl MyProofOfBurn {
    pub fn new() -> MyProofOfBurn {
        ::std::default::Default::default()
    }

    // string tx_id = 1;

    pub fn get_tx_id(&self) -> &str {
        &self.tx_id
    }
    pub fn clear_tx_id(&mut self) {
        self.tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_id(&mut self, v: ::std::string::String) {
        self.tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.tx_id
    }

    // Take field
    pub fn take_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_id, ::std::string::String::new())
    }

    // string pre_image = 2;

    pub fn get_pre_image(&self) -> &str {
        &self.pre_image
    }
    pub fn clear_pre_image(&mut self) {
        self.pre_image.clear();
    }

    // Param is passed by value, moved
    pub fn set_pre_image(&mut self, v: ::std::string::String) {
        self.pre_image = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pre_image(&mut self) -> &mut ::std::string::String {
        &mut self.pre_image
    }

    // Take field
    pub fn take_pre_image(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pre_image, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MyProofOfBurn {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.tx_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.pre_image,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tx_id);
        }
        if !self.pre_image.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.pre_image);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.tx_id.is_empty() {
            os.write_string(1, &self.tx_id)?;
        }
        if !self.pre_image.is_empty() {
            os.write_string(2, &self.pre_image)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MyProofOfBurn {
        MyProofOfBurn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "tx_id",
                    |m: &MyProofOfBurn| &m.tx_id,
                    |m: &mut MyProofOfBurn| &mut m.tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "pre_image",
                    |m: &MyProofOfBurn| &m.pre_image,
                    |m: &mut MyProofOfBurn| &mut m.pre_image,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MyProofOfBurn>(
                    "MyProofOfBurn",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MyProofOfBurn {
        static mut instance: ::protobuf::lazy::Lazy<MyProofOfBurn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MyProofOfBurn,
        };
        unsafe { instance.get(MyProofOfBurn::new) }
    }
}

impl ::protobuf::Clear for MyProofOfBurn {
    fn clear(&mut self) {
        self.tx_id.clear();
        self.pre_image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MyProofOfBurn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyProofOfBurn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MyProofOfBurnList {
    // message fields
    pub my_proof_of_burn: ::protobuf::RepeatedField<MyProofOfBurn>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MyProofOfBurnList {
    fn default() -> &'a MyProofOfBurnList {
        <MyProofOfBurnList as ::protobuf::Message>::default_instance()
    }
}

impl MyProofOfBurnList {
    pub fn new() -> MyProofOfBurnList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.MyProofOfBurn my_proof_of_burn = 1;

    pub fn get_my_proof_of_burn(&self) -> &[MyProofOfBurn] {
        &self.my_proof_of_burn
    }
    pub fn clear_my_proof_of_burn(&mut self) {
        self.my_proof_of_burn.clear();
    }

    // Param is passed by value, moved
    pub fn set_my_proof_of_burn(&mut self, v: ::protobuf::RepeatedField<MyProofOfBurn>) {
        self.my_proof_of_burn = v;
    }

    // Mutable pointer to the field.
    pub fn mut_my_proof_of_burn(&mut self) -> &mut ::protobuf::RepeatedField<MyProofOfBurn> {
        &mut self.my_proof_of_burn
    }

    // Take field
    pub fn take_my_proof_of_burn(&mut self) -> ::protobuf::RepeatedField<MyProofOfBurn> {
        ::std::mem::replace(&mut self.my_proof_of_burn, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MyProofOfBurnList {
    fn is_initialized(&self) -> bool {
        for v in &self.my_proof_of_burn {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.my_proof_of_burn,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.my_proof_of_burn {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.my_proof_of_burn {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MyProofOfBurnList {
        MyProofOfBurnList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<MyProofOfBurn>,
                    >(
                        "my_proof_of_burn",
                        |m: &MyProofOfBurnList| &m.my_proof_of_burn,
                        |m: &mut MyProofOfBurnList| &mut m.my_proof_of_burn,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<MyProofOfBurnList>(
                    "MyProofOfBurnList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MyProofOfBurnList {
        static mut instance: ::protobuf::lazy::Lazy<MyProofOfBurnList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MyProofOfBurnList,
        };
        unsafe { instance.get(MyProofOfBurnList::new) }
    }
}

impl ::protobuf::Clear for MyProofOfBurnList {
    fn clear(&mut self) {
        self.my_proof_of_burn.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MyProofOfBurnList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyProofOfBurnList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct UnconfirmedBsqChangeOutputList {
    // message fields
    pub unconfirmed_tx_output: ::protobuf::RepeatedField<UnconfirmedTxOutput>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnconfirmedBsqChangeOutputList {
    fn default() -> &'a UnconfirmedBsqChangeOutputList {
        <UnconfirmedBsqChangeOutputList as ::protobuf::Message>::default_instance()
    }
}

impl UnconfirmedBsqChangeOutputList {
    pub fn new() -> UnconfirmedBsqChangeOutputList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.UnconfirmedTxOutput unconfirmed_tx_output = 1;

    pub fn get_unconfirmed_tx_output(&self) -> &[UnconfirmedTxOutput] {
        &self.unconfirmed_tx_output
    }
    pub fn clear_unconfirmed_tx_output(&mut self) {
        self.unconfirmed_tx_output.clear();
    }

    // Param is passed by value, moved
    pub fn set_unconfirmed_tx_output(&mut self, v: ::protobuf::RepeatedField<UnconfirmedTxOutput>) {
        self.unconfirmed_tx_output = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unconfirmed_tx_output(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<UnconfirmedTxOutput> {
        &mut self.unconfirmed_tx_output
    }

    // Take field
    pub fn take_unconfirmed_tx_output(&mut self) -> ::protobuf::RepeatedField<UnconfirmedTxOutput> {
        ::std::mem::replace(
            &mut self.unconfirmed_tx_output,
            ::protobuf::RepeatedField::new(),
        )
    }
}

impl ::protobuf::Message for UnconfirmedBsqChangeOutputList {
    fn is_initialized(&self) -> bool {
        for v in &self.unconfirmed_tx_output {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.unconfirmed_tx_output,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.unconfirmed_tx_output {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.unconfirmed_tx_output {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnconfirmedBsqChangeOutputList {
        UnconfirmedBsqChangeOutputList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<UnconfirmedTxOutput>,
                    >(
                        "unconfirmed_tx_output",
                        |m: &UnconfirmedBsqChangeOutputList| &m.unconfirmed_tx_output,
                        |m: &mut UnconfirmedBsqChangeOutputList| &mut m.unconfirmed_tx_output,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<UnconfirmedBsqChangeOutputList>(
                    "UnconfirmedBsqChangeOutputList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static UnconfirmedBsqChangeOutputList {
        static mut instance: ::protobuf::lazy::Lazy<UnconfirmedBsqChangeOutputList> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const UnconfirmedBsqChangeOutputList,
            };
        unsafe { instance.get(UnconfirmedBsqChangeOutputList::new) }
    }
}

impl ::protobuf::Clear for UnconfirmedBsqChangeOutputList {
    fn clear(&mut self) {
        self.unconfirmed_tx_output.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnconfirmedBsqChangeOutputList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnconfirmedBsqChangeOutputList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct TempProposalPayload {
    // message fields
    pub proposal: ::protobuf::SingularPtrField<Proposal>,
    pub owner_pub_key_encoded: ::std::vec::Vec<u8>,
    pub extra_data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TempProposalPayload {
    fn default() -> &'a TempProposalPayload {
        <TempProposalPayload as ::protobuf::Message>::default_instance()
    }
}

impl TempProposalPayload {
    pub fn new() -> TempProposalPayload {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Proposal proposal = 1;

    pub fn get_proposal(&self) -> &Proposal {
        self.proposal
            .as_ref()
            .unwrap_or_else(|| Proposal::default_instance())
    }
    pub fn clear_proposal(&mut self) {
        self.proposal.clear();
    }

    pub fn has_proposal(&self) -> bool {
        self.proposal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proposal(&mut self, v: Proposal) {
        self.proposal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposal(&mut self) -> &mut Proposal {
        if self.proposal.is_none() {
            self.proposal.set_default();
        }
        self.proposal.as_mut().unwrap()
    }

    // Take field
    pub fn take_proposal(&mut self) -> Proposal {
        self.proposal.take().unwrap_or_else(|| Proposal::new())
    }

    // bytes owner_pub_key_encoded = 2;

    pub fn get_owner_pub_key_encoded(&self) -> &[u8] {
        &self.owner_pub_key_encoded
    }
    pub fn clear_owner_pub_key_encoded(&mut self) {
        self.owner_pub_key_encoded.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_pub_key_encoded(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_pub_key_encoded = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_pub_key_encoded(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_pub_key_encoded
    }

    // Take field
    pub fn take_owner_pub_key_encoded(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_pub_key_encoded, ::std::vec::Vec::new())
    }

    // repeated .io.bisq.protobuffer.TempProposalPayload.ExtraDataEntry extra_data = 3;

    pub fn get_extra_data(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.extra_data
    }
    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_data(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ) {
        self.extra_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_data(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.extra_data
    }

    // Take field
    pub fn take_extra_data(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.extra_data, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for TempProposalPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.proposal {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proposal)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.owner_pub_key_encoded,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeString,
                    >(wire_type, is, &mut self.extra_data)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.proposal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.owner_pub_key_encoded.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.owner_pub_key_encoded);
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(3, &self.extra_data);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.proposal.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.owner_pub_key_encoded.is_empty() {
            os.write_bytes(2, &self.owner_pub_key_encoded)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(3, &self.extra_data, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TempProposalPayload {
        TempProposalPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Proposal>,
                    >(
                        "proposal",
                        |m: &TempProposalPayload| &m.proposal,
                        |m: &mut TempProposalPayload| &mut m.proposal,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "owner_pub_key_encoded",
                    |m: &TempProposalPayload| &m.owner_pub_key_encoded,
                    |m: &mut TempProposalPayload| &mut m.owner_pub_key_encoded,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "extra_data",
                    |m: &TempProposalPayload| &m.extra_data,
                    |m: &mut TempProposalPayload| &mut m.extra_data,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TempProposalPayload>(
                    "TempProposalPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static TempProposalPayload {
        static mut instance: ::protobuf::lazy::Lazy<TempProposalPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TempProposalPayload,
        };
        unsafe { instance.get(TempProposalPayload::new) }
    }
}

impl ::protobuf::Clear for TempProposalPayload {
    fn clear(&mut self) {
        self.proposal.clear();
        self.owner_pub_key_encoded.clear();
        self.extra_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TempProposalPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TempProposalPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ProposalPayload {
    // message fields
    pub proposal: ::protobuf::SingularPtrField<Proposal>,
    pub hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposalPayload {
    fn default() -> &'a ProposalPayload {
        <ProposalPayload as ::protobuf::Message>::default_instance()
    }
}

impl ProposalPayload {
    pub fn new() -> ProposalPayload {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Proposal proposal = 1;

    pub fn get_proposal(&self) -> &Proposal {
        self.proposal
            .as_ref()
            .unwrap_or_else(|| Proposal::default_instance())
    }
    pub fn clear_proposal(&mut self) {
        self.proposal.clear();
    }

    pub fn has_proposal(&self) -> bool {
        self.proposal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proposal(&mut self, v: Proposal) {
        self.proposal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposal(&mut self) -> &mut Proposal {
        if self.proposal.is_none() {
            self.proposal.set_default();
        }
        self.proposal.as_mut().unwrap()
    }

    // Take field
    pub fn take_proposal(&mut self) -> Proposal {
        self.proposal.take().unwrap_or_else(|| Proposal::new())
    }

    // bytes hash = 2;

    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ProposalPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.proposal {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proposal)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.proposal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.proposal.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposalPayload {
        ProposalPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Proposal>,
                    >(
                        "proposal",
                        |m: &ProposalPayload| &m.proposal,
                        |m: &mut ProposalPayload| &mut m.proposal,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "hash",
                    |m: &ProposalPayload| &m.hash,
                    |m: &mut ProposalPayload| &mut m.hash,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProposalPayload>(
                    "ProposalPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ProposalPayload {
        static mut instance: ::protobuf::lazy::Lazy<ProposalPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProposalPayload,
        };
        unsafe { instance.get(ProposalPayload::new) }
    }
}

impl ::protobuf::Clear for ProposalPayload {
    fn clear(&mut self) {
        self.proposal.clear();
        self.hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposalPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposalPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ProposalStore {
    // message fields
    pub items: ::protobuf::RepeatedField<ProposalPayload>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposalStore {
    fn default() -> &'a ProposalStore {
        <ProposalStore as ::protobuf::Message>::default_instance()
    }
}

impl ProposalStore {
    pub fn new() -> ProposalStore {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.ProposalPayload items = 1;

    pub fn get_items(&self) -> &[ProposalPayload] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ProposalPayload>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ProposalPayload> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ProposalPayload> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ProposalStore {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposalStore {
        ProposalStore::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<ProposalPayload>,
                    >(
                        "items",
                        |m: &ProposalStore| &m.items,
                        |m: &mut ProposalStore| &mut m.items,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<ProposalStore>(
                    "ProposalStore",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ProposalStore {
        static mut instance: ::protobuf::lazy::Lazy<ProposalStore> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProposalStore,
        };
        unsafe { instance.get(ProposalStore::new) }
    }
}

impl ::protobuf::Clear for ProposalStore {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposalStore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposalStore {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct TempProposalStore {
    // message fields
    pub items: ::protobuf::RepeatedField<ProtectedStorageEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TempProposalStore {
    fn default() -> &'a TempProposalStore {
        <TempProposalStore as ::protobuf::Message>::default_instance()
    }
}

impl TempProposalStore {
    pub fn new() -> TempProposalStore {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.ProtectedStorageEntry items = 1;

    pub fn get_items(&self) -> &[ProtectedStorageEntry] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ProtectedStorageEntry>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ProtectedStorageEntry> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ProtectedStorageEntry> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TempProposalStore {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TempProposalStore {
        TempProposalStore::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<ProtectedStorageEntry>,
                    >(
                        "items",
                        |m: &TempProposalStore| &m.items,
                        |m: &mut TempProposalStore| &mut m.items,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<TempProposalStore>(
                    "TempProposalStore",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static TempProposalStore {
        static mut instance: ::protobuf::lazy::Lazy<TempProposalStore> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TempProposalStore,
        };
        unsafe { instance.get(TempProposalStore::new) }
    }
}

impl ::protobuf::Clear for TempProposalStore {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TempProposalStore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TempProposalStore {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Ballot {
    // message fields
    pub proposal: ::protobuf::SingularPtrField<Proposal>,
    pub vote: ::protobuf::SingularPtrField<Vote>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ballot {
    fn default() -> &'a Ballot {
        <Ballot as ::protobuf::Message>::default_instance()
    }
}

impl Ballot {
    pub fn new() -> Ballot {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Proposal proposal = 1;

    pub fn get_proposal(&self) -> &Proposal {
        self.proposal
            .as_ref()
            .unwrap_or_else(|| Proposal::default_instance())
    }
    pub fn clear_proposal(&mut self) {
        self.proposal.clear();
    }

    pub fn has_proposal(&self) -> bool {
        self.proposal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proposal(&mut self, v: Proposal) {
        self.proposal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposal(&mut self) -> &mut Proposal {
        if self.proposal.is_none() {
            self.proposal.set_default();
        }
        self.proposal.as_mut().unwrap()
    }

    // Take field
    pub fn take_proposal(&mut self) -> Proposal {
        self.proposal.take().unwrap_or_else(|| Proposal::new())
    }

    // .io.bisq.protobuffer.Vote vote = 2;

    pub fn get_vote(&self) -> &Vote {
        self.vote
            .as_ref()
            .unwrap_or_else(|| Vote::default_instance())
    }
    pub fn clear_vote(&mut self) {
        self.vote.clear();
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: Vote) {
        self.vote = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vote(&mut self) -> &mut Vote {
        if self.vote.is_none() {
            self.vote.set_default();
        }
        self.vote.as_mut().unwrap()
    }

    // Take field
    pub fn take_vote(&mut self) -> Vote {
        self.vote.take().unwrap_or_else(|| Vote::new())
    }
}

impl ::protobuf::Message for Ballot {
    fn is_initialized(&self) -> bool {
        for v in &self.proposal {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.vote {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proposal)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vote)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.proposal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.proposal.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vote.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ballot {
        Ballot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Proposal>,
                    >(
                        "proposal",
                        |m: &Ballot| &m.proposal,
                        |m: &mut Ballot| &mut m.proposal,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Vote>,
                    >(
                        "vote", |m: &Ballot| &m.vote, |m: &mut Ballot| &mut m.vote
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<Ballot>(
                    "Ballot",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Ballot {
        static mut instance: ::protobuf::lazy::Lazy<Ballot> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Ballot,
        };
        unsafe { instance.get(Ballot::new) }
    }
}

impl ::protobuf::Clear for Ballot {
    fn clear(&mut self) {
        self.proposal.clear();
        self.vote.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ballot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ballot {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MyProposalList {
    // message fields
    pub proposal: ::protobuf::RepeatedField<Proposal>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MyProposalList {
    fn default() -> &'a MyProposalList {
        <MyProposalList as ::protobuf::Message>::default_instance()
    }
}

impl MyProposalList {
    pub fn new() -> MyProposalList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.Proposal proposal = 1;

    pub fn get_proposal(&self) -> &[Proposal] {
        &self.proposal
    }
    pub fn clear_proposal(&mut self) {
        self.proposal.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposal(&mut self, v: ::protobuf::RepeatedField<Proposal>) {
        self.proposal = v;
    }

    // Mutable pointer to the field.
    pub fn mut_proposal(&mut self) -> &mut ::protobuf::RepeatedField<Proposal> {
        &mut self.proposal
    }

    // Take field
    pub fn take_proposal(&mut self) -> ::protobuf::RepeatedField<Proposal> {
        ::std::mem::replace(&mut self.proposal, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MyProposalList {
    fn is_initialized(&self) -> bool {
        for v in &self.proposal {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.proposal)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.proposal {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.proposal {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MyProposalList {
        MyProposalList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Proposal>,
                    >(
                        "proposal",
                        |m: &MyProposalList| &m.proposal,
                        |m: &mut MyProposalList| &mut m.proposal,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<MyProposalList>(
                    "MyProposalList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MyProposalList {
        static mut instance: ::protobuf::lazy::Lazy<MyProposalList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MyProposalList,
        };
        unsafe { instance.get(MyProposalList::new) }
    }
}

impl ::protobuf::Clear for MyProposalList {
    fn clear(&mut self) {
        self.proposal.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MyProposalList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyProposalList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct BallotList {
    // message fields
    pub ballot: ::protobuf::RepeatedField<Ballot>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BallotList {
    fn default() -> &'a BallotList {
        <BallotList as ::protobuf::Message>::default_instance()
    }
}

impl BallotList {
    pub fn new() -> BallotList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.Ballot ballot = 1;

    pub fn get_ballot(&self) -> &[Ballot] {
        &self.ballot
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: ::protobuf::RepeatedField<Ballot>) {
        self.ballot = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ballot(&mut self) -> &mut ::protobuf::RepeatedField<Ballot> {
        &mut self.ballot
    }

    // Take field
    pub fn take_ballot(&mut self) -> ::protobuf::RepeatedField<Ballot> {
        ::std::mem::replace(&mut self.ballot, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BallotList {
    fn is_initialized(&self) -> bool {
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ballot)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ballot {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ballot {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BallotList {
        BallotList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Ballot>,
                    >(
                        "ballot",
                        |m: &BallotList| &m.ballot,
                        |m: &mut BallotList| &mut m.ballot,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<BallotList>(
                    "BallotList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static BallotList {
        static mut instance: ::protobuf::lazy::Lazy<BallotList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BallotList,
        };
        unsafe { instance.get(BallotList::new) }
    }
}

impl ::protobuf::Clear for BallotList {
    fn clear(&mut self) {
        self.ballot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BallotList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BallotList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ParamChange {
    // message fields
    pub param_name: ::std::string::String,
    pub param_value: ::std::string::String,
    pub activation_height: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ParamChange {
    fn default() -> &'a ParamChange {
        <ParamChange as ::protobuf::Message>::default_instance()
    }
}

impl ParamChange {
    pub fn new() -> ParamChange {
        ::std::default::Default::default()
    }

    // string param_name = 1;

    pub fn get_param_name(&self) -> &str {
        &self.param_name
    }
    pub fn clear_param_name(&mut self) {
        self.param_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_param_name(&mut self, v: ::std::string::String) {
        self.param_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param_name(&mut self) -> &mut ::std::string::String {
        &mut self.param_name
    }

    // Take field
    pub fn take_param_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.param_name, ::std::string::String::new())
    }

    // string param_value = 2;

    pub fn get_param_value(&self) -> &str {
        &self.param_value
    }
    pub fn clear_param_value(&mut self) {
        self.param_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_param_value(&mut self, v: ::std::string::String) {
        self.param_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param_value(&mut self) -> &mut ::std::string::String {
        &mut self.param_value
    }

    // Take field
    pub fn take_param_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.param_value, ::std::string::String::new())
    }

    // int32 activation_height = 3;

    pub fn get_activation_height(&self) -> i32 {
        self.activation_height
    }
    pub fn clear_activation_height(&mut self) {
        self.activation_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_activation_height(&mut self, v: i32) {
        self.activation_height = v;
    }
}

impl ::protobuf::Message for ParamChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.param_name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.param_value,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.activation_height = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.param_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.param_name);
        }
        if !self.param_value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.param_value);
        }
        if self.activation_height != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.activation_height,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.param_name.is_empty() {
            os.write_string(1, &self.param_name)?;
        }
        if !self.param_value.is_empty() {
            os.write_string(2, &self.param_value)?;
        }
        if self.activation_height != 0 {
            os.write_int32(3, self.activation_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ParamChange {
        ParamChange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "param_name",
                    |m: &ParamChange| &m.param_name,
                    |m: &mut ParamChange| &mut m.param_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "param_value",
                    |m: &ParamChange| &m.param_value,
                    |m: &mut ParamChange| &mut m.param_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "activation_height",
                    |m: &ParamChange| &m.activation_height,
                    |m: &mut ParamChange| &mut m.activation_height,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ParamChange>(
                    "ParamChange",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ParamChange {
        static mut instance: ::protobuf::lazy::Lazy<ParamChange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ParamChange,
        };
        unsafe { instance.get(ParamChange::new) }
    }
}

impl ::protobuf::Clear for ParamChange {
    fn clear(&mut self) {
        self.param_name.clear();
        self.param_value.clear();
        self.activation_height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ParamChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParamChange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ConfiscateBond {
    // message fields
    pub lockup_tx_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfiscateBond {
    fn default() -> &'a ConfiscateBond {
        <ConfiscateBond as ::protobuf::Message>::default_instance()
    }
}

impl ConfiscateBond {
    pub fn new() -> ConfiscateBond {
        ::std::default::Default::default()
    }

    // string lockup_tx_id = 1;

    pub fn get_lockup_tx_id(&self) -> &str {
        &self.lockup_tx_id
    }
    pub fn clear_lockup_tx_id(&mut self) {
        self.lockup_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_lockup_tx_id(&mut self, v: ::std::string::String) {
        self.lockup_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lockup_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.lockup_tx_id
    }

    // Take field
    pub fn take_lockup_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lockup_tx_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConfiscateBond {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.lockup_tx_id,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.lockup_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.lockup_tx_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.lockup_tx_id.is_empty() {
            os.write_string(1, &self.lockup_tx_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfiscateBond {
        ConfiscateBond::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "lockup_tx_id",
                    |m: &ConfiscateBond| &m.lockup_tx_id,
                    |m: &mut ConfiscateBond| &mut m.lockup_tx_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfiscateBond>(
                    "ConfiscateBond",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ConfiscateBond {
        static mut instance: ::protobuf::lazy::Lazy<ConfiscateBond> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConfiscateBond,
        };
        unsafe { instance.get(ConfiscateBond::new) }
    }
}

impl ::protobuf::Clear for ConfiscateBond {
    fn clear(&mut self) {
        self.lockup_tx_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfiscateBond {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfiscateBond {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MyVote {
    // message fields
    pub height: i32,
    pub ballot_list: ::protobuf::SingularPtrField<BallotList>,
    pub secret_key_encoded: ::std::vec::Vec<u8>,
    pub blind_vote: ::protobuf::SingularPtrField<BlindVote>,
    pub date: i64,
    pub reveal_tx_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MyVote {
    fn default() -> &'a MyVote {
        <MyVote as ::protobuf::Message>::default_instance()
    }
}

impl MyVote {
    pub fn new() -> MyVote {
        ::std::default::Default::default()
    }

    // int32 height = 1;

    pub fn get_height(&self) -> i32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = v;
    }

    // .io.bisq.protobuffer.BallotList ballot_list = 2;

    pub fn get_ballot_list(&self) -> &BallotList {
        self.ballot_list
            .as_ref()
            .unwrap_or_else(|| BallotList::default_instance())
    }
    pub fn clear_ballot_list(&mut self) {
        self.ballot_list.clear();
    }

    pub fn has_ballot_list(&self) -> bool {
        self.ballot_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot_list(&mut self, v: BallotList) {
        self.ballot_list = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot_list(&mut self) -> &mut BallotList {
        if self.ballot_list.is_none() {
            self.ballot_list.set_default();
        }
        self.ballot_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot_list(&mut self) -> BallotList {
        self.ballot_list.take().unwrap_or_else(|| BallotList::new())
    }

    // bytes secret_key_encoded = 3;

    pub fn get_secret_key_encoded(&self) -> &[u8] {
        &self.secret_key_encoded
    }
    pub fn clear_secret_key_encoded(&mut self) {
        self.secret_key_encoded.clear();
    }

    // Param is passed by value, moved
    pub fn set_secret_key_encoded(&mut self, v: ::std::vec::Vec<u8>) {
        self.secret_key_encoded = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret_key_encoded(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.secret_key_encoded
    }

    // Take field
    pub fn take_secret_key_encoded(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.secret_key_encoded, ::std::vec::Vec::new())
    }

    // .io.bisq.protobuffer.BlindVote blind_vote = 4;

    pub fn get_blind_vote(&self) -> &BlindVote {
        self.blind_vote
            .as_ref()
            .unwrap_or_else(|| BlindVote::default_instance())
    }
    pub fn clear_blind_vote(&mut self) {
        self.blind_vote.clear();
    }

    pub fn has_blind_vote(&self) -> bool {
        self.blind_vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blind_vote(&mut self, v: BlindVote) {
        self.blind_vote = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blind_vote(&mut self) -> &mut BlindVote {
        if self.blind_vote.is_none() {
            self.blind_vote.set_default();
        }
        self.blind_vote.as_mut().unwrap()
    }

    // Take field
    pub fn take_blind_vote(&mut self) -> BlindVote {
        self.blind_vote.take().unwrap_or_else(|| BlindVote::new())
    }

    // int64 date = 5;

    pub fn get_date(&self) -> i64 {
        self.date
    }
    pub fn clear_date(&mut self) {
        self.date = 0;
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: i64) {
        self.date = v;
    }

    // string reveal_tx_id = 6;

    pub fn get_reveal_tx_id(&self) -> &str {
        &self.reveal_tx_id
    }
    pub fn clear_reveal_tx_id(&mut self) {
        self.reveal_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_reveal_tx_id(&mut self, v: ::std::string::String) {
        self.reveal_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reveal_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.reveal_tx_id
    }

    // Take field
    pub fn take_reveal_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reveal_tx_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MyVote {
    fn is_initialized(&self) -> bool {
        for v in &self.ballot_list {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.blind_vote {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.height = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.ballot_list,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.secret_key_encoded,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.blind_vote,
                    )?;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.date = tmp;
                }
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.reveal_tx_id,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ballot_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.secret_key_encoded.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.secret_key_encoded);
        }
        if let Some(ref v) = self.blind_vote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.date != 0 {
            my_size +=
                ::protobuf::rt::value_size(5, self.date, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.reveal_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.reveal_tx_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_int32(1, self.height)?;
        }
        if let Some(ref v) = self.ballot_list.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.secret_key_encoded.is_empty() {
            os.write_bytes(3, &self.secret_key_encoded)?;
        }
        if let Some(ref v) = self.blind_vote.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.date != 0 {
            os.write_int64(5, self.date)?;
        }
        if !self.reveal_tx_id.is_empty() {
            os.write_string(6, &self.reveal_tx_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MyVote {
        MyVote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "height",
                    |m: &MyVote| &m.height,
                    |m: &mut MyVote| &mut m.height,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BallotList>,
                    >(
                        "ballot_list",
                        |m: &MyVote| &m.ballot_list,
                        |m: &mut MyVote| &mut m.ballot_list,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "secret_key_encoded",
                    |m: &MyVote| &m.secret_key_encoded,
                    |m: &mut MyVote| &mut m.secret_key_encoded,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BlindVote>,
                    >(
                        "blind_vote",
                        |m: &MyVote| &m.blind_vote,
                        |m: &mut MyVote| &mut m.blind_vote,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "date", |m: &MyVote| &m.date, |m: &mut MyVote| &mut m.date
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "reveal_tx_id",
                    |m: &MyVote| &m.reveal_tx_id,
                    |m: &mut MyVote| &mut m.reveal_tx_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MyVote>(
                    "MyVote",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MyVote {
        static mut instance: ::protobuf::lazy::Lazy<MyVote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MyVote,
        };
        unsafe { instance.get(MyVote::new) }
    }
}

impl ::protobuf::Clear for MyVote {
    fn clear(&mut self) {
        self.height = 0;
        self.ballot_list.clear();
        self.secret_key_encoded.clear();
        self.blind_vote.clear();
        self.date = 0;
        self.reveal_tx_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MyVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyVote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MyVoteList {
    // message fields
    pub my_vote: ::protobuf::RepeatedField<MyVote>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MyVoteList {
    fn default() -> &'a MyVoteList {
        <MyVoteList as ::protobuf::Message>::default_instance()
    }
}

impl MyVoteList {
    pub fn new() -> MyVoteList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.MyVote my_vote = 1;

    pub fn get_my_vote(&self) -> &[MyVote] {
        &self.my_vote
    }
    pub fn clear_my_vote(&mut self) {
        self.my_vote.clear();
    }

    // Param is passed by value, moved
    pub fn set_my_vote(&mut self, v: ::protobuf::RepeatedField<MyVote>) {
        self.my_vote = v;
    }

    // Mutable pointer to the field.
    pub fn mut_my_vote(&mut self) -> &mut ::protobuf::RepeatedField<MyVote> {
        &mut self.my_vote
    }

    // Take field
    pub fn take_my_vote(&mut self) -> ::protobuf::RepeatedField<MyVote> {
        ::std::mem::replace(&mut self.my_vote, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MyVoteList {
    fn is_initialized(&self) -> bool {
        for v in &self.my_vote {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.my_vote)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.my_vote {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.my_vote {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MyVoteList {
        MyVoteList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<MyVote>,
                    >(
                        "my_vote",
                        |m: &MyVoteList| &m.my_vote,
                        |m: &mut MyVoteList| &mut m.my_vote,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<MyVoteList>(
                    "MyVoteList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MyVoteList {
        static mut instance: ::protobuf::lazy::Lazy<MyVoteList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MyVoteList,
        };
        unsafe { instance.get(MyVoteList::new) }
    }
}

impl ::protobuf::Clear for MyVoteList {
    fn clear(&mut self) {
        self.my_vote.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MyVoteList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyVoteList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct VoteWithProposalTxId {
    // message fields
    pub proposal_tx_id: ::std::string::String,
    pub vote: ::protobuf::SingularPtrField<Vote>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteWithProposalTxId {
    fn default() -> &'a VoteWithProposalTxId {
        <VoteWithProposalTxId as ::protobuf::Message>::default_instance()
    }
}

impl VoteWithProposalTxId {
    pub fn new() -> VoteWithProposalTxId {
        ::std::default::Default::default()
    }

    // string proposal_tx_id = 1;

    pub fn get_proposal_tx_id(&self) -> &str {
        &self.proposal_tx_id
    }
    pub fn clear_proposal_tx_id(&mut self) {
        self.proposal_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposal_tx_id(&mut self, v: ::std::string::String) {
        self.proposal_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposal_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.proposal_tx_id
    }

    // Take field
    pub fn take_proposal_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.proposal_tx_id, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.Vote vote = 2;

    pub fn get_vote(&self) -> &Vote {
        self.vote
            .as_ref()
            .unwrap_or_else(|| Vote::default_instance())
    }
    pub fn clear_vote(&mut self) {
        self.vote.clear();
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: Vote) {
        self.vote = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vote(&mut self) -> &mut Vote {
        if self.vote.is_none() {
            self.vote.set_default();
        }
        self.vote.as_mut().unwrap()
    }

    // Take field
    pub fn take_vote(&mut self) -> Vote {
        self.vote.take().unwrap_or_else(|| Vote::new())
    }
}

impl ::protobuf::Message for VoteWithProposalTxId {
    fn is_initialized(&self) -> bool {
        for v in &self.vote {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.proposal_tx_id,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vote)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.proposal_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.proposal_tx_id);
        }
        if let Some(ref v) = self.vote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.proposal_tx_id.is_empty() {
            os.write_string(1, &self.proposal_tx_id)?;
        }
        if let Some(ref v) = self.vote.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteWithProposalTxId {
        VoteWithProposalTxId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "proposal_tx_id",
                    |m: &VoteWithProposalTxId| &m.proposal_tx_id,
                    |m: &mut VoteWithProposalTxId| &mut m.proposal_tx_id,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Vote>,
                    >(
                        "vote",
                        |m: &VoteWithProposalTxId| &m.vote,
                        |m: &mut VoteWithProposalTxId| &mut m.vote,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<VoteWithProposalTxId>(
                    "VoteWithProposalTxId",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static VoteWithProposalTxId {
        static mut instance: ::protobuf::lazy::Lazy<VoteWithProposalTxId> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const VoteWithProposalTxId,
            };
        unsafe { instance.get(VoteWithProposalTxId::new) }
    }
}

impl ::protobuf::Clear for VoteWithProposalTxId {
    fn clear(&mut self) {
        self.proposal_tx_id.clear();
        self.vote.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteWithProposalTxId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteWithProposalTxId {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct VoteWithProposalTxIdList {
    // message fields
    pub item: ::protobuf::RepeatedField<VoteWithProposalTxId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteWithProposalTxIdList {
    fn default() -> &'a VoteWithProposalTxIdList {
        <VoteWithProposalTxIdList as ::protobuf::Message>::default_instance()
    }
}

impl VoteWithProposalTxIdList {
    pub fn new() -> VoteWithProposalTxIdList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.VoteWithProposalTxId item = 1;

    pub fn get_item(&self) -> &[VoteWithProposalTxId] {
        &self.item
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: ::protobuf::RepeatedField<VoteWithProposalTxId>) {
        self.item = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item(&mut self) -> &mut ::protobuf::RepeatedField<VoteWithProposalTxId> {
        &mut self.item
    }

    // Take field
    pub fn take_item(&mut self) -> ::protobuf::RepeatedField<VoteWithProposalTxId> {
        ::std::mem::replace(&mut self.item, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VoteWithProposalTxIdList {
    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.item)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteWithProposalTxIdList {
        VoteWithProposalTxIdList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<VoteWithProposalTxId>,
                    >(
                        "item",
                        |m: &VoteWithProposalTxIdList| &m.item,
                        |m: &mut VoteWithProposalTxIdList| &mut m.item,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<VoteWithProposalTxIdList>(
                    "VoteWithProposalTxIdList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static VoteWithProposalTxIdList {
        static mut instance: ::protobuf::lazy::Lazy<VoteWithProposalTxIdList> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const VoteWithProposalTxIdList,
            };
        unsafe { instance.get(VoteWithProposalTxIdList::new) }
    }
}

impl ::protobuf::Clear for VoteWithProposalTxIdList {
    fn clear(&mut self) {
        self.item.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteWithProposalTxIdList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteWithProposalTxIdList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct BlindVote {
    // message fields
    pub encrypted_votes: ::std::vec::Vec<u8>,
    pub tx_id: ::std::string::String,
    pub stake: i64,
    pub encrypted_merit_list: ::std::vec::Vec<u8>,
    pub date: i64,
    pub extra_data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlindVote {
    fn default() -> &'a BlindVote {
        <BlindVote as ::protobuf::Message>::default_instance()
    }
}

impl BlindVote {
    pub fn new() -> BlindVote {
        ::std::default::Default::default()
    }

    // bytes encrypted_votes = 1;

    pub fn get_encrypted_votes(&self) -> &[u8] {
        &self.encrypted_votes
    }
    pub fn clear_encrypted_votes(&mut self) {
        self.encrypted_votes.clear();
    }

    // Param is passed by value, moved
    pub fn set_encrypted_votes(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_votes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_votes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.encrypted_votes
    }

    // Take field
    pub fn take_encrypted_votes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.encrypted_votes, ::std::vec::Vec::new())
    }

    // string tx_id = 2;

    pub fn get_tx_id(&self) -> &str {
        &self.tx_id
    }
    pub fn clear_tx_id(&mut self) {
        self.tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_id(&mut self, v: ::std::string::String) {
        self.tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.tx_id
    }

    // Take field
    pub fn take_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_id, ::std::string::String::new())
    }

    // int64 stake = 3;

    pub fn get_stake(&self) -> i64 {
        self.stake
    }
    pub fn clear_stake(&mut self) {
        self.stake = 0;
    }

    // Param is passed by value, moved
    pub fn set_stake(&mut self, v: i64) {
        self.stake = v;
    }

    // bytes encrypted_merit_list = 4;

    pub fn get_encrypted_merit_list(&self) -> &[u8] {
        &self.encrypted_merit_list
    }
    pub fn clear_encrypted_merit_list(&mut self) {
        self.encrypted_merit_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_encrypted_merit_list(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_merit_list = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_merit_list(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.encrypted_merit_list
    }

    // Take field
    pub fn take_encrypted_merit_list(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.encrypted_merit_list, ::std::vec::Vec::new())
    }

    // int64 date = 5;

    pub fn get_date(&self) -> i64 {
        self.date
    }
    pub fn clear_date(&mut self) {
        self.date = 0;
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: i64) {
        self.date = v;
    }

    // repeated .io.bisq.protobuffer.BlindVote.ExtraDataEntry extra_data = 6;

    pub fn get_extra_data(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.extra_data
    }
    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_data(
        &mut self,
        v: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ) {
        self.extra_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_data(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.extra_data
    }

    // Take field
    pub fn take_extra_data(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.extra_data, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for BlindVote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.encrypted_votes,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.tx_id,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.stake = tmp;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.encrypted_merit_list,
                    )?;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.date = tmp;
                }
                6 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeString,
                    >(wire_type, is, &mut self.extra_data)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.encrypted_votes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.encrypted_votes);
        }
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tx_id);
        }
        if self.stake != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.stake, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.encrypted_merit_list.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.encrypted_merit_list);
        }
        if self.date != 0 {
            my_size +=
                ::protobuf::rt::value_size(5, self.date, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(6, &self.extra_data);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.encrypted_votes.is_empty() {
            os.write_bytes(1, &self.encrypted_votes)?;
        }
        if !self.tx_id.is_empty() {
            os.write_string(2, &self.tx_id)?;
        }
        if self.stake != 0 {
            os.write_int64(3, self.stake)?;
        }
        if !self.encrypted_merit_list.is_empty() {
            os.write_bytes(4, &self.encrypted_merit_list)?;
        }
        if self.date != 0 {
            os.write_int64(5, self.date)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeString,
        >(6, &self.extra_data, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlindVote {
        BlindVote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "encrypted_votes",
                    |m: &BlindVote| &m.encrypted_votes,
                    |m: &mut BlindVote| &mut m.encrypted_votes,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "tx_id",
                    |m: &BlindVote| &m.tx_id,
                    |m: &mut BlindVote| &mut m.tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "stake",
                    |m: &BlindVote| &m.stake,
                    |m: &mut BlindVote| &mut m.stake,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "encrypted_merit_list",
                    |m: &BlindVote| &m.encrypted_merit_list,
                    |m: &mut BlindVote| &mut m.encrypted_merit_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "date",
                    |m: &BlindVote| &m.date,
                    |m: &mut BlindVote| &mut m.date,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "extra_data",
                    |m: &BlindVote| &m.extra_data,
                    |m: &mut BlindVote| &mut m.extra_data,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlindVote>(
                    "BlindVote",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static BlindVote {
        static mut instance: ::protobuf::lazy::Lazy<BlindVote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlindVote,
        };
        unsafe { instance.get(BlindVote::new) }
    }
}

impl ::protobuf::Clear for BlindVote {
    fn clear(&mut self) {
        self.encrypted_votes.clear();
        self.tx_id.clear();
        self.stake = 0;
        self.encrypted_merit_list.clear();
        self.date = 0;
        self.extra_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlindVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlindVote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MyBlindVoteList {
    // message fields
    pub blind_vote: ::protobuf::RepeatedField<BlindVote>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MyBlindVoteList {
    fn default() -> &'a MyBlindVoteList {
        <MyBlindVoteList as ::protobuf::Message>::default_instance()
    }
}

impl MyBlindVoteList {
    pub fn new() -> MyBlindVoteList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.BlindVote blind_vote = 1;

    pub fn get_blind_vote(&self) -> &[BlindVote] {
        &self.blind_vote
    }
    pub fn clear_blind_vote(&mut self) {
        self.blind_vote.clear();
    }

    // Param is passed by value, moved
    pub fn set_blind_vote(&mut self, v: ::protobuf::RepeatedField<BlindVote>) {
        self.blind_vote = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blind_vote(&mut self) -> &mut ::protobuf::RepeatedField<BlindVote> {
        &mut self.blind_vote
    }

    // Take field
    pub fn take_blind_vote(&mut self) -> ::protobuf::RepeatedField<BlindVote> {
        ::std::mem::replace(&mut self.blind_vote, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MyBlindVoteList {
    fn is_initialized(&self) -> bool {
        for v in &self.blind_vote {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.blind_vote,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blind_vote {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blind_vote {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MyBlindVoteList {
        MyBlindVoteList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BlindVote>,
                    >(
                        "blind_vote",
                        |m: &MyBlindVoteList| &m.blind_vote,
                        |m: &mut MyBlindVoteList| &mut m.blind_vote,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<MyBlindVoteList>(
                    "MyBlindVoteList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MyBlindVoteList {
        static mut instance: ::protobuf::lazy::Lazy<MyBlindVoteList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MyBlindVoteList,
        };
        unsafe { instance.get(MyBlindVoteList::new) }
    }
}

impl ::protobuf::Clear for MyBlindVoteList {
    fn clear(&mut self) {
        self.blind_vote.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MyBlindVoteList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyBlindVoteList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct BlindVoteStore {
    // message fields
    pub items: ::protobuf::RepeatedField<BlindVotePayload>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlindVoteStore {
    fn default() -> &'a BlindVoteStore {
        <BlindVoteStore as ::protobuf::Message>::default_instance()
    }
}

impl BlindVoteStore {
    pub fn new() -> BlindVoteStore {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.BlindVotePayload items = 1;

    pub fn get_items(&self) -> &[BlindVotePayload] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<BlindVotePayload>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<BlindVotePayload> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<BlindVotePayload> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlindVoteStore {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlindVoteStore {
        BlindVoteStore::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BlindVotePayload>,
                    >(
                        "items",
                        |m: &BlindVoteStore| &m.items,
                        |m: &mut BlindVoteStore| &mut m.items,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<BlindVoteStore>(
                    "BlindVoteStore",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static BlindVoteStore {
        static mut instance: ::protobuf::lazy::Lazy<BlindVoteStore> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlindVoteStore,
        };
        unsafe { instance.get(BlindVoteStore::new) }
    }
}

impl ::protobuf::Clear for BlindVoteStore {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlindVoteStore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlindVoteStore {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct BlindVotePayload {
    // message fields
    pub blind_vote: ::protobuf::SingularPtrField<BlindVote>,
    pub hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlindVotePayload {
    fn default() -> &'a BlindVotePayload {
        <BlindVotePayload as ::protobuf::Message>::default_instance()
    }
}

impl BlindVotePayload {
    pub fn new() -> BlindVotePayload {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.BlindVote blind_vote = 1;

    pub fn get_blind_vote(&self) -> &BlindVote {
        self.blind_vote
            .as_ref()
            .unwrap_or_else(|| BlindVote::default_instance())
    }
    pub fn clear_blind_vote(&mut self) {
        self.blind_vote.clear();
    }

    pub fn has_blind_vote(&self) -> bool {
        self.blind_vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blind_vote(&mut self, v: BlindVote) {
        self.blind_vote = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blind_vote(&mut self) -> &mut BlindVote {
        if self.blind_vote.is_none() {
            self.blind_vote.set_default();
        }
        self.blind_vote.as_mut().unwrap()
    }

    // Take field
    pub fn take_blind_vote(&mut self) -> BlindVote {
        self.blind_vote.take().unwrap_or_else(|| BlindVote::new())
    }

    // bytes hash = 2;

    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BlindVotePayload {
    fn is_initialized(&self) -> bool {
        for v in &self.blind_vote {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.blind_vote,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blind_vote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blind_vote.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlindVotePayload {
        BlindVotePayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BlindVote>,
                    >(
                        "blind_vote",
                        |m: &BlindVotePayload| &m.blind_vote,
                        |m: &mut BlindVotePayload| &mut m.blind_vote,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "hash",
                    |m: &BlindVotePayload| &m.hash,
                    |m: &mut BlindVotePayload| &mut m.hash,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlindVotePayload>(
                    "BlindVotePayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static BlindVotePayload {
        static mut instance: ::protobuf::lazy::Lazy<BlindVotePayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlindVotePayload,
        };
        unsafe { instance.get(BlindVotePayload::new) }
    }
}

impl ::protobuf::Clear for BlindVotePayload {
    fn clear(&mut self) {
        self.blind_vote.clear();
        self.hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlindVotePayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlindVotePayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Vote {
    // message fields
    pub accepted: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vote {
    fn default() -> &'a Vote {
        <Vote as ::protobuf::Message>::default_instance()
    }
}

impl Vote {
    pub fn new() -> Vote {
        ::std::default::Default::default()
    }

    // bool accepted = 1;

    pub fn get_accepted(&self) -> bool {
        self.accepted
    }
    pub fn clear_accepted(&mut self) {
        self.accepted = false;
    }

    // Param is passed by value, moved
    pub fn set_accepted(&mut self, v: bool) {
        self.accepted = v;
    }
}

impl ::protobuf::Message for Vote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.accepted = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.accepted != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.accepted != false {
            os.write_bool(1, self.accepted)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vote {
        Vote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "accepted",
                    |m: &Vote| &m.accepted,
                    |m: &mut Vote| &mut m.accepted,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Vote>(
                    "Vote",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Vote {
        static mut instance: ::protobuf::lazy::Lazy<Vote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Vote,
        };
        unsafe { instance.get(Vote::new) }
    }
}

impl ::protobuf::Clear for Vote {
    fn clear(&mut self) {
        self.accepted = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Merit {
    // message fields
    pub issuance: ::protobuf::SingularPtrField<Issuance>,
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Merit {
    fn default() -> &'a Merit {
        <Merit as ::protobuf::Message>::default_instance()
    }
}

impl Merit {
    pub fn new() -> Merit {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Issuance issuance = 1;

    pub fn get_issuance(&self) -> &Issuance {
        self.issuance
            .as_ref()
            .unwrap_or_else(|| Issuance::default_instance())
    }
    pub fn clear_issuance(&mut self) {
        self.issuance.clear();
    }

    pub fn has_issuance(&self) -> bool {
        self.issuance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issuance(&mut self, v: Issuance) {
        self.issuance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuance(&mut self) -> &mut Issuance {
        if self.issuance.is_none() {
            self.issuance.set_default();
        }
        self.issuance.as_mut().unwrap()
    }

    // Take field
    pub fn take_issuance(&mut self) -> Issuance {
        self.issuance.take().unwrap_or_else(|| Issuance::new())
    }

    // bytes signature = 2;

    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Merit {
    fn is_initialized(&self) -> bool {
        for v in &self.issuance {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.issuance)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.signature,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.issuance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.issuance.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(2, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Merit {
        Merit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Issuance>,
                    >(
                        "issuance",
                        |m: &Merit| &m.issuance,
                        |m: &mut Merit| &mut m.issuance,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "signature",
                    |m: &Merit| &m.signature,
                    |m: &mut Merit| &mut m.signature,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Merit>(
                    "Merit",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Merit {
        static mut instance: ::protobuf::lazy::Lazy<Merit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Merit,
        };
        unsafe { instance.get(Merit::new) }
    }
}

impl ::protobuf::Clear for Merit {
    fn clear(&mut self) {
        self.issuance.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Merit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Merit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MeritList {
    // message fields
    pub merit: ::protobuf::RepeatedField<Merit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MeritList {
    fn default() -> &'a MeritList {
        <MeritList as ::protobuf::Message>::default_instance()
    }
}

impl MeritList {
    pub fn new() -> MeritList {
        ::std::default::Default::default()
    }

    // repeated .io.bisq.protobuffer.Merit merit = 1;

    pub fn get_merit(&self) -> &[Merit] {
        &self.merit
    }
    pub fn clear_merit(&mut self) {
        self.merit.clear();
    }

    // Param is passed by value, moved
    pub fn set_merit(&mut self, v: ::protobuf::RepeatedField<Merit>) {
        self.merit = v;
    }

    // Mutable pointer to the field.
    pub fn mut_merit(&mut self) -> &mut ::protobuf::RepeatedField<Merit> {
        &mut self.merit
    }

    // Take field
    pub fn take_merit(&mut self) -> ::protobuf::RepeatedField<Merit> {
        ::std::mem::replace(&mut self.merit, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MeritList {
    fn is_initialized(&self) -> bool {
        for v in &self.merit {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.merit)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.merit {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.merit {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeritList {
        MeritList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Merit>,
                    >(
                        "merit",
                        |m: &MeritList| &m.merit,
                        |m: &mut MeritList| &mut m.merit,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<MeritList>(
                    "MeritList",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MeritList {
        static mut instance: ::protobuf::lazy::Lazy<MeritList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MeritList,
        };
        unsafe { instance.get(MeritList::new) }
    }
}

impl ::protobuf::Clear for MeritList {
    fn clear(&mut self) {
        self.merit.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeritList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeritList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ProposalVoteResult {
    // message fields
    pub proposal: ::protobuf::SingularPtrField<Proposal>,
    pub stake_of_Accepted_votes: i64,
    pub stake_of_Rejected_votes: i64,
    pub num_accepted_votes: i32,
    pub num_rejected_votes: i32,
    pub num_ignored_votes: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposalVoteResult {
    fn default() -> &'a ProposalVoteResult {
        <ProposalVoteResult as ::protobuf::Message>::default_instance()
    }
}

impl ProposalVoteResult {
    pub fn new() -> ProposalVoteResult {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Proposal proposal = 1;

    pub fn get_proposal(&self) -> &Proposal {
        self.proposal
            .as_ref()
            .unwrap_or_else(|| Proposal::default_instance())
    }
    pub fn clear_proposal(&mut self) {
        self.proposal.clear();
    }

    pub fn has_proposal(&self) -> bool {
        self.proposal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proposal(&mut self, v: Proposal) {
        self.proposal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposal(&mut self) -> &mut Proposal {
        if self.proposal.is_none() {
            self.proposal.set_default();
        }
        self.proposal.as_mut().unwrap()
    }

    // Take field
    pub fn take_proposal(&mut self) -> Proposal {
        self.proposal.take().unwrap_or_else(|| Proposal::new())
    }

    // int64 stake_of_Accepted_votes = 2;

    pub fn get_stake_of_Accepted_votes(&self) -> i64 {
        self.stake_of_Accepted_votes
    }
    pub fn clear_stake_of_Accepted_votes(&mut self) {
        self.stake_of_Accepted_votes = 0;
    }

    // Param is passed by value, moved
    pub fn set_stake_of_Accepted_votes(&mut self, v: i64) {
        self.stake_of_Accepted_votes = v;
    }

    // int64 stake_of_Rejected_votes = 3;

    pub fn get_stake_of_Rejected_votes(&self) -> i64 {
        self.stake_of_Rejected_votes
    }
    pub fn clear_stake_of_Rejected_votes(&mut self) {
        self.stake_of_Rejected_votes = 0;
    }

    // Param is passed by value, moved
    pub fn set_stake_of_Rejected_votes(&mut self, v: i64) {
        self.stake_of_Rejected_votes = v;
    }

    // int32 num_accepted_votes = 4;

    pub fn get_num_accepted_votes(&self) -> i32 {
        self.num_accepted_votes
    }
    pub fn clear_num_accepted_votes(&mut self) {
        self.num_accepted_votes = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_accepted_votes(&mut self, v: i32) {
        self.num_accepted_votes = v;
    }

    // int32 num_rejected_votes = 5;

    pub fn get_num_rejected_votes(&self) -> i32 {
        self.num_rejected_votes
    }
    pub fn clear_num_rejected_votes(&mut self) {
        self.num_rejected_votes = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_rejected_votes(&mut self, v: i32) {
        self.num_rejected_votes = v;
    }

    // int32 num_ignored_votes = 6;

    pub fn get_num_ignored_votes(&self) -> i32 {
        self.num_ignored_votes
    }
    pub fn clear_num_ignored_votes(&mut self) {
        self.num_ignored_votes = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_ignored_votes(&mut self, v: i32) {
        self.num_ignored_votes = v;
    }
}

impl ::protobuf::Message for ProposalVoteResult {
    fn is_initialized(&self) -> bool {
        for v in &self.proposal {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proposal)?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.stake_of_Accepted_votes = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.stake_of_Rejected_votes = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.num_accepted_votes = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.num_rejected_votes = tmp;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.num_ignored_votes = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.proposal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stake_of_Accepted_votes != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.stake_of_Accepted_votes,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.stake_of_Rejected_votes != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.stake_of_Rejected_votes,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.num_accepted_votes != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.num_accepted_votes,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.num_rejected_votes != 0 {
            my_size += ::protobuf::rt::value_size(
                5,
                self.num_rejected_votes,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.num_ignored_votes != 0 {
            my_size += ::protobuf::rt::value_size(
                6,
                self.num_ignored_votes,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.proposal.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stake_of_Accepted_votes != 0 {
            os.write_int64(2, self.stake_of_Accepted_votes)?;
        }
        if self.stake_of_Rejected_votes != 0 {
            os.write_int64(3, self.stake_of_Rejected_votes)?;
        }
        if self.num_accepted_votes != 0 {
            os.write_int32(4, self.num_accepted_votes)?;
        }
        if self.num_rejected_votes != 0 {
            os.write_int32(5, self.num_rejected_votes)?;
        }
        if self.num_ignored_votes != 0 {
            os.write_int32(6, self.num_ignored_votes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposalVoteResult {
        ProposalVoteResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Proposal>,
                    >(
                        "proposal",
                        |m: &ProposalVoteResult| &m.proposal,
                        |m: &mut ProposalVoteResult| &mut m.proposal,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "stake_of_Accepted_votes",
                    |m: &ProposalVoteResult| &m.stake_of_Accepted_votes,
                    |m: &mut ProposalVoteResult| &mut m.stake_of_Accepted_votes,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "stake_of_Rejected_votes",
                    |m: &ProposalVoteResult| &m.stake_of_Rejected_votes,
                    |m: &mut ProposalVoteResult| &mut m.stake_of_Rejected_votes,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "num_accepted_votes",
                    |m: &ProposalVoteResult| &m.num_accepted_votes,
                    |m: &mut ProposalVoteResult| &mut m.num_accepted_votes,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "num_rejected_votes",
                    |m: &ProposalVoteResult| &m.num_rejected_votes,
                    |m: &mut ProposalVoteResult| &mut m.num_rejected_votes,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "num_ignored_votes",
                    |m: &ProposalVoteResult| &m.num_ignored_votes,
                    |m: &mut ProposalVoteResult| &mut m.num_ignored_votes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProposalVoteResult>(
                    "ProposalVoteResult",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ProposalVoteResult {
        static mut instance: ::protobuf::lazy::Lazy<ProposalVoteResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProposalVoteResult,
        };
        unsafe { instance.get(ProposalVoteResult::new) }
    }
}

impl ::protobuf::Clear for ProposalVoteResult {
    fn clear(&mut self) {
        self.proposal.clear();
        self.stake_of_Accepted_votes = 0;
        self.stake_of_Rejected_votes = 0;
        self.num_accepted_votes = 0;
        self.num_rejected_votes = 0;
        self.num_ignored_votes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposalVoteResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposalVoteResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct EvaluatedProposal {
    // message fields
    pub is_accepted: bool,
    pub proposal_vote_result: ::protobuf::SingularPtrField<ProposalVoteResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EvaluatedProposal {
    fn default() -> &'a EvaluatedProposal {
        <EvaluatedProposal as ::protobuf::Message>::default_instance()
    }
}

impl EvaluatedProposal {
    pub fn new() -> EvaluatedProposal {
        ::std::default::Default::default()
    }

    // bool is_accepted = 1;

    pub fn get_is_accepted(&self) -> bool {
        self.is_accepted
    }
    pub fn clear_is_accepted(&mut self) {
        self.is_accepted = false;
    }

    // Param is passed by value, moved
    pub fn set_is_accepted(&mut self, v: bool) {
        self.is_accepted = v;
    }

    // .io.bisq.protobuffer.ProposalVoteResult proposal_vote_result = 2;

    pub fn get_proposal_vote_result(&self) -> &ProposalVoteResult {
        self.proposal_vote_result
            .as_ref()
            .unwrap_or_else(|| ProposalVoteResult::default_instance())
    }
    pub fn clear_proposal_vote_result(&mut self) {
        self.proposal_vote_result.clear();
    }

    pub fn has_proposal_vote_result(&self) -> bool {
        self.proposal_vote_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proposal_vote_result(&mut self, v: ProposalVoteResult) {
        self.proposal_vote_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposal_vote_result(&mut self) -> &mut ProposalVoteResult {
        if self.proposal_vote_result.is_none() {
            self.proposal_vote_result.set_default();
        }
        self.proposal_vote_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_proposal_vote_result(&mut self) -> ProposalVoteResult {
        self.proposal_vote_result
            .take()
            .unwrap_or_else(|| ProposalVoteResult::new())
    }
}

impl ::protobuf::Message for EvaluatedProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.proposal_vote_result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_accepted = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.proposal_vote_result,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_accepted != false {
            my_size += 2;
        }
        if let Some(ref v) = self.proposal_vote_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.is_accepted != false {
            os.write_bool(1, self.is_accepted)?;
        }
        if let Some(ref v) = self.proposal_vote_result.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EvaluatedProposal {
        EvaluatedProposal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_accepted",
                    |m: &EvaluatedProposal| &m.is_accepted,
                    |m: &mut EvaluatedProposal| &mut m.is_accepted,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<ProposalVoteResult>,
                    >(
                        "proposal_vote_result",
                        |m: &EvaluatedProposal| &m.proposal_vote_result,
                        |m: &mut EvaluatedProposal| &mut m.proposal_vote_result,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<EvaluatedProposal>(
                    "EvaluatedProposal",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static EvaluatedProposal {
        static mut instance: ::protobuf::lazy::Lazy<EvaluatedProposal> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EvaluatedProposal,
        };
        unsafe { instance.get(EvaluatedProposal::new) }
    }
}

impl ::protobuf::Clear for EvaluatedProposal {
    fn clear(&mut self) {
        self.is_accepted = false;
        self.proposal_vote_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EvaluatedProposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvaluatedProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct DecryptedBallotsWithMerits {
    // message fields
    pub hash_of_blind_vote_list: ::std::vec::Vec<u8>,
    pub blind_vote_tx_id: ::std::string::String,
    pub vote_reveal_tx_id: ::std::string::String,
    pub stake: i64,
    pub ballot_list: ::protobuf::SingularPtrField<BallotList>,
    pub merit_list: ::protobuf::SingularPtrField<MeritList>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptedBallotsWithMerits {
    fn default() -> &'a DecryptedBallotsWithMerits {
        <DecryptedBallotsWithMerits as ::protobuf::Message>::default_instance()
    }
}

impl DecryptedBallotsWithMerits {
    pub fn new() -> DecryptedBallotsWithMerits {
        ::std::default::Default::default()
    }

    // bytes hash_of_blind_vote_list = 1;

    pub fn get_hash_of_blind_vote_list(&self) -> &[u8] {
        &self.hash_of_blind_vote_list
    }
    pub fn clear_hash_of_blind_vote_list(&mut self) {
        self.hash_of_blind_vote_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash_of_blind_vote_list(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash_of_blind_vote_list = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash_of_blind_vote_list(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash_of_blind_vote_list
    }

    // Take field
    pub fn take_hash_of_blind_vote_list(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash_of_blind_vote_list, ::std::vec::Vec::new())
    }

    // string blind_vote_tx_id = 2;

    pub fn get_blind_vote_tx_id(&self) -> &str {
        &self.blind_vote_tx_id
    }
    pub fn clear_blind_vote_tx_id(&mut self) {
        self.blind_vote_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_blind_vote_tx_id(&mut self, v: ::std::string::String) {
        self.blind_vote_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blind_vote_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.blind_vote_tx_id
    }

    // Take field
    pub fn take_blind_vote_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.blind_vote_tx_id, ::std::string::String::new())
    }

    // string vote_reveal_tx_id = 3;

    pub fn get_vote_reveal_tx_id(&self) -> &str {
        &self.vote_reveal_tx_id
    }
    pub fn clear_vote_reveal_tx_id(&mut self) {
        self.vote_reveal_tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_vote_reveal_tx_id(&mut self, v: ::std::string::String) {
        self.vote_reveal_tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vote_reveal_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.vote_reveal_tx_id
    }

    // Take field
    pub fn take_vote_reveal_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.vote_reveal_tx_id, ::std::string::String::new())
    }

    // int64 stake = 4;

    pub fn get_stake(&self) -> i64 {
        self.stake
    }
    pub fn clear_stake(&mut self) {
        self.stake = 0;
    }

    // Param is passed by value, moved
    pub fn set_stake(&mut self, v: i64) {
        self.stake = v;
    }

    // .io.bisq.protobuffer.BallotList ballot_list = 5;

    pub fn get_ballot_list(&self) -> &BallotList {
        self.ballot_list
            .as_ref()
            .unwrap_or_else(|| BallotList::default_instance())
    }
    pub fn clear_ballot_list(&mut self) {
        self.ballot_list.clear();
    }

    pub fn has_ballot_list(&self) -> bool {
        self.ballot_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot_list(&mut self, v: BallotList) {
        self.ballot_list = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot_list(&mut self) -> &mut BallotList {
        if self.ballot_list.is_none() {
            self.ballot_list.set_default();
        }
        self.ballot_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot_list(&mut self) -> BallotList {
        self.ballot_list.take().unwrap_or_else(|| BallotList::new())
    }

    // .io.bisq.protobuffer.MeritList merit_list = 6;

    pub fn get_merit_list(&self) -> &MeritList {
        self.merit_list
            .as_ref()
            .unwrap_or_else(|| MeritList::default_instance())
    }
    pub fn clear_merit_list(&mut self) {
        self.merit_list.clear();
    }

    pub fn has_merit_list(&self) -> bool {
        self.merit_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merit_list(&mut self, v: MeritList) {
        self.merit_list = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merit_list(&mut self) -> &mut MeritList {
        if self.merit_list.is_none() {
            self.merit_list.set_default();
        }
        self.merit_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_merit_list(&mut self) -> MeritList {
        self.merit_list.take().unwrap_or_else(|| MeritList::new())
    }
}

impl ::protobuf::Message for DecryptedBallotsWithMerits {
    fn is_initialized(&self) -> bool {
        for v in &self.ballot_list {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.merit_list {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.hash_of_blind_vote_list,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.blind_vote_tx_id,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.vote_reveal_tx_id,
                    )?;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.stake = tmp;
                }
                5 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.ballot_list,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.merit_list,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash_of_blind_vote_list.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash_of_blind_vote_list);
        }
        if !self.blind_vote_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.blind_vote_tx_id);
        }
        if !self.vote_reveal_tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.vote_reveal_tx_id);
        }
        if self.stake != 0 {
            my_size +=
                ::protobuf::rt::value_size(4, self.stake, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ballot_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.merit_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.hash_of_blind_vote_list.is_empty() {
            os.write_bytes(1, &self.hash_of_blind_vote_list)?;
        }
        if !self.blind_vote_tx_id.is_empty() {
            os.write_string(2, &self.blind_vote_tx_id)?;
        }
        if !self.vote_reveal_tx_id.is_empty() {
            os.write_string(3, &self.vote_reveal_tx_id)?;
        }
        if self.stake != 0 {
            os.write_int64(4, self.stake)?;
        }
        if let Some(ref v) = self.ballot_list.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.merit_list.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptedBallotsWithMerits {
        DecryptedBallotsWithMerits::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "hash_of_blind_vote_list",
                    |m: &DecryptedBallotsWithMerits| &m.hash_of_blind_vote_list,
                    |m: &mut DecryptedBallotsWithMerits| &mut m.hash_of_blind_vote_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "blind_vote_tx_id",
                    |m: &DecryptedBallotsWithMerits| &m.blind_vote_tx_id,
                    |m: &mut DecryptedBallotsWithMerits| &mut m.blind_vote_tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "vote_reveal_tx_id",
                    |m: &DecryptedBallotsWithMerits| &m.vote_reveal_tx_id,
                    |m: &mut DecryptedBallotsWithMerits| &mut m.vote_reveal_tx_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "stake",
                    |m: &DecryptedBallotsWithMerits| &m.stake,
                    |m: &mut DecryptedBallotsWithMerits| &mut m.stake,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<BallotList>,
                    >(
                        "ballot_list",
                        |m: &DecryptedBallotsWithMerits| &m.ballot_list,
                        |m: &mut DecryptedBallotsWithMerits| &mut m.ballot_list,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<MeritList>,
                    >(
                        "merit_list",
                        |m: &DecryptedBallotsWithMerits| &m.merit_list,
                        |m: &mut DecryptedBallotsWithMerits| &mut m.merit_list,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<DecryptedBallotsWithMerits>(
                    "DecryptedBallotsWithMerits",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static DecryptedBallotsWithMerits {
        static mut instance: ::protobuf::lazy::Lazy<DecryptedBallotsWithMerits> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const DecryptedBallotsWithMerits,
            };
        unsafe { instance.get(DecryptedBallotsWithMerits::new) }
    }
}

impl ::protobuf::Clear for DecryptedBallotsWithMerits {
    fn clear(&mut self) {
        self.hash_of_blind_vote_list.clear();
        self.blind_vote_tx_id.clear();
        self.vote_reveal_tx_id.clear();
        self.stake = 0;
        self.ballot_list.clear();
        self.merit_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptedBallotsWithMerits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptedBallotsWithMerits {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct DaoStateStore {
    // message fields
    pub dao_state: ::protobuf::SingularPtrField<DaoState>,
    pub dao_state_hash: ::protobuf::RepeatedField<DaoStateHash>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DaoStateStore {
    fn default() -> &'a DaoStateStore {
        <DaoStateStore as ::protobuf::Message>::default_instance()
    }
}

impl DaoStateStore {
    pub fn new() -> DaoStateStore {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.DaoState dao_state = 1;

    pub fn get_dao_state(&self) -> &DaoState {
        self.dao_state
            .as_ref()
            .unwrap_or_else(|| DaoState::default_instance())
    }
    pub fn clear_dao_state(&mut self) {
        self.dao_state.clear();
    }

    pub fn has_dao_state(&self) -> bool {
        self.dao_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dao_state(&mut self, v: DaoState) {
        self.dao_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dao_state(&mut self) -> &mut DaoState {
        if self.dao_state.is_none() {
            self.dao_state.set_default();
        }
        self.dao_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_dao_state(&mut self) -> DaoState {
        self.dao_state.take().unwrap_or_else(|| DaoState::new())
    }

    // repeated .io.bisq.protobuffer.DaoStateHash dao_state_hash = 2;

    pub fn get_dao_state_hash(&self) -> &[DaoStateHash] {
        &self.dao_state_hash
    }
    pub fn clear_dao_state_hash(&mut self) {
        self.dao_state_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_dao_state_hash(&mut self, v: ::protobuf::RepeatedField<DaoStateHash>) {
        self.dao_state_hash = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dao_state_hash(&mut self) -> &mut ::protobuf::RepeatedField<DaoStateHash> {
        &mut self.dao_state_hash
    }

    // Take field
    pub fn take_dao_state_hash(&mut self) -> ::protobuf::RepeatedField<DaoStateHash> {
        ::std::mem::replace(&mut self.dao_state_hash, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DaoStateStore {
    fn is_initialized(&self) -> bool {
        for v in &self.dao_state {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.dao_state_hash {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dao_state)?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.dao_state_hash,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dao_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.dao_state_hash {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dao_state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.dao_state_hash {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DaoStateStore {
        DaoStateStore::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<DaoState>,
                    >(
                        "dao_state",
                        |m: &DaoStateStore| &m.dao_state,
                        |m: &mut DaoStateStore| &mut m.dao_state,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<DaoStateHash>,
                    >(
                        "dao_state_hash",
                        |m: &DaoStateStore| &m.dao_state_hash,
                        |m: &mut DaoStateStore| &mut m.dao_state_hash,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<DaoStateStore>(
                    "DaoStateStore",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static DaoStateStore {
        static mut instance: ::protobuf::lazy::Lazy<DaoStateStore> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DaoStateStore,
        };
        unsafe { instance.get(DaoStateStore::new) }
    }
}

impl ::protobuf::Clear for DaoStateStore {
    fn clear(&mut self) {
        self.dao_state.clear();
        self.dao_state_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DaoStateStore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaoStateStore {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct DaoStateHash {
    // message fields
    pub height: i32,
    pub hash: ::std::vec::Vec<u8>,
    pub prev_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DaoStateHash {
    fn default() -> &'a DaoStateHash {
        <DaoStateHash as ::protobuf::Message>::default_instance()
    }
}

impl DaoStateHash {
    pub fn new() -> DaoStateHash {
        ::std::default::Default::default()
    }

    // int32 height = 1;

    pub fn get_height(&self) -> i32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = v;
    }

    // bytes hash = 2;

    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // bytes prev_hash = 3;

    pub fn get_prev_hash(&self) -> &[u8] {
        &self.prev_hash
    }
    pub fn clear_prev_hash(&mut self) {
        self.prev_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_prev_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.prev_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prev_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prev_hash
    }

    // Take field
    pub fn take_prev_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prev_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DaoStateHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.height = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.prev_hash,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        if !self.prev_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.prev_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_int32(1, self.height)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        if !self.prev_hash.is_empty() {
            os.write_bytes(3, &self.prev_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DaoStateHash {
        DaoStateHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "height",
                    |m: &DaoStateHash| &m.height,
                    |m: &mut DaoStateHash| &mut m.height,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "hash",
                    |m: &DaoStateHash| &m.hash,
                    |m: &mut DaoStateHash| &mut m.hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "prev_hash",
                    |m: &DaoStateHash| &m.prev_hash,
                    |m: &mut DaoStateHash| &mut m.prev_hash,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DaoStateHash>(
                    "DaoStateHash",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static DaoStateHash {
        static mut instance: ::protobuf::lazy::Lazy<DaoStateHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DaoStateHash,
        };
        unsafe { instance.get(DaoStateHash::new) }
    }
}

impl ::protobuf::Clear for DaoStateHash {
    fn clear(&mut self) {
        self.height = 0;
        self.hash.clear();
        self.prev_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DaoStateHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaoStateHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ProposalStateHash {
    // message fields
    pub height: i32,
    pub hash: ::std::vec::Vec<u8>,
    pub prev_hash: ::std::vec::Vec<u8>,
    pub num_proposals: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposalStateHash {
    fn default() -> &'a ProposalStateHash {
        <ProposalStateHash as ::protobuf::Message>::default_instance()
    }
}

impl ProposalStateHash {
    pub fn new() -> ProposalStateHash {
        ::std::default::Default::default()
    }

    // int32 height = 1;

    pub fn get_height(&self) -> i32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = v;
    }

    // bytes hash = 2;

    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // bytes prev_hash = 3;

    pub fn get_prev_hash(&self) -> &[u8] {
        &self.prev_hash
    }
    pub fn clear_prev_hash(&mut self) {
        self.prev_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_prev_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.prev_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prev_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prev_hash
    }

    // Take field
    pub fn take_prev_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prev_hash, ::std::vec::Vec::new())
    }

    // int32 num_proposals = 4;

    pub fn get_num_proposals(&self) -> i32 {
        self.num_proposals
    }
    pub fn clear_num_proposals(&mut self) {
        self.num_proposals = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_proposals(&mut self, v: i32) {
        self.num_proposals = v;
    }
}

impl ::protobuf::Message for ProposalStateHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.height = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.prev_hash,
                    )?;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.num_proposals = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        if !self.prev_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.prev_hash);
        }
        if self.num_proposals != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.num_proposals,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_int32(1, self.height)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        if !self.prev_hash.is_empty() {
            os.write_bytes(3, &self.prev_hash)?;
        }
        if self.num_proposals != 0 {
            os.write_int32(4, self.num_proposals)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposalStateHash {
        ProposalStateHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "height",
                    |m: &ProposalStateHash| &m.height,
                    |m: &mut ProposalStateHash| &mut m.height,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "hash",
                    |m: &ProposalStateHash| &m.hash,
                    |m: &mut ProposalStateHash| &mut m.hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "prev_hash",
                    |m: &ProposalStateHash| &m.prev_hash,
                    |m: &mut ProposalStateHash| &mut m.prev_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "num_proposals",
                    |m: &ProposalStateHash| &m.num_proposals,
                    |m: &mut ProposalStateHash| &mut m.num_proposals,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProposalStateHash>(
                    "ProposalStateHash",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static ProposalStateHash {
        static mut instance: ::protobuf::lazy::Lazy<ProposalStateHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProposalStateHash,
        };
        unsafe { instance.get(ProposalStateHash::new) }
    }
}

impl ::protobuf::Clear for ProposalStateHash {
    fn clear(&mut self) {
        self.height = 0;
        self.hash.clear();
        self.prev_hash.clear();
        self.num_proposals = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposalStateHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposalStateHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct BlindVoteStateHash {
    // message fields
    pub height: i32,
    pub hash: ::std::vec::Vec<u8>,
    pub prev_hash: ::std::vec::Vec<u8>,
    pub num_blind_votes: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlindVoteStateHash {
    fn default() -> &'a BlindVoteStateHash {
        <BlindVoteStateHash as ::protobuf::Message>::default_instance()
    }
}

impl BlindVoteStateHash {
    pub fn new() -> BlindVoteStateHash {
        ::std::default::Default::default()
    }

    // int32 height = 1;

    pub fn get_height(&self) -> i32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = v;
    }

    // bytes hash = 2;

    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // bytes prev_hash = 3;

    pub fn get_prev_hash(&self) -> &[u8] {
        &self.prev_hash
    }
    pub fn clear_prev_hash(&mut self) {
        self.prev_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_prev_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.prev_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prev_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prev_hash
    }

    // Take field
    pub fn take_prev_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prev_hash, ::std::vec::Vec::new())
    }

    // int32 num_blind_votes = 4;

    pub fn get_num_blind_votes(&self) -> i32 {
        self.num_blind_votes
    }
    pub fn clear_num_blind_votes(&mut self) {
        self.num_blind_votes = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_blind_votes(&mut self, v: i32) {
        self.num_blind_votes = v;
    }
}

impl ::protobuf::Message for BlindVoteStateHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.height = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.prev_hash,
                    )?;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.num_blind_votes = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        if !self.prev_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.prev_hash);
        }
        if self.num_blind_votes != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.num_blind_votes,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_int32(1, self.height)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        if !self.prev_hash.is_empty() {
            os.write_bytes(3, &self.prev_hash)?;
        }
        if self.num_blind_votes != 0 {
            os.write_int32(4, self.num_blind_votes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlindVoteStateHash {
        BlindVoteStateHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "height",
                    |m: &BlindVoteStateHash| &m.height,
                    |m: &mut BlindVoteStateHash| &mut m.height,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "hash",
                    |m: &BlindVoteStateHash| &m.hash,
                    |m: &mut BlindVoteStateHash| &mut m.hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "prev_hash",
                    |m: &BlindVoteStateHash| &m.prev_hash,
                    |m: &mut BlindVoteStateHash| &mut m.prev_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "num_blind_votes",
                    |m: &BlindVoteStateHash| &m.num_blind_votes,
                    |m: &mut BlindVoteStateHash| &mut m.num_blind_votes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlindVoteStateHash>(
                    "BlindVoteStateHash",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static BlindVoteStateHash {
        static mut instance: ::protobuf::lazy::Lazy<BlindVoteStateHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlindVoteStateHash,
        };
        unsafe { instance.get(BlindVoteStateHash::new) }
    }
}

impl ::protobuf::Clear for BlindVoteStateHash {
    fn clear(&mut self) {
        self.height = 0;
        self.hash.clear();
        self.prev_hash.clear();
        self.num_blind_votes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlindVoteStateHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlindVoteStateHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct BlockChainExplorer {
    // message fields
    pub name: ::std::string::String,
    pub tx_url: ::std::string::String,
    pub address_url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockChainExplorer {
    fn default() -> &'a BlockChainExplorer {
        <BlockChainExplorer as ::protobuf::Message>::default_instance()
    }
}

impl BlockChainExplorer {
    pub fn new() -> BlockChainExplorer {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string tx_url = 2;

    pub fn get_tx_url(&self) -> &str {
        &self.tx_url
    }
    pub fn clear_tx_url(&mut self) {
        self.tx_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_url(&mut self, v: ::std::string::String) {
        self.tx_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_url(&mut self) -> &mut ::std::string::String {
        &mut self.tx_url
    }

    // Take field
    pub fn take_tx_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_url, ::std::string::String::new())
    }

    // string address_url = 3;

    pub fn get_address_url(&self) -> &str {
        &self.address_url
    }
    pub fn clear_address_url(&mut self) {
        self.address_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_url(&mut self, v: ::std::string::String) {
        self.address_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address_url(&mut self) -> &mut ::std::string::String {
        &mut self.address_url
    }

    // Take field
    pub fn take_address_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address_url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BlockChainExplorer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.tx_url,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.address_url,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.tx_url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tx_url);
        }
        if !self.address_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.tx_url.is_empty() {
            os.write_string(2, &self.tx_url)?;
        }
        if !self.address_url.is_empty() {
            os.write_string(3, &self.address_url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockChainExplorer {
        BlockChainExplorer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "name",
                    |m: &BlockChainExplorer| &m.name,
                    |m: &mut BlockChainExplorer| &mut m.name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "tx_url",
                    |m: &BlockChainExplorer| &m.tx_url,
                    |m: &mut BlockChainExplorer| &mut m.tx_url,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "address_url",
                    |m: &BlockChainExplorer| &m.address_url,
                    |m: &mut BlockChainExplorer| &mut m.address_url,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockChainExplorer>(
                    "BlockChainExplorer",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static BlockChainExplorer {
        static mut instance: ::protobuf::lazy::Lazy<BlockChainExplorer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockChainExplorer,
        };
        unsafe { instance.get(BlockChainExplorer::new) }
    }
}

impl ::protobuf::Clear for BlockChainExplorer {
    fn clear(&mut self) {
        self.name.clear();
        self.tx_url.clear();
        self.address_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockChainExplorer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockChainExplorer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PaymentAccount {
    // message fields
    pub id: ::std::string::String,
    pub creation_date: i64,
    pub payment_method: ::protobuf::SingularPtrField<PaymentMethod>,
    pub account_name: ::std::string::String,
    pub trade_currencies: ::protobuf::RepeatedField<TradeCurrency>,
    pub selected_trade_currency: ::protobuf::SingularPtrField<TradeCurrency>,
    pub payment_account_payload: ::protobuf::SingularPtrField<PaymentAccountPayload>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentAccount {
    fn default() -> &'a PaymentAccount {
        <PaymentAccount as ::protobuf::Message>::default_instance()
    }
}

impl PaymentAccount {
    pub fn new() -> PaymentAccount {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // int64 creation_date = 2;

    pub fn get_creation_date(&self) -> i64 {
        self.creation_date
    }
    pub fn clear_creation_date(&mut self) {
        self.creation_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_date(&mut self, v: i64) {
        self.creation_date = v;
    }

    // .io.bisq.protobuffer.PaymentMethod payment_method = 3;

    pub fn get_payment_method(&self) -> &PaymentMethod {
        self.payment_method
            .as_ref()
            .unwrap_or_else(|| PaymentMethod::default_instance())
    }
    pub fn clear_payment_method(&mut self) {
        self.payment_method.clear();
    }

    pub fn has_payment_method(&self) -> bool {
        self.payment_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_method(&mut self, v: PaymentMethod) {
        self.payment_method = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_method(&mut self) -> &mut PaymentMethod {
        if self.payment_method.is_none() {
            self.payment_method.set_default();
        }
        self.payment_method.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment_method(&mut self) -> PaymentMethod {
        self.payment_method
            .take()
            .unwrap_or_else(|| PaymentMethod::new())
    }

    // string account_name = 4;

    pub fn get_account_name(&self) -> &str {
        &self.account_name
    }
    pub fn clear_account_name(&mut self) {
        self.account_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        &mut self.account_name
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_name, ::std::string::String::new())
    }

    // repeated .io.bisq.protobuffer.TradeCurrency trade_currencies = 5;

    pub fn get_trade_currencies(&self) -> &[TradeCurrency] {
        &self.trade_currencies
    }
    pub fn clear_trade_currencies(&mut self) {
        self.trade_currencies.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_currencies(&mut self, v: ::protobuf::RepeatedField<TradeCurrency>) {
        self.trade_currencies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trade_currencies(&mut self) -> &mut ::protobuf::RepeatedField<TradeCurrency> {
        &mut self.trade_currencies
    }

    // Take field
    pub fn take_trade_currencies(&mut self) -> ::protobuf::RepeatedField<TradeCurrency> {
        ::std::mem::replace(&mut self.trade_currencies, ::protobuf::RepeatedField::new())
    }

    // .io.bisq.protobuffer.TradeCurrency selected_trade_currency = 6;

    pub fn get_selected_trade_currency(&self) -> &TradeCurrency {
        self.selected_trade_currency
            .as_ref()
            .unwrap_or_else(|| TradeCurrency::default_instance())
    }
    pub fn clear_selected_trade_currency(&mut self) {
        self.selected_trade_currency.clear();
    }

    pub fn has_selected_trade_currency(&self) -> bool {
        self.selected_trade_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_trade_currency(&mut self, v: TradeCurrency) {
        self.selected_trade_currency = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selected_trade_currency(&mut self) -> &mut TradeCurrency {
        if self.selected_trade_currency.is_none() {
            self.selected_trade_currency.set_default();
        }
        self.selected_trade_currency.as_mut().unwrap()
    }

    // Take field
    pub fn take_selected_trade_currency(&mut self) -> TradeCurrency {
        self.selected_trade_currency
            .take()
            .unwrap_or_else(|| TradeCurrency::new())
    }

    // .io.bisq.protobuffer.PaymentAccountPayload payment_account_payload = 7;

    pub fn get_payment_account_payload(&self) -> &PaymentAccountPayload {
        self.payment_account_payload
            .as_ref()
            .unwrap_or_else(|| PaymentAccountPayload::default_instance())
    }
    pub fn clear_payment_account_payload(&mut self) {
        self.payment_account_payload.clear();
    }

    pub fn has_payment_account_payload(&self) -> bool {
        self.payment_account_payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_account_payload(&mut self, v: PaymentAccountPayload) {
        self.payment_account_payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_account_payload(&mut self) -> &mut PaymentAccountPayload {
        if self.payment_account_payload.is_none() {
            self.payment_account_payload.set_default();
        }
        self.payment_account_payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment_account_payload(&mut self) -> PaymentAccountPayload {
        self.payment_account_payload
            .take()
            .unwrap_or_else(|| PaymentAccountPayload::new())
    }
}

impl ::protobuf::Message for PaymentAccount {
    fn is_initialized(&self) -> bool {
        for v in &self.payment_method {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.trade_currencies {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.selected_trade_currency {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.payment_account_payload {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_date = tmp;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.payment_method,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.account_name,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.trade_currencies,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.selected_trade_currency,
                    )?;
                }
                7 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.payment_account_payload,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.creation_date != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.creation_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if let Some(ref v) = self.payment_method.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.account_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.account_name);
        }
        for value in &self.trade_currencies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.selected_trade_currency.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.payment_account_payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.creation_date != 0 {
            os.write_int64(2, self.creation_date)?;
        }
        if let Some(ref v) = self.payment_method.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.account_name.is_empty() {
            os.write_string(4, &self.account_name)?;
        }
        for v in &self.trade_currencies {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.selected_trade_currency.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.payment_account_payload.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaymentAccount {
        PaymentAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "id",
                    |m: &PaymentAccount| &m.id,
                    |m: &mut PaymentAccount| &mut m.id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "creation_date",
                    |m: &PaymentAccount| &m.creation_date,
                    |m: &mut PaymentAccount| &mut m.creation_date,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PaymentMethod>,
                    >(
                        "payment_method",
                        |m: &PaymentAccount| &m.payment_method,
                        |m: &mut PaymentAccount| &mut m.payment_method,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "account_name",
                    |m: &PaymentAccount| &m.account_name,
                    |m: &mut PaymentAccount| &mut m.account_name,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<TradeCurrency>,
                    >(
                        "trade_currencies",
                        |m: &PaymentAccount| &m.trade_currencies,
                        |m: &mut PaymentAccount| &mut m.trade_currencies,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<TradeCurrency>,
                    >(
                        "selected_trade_currency",
                        |m: &PaymentAccount| &m.selected_trade_currency,
                        |m: &mut PaymentAccount| &mut m.selected_trade_currency,
                    ),
                );
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PaymentAccountPayload>,
                    >(
                        "payment_account_payload",
                        |m: &PaymentAccount| &m.payment_account_payload,
                        |m: &mut PaymentAccount| &mut m.payment_account_payload,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<PaymentAccount>(
                    "PaymentAccount",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PaymentAccount {
        static mut instance: ::protobuf::lazy::Lazy<PaymentAccount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PaymentAccount,
        };
        unsafe { instance.get(PaymentAccount::new) }
    }
}

impl ::protobuf::Clear for PaymentAccount {
    fn clear(&mut self) {
        self.id.clear();
        self.creation_date = 0;
        self.payment_method.clear();
        self.account_name.clear();
        self.trade_currencies.clear();
        self.selected_trade_currency.clear();
        self.payment_account_payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PaymentMethod {
    // message fields
    pub id: ::std::string::String,
    pub max_trade_period: i64,
    pub max_trade_limit: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentMethod {
    fn default() -> &'a PaymentMethod {
        <PaymentMethod as ::protobuf::Message>::default_instance()
    }
}

impl PaymentMethod {
    pub fn new() -> PaymentMethod {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // int64 max_trade_period = 2;

    pub fn get_max_trade_period(&self) -> i64 {
        self.max_trade_period
    }
    pub fn clear_max_trade_period(&mut self) {
        self.max_trade_period = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_trade_period(&mut self, v: i64) {
        self.max_trade_period = v;
    }

    // int64 max_trade_limit = 3;

    pub fn get_max_trade_limit(&self) -> i64 {
        self.max_trade_limit
    }
    pub fn clear_max_trade_limit(&mut self) {
        self.max_trade_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_trade_limit(&mut self, v: i64) {
        self.max_trade_limit = v;
    }
}

impl ::protobuf::Message for PaymentMethod {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.max_trade_period = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.max_trade_limit = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.max_trade_period != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.max_trade_period,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.max_trade_limit != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.max_trade_limit,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.max_trade_period != 0 {
            os.write_int64(2, self.max_trade_period)?;
        }
        if self.max_trade_limit != 0 {
            os.write_int64(3, self.max_trade_limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaymentMethod {
        PaymentMethod::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "id",
                    |m: &PaymentMethod| &m.id,
                    |m: &mut PaymentMethod| &mut m.id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "max_trade_period",
                    |m: &PaymentMethod| &m.max_trade_period,
                    |m: &mut PaymentMethod| &mut m.max_trade_period,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "max_trade_limit",
                    |m: &PaymentMethod| &m.max_trade_limit,
                    |m: &mut PaymentMethod| &mut m.max_trade_limit,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PaymentMethod>(
                    "PaymentMethod",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PaymentMethod {
        static mut instance: ::protobuf::lazy::Lazy<PaymentMethod> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PaymentMethod,
        };
        unsafe { instance.get(PaymentMethod::new) }
    }
}

impl ::protobuf::Clear for PaymentMethod {
    fn clear(&mut self) {
        self.id.clear();
        self.max_trade_period = 0;
        self.max_trade_limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentMethod {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Currency {
    // message fields
    pub currency_code: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Currency {
    fn default() -> &'a Currency {
        <Currency as ::protobuf::Message>::default_instance()
    }
}

impl Currency {
    pub fn new() -> Currency {
        ::std::default::Default::default()
    }

    // string currency_code = 1;

    pub fn get_currency_code(&self) -> &str {
        &self.currency_code
    }
    pub fn clear_currency_code(&mut self) {
        self.currency_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_currency_code(&mut self, v: ::std::string::String) {
        self.currency_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currency_code(&mut self) -> &mut ::std::string::String {
        &mut self.currency_code
    }

    // Take field
    pub fn take_currency_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.currency_code, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Currency {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.currency_code,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.currency_code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.currency_code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.currency_code.is_empty() {
            os.write_string(1, &self.currency_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Currency {
        Currency::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "currency_code",
                    |m: &Currency| &m.currency_code,
                    |m: &mut Currency| &mut m.currency_code,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Currency>(
                    "Currency",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Currency {
        static mut instance: ::protobuf::lazy::Lazy<Currency> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Currency,
        };
        unsafe { instance.get(Currency::new) }
    }
}

impl ::protobuf::Clear for Currency {
    fn clear(&mut self) {
        self.currency_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Currency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Currency {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct TradeCurrency {
    // message fields
    pub code: ::std::string::String,
    pub name: ::std::string::String,
    // message oneof groups
    pub message: ::std::option::Option<TradeCurrency_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradeCurrency {
    fn default() -> &'a TradeCurrency {
        <TradeCurrency as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum TradeCurrency_oneof_message {
    crypto_currency(CryptoCurrency),
    fiat_currency(FiatCurrency),
}

impl TradeCurrency {
    pub fn new() -> TradeCurrency {
        ::std::default::Default::default()
    }

    // string code = 1;

    pub fn get_code(&self) -> &str {
        &self.code
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.code, ::std::string::String::new())
    }

    // string name = 2;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.CryptoCurrency crypto_currency = 3;

    pub fn get_crypto_currency(&self) -> &CryptoCurrency {
        match self.message {
            ::std::option::Option::Some(TradeCurrency_oneof_message::crypto_currency(ref v)) => v,
            _ => CryptoCurrency::default_instance(),
        }
    }
    pub fn clear_crypto_currency(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_crypto_currency(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(TradeCurrency_oneof_message::crypto_currency(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_crypto_currency(&mut self, v: CryptoCurrency) {
        self.message = ::std::option::Option::Some(TradeCurrency_oneof_message::crypto_currency(v))
    }

    // Mutable pointer to the field.
    pub fn mut_crypto_currency(&mut self) -> &mut CryptoCurrency {
        if let ::std::option::Option::Some(TradeCurrency_oneof_message::crypto_currency(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(
                TradeCurrency_oneof_message::crypto_currency(CryptoCurrency::new()),
            );
        }
        match self.message {
            ::std::option::Option::Some(TradeCurrency_oneof_message::crypto_currency(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_crypto_currency(&mut self) -> CryptoCurrency {
        if self.has_crypto_currency() {
            match self.message.take() {
                ::std::option::Option::Some(TradeCurrency_oneof_message::crypto_currency(v)) => v,
                _ => panic!(),
            }
        } else {
            CryptoCurrency::new()
        }
    }

    // .io.bisq.protobuffer.FiatCurrency fiat_currency = 4;

    pub fn get_fiat_currency(&self) -> &FiatCurrency {
        match self.message {
            ::std::option::Option::Some(TradeCurrency_oneof_message::fiat_currency(ref v)) => v,
            _ => FiatCurrency::default_instance(),
        }
    }
    pub fn clear_fiat_currency(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_fiat_currency(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(TradeCurrency_oneof_message::fiat_currency(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fiat_currency(&mut self, v: FiatCurrency) {
        self.message = ::std::option::Option::Some(TradeCurrency_oneof_message::fiat_currency(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fiat_currency(&mut self) -> &mut FiatCurrency {
        if let ::std::option::Option::Some(TradeCurrency_oneof_message::fiat_currency(_)) =
            self.message
        {
        } else {
            self.message = ::std::option::Option::Some(TradeCurrency_oneof_message::fiat_currency(
                FiatCurrency::new(),
            ));
        }
        match self.message {
            ::std::option::Option::Some(TradeCurrency_oneof_message::fiat_currency(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fiat_currency(&mut self) -> FiatCurrency {
        if self.has_fiat_currency() {
            match self.message.take() {
                ::std::option::Option::Some(TradeCurrency_oneof_message::fiat_currency(v)) => v,
                _ => panic!(),
            }
        } else {
            FiatCurrency::new()
        }
    }
}

impl ::protobuf::Message for TradeCurrency {
    fn is_initialized(&self) -> bool {
        if let Some(TradeCurrency_oneof_message::crypto_currency(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TradeCurrency_oneof_message::fiat_currency(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.code,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        TradeCurrency_oneof_message::crypto_currency(is.read_message()?),
                    );
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.message = ::std::option::Option::Some(
                        TradeCurrency_oneof_message::fiat_currency(is.read_message()?),
                    );
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &TradeCurrency_oneof_message::crypto_currency(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
                &TradeCurrency_oneof_message::fiat_currency(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &TradeCurrency_oneof_message::crypto_currency(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
                &TradeCurrency_oneof_message::fiat_currency(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradeCurrency {
        TradeCurrency::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "code",
                    |m: &TradeCurrency| { &m.code },
                    |m: &mut TradeCurrency| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &TradeCurrency| { &m.name },
                    |m: &mut TradeCurrency| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CryptoCurrency>(
                    "crypto_currency",
                    TradeCurrency::has_crypto_currency,
                    TradeCurrency::get_crypto_currency,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FiatCurrency>(
                    "fiat_currency",
                    TradeCurrency::has_fiat_currency,
                    TradeCurrency::get_fiat_currency,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TradeCurrency>(
                    "TradeCurrency",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TradeCurrency {
        static mut instance: ::protobuf::lazy::Lazy<TradeCurrency> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TradeCurrency,
        };
        unsafe { instance.get(TradeCurrency::new) }
    }
}

impl ::protobuf::Clear for TradeCurrency {
    fn clear(&mut self) {
        self.code.clear();
        self.name.clear();
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TradeCurrency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TradeCurrency {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct CryptoCurrency {
    // message fields
    pub is_asset: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CryptoCurrency {
    fn default() -> &'a CryptoCurrency {
        <CryptoCurrency as ::protobuf::Message>::default_instance()
    }
}

impl CryptoCurrency {
    pub fn new() -> CryptoCurrency {
        ::std::default::Default::default()
    }

    // bool is_asset = 1;

    pub fn get_is_asset(&self) -> bool {
        self.is_asset
    }
    pub fn clear_is_asset(&mut self) {
        self.is_asset = false;
    }

    // Param is passed by value, moved
    pub fn set_is_asset(&mut self, v: bool) {
        self.is_asset = v;
    }
}

impl ::protobuf::Message for CryptoCurrency {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_asset = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_asset != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.is_asset != false {
            os.write_bool(1, self.is_asset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CryptoCurrency {
        CryptoCurrency::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_asset",
                    |m: &CryptoCurrency| &m.is_asset,
                    |m: &mut CryptoCurrency| &mut m.is_asset,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CryptoCurrency>(
                    "CryptoCurrency",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static CryptoCurrency {
        static mut instance: ::protobuf::lazy::Lazy<CryptoCurrency> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CryptoCurrency,
        };
        unsafe { instance.get(CryptoCurrency::new) }
    }
}

impl ::protobuf::Clear for CryptoCurrency {
    fn clear(&mut self) {
        self.is_asset = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CryptoCurrency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptoCurrency {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct FiatCurrency {
    // message fields
    pub currency: ::protobuf::SingularPtrField<Currency>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FiatCurrency {
    fn default() -> &'a FiatCurrency {
        <FiatCurrency as ::protobuf::Message>::default_instance()
    }
}

impl FiatCurrency {
    pub fn new() -> FiatCurrency {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.Currency currency = 1;

    pub fn get_currency(&self) -> &Currency {
        self.currency
            .as_ref()
            .unwrap_or_else(|| Currency::default_instance())
    }
    pub fn clear_currency(&mut self) {
        self.currency.clear();
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: Currency) {
        self.currency = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currency(&mut self) -> &mut Currency {
        if self.currency.is_none() {
            self.currency.set_default();
        }
        self.currency.as_mut().unwrap()
    }

    // Take field
    pub fn take_currency(&mut self) -> Currency {
        self.currency.take().unwrap_or_else(|| Currency::new())
    }
}

impl ::protobuf::Message for FiatCurrency {
    fn is_initialized(&self) -> bool {
        for v in &self.currency {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.currency)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.currency.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.currency.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FiatCurrency {
        FiatCurrency::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Currency>,
                    >(
                        "currency",
                        |m: &FiatCurrency| &m.currency,
                        |m: &mut FiatCurrency| &mut m.currency,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<FiatCurrency>(
                    "FiatCurrency",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static FiatCurrency {
        static mut instance: ::protobuf::lazy::Lazy<FiatCurrency> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FiatCurrency,
        };
        unsafe { instance.get(FiatCurrency::new) }
    }
}

impl ::protobuf::Clear for FiatCurrency {
    fn clear(&mut self) {
        self.currency.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FiatCurrency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FiatCurrency {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Country {
    // message fields
    pub code: ::std::string::String,
    pub name: ::std::string::String,
    pub region: ::protobuf::SingularPtrField<Region>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Country {
    fn default() -> &'a Country {
        <Country as ::protobuf::Message>::default_instance()
    }
}

impl Country {
    pub fn new() -> Country {
        ::std::default::Default::default()
    }

    // string code = 1;

    pub fn get_code(&self) -> &str {
        &self.code
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.code, ::std::string::String::new())
    }

    // string name = 2;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.Region region = 3;

    pub fn get_region(&self) -> &Region {
        self.region
            .as_ref()
            .unwrap_or_else(|| Region::default_instance())
    }
    pub fn clear_region(&mut self) {
        self.region.clear();
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: Region) {
        self.region = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region(&mut self) -> &mut Region {
        if self.region.is_none() {
            self.region.set_default();
        }
        self.region.as_mut().unwrap()
    }

    // Take field
    pub fn take_region(&mut self) -> Region {
        self.region.take().unwrap_or_else(|| Region::new())
    }
}

impl ::protobuf::Message for Country {
    fn is_initialized(&self) -> bool {
        for v in &self.region {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.code,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(ref v) = self.region.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(ref v) = self.region.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Country {
        Country::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "code",
                    |m: &Country| &m.code,
                    |m: &mut Country| &mut m.code,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "name",
                    |m: &Country| &m.name,
                    |m: &mut Country| &mut m.name,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Region>,
                    >(
                        "region",
                        |m: &Country| &m.region,
                        |m: &mut Country| &mut m.region,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<Country>(
                    "Country",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Country {
        static mut instance: ::protobuf::lazy::Lazy<Country> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Country,
        };
        unsafe { instance.get(Country::new) }
    }
}

impl ::protobuf::Clear for Country {
    fn clear(&mut self) {
        self.code.clear();
        self.name.clear();
        self.region.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Country {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Country {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Region {
    // message fields
    pub code: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Region {
    fn default() -> &'a Region {
        <Region as ::protobuf::Message>::default_instance()
    }
}

impl Region {
    pub fn new() -> Region {
        ::std::default::Default::default()
    }

    // string code = 1;

    pub fn get_code(&self) -> &str {
        &self.code
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.code, ::std::string::String::new())
    }

    // string name = 2;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Region {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.code,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Region {
        Region::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "code", |m: &Region| &m.code, |m: &mut Region| &mut m.code
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "name", |m: &Region| &m.name, |m: &mut Region| &mut m.name
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Region>(
                    "Region",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Region {
        static mut instance: ::protobuf::lazy::Lazy<Region> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Region,
        };
        unsafe { instance.get(Region::new) }
    }
}

impl ::protobuf::Clear for Region {
    fn clear(&mut self) {
        self.code.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Region {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Region {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct PriceAlertFilter {
    // message fields
    pub currencyCode: ::std::string::String,
    pub high: i64,
    pub low: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PriceAlertFilter {
    fn default() -> &'a PriceAlertFilter {
        <PriceAlertFilter as ::protobuf::Message>::default_instance()
    }
}

impl PriceAlertFilter {
    pub fn new() -> PriceAlertFilter {
        ::std::default::Default::default()
    }

    // string currencyCode = 1;

    pub fn get_currencyCode(&self) -> &str {
        &self.currencyCode
    }
    pub fn clear_currencyCode(&mut self) {
        self.currencyCode.clear();
    }

    // Param is passed by value, moved
    pub fn set_currencyCode(&mut self, v: ::std::string::String) {
        self.currencyCode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currencyCode(&mut self) -> &mut ::std::string::String {
        &mut self.currencyCode
    }

    // Take field
    pub fn take_currencyCode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.currencyCode, ::std::string::String::new())
    }

    // int64 high = 2;

    pub fn get_high(&self) -> i64 {
        self.high
    }
    pub fn clear_high(&mut self) {
        self.high = 0;
    }

    // Param is passed by value, moved
    pub fn set_high(&mut self, v: i64) {
        self.high = v;
    }

    // int64 low = 3;

    pub fn get_low(&self) -> i64 {
        self.low
    }
    pub fn clear_low(&mut self) {
        self.low = 0;
    }

    // Param is passed by value, moved
    pub fn set_low(&mut self, v: i64) {
        self.low = v;
    }
}

impl ::protobuf::Message for PriceAlertFilter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.currencyCode,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.high = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.low = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.currencyCode.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.currencyCode);
        }
        if self.high != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.high, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.low != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.low, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.currencyCode.is_empty() {
            os.write_string(1, &self.currencyCode)?;
        }
        if self.high != 0 {
            os.write_int64(2, self.high)?;
        }
        if self.low != 0 {
            os.write_int64(3, self.low)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PriceAlertFilter {
        PriceAlertFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "currencyCode",
                    |m: &PriceAlertFilter| &m.currencyCode,
                    |m: &mut PriceAlertFilter| &mut m.currencyCode,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "high",
                    |m: &PriceAlertFilter| &m.high,
                    |m: &mut PriceAlertFilter| &mut m.high,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "low",
                    |m: &PriceAlertFilter| &m.low,
                    |m: &mut PriceAlertFilter| &mut m.low,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PriceAlertFilter>(
                    "PriceAlertFilter",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static PriceAlertFilter {
        static mut instance: ::protobuf::lazy::Lazy<PriceAlertFilter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PriceAlertFilter,
        };
        unsafe { instance.get(PriceAlertFilter::new) }
    }
}

impl ::protobuf::Clear for PriceAlertFilter {
    fn clear(&mut self) {
        self.currencyCode.clear();
        self.high = 0;
        self.low = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PriceAlertFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PriceAlertFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MarketAlertFilter {
    // message fields
    pub payment_account: ::protobuf::SingularPtrField<PaymentAccount>,
    pub trigger_value: i32,
    pub is_buy_offer: bool,
    pub alert_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarketAlertFilter {
    fn default() -> &'a MarketAlertFilter {
        <MarketAlertFilter as ::protobuf::Message>::default_instance()
    }
}

impl MarketAlertFilter {
    pub fn new() -> MarketAlertFilter {
        ::std::default::Default::default()
    }

    // .io.bisq.protobuffer.PaymentAccount payment_account = 1;

    pub fn get_payment_account(&self) -> &PaymentAccount {
        self.payment_account
            .as_ref()
            .unwrap_or_else(|| PaymentAccount::default_instance())
    }
    pub fn clear_payment_account(&mut self) {
        self.payment_account.clear();
    }

    pub fn has_payment_account(&self) -> bool {
        self.payment_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_account(&mut self, v: PaymentAccount) {
        self.payment_account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_account(&mut self) -> &mut PaymentAccount {
        if self.payment_account.is_none() {
            self.payment_account.set_default();
        }
        self.payment_account.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment_account(&mut self) -> PaymentAccount {
        self.payment_account
            .take()
            .unwrap_or_else(|| PaymentAccount::new())
    }

    // int32 trigger_value = 2;

    pub fn get_trigger_value(&self) -> i32 {
        self.trigger_value
    }
    pub fn clear_trigger_value(&mut self) {
        self.trigger_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_trigger_value(&mut self, v: i32) {
        self.trigger_value = v;
    }

    // bool is_buy_offer = 3;

    pub fn get_is_buy_offer(&self) -> bool {
        self.is_buy_offer
    }
    pub fn clear_is_buy_offer(&mut self) {
        self.is_buy_offer = false;
    }

    // Param is passed by value, moved
    pub fn set_is_buy_offer(&mut self, v: bool) {
        self.is_buy_offer = v;
    }

    // repeated string alert_ids = 4;

    pub fn get_alert_ids(&self) -> &[::std::string::String] {
        &self.alert_ids
    }
    pub fn clear_alert_ids(&mut self) {
        self.alert_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_alert_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.alert_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_alert_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.alert_ids
    }

    // Take field
    pub fn take_alert_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.alert_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MarketAlertFilter {
    fn is_initialized(&self) -> bool {
        for v in &self.payment_account {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.payment_account,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.trigger_value = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.is_buy_offer = tmp;
                }
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.alert_ids)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.payment_account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.trigger_value != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.trigger_value,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.is_buy_offer != false {
            my_size += 2;
        }
        for value in &self.alert_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.payment_account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.trigger_value != 0 {
            os.write_int32(2, self.trigger_value)?;
        }
        if self.is_buy_offer != false {
            os.write_bool(3, self.is_buy_offer)?;
        }
        for v in &self.alert_ids {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarketAlertFilter {
        MarketAlertFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<PaymentAccount>,
                    >(
                        "payment_account",
                        |m: &MarketAlertFilter| &m.payment_account,
                        |m: &mut MarketAlertFilter| &mut m.payment_account,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt32,
                >(
                    "trigger_value",
                    |m: &MarketAlertFilter| &m.trigger_value,
                    |m: &mut MarketAlertFilter| &mut m.trigger_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBool,
                >(
                    "is_buy_offer",
                    |m: &MarketAlertFilter| &m.is_buy_offer,
                    |m: &mut MarketAlertFilter| &mut m.is_buy_offer,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeString,
                    >(
                        "alert_ids",
                        |m: &MarketAlertFilter| &m.alert_ids,
                        |m: &mut MarketAlertFilter| &mut m.alert_ids,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<MarketAlertFilter>(
                    "MarketAlertFilter",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MarketAlertFilter {
        static mut instance: ::protobuf::lazy::Lazy<MarketAlertFilter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MarketAlertFilter,
        };
        unsafe { instance.get(MarketAlertFilter::new) }
    }
}

impl ::protobuf::Clear for MarketAlertFilter {
    fn clear(&mut self) {
        self.payment_account.clear();
        self.trigger_value = 0;
        self.is_buy_offer = false;
        self.alert_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MarketAlertFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketAlertFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MockMailboxPayload {
    // message fields
    pub message: ::std::string::String,
    pub sender_node_address: ::protobuf::SingularPtrField<NodeAddress>,
    pub uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MockMailboxPayload {
    fn default() -> &'a MockMailboxPayload {
        <MockMailboxPayload as ::protobuf::Message>::default_instance()
    }
}

impl MockMailboxPayload {
    pub fn new() -> MockMailboxPayload {
        ::std::default::Default::default()
    }

    // string message = 1;

    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // .io.bisq.protobuffer.NodeAddress sender_node_address = 2;

    pub fn get_sender_node_address(&self) -> &NodeAddress {
        self.sender_node_address
            .as_ref()
            .unwrap_or_else(|| NodeAddress::default_instance())
    }
    pub fn clear_sender_node_address(&mut self) {
        self.sender_node_address.clear();
    }

    pub fn has_sender_node_address(&self) -> bool {
        self.sender_node_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_node_address(&mut self, v: NodeAddress) {
        self.sender_node_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_node_address(&mut self) -> &mut NodeAddress {
        if self.sender_node_address.is_none() {
            self.sender_node_address.set_default();
        }
        self.sender_node_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_node_address(&mut self) -> NodeAddress {
        self.sender_node_address
            .take()
            .unwrap_or_else(|| NodeAddress::new())
    }

    // string uid = 3;

    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MockMailboxPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.sender_node_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.message,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.sender_node_address,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        if let Some(ref v) = self.sender_node_address.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.uid.is_empty() {
            os.write_string(3, &self.uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MockMailboxPayload {
        MockMailboxPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "message",
                    |m: &MockMailboxPayload| &m.message,
                    |m: &mut MockMailboxPayload| &mut m.message,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<NodeAddress>,
                    >(
                        "sender_node_address",
                        |m: &MockMailboxPayload| &m.sender_node_address,
                        |m: &mut MockMailboxPayload| &mut m.sender_node_address,
                    ),
                );
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "uid",
                    |m: &MockMailboxPayload| &m.uid,
                    |m: &mut MockMailboxPayload| &mut m.uid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MockMailboxPayload>(
                    "MockMailboxPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MockMailboxPayload {
        static mut instance: ::protobuf::lazy::Lazy<MockMailboxPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MockMailboxPayload,
        };
        unsafe { instance.get(MockMailboxPayload::new) }
    }
}

impl ::protobuf::Clear for MockMailboxPayload {
    fn clear(&mut self) {
        self.message.clear();
        self.sender_node_address.clear();
        self.uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MockMailboxPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MockMailboxPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct MockPayload {
    // message fields
    pub message_version: ::std::string::String,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MockPayload {
    fn default() -> &'a MockPayload {
        <MockPayload as ::protobuf::Message>::default_instance()
    }
}

impl MockPayload {
    pub fn new() -> MockPayload {
        ::std::default::Default::default()
    }

    // string message_version = 1;

    pub fn get_message_version(&self) -> &str {
        &self.message_version
    }
    pub fn clear_message_version(&mut self) {
        self.message_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_version(&mut self, v: ::std::string::String) {
        self.message_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_version(&mut self) -> &mut ::std::string::String {
        &mut self.message_version
    }

    // Take field
    pub fn take_message_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_version, ::std::string::String::new())
    }

    // string message = 2;

    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MockPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.message_version,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.message,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_version);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.message_version.is_empty() {
            os.write_string(1, &self.message_version)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MockPayload {
        MockPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "message_version",
                    |m: &MockPayload| &m.message_version,
                    |m: &mut MockPayload| &mut m.message_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "message",
                    |m: &MockPayload| &m.message,
                    |m: &mut MockPayload| &mut m.message,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MockPayload>(
                    "MockPayload",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static MockPayload {
        static mut instance: ::protobuf::lazy::Lazy<MockPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MockPayload,
        };
        unsafe { instance.get(MockPayload::new) }
    }
}

impl ::protobuf::Clear for MockPayload {
    fn clear(&mut self) {
        self.message_version.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MockPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MockPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum SupportType {
    ARBITRATION = 0,
    MEDIATION = 1,
    TRADE = 2,
    REFUND = 3,
}

impl ::protobuf::ProtobufEnum for SupportType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SupportType> {
        match value {
            0 => ::std::option::Option::Some(SupportType::ARBITRATION),
            1 => ::std::option::Option::Some(SupportType::MEDIATION),
            2 => ::std::option::Option::Some(SupportType::TRADE),
            3 => ::std::option::Option::Some(SupportType::REFUND),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SupportType] = &[
            SupportType::ARBITRATION,
            SupportType::MEDIATION,
            SupportType::TRADE,
            SupportType::REFUND,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SupportType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SupportType {}

impl ::std::default::Default for SupportType {
    fn default() -> Self {
        SupportType::ARBITRATION
    }
}

impl ::protobuf::reflect::ProtobufValue for SupportType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum AvailabilityResult {
    PB_ERROR = 0,
    UNKNOWN_FAILURE = 1,
    AVAILABLE = 2,
    OFFER_TAKEN = 3,
    PRICE_OUT_OF_TOLERANCE = 4,
    MARKET_PRICE_NOT_AVAILABLE = 5,
    NO_ARBITRATORS = 6,
    NO_MEDIATORS = 7,
    USER_IGNORED = 8,
    MISSING_MANDATORY_CAPABILITY = 9,
    NO_REFUND_AGENTS = 10,
}

impl ::protobuf::ProtobufEnum for AvailabilityResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AvailabilityResult> {
        match value {
            0 => ::std::option::Option::Some(AvailabilityResult::PB_ERROR),
            1 => ::std::option::Option::Some(AvailabilityResult::UNKNOWN_FAILURE),
            2 => ::std::option::Option::Some(AvailabilityResult::AVAILABLE),
            3 => ::std::option::Option::Some(AvailabilityResult::OFFER_TAKEN),
            4 => ::std::option::Option::Some(AvailabilityResult::PRICE_OUT_OF_TOLERANCE),
            5 => ::std::option::Option::Some(AvailabilityResult::MARKET_PRICE_NOT_AVAILABLE),
            6 => ::std::option::Option::Some(AvailabilityResult::NO_ARBITRATORS),
            7 => ::std::option::Option::Some(AvailabilityResult::NO_MEDIATORS),
            8 => ::std::option::Option::Some(AvailabilityResult::USER_IGNORED),
            9 => ::std::option::Option::Some(AvailabilityResult::MISSING_MANDATORY_CAPABILITY),
            10 => ::std::option::Option::Some(AvailabilityResult::NO_REFUND_AGENTS),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AvailabilityResult] = &[
            AvailabilityResult::PB_ERROR,
            AvailabilityResult::UNKNOWN_FAILURE,
            AvailabilityResult::AVAILABLE,
            AvailabilityResult::OFFER_TAKEN,
            AvailabilityResult::PRICE_OUT_OF_TOLERANCE,
            AvailabilityResult::MARKET_PRICE_NOT_AVAILABLE,
            AvailabilityResult::NO_ARBITRATORS,
            AvailabilityResult::NO_MEDIATORS,
            AvailabilityResult::USER_IGNORED,
            AvailabilityResult::MISSING_MANDATORY_CAPABILITY,
            AvailabilityResult::NO_REFUND_AGENTS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new(
                    "AvailabilityResult",
                    file_descriptor_proto(),
                )
            })
        }
    }
}

impl ::std::marker::Copy for AvailabilityResult {}

impl ::std::default::Default for AvailabilityResult {
    fn default() -> Self {
        AvailabilityResult::PB_ERROR
    }
}

impl ::protobuf::reflect::ProtobufValue for AvailabilityResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum MediationResultState {
    PB_ERROR_MEDIATION_RESULT = 0,
    UNDEFINED_MEDIATION_RESULT = 1,
    MEDIATION_RESULT_ACCEPTED = 2,
    MEDIATION_RESULT_REJECTED = 3,
    SIG_MSG_SENT = 4,
    SIG_MSG_ARRIVED = 5,
    SIG_MSG_IN_MAILBOX = 6,
    SIG_MSG_SEND_FAILED = 7,
    RECEIVED_SIG_MSG = 8,
    PAYOUT_TX_PUBLISHED = 9,
    PAYOUT_TX_PUBLISHED_MSG_SENT = 10,
    PAYOUT_TX_PUBLISHED_MSG_ARRIVED = 11,
    PAYOUT_TX_PUBLISHED_MSG_IN_MAILBOX = 12,
    PAYOUT_TX_PUBLISHED_MSG_SEND_FAILED = 13,
    RECEIVED_PAYOUT_TX_PUBLISHED_MSG = 14,
    PAYOUT_TX_SEEN_IN_NETWORK = 15,
}

impl ::protobuf::ProtobufEnum for MediationResultState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MediationResultState> {
        match value {
            0 => ::std::option::Option::Some(MediationResultState::PB_ERROR_MEDIATION_RESULT),
            1 => ::std::option::Option::Some(MediationResultState::UNDEFINED_MEDIATION_RESULT),
            2 => ::std::option::Option::Some(MediationResultState::MEDIATION_RESULT_ACCEPTED),
            3 => ::std::option::Option::Some(MediationResultState::MEDIATION_RESULT_REJECTED),
            4 => ::std::option::Option::Some(MediationResultState::SIG_MSG_SENT),
            5 => ::std::option::Option::Some(MediationResultState::SIG_MSG_ARRIVED),
            6 => ::std::option::Option::Some(MediationResultState::SIG_MSG_IN_MAILBOX),
            7 => ::std::option::Option::Some(MediationResultState::SIG_MSG_SEND_FAILED),
            8 => ::std::option::Option::Some(MediationResultState::RECEIVED_SIG_MSG),
            9 => ::std::option::Option::Some(MediationResultState::PAYOUT_TX_PUBLISHED),
            10 => ::std::option::Option::Some(MediationResultState::PAYOUT_TX_PUBLISHED_MSG_SENT),
            11 => {
                ::std::option::Option::Some(MediationResultState::PAYOUT_TX_PUBLISHED_MSG_ARRIVED)
            }
            12 => ::std::option::Option::Some(
                MediationResultState::PAYOUT_TX_PUBLISHED_MSG_IN_MAILBOX,
            ),
            13 => ::std::option::Option::Some(
                MediationResultState::PAYOUT_TX_PUBLISHED_MSG_SEND_FAILED,
            ),
            14 => {
                ::std::option::Option::Some(MediationResultState::RECEIVED_PAYOUT_TX_PUBLISHED_MSG)
            }
            15 => ::std::option::Option::Some(MediationResultState::PAYOUT_TX_SEEN_IN_NETWORK),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MediationResultState] = &[
            MediationResultState::PB_ERROR_MEDIATION_RESULT,
            MediationResultState::UNDEFINED_MEDIATION_RESULT,
            MediationResultState::MEDIATION_RESULT_ACCEPTED,
            MediationResultState::MEDIATION_RESULT_REJECTED,
            MediationResultState::SIG_MSG_SENT,
            MediationResultState::SIG_MSG_ARRIVED,
            MediationResultState::SIG_MSG_IN_MAILBOX,
            MediationResultState::SIG_MSG_SEND_FAILED,
            MediationResultState::RECEIVED_SIG_MSG,
            MediationResultState::PAYOUT_TX_PUBLISHED,
            MediationResultState::PAYOUT_TX_PUBLISHED_MSG_SENT,
            MediationResultState::PAYOUT_TX_PUBLISHED_MSG_ARRIVED,
            MediationResultState::PAYOUT_TX_PUBLISHED_MSG_IN_MAILBOX,
            MediationResultState::PAYOUT_TX_PUBLISHED_MSG_SEND_FAILED,
            MediationResultState::RECEIVED_PAYOUT_TX_PUBLISHED_MSG,
            MediationResultState::PAYOUT_TX_SEEN_IN_NETWORK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new(
                    "MediationResultState",
                    file_descriptor_proto(),
                )
            })
        }
    }
}

impl ::std::marker::Copy for MediationResultState {}

impl ::std::default::Default for MediationResultState {
    fn default() -> Self {
        MediationResultState::PB_ERROR_MEDIATION_RESULT
    }
}

impl ::protobuf::reflect::ProtobufValue for MediationResultState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum RefundResultState {
    PB_ERROR_REFUND_RESULT = 0,
    UNDEFINED_REFUND_RESULT = 1,
}

impl ::protobuf::ProtobufEnum for RefundResultState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RefundResultState> {
        match value {
            0 => ::std::option::Option::Some(RefundResultState::PB_ERROR_REFUND_RESULT),
            1 => ::std::option::Option::Some(RefundResultState::UNDEFINED_REFUND_RESULT),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RefundResultState] = &[
            RefundResultState::PB_ERROR_REFUND_RESULT,
            RefundResultState::UNDEFINED_REFUND_RESULT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new(
                    "RefundResultState",
                    file_descriptor_proto(),
                )
            })
        }
    }
}

impl ::std::marker::Copy for RefundResultState {}

impl ::std::default::Default for RefundResultState {
    fn default() -> Self {
        RefundResultState::PB_ERROR_REFUND_RESULT
    }
}

impl ::protobuf::reflect::ProtobufValue for RefundResultState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum TxType {
    PB_ERROR_TX_TYPE = 0,
    UNDEFINED_TX_TYPE = 1,
    UNVERIFIED = 2,
    INVALID = 3,
    GENESIS = 4,
    TRANSFER_BSQ = 5,
    PAY_TRADE_FEE = 6,
    PROPOSAL = 7,
    COMPENSATION_REQUEST = 8,
    REIMBURSEMENT_REQUEST = 9,
    BLIND_VOTE = 10,
    VOTE_REVEAL = 11,
    LOCKUP = 12,
    UNLOCK = 13,
    ASSET_LISTING_FEE = 14,
    PROOF_OF_BURN = 15,
    IRREGULAR = 16,
}

impl ::protobuf::ProtobufEnum for TxType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TxType> {
        match value {
            0 => ::std::option::Option::Some(TxType::PB_ERROR_TX_TYPE),
            1 => ::std::option::Option::Some(TxType::UNDEFINED_TX_TYPE),
            2 => ::std::option::Option::Some(TxType::UNVERIFIED),
            3 => ::std::option::Option::Some(TxType::INVALID),
            4 => ::std::option::Option::Some(TxType::GENESIS),
            5 => ::std::option::Option::Some(TxType::TRANSFER_BSQ),
            6 => ::std::option::Option::Some(TxType::PAY_TRADE_FEE),
            7 => ::std::option::Option::Some(TxType::PROPOSAL),
            8 => ::std::option::Option::Some(TxType::COMPENSATION_REQUEST),
            9 => ::std::option::Option::Some(TxType::REIMBURSEMENT_REQUEST),
            10 => ::std::option::Option::Some(TxType::BLIND_VOTE),
            11 => ::std::option::Option::Some(TxType::VOTE_REVEAL),
            12 => ::std::option::Option::Some(TxType::LOCKUP),
            13 => ::std::option::Option::Some(TxType::UNLOCK),
            14 => ::std::option::Option::Some(TxType::ASSET_LISTING_FEE),
            15 => ::std::option::Option::Some(TxType::PROOF_OF_BURN),
            16 => ::std::option::Option::Some(TxType::IRREGULAR),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TxType] = &[
            TxType::PB_ERROR_TX_TYPE,
            TxType::UNDEFINED_TX_TYPE,
            TxType::UNVERIFIED,
            TxType::INVALID,
            TxType::GENESIS,
            TxType::TRANSFER_BSQ,
            TxType::PAY_TRADE_FEE,
            TxType::PROPOSAL,
            TxType::COMPENSATION_REQUEST,
            TxType::REIMBURSEMENT_REQUEST,
            TxType::BLIND_VOTE,
            TxType::VOTE_REVEAL,
            TxType::LOCKUP,
            TxType::UNLOCK,
            TxType::ASSET_LISTING_FEE,
            TxType::PROOF_OF_BURN,
            TxType::IRREGULAR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor
                .get(|| ::protobuf::reflect::EnumDescriptor::new("TxType", file_descriptor_proto()))
        }
    }
}

impl ::std::marker::Copy for TxType {}

impl ::std::default::Default for TxType {
    fn default() -> Self {
        TxType::PB_ERROR_TX_TYPE
    }
}

impl ::protobuf::reflect::ProtobufValue for TxType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum TxOutputType {
    PB_ERROR_TX_OUTPUT_TYPE = 0,
    UNDEFINED_OUTPUT = 1,
    GENESIS_OUTPUT = 2,
    BSQ_OUTPUT = 3,
    BTC_OUTPUT = 4,
    PROPOSAL_OP_RETURN_OUTPUT = 5,
    COMP_REQ_OP_RETURN_OUTPUT = 6,
    REIMBURSEMENT_OP_RETURN_OUTPUT = 7,
    CONFISCATE_BOND_OP_RETURN_OUTPUT = 8,
    ISSUANCE_CANDIDATE_OUTPUT = 9,
    BLIND_VOTE_LOCK_STAKE_OUTPUT = 10,
    BLIND_VOTE_OP_RETURN_OUTPUT = 11,
    VOTE_REVEAL_UNLOCK_STAKE_OUTPUT = 12,
    VOTE_REVEAL_OP_RETURN_OUTPUT = 13,
    ASSET_LISTING_FEE_OP_RETURN_OUTPUT = 14,
    PROOF_OF_BURN_OP_RETURN_OUTPUT = 15,
    LOCKUP_OUTPUT = 16,
    LOCKUP_OP_RETURN_OUTPUT = 17,
    UNLOCK_OUTPUT = 18,
    INVALID_OUTPUT = 19,
}

impl ::protobuf::ProtobufEnum for TxOutputType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TxOutputType> {
        match value {
            0 => ::std::option::Option::Some(TxOutputType::PB_ERROR_TX_OUTPUT_TYPE),
            1 => ::std::option::Option::Some(TxOutputType::UNDEFINED_OUTPUT),
            2 => ::std::option::Option::Some(TxOutputType::GENESIS_OUTPUT),
            3 => ::std::option::Option::Some(TxOutputType::BSQ_OUTPUT),
            4 => ::std::option::Option::Some(TxOutputType::BTC_OUTPUT),
            5 => ::std::option::Option::Some(TxOutputType::PROPOSAL_OP_RETURN_OUTPUT),
            6 => ::std::option::Option::Some(TxOutputType::COMP_REQ_OP_RETURN_OUTPUT),
            7 => ::std::option::Option::Some(TxOutputType::REIMBURSEMENT_OP_RETURN_OUTPUT),
            8 => ::std::option::Option::Some(TxOutputType::CONFISCATE_BOND_OP_RETURN_OUTPUT),
            9 => ::std::option::Option::Some(TxOutputType::ISSUANCE_CANDIDATE_OUTPUT),
            10 => ::std::option::Option::Some(TxOutputType::BLIND_VOTE_LOCK_STAKE_OUTPUT),
            11 => ::std::option::Option::Some(TxOutputType::BLIND_VOTE_OP_RETURN_OUTPUT),
            12 => ::std::option::Option::Some(TxOutputType::VOTE_REVEAL_UNLOCK_STAKE_OUTPUT),
            13 => ::std::option::Option::Some(TxOutputType::VOTE_REVEAL_OP_RETURN_OUTPUT),
            14 => ::std::option::Option::Some(TxOutputType::ASSET_LISTING_FEE_OP_RETURN_OUTPUT),
            15 => ::std::option::Option::Some(TxOutputType::PROOF_OF_BURN_OP_RETURN_OUTPUT),
            16 => ::std::option::Option::Some(TxOutputType::LOCKUP_OUTPUT),
            17 => ::std::option::Option::Some(TxOutputType::LOCKUP_OP_RETURN_OUTPUT),
            18 => ::std::option::Option::Some(TxOutputType::UNLOCK_OUTPUT),
            19 => ::std::option::Option::Some(TxOutputType::INVALID_OUTPUT),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TxOutputType] = &[
            TxOutputType::PB_ERROR_TX_OUTPUT_TYPE,
            TxOutputType::UNDEFINED_OUTPUT,
            TxOutputType::GENESIS_OUTPUT,
            TxOutputType::BSQ_OUTPUT,
            TxOutputType::BTC_OUTPUT,
            TxOutputType::PROPOSAL_OP_RETURN_OUTPUT,
            TxOutputType::COMP_REQ_OP_RETURN_OUTPUT,
            TxOutputType::REIMBURSEMENT_OP_RETURN_OUTPUT,
            TxOutputType::CONFISCATE_BOND_OP_RETURN_OUTPUT,
            TxOutputType::ISSUANCE_CANDIDATE_OUTPUT,
            TxOutputType::BLIND_VOTE_LOCK_STAKE_OUTPUT,
            TxOutputType::BLIND_VOTE_OP_RETURN_OUTPUT,
            TxOutputType::VOTE_REVEAL_UNLOCK_STAKE_OUTPUT,
            TxOutputType::VOTE_REVEAL_OP_RETURN_OUTPUT,
            TxOutputType::ASSET_LISTING_FEE_OP_RETURN_OUTPUT,
            TxOutputType::PROOF_OF_BURN_OP_RETURN_OUTPUT,
            TxOutputType::LOCKUP_OUTPUT,
            TxOutputType::LOCKUP_OP_RETURN_OUTPUT,
            TxOutputType::UNLOCK_OUTPUT,
            TxOutputType::INVALID_OUTPUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TxOutputType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TxOutputType {}

impl ::std::default::Default for TxOutputType {
    fn default() -> Self {
        TxOutputType::PB_ERROR_TX_OUTPUT_TYPE
    }
}

impl ::protobuf::reflect::ProtobufValue for TxOutputType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum ScriptType {
    PB_ERROR_SCRIPT_TYPES = 0,
    PUB_KEY = 1,
    PUB_KEY_HASH = 2,
    SCRIPT_HASH = 3,
    MULTISIG = 4,
    NULL_DATA = 5,
    WITNESS_V0_KEYHASH = 6,
    WITNESS_V0_SCRIPTHASH = 7,
    NONSTANDARD = 8,
}

impl ::protobuf::ProtobufEnum for ScriptType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ScriptType> {
        match value {
            0 => ::std::option::Option::Some(ScriptType::PB_ERROR_SCRIPT_TYPES),
            1 => ::std::option::Option::Some(ScriptType::PUB_KEY),
            2 => ::std::option::Option::Some(ScriptType::PUB_KEY_HASH),
            3 => ::std::option::Option::Some(ScriptType::SCRIPT_HASH),
            4 => ::std::option::Option::Some(ScriptType::MULTISIG),
            5 => ::std::option::Option::Some(ScriptType::NULL_DATA),
            6 => ::std::option::Option::Some(ScriptType::WITNESS_V0_KEYHASH),
            7 => ::std::option::Option::Some(ScriptType::WITNESS_V0_SCRIPTHASH),
            8 => ::std::option::Option::Some(ScriptType::NONSTANDARD),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ScriptType] = &[
            ScriptType::PB_ERROR_SCRIPT_TYPES,
            ScriptType::PUB_KEY,
            ScriptType::PUB_KEY_HASH,
            ScriptType::SCRIPT_HASH,
            ScriptType::MULTISIG,
            ScriptType::NULL_DATA,
            ScriptType::WITNESS_V0_KEYHASH,
            ScriptType::WITNESS_V0_SCRIPTHASH,
            ScriptType::NONSTANDARD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ScriptType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ScriptType {}

impl ::std::default::Default for ScriptType {
    fn default() -> Self {
        ScriptType::PB_ERROR_SCRIPT_TYPES
    }
}

impl ::protobuf::reflect::ProtobufValue for ScriptType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x08pb.proto\x12\x13io.bisq.protobuffer\"\x97*\n\x0fNetworkEnvelope\
    \x12'\n\x0fmessage_version\x18\x01\x20\x01(\x05R\x0emessageVersion\x12q\
    \n\x1cpreliminary_get_data_request\x18\x02\x20\x01(\x0b2..io.bisq.protob\
    uffer.PreliminaryGetDataRequestH\0R\x19preliminaryGetDataRequest\x12R\n\
    \x11get_data_response\x18\x03\x20\x01(\x0b2$.io.bisq.protobuffer.GetData\
    ResponseH\0R\x0fgetDataResponse\x12e\n\x18get_updated_data_request\x18\
    \x04\x20\x01(\x0b2*.io.bisq.protobuffer.GetUpdatedDataRequestH\0R\x15get\
    UpdatedDataRequest\x12R\n\x11get_peers_request\x18\x05\x20\x01(\x0b2$.io\
    .bisq.protobuffer.GetPeersRequestH\0R\x0fgetPeersRequest\x12U\n\x12get_p\
    eers_response\x18\x06\x20\x01(\x0b2%.io.bisq.protobuffer.GetPeersRespons\
    eH\0R\x10getPeersResponse\x12/\n\x04ping\x18\x07\x20\x01(\x0b2\x19.io.bi\
    sq.protobuffer.PingH\0R\x04ping\x12/\n\x04pong\x18\x08\x20\x01(\x0b2\x19\
    .io.bisq.protobuffer.PongH\0R\x04pong\x12m\n\x1aoffer_availability_reque\
    st\x18\t\x20\x01(\x0b2-.io.bisq.protobuffer.OfferAvailabilityRequestH\0R\
    \x18offerAvailabilityRequest\x12p\n\x1boffer_availability_response\x18\n\
    \x20\x01(\x0b2..io.bisq.protobuffer.OfferAvailabilityResponseH\0R\x19off\
    erAvailabilityResponse\x12^\n\x15refresh_offer_message\x18\x0b\x20\x01(\
    \x0b2(.io.bisq.protobuffer.RefreshOfferMessageH\0R\x13refreshOfferMessag\
    e\x12O\n\x10add_data_message\x18\x0c\x20\x01(\x0b2#.io.bisq.protobuffer.\
    AddDataMessageH\0R\x0eaddDataMessage\x12X\n\x13remove_data_message\x18\r\
    \x20\x01(\x0b2&.io.bisq.protobuffer.RemoveDataMessageH\0R\x11removeDataM\
    essage\x12n\n\x1bremove_mailbox_data_message\x18\x0e\x20\x01(\x0b2-.io.b\
    isq.protobuffer.RemoveMailboxDataMessageH\0R\x18removeMailboxDataMessage\
    \x12g\n\x18close_connection_message\x18\x0f\x20\x01(\x0b2+.io.bisq.proto\
    buffer.CloseConnectionMessageH\0R\x16closeConnectionMessage\x12\x81\x01\
    \n\"prefixed_sealed_and_signed_message\x18\x10\x20\x01(\x0b23.io.bisq.pr\
    otobuffer.PrefixedSealedAndSignedMessageH\0R\x1eprefixedSealedAndSignedM\
    essage\x12r\n\x1dinputs_for_deposit_tx_request\x18\x11\x20\x01(\x0b2..io\
    .bisq.protobuffer.InputsForDepositTxRequestH\0R\x19inputsForDepositTxReq\
    uest\x12u\n\x1einputs_for_deposit_tx_response\x18\x12\x20\x01(\x0b2/.io.\
    bisq.protobuffer.InputsForDepositTxResponseH\0R\x1ainputsForDepositTxRes\
    ponse\x12U\n\x12deposit_tx_message\x18\x13\x20\x01(\x0b2%.io.bisq.protob\
    uffer.DepositTxMessageH\0R\x10depositTxMessage\x12\x96\x01\n)counter_cur\
    rency_transfer_started_message\x18\x14\x20\x01(\x0b2:.io.bisq.protobuffe\
    r.CounterCurrencyTransferStartedMessageH\0R%counterCurrencyTransferStart\
    edMessage\x12n\n\x1bpayout_tx_published_message\x18\x15\x20\x01(\x0b2-.i\
    o.bisq.protobuffer.PayoutTxPublishedMessageH\0R\x18payoutTxPublishedMess\
    age\x12e\n\x18open_new_dispute_message\x18\x16\x20\x01(\x0b2*.io.bisq.pr\
    otobuffer.OpenNewDisputeMessageH\0R\x15openNewDisputeMessage\x12n\n\x1bp\
    eer_opened_dispute_message\x18\x17\x20\x01(\x0b2-.io.bisq.protobuffer.Pe\
    erOpenedDisputeMessageH\0R\x18peerOpenedDisputeMessage\x12E\n\x0cchat_me\
    ssage\x18\x18\x20\x01(\x0b2\x20.io.bisq.protobuffer.ChatMessageH\0R\x0bc\
    hatMessage\x12a\n\x16dispute_result_message\x18\x19\x20\x01(\x0b2).io.bi\
    sq.protobuffer.DisputeResultMessageH\0R\x14disputeResultMessage\x12\x91\
    \x01\n(peer_published_dispute_payout_tx_message\x18\x1a\x20\x01(\x0b28.i\
    o.bisq.protobuffer.PeerPublishedDisputePayoutTxMessageH\0R#peerPublished\
    DisputePayoutTxMessage\x12s\n\x1cprivate_notification_message\x18\x1b\
    \x20\x01(\x0b2/.io.bisq.protobuffer.PrivateNotificationMessageH\0R\x1apr\
    ivateNotificationMessage\x12U\n\x12get_blocks_request\x18\x1c\x20\x01(\
    \x0b2%.io.bisq.protobuffer.GetBlocksRequestH\0R\x10getBlocksRequest\x12X\
    \n\x13get_blocks_response\x18\x1d\x20\x01(\x0b2&.io.bisq.protobuffer.Get\
    BlocksResponseH\0R\x11getBlocksResponse\x12n\n\x1bnew_block_broadcast_me\
    ssage\x18\x1e\x20\x01(\x0b2-.io.bisq.protobuffer.NewBlockBroadcastMessag\
    eH\0R\x18newBlockBroadcastMessage\x12\x90\x01\n'add_persistable_network_\
    payload_message\x18\x1f\x20\x01(\x0b28.io.bisq.protobuffer.AddPersistabl\
    eNetworkPayloadMessageH\0R#addPersistableNetworkPayloadMessage\x12B\n\
    \x0back_message\x18\x20\x20\x01(\x0b2\x1f.io.bisq.protobuffer.AckMessage\
    H\0R\nackMessage\x12\x80\x01\n!republish_governance_data_request\x18!\
    \x20\x01(\x0b23.io.bisq.protobuffer.RepublishGovernanceDataRequestH\0R\
    \x1erepublishGovernanceDataRequest\x12i\n\x1anew_dao_state_hash_message\
    \x18\"\x20\x01(\x0b2+.io.bisq.protobuffer.NewDaoStateHashMessageH\0R\x16\
    newDaoStateHashMessage\x12o\n\x1cget_dao_state_hashes_request\x18#\x20\
    \x01(\x0b2-.io.bisq.protobuffer.GetDaoStateHashesRequestH\0R\x18getDaoSt\
    ateHashesRequest\x12r\n\x1dget_dao_state_hashes_response\x18$\x20\x01(\
    \x0b2..io.bisq.protobuffer.GetDaoStateHashesResponseH\0R\x19getDaoStateH\
    ashesResponse\x12x\n\x1fnew_proposal_state_hash_message\x18%\x20\x01(\
    \x0b20.io.bisq.protobuffer.NewProposalStateHashMessageH\0R\x1bnewProposa\
    lStateHashMessage\x12~\n!get_proposal_state_hashes_request\x18&\x20\x01(\
    \x0b22.io.bisq.protobuffer.GetProposalStateHashesRequestH\0R\x1dgetPropo\
    salStateHashesRequest\x12\x81\x01\n\"get_proposal_state_hashes_response\
    \x18'\x20\x01(\x0b23.io.bisq.protobuffer.GetProposalStateHashesResponseH\
    \0R\x1egetProposalStateHashesResponse\x12|\n!new_blind_vote_state_hash_m\
    essage\x18(\x20\x01(\x0b21.io.bisq.protobuffer.NewBlindVoteStateHashMess\
    ageH\0R\x1cnewBlindVoteStateHashMessage\x12\x82\x01\n#get_blind_vote_sta\
    te_hashes_request\x18)\x20\x01(\x0b23.io.bisq.protobuffer.GetBlindVoteSt\
    ateHashesRequestH\0R\x1egetBlindVoteStateHashesRequest\x12\x85\x01\n$get\
    _blind_vote_state_hashes_response\x18*\x20\x01(\x0b24.io.bisq.protobuffe\
    r.GetBlindVoteStateHashesResponseH\0R\x1fgetBlindVoteStateHashesResponse\
    \x12X\n\x13bundle_of_envelopes\x18+\x20\x01(\x0b2&.io.bisq.protobuffer.B\
    undleOfEnvelopesH\0R\x11bundleOfEnvelopes\x12\x87\x01\n$mediated_payout_\
    tx_signature_message\x18,\x20\x01(\x0b25.io.bisq.protobuffer.MediatedPay\
    outTxSignatureMessageH\0R\x20mediatedPayoutTxSignatureMessage\x12\x87\
    \x01\n$mediated_payout_tx_published_message\x18-\x20\x01(\x0b25.io.bisq.\
    protobuffer.MediatedPayoutTxPublishedMessageH\0R\x20mediatedPayoutTxPubl\
    ishedMessage\x12\x84\x01\n#delayed_payout_tx_signature_request\x18.\x20\
    \x01(\x0b24.io.bisq.protobuffer.DelayedPayoutTxSignatureRequestH\0R\x1fd\
    elayedPayoutTxSignatureRequest\x12\x87\x01\n$delayed_payout_tx_signature\
    _response\x18/\x20\x01(\x0b25.io.bisq.protobuffer.DelayedPayoutTxSignatu\
    reResponseH\0R\x20delayedPayoutTxSignatureResponse\x12\x8f\x01\n(deposit\
    _tx_and_delayed_payout_tx_message\x180\x20\x01(\x0b27.io.bisq.protobuffe\
    r.DepositTxAndDelayedPayoutTxMessageH\0R\"depositTxAndDelayedPayoutTxMes\
    sage\x12\x91\x01\n(peer_published_delayed_payout_tx_message\x181\x20\x01\
    (\x0b28.io.bisq.protobuffer.PeerPublishedDelayedPayoutTxMessageH\0R#peer\
    PublishedDelayedPayoutTxMessageB\t\n\x07message\"W\n\x11BundleOfEnvelope\
    s\x12B\n\tenvelopes\x18\x01\x20\x03(\x0b2$.io.bisq.protobuffer.NetworkEn\
    velopeR\tenvelopes\"\x8d\x01\n\x19PreliminaryGetDataRequest\x12\x14\n\
    \x05nonce\x18\x15\x20\x01(\x05R\x05nonce\x12#\n\rexcluded_keys\x18\x02\
    \x20\x03(\x0cR\x0cexcludedKeys\x125\n\x16supported_capabilities\x18\x03\
    \x20\x03(\x05R\x15supportedCapabilities\"\xed\x02\n\x0fGetDataResponse\
    \x12#\n\rrequest_nonce\x18\x01\x20\x01(\x05R\x0crequestNonce\x12>\n\x1ci\
    s_get_updated_data_response\x18\x02\x20\x01(\x08R\x18isGetUpdatedDataRes\
    ponse\x12C\n\x08data_set\x18\x03\x20\x03(\x0b2(.io.bisq.protobuffer.Stor\
    ageEntryWrapperR\x07dataSet\x125\n\x16supported_capabilities\x18\x04\x20\
    \x03(\x05R\x15supportedCapabilities\x12y\n!persistable_network_payload_i\
    tems\x18\x05\x20\x03(\x0b2..io.bisq.protobuffer.PersistableNetworkPayloa\
    dR\x1epersistableNetworkPayloadItems\"\xa4\x01\n\x15GetUpdatedDataReques\
    t\x12P\n\x13sender_node_address\x18\x01\x20\x01(\x0b2\x20.io.bisq.protob\
    uffer.NodeAddressR\x11senderNodeAddress\x12\x14\n\x05nonce\x18\x02\x20\
    \x01(\x05R\x05nonce\x12#\n\rexcluded_keys\x18\x03\x20\x03(\x0cR\x0cexclu\
    dedKeys\"\xf2\x01\n\x0fGetPeersRequest\x12P\n\x13sender_node_address\x18\
    \x01\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x11senderNodeAdd\
    ress\x12\x14\n\x05nonce\x18\x02\x20\x01(\x05R\x05nonce\x125\n\x16support\
    ed_capabilities\x18\x03\x20\x03(\x05R\x15supportedCapabilities\x12@\n\
    \x0ereported_peers\x18\x04\x20\x03(\x0b2\x19.io.bisq.protobuffer.PeerR\r\
    reportedPeers\"\xb0\x01\n\x10GetPeersResponse\x12#\n\rrequest_nonce\x18\
    \x01\x20\x01(\x05R\x0crequestNonce\x12@\n\x0ereported_peers\x18\x02\x20\
    \x03(\x0b2\x19.io.bisq.protobuffer.PeerR\rreportedPeers\x125\n\x16suppor\
    ted_capabilities\x18\x03\x20\x03(\x05R\x15supportedCapabilities\"M\n\x04\
    Ping\x12\x14\n\x05nonce\x18\x01\x20\x01(\x05R\x05nonce\x12/\n\x14last_ro\
    und_trip_time\x18\x02\x20\x01(\x05R\x11lastRoundTripTime\"+\n\x04Pong\
    \x12#\n\rrequest_nonce\x18\x01\x20\x01(\x05R\x0crequestNonce\"\xef\x01\n\
    \x18OfferAvailabilityRequest\x12\x19\n\x08offer_id\x18\x01\x20\x01(\tR\
    \x07offerId\x12A\n\x0cpub_key_ring\x18\x02\x20\x01(\x0b2\x1f.io.bisq.pro\
    tobuffer.PubKeyRingR\npubKeyRing\x12,\n\x12takers_trade_price\x18\x03\
    \x20\x01(\x03R\x10takersTradePrice\x125\n\x16supported_capabilities\x18\
    \x04\x20\x03(\x05R\x15supportedCapabilities\x12\x10\n\x03uid\x18\x05\x20\
    \x01(\tR\x03uid\"\x9e\x03\n\x19OfferAvailabilityResponse\x12\x19\n\x08of\
    fer_id\x18\x01\x20\x01(\tR\x07offerId\x12X\n\x13availability_result\x18\
    \x02\x20\x01(\x0e2'.io.bisq.protobuffer.AvailabilityResultR\x12availabil\
    ityResult\x125\n\x16supported_capabilities\x18\x03\x20\x03(\x05R\x15supp\
    ortedCapabilities\x12\x10\n\x03uid\x18\x04\x20\x01(\tR\x03uid\x12@\n\nar\
    bitrator\x18\x05\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\narb\
    itrator\x12<\n\x08mediator\x18\x06\x20\x01(\x0b2\x20.io.bisq.protobuffer\
    .NodeAddressR\x08mediator\x12C\n\x0crefund_agent\x18\x07\x20\x01(\x0b2\
    \x20.io.bisq.protobuffer.NodeAddressR\x0brefundAgent\"\xb9\x01\n\x13Refr\
    eshOfferMessage\x123\n\x17hash_of_data_and_seq_nr\x18\x01\x20\x01(\x0cR\
    \x12hashOfDataAndSeqNr\x12\x1c\n\tsignature\x18\x02\x20\x01(\x0cR\tsigna\
    ture\x12&\n\x0fhash_of_payload\x18\x03\x20\x01(\x0cR\rhashOfPayload\x12'\
    \n\x0fsequence_number\x18\x04\x20\x01(\x05R\x0esequenceNumber\"P\n\x0eAd\
    dDataMessage\x12>\n\x05entry\x18\x01\x20\x01(\x0b2(.io.bisq.protobuffer.\
    StorageEntryWrapperR\x05entry\"w\n\x11RemoveDataMessage\x12b\n\x17protec\
    ted_storage_entry\x18\x01\x20\x01(\x0b2*.io.bisq.protobuffer.ProtectedSt\
    orageEntryR\x15protectedStorageEntry\"\x85\x01\n\x18RemoveMailboxDataMes\
    sage\x12i\n\x17protected_storage_entry\x18\x01\x20\x01(\x0b21.io.bisq.pr\
    otobuffer.ProtectedMailboxStorageEntryR\x15protectedStorageEntry\"o\n#Ad\
    dPersistableNetworkPayloadMessage\x12H\n\x07payload\x18\x01\x20\x01(\x0b\
    2..io.bisq.protobuffer.PersistableNetworkPayloadR\x07payload\"0\n\x16Clo\
    seConnectionMessage\x12\x16\n\x06reason\x18\x01\x20\x01(\tR\x06reason\"\
    \xbf\x02\n\nAckMessage\x12\x10\n\x03uid\x18\x01\x20\x01(\tR\x03uid\x12P\
    \n\x13sender_node_address\x18\x02\x20\x01(\x0b2\x20.io.bisq.protobuffer.\
    NodeAddressR\x11senderNodeAddress\x12\x1f\n\x0bsource_type\x18\x03\x20\
    \x01(\tR\nsourceType\x121\n\x15source_msg_class_name\x18\x04\x20\x01(\tR\
    \x12sourceMsgClassName\x12\x1d\n\nsource_uid\x18\x05\x20\x01(\tR\tsource\
    Uid\x12\x1b\n\tsource_id\x18\x06\x20\x01(\tR\x08sourceId\x12\x18\n\x07su\
    ccess\x18\x07\x20\x01(\x08R\x07success\x12#\n\rerror_message\x18\x08\x20\
    \x01(\tR\x0cerrorMessage\"\xf9\x01\n\x1ePrefixedSealedAndSignedMessage\
    \x12C\n\x0cnode_address\x18\x01\x20\x01(\x0b2\x20.io.bisq.protobuffer.No\
    deAddressR\x0bnodeAddress\x12P\n\x11sealed_and_signed\x18\x02\x20\x01(\
    \x0b2$.io.bisq.protobuffer.SealedAndSignedR\x0fsealedAndSigned\x12.\n\
    \x13address_prefix_hash\x18\x03\x20\x01(\x0cR\x11addressPrefixHash\x12\
    \x10\n\x03uid\x18\x04\x20\x01(\tR\x03uid\"\xee\x0c\n\x19InputsForDeposit\
    TxRequest\x12\x19\n\x08trade_id\x18\x01\x20\x01(\tR\x07tradeId\x12P\n\
    \x13sender_node_address\x18\x02\x20\x01(\x0b2\x20.io.bisq.protobuffer.No\
    deAddressR\x11senderNodeAddress\x12!\n\x0ctrade_amount\x18\x03\x20\x01(\
    \x03R\x0btradeAmount\x12\x1f\n\x0btrade_price\x18\x04\x20\x01(\x03R\ntra\
    dePrice\x12\x15\n\x06tx_fee\x18\x05\x20\x01(\x03R\x05txFee\x12\x1b\n\tta\
    ker_fee\x18\x06\x20\x01(\x03R\x08takerFee\x12?\n\x1dis_currency_for_take\
    r_fee_btc\x18\x07\x20\x01(\x08R\x18isCurrencyForTakerFeeBtc\x12^\n\x16ra\
    w_transaction_inputs\x18\x08\x20\x03(\x0b2(.io.bisq.protobuffer.RawTrans\
    actionInputR\x14rawTransactionInputs\x12.\n\x13change_output_value\x18\t\
    \x20\x01(\x03R\x11changeOutputValue\x122\n\x15change_output_address\x18\
    \n\x20\x01(\tR\x13changeOutputAddress\x124\n\x17taker_multi_sig_pub_key\
    \x18\x0b\x20\x01(\x0cR\x13takerMultiSigPubKey\x12=\n\x1btaker_payout_add\
    ress_string\x18\x0c\x20\x01(\tR\x18takerPayoutAddressString\x12L\n\x12ta\
    ker_pub_key_ring\x18\r\x20\x01(\x0b2\x1f.io.bisq.protobuffer.PubKeyRingR\
    \x0ftakerPubKeyRing\x12m\n\x1dtaker_payment_account_payload\x18\x0e\x20\
    \x01(\x0b2*.io.bisq.protobuffer.PaymentAccountPayloadR\x1atakerPaymentAc\
    countPayload\x12(\n\x10taker_account_id\x18\x0f\x20\x01(\tR\x0etakerAcco\
    untId\x12%\n\x0ftaker_fee_tx_id\x18\x10\x20\x01(\tR\x0ctakerFeeTxId\x12m\
    \n\"accepted_arbitrator_node_addresses\x18\x11\x20\x03(\x0b2\x20.io.bisq\
    .protobuffer.NodeAddressR\x1facceptedArbitratorNodeAddresses\x12i\n\x20a\
    ccepted_mediator_node_addresses\x18\x12\x20\x03(\x0b2\x20.io.bisq.protob\
    uffer.NodeAddressR\x1dacceptedMediatorNodeAddresses\x12X\n\x17arbitrator\
    _node_address\x18\x13\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\
    \x15arbitratorNodeAddress\x12T\n\x15mediator_node_address\x18\x14\x20\
    \x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x13mediatorNodeAddress\
    \x12\x10\n\x03uid\x18\x15\x20\x01(\tR\x03uid\x12V\n)account_age_witness_\
    signature_of_offer_id\x18\x16\x20\x01(\x0cR#accountAgeWitnessSignatureOf\
    OfferId\x12!\n\x0ccurrent_date\x18\x17\x20\x01(\x03R\x0bcurrentDate\x12p\
    \n$accepted_refund_agent_node_addresses\x18\x18\x20\x03(\x0b2\x20.io.bis\
    q.protobuffer.NodeAddressR\x20acceptedRefundAgentNodeAddresses\x12[\n\
    \x19refund_agent_node_address\x18\x19\x20\x01(\x0b2\x20.io.bisq.protobuf\
    fer.NodeAddressR\x16refundAgentNodeAddress\"\xc2\x06\n\x1aInputsForDepos\
    itTxResponse\x12\x19\n\x08trade_id\x18\x01\x20\x01(\tR\x07tradeId\x12m\n\
    \x1dmaker_payment_account_payload\x18\x02\x20\x01(\x0b2*.io.bisq.protobu\
    ffer.PaymentAccountPayloadR\x1amakerPaymentAccountPayload\x12(\n\x10make\
    r_account_id\x18\x03\x20\x01(\tR\x0emakerAccountId\x123\n\x16maker_contr\
    act_as_json\x18\x04\x20\x01(\tR\x13makerContractAsJson\x128\n\x18maker_c\
    ontract_signature\x18\x05\x20\x01(\tR\x16makerContractSignature\x12=\n\
    \x1bmaker_payout_address_string\x18\x06\x20\x01(\tR\x18makerPayoutAddres\
    sString\x12.\n\x13prepared_deposit_tx\x18\x07\x20\x01(\x0cR\x11preparedD\
    epositTx\x12K\n\x0cmaker_inputs\x18\x08\x20\x03(\x0b2(.io.bisq.protobuff\
    er.RawTransactionInputR\x0bmakerInputs\x124\n\x17maker_multi_sig_pub_key\
    \x18\t\x20\x01(\x0cR\x13makerMultiSigPubKey\x12P\n\x13sender_node_addres\
    s\x18\n\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x11senderNode\
    Address\x12\x10\n\x03uid\x18\x0b\x20\x01(\tR\x03uid\x12k\n4account_age_w\
    itness_signature_of_prepared_deposit_tx\x18\x0c\x20\x01(\x0cR-accountAge\
    WitnessSignatureOfPreparedDepositTx\x12!\n\x0ccurrent_date\x18\r\x20\x01\
    (\x03R\x0bcurrentDate\x12\x1b\n\tlock_time\x18\x0e\x20\x01(\x03R\x08lock\
    Time\"\xcc\x01\n\x1fDelayedPayoutTxSignatureRequest\x12\x10\n\x03uid\x18\
    \x01\x20\x01(\tR\x03uid\x12\x19\n\x08trade_id\x18\x02\x20\x01(\tR\x07tra\
    deId\x12P\n\x13sender_node_address\x18\x03\x20\x01(\x0b2\x20.io.bisq.pro\
    tobuffer.NodeAddressR\x11senderNodeAddress\x12*\n\x11delayed_payout_tx\
    \x18\x04\x20\x01(\x0cR\x0fdelayedPayoutTx\"\xe0\x01\n\x20DelayedPayoutTx\
    SignatureResponse\x12\x10\n\x03uid\x18\x01\x20\x01(\tR\x03uid\x12\x19\n\
    \x08trade_id\x18\x02\x20\x01(\tR\x07tradeId\x12P\n\x13sender_node_addres\
    s\x18\x03\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x11senderNo\
    deAddress\x12=\n\x1bdelayed_payout_tx_signature\x18\x04\x20\x01(\x0cR\
    \x18delayedPayoutTxSignature\"\xee\x01\n\"DepositTxAndDelayedPayoutTxMes\
    sage\x12\x10\n\x03uid\x18\x01\x20\x01(\tR\x03uid\x12\x19\n\x08trade_id\
    \x18\x02\x20\x01(\tR\x07tradeId\x12P\n\x13sender_node_address\x18\x03\
    \x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x11senderNodeAddress\
    \x12\x1d\n\ndeposit_tx\x18\x04\x20\x01(\x0cR\tdepositTx\x12*\n\x11delaye\
    d_payout_tx\x18\x05\x20\x01(\x0cR\x0fdelayedPayoutTx\"\xb0\x01\n\x10Depo\
    sitTxMessage\x12\x10\n\x03uid\x18\x01\x20\x01(\tR\x03uid\x12\x19\n\x08tr\
    ade_id\x18\x02\x20\x01(\tR\x07tradeId\x12P\n\x13sender_node_address\x18\
    \x03\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x11senderNodeAdd\
    ress\x12\x1d\n\ndeposit_tx\x18\x04\x20\x01(\x0cR\tdepositTx\"\xa4\x01\n#\
    PeerPublishedDelayedPayoutTxMessage\x12\x10\n\x03uid\x18\x01\x20\x01(\tR\
    \x03uid\x12\x19\n\x08trade_id\x18\x02\x20\x01(\tR\x07tradeId\x12P\n\x13s\
    ender_node_address\x18\x03\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAdd\
    ressR\x11senderNodeAddress\"\xb6\x02\n%CounterCurrencyTransferStartedMes\
    sage\x12\x19\n\x08trade_id\x18\x01\x20\x01(\tR\x07tradeId\x120\n\x14buye\
    r_payout_address\x18\x02\x20\x01(\tR\x12buyerPayoutAddress\x12P\n\x13sen\
    der_node_address\x18\x03\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddre\
    ssR\x11senderNodeAddress\x12'\n\x0fbuyer_signature\x18\x04\x20\x01(\x0cR\
    \x0ebuyerSignature\x123\n\x16counter_currency_tx_id\x18\x05\x20\x01(\tR\
    \x13counterCurrencyTxId\x12\x10\n\x03uid\x18\x06\x20\x01(\tR\x03uid\"\
    \xf7\x01\n\x17FinalizePayoutTxRequest\x12\x19\n\x08trade_id\x18\x01\x20\
    \x01(\tR\x07tradeId\x12)\n\x10seller_signature\x18\x02\x20\x01(\x0cR\x0f\
    sellerSignature\x122\n\x15seller_payout_address\x18\x03\x20\x01(\tR\x13s\
    ellerPayoutAddress\x12P\n\x13sender_node_address\x18\x04\x20\x01(\x0b2\
    \x20.io.bisq.protobuffer.NodeAddressR\x11senderNodeAddress\x12\x10\n\x03\
    uid\x18\x05\x20\x01(\tR\x03uid\"\xb6\x01\n\x18PayoutTxPublishedMessage\
    \x12\x19\n\x08trade_id\x18\x01\x20\x01(\tR\x07tradeId\x12\x1b\n\tpayout_\
    tx\x18\x02\x20\x01(\x0cR\x08payoutTx\x12P\n\x13sender_node_address\x18\
    \x03\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x11senderNodeAdd\
    ress\x12\x10\n\x03uid\x18\x04\x20\x01(\tR\x03uid\"\xbe\x01\n\x20Mediated\
    PayoutTxPublishedMessage\x12\x19\n\x08trade_id\x18\x01\x20\x01(\tR\x07tr\
    adeId\x12\x1b\n\tpayout_tx\x18\x02\x20\x01(\x0cR\x08payoutTx\x12P\n\x13s\
    ender_node_address\x18\x03\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAdd\
    ressR\x11senderNodeAddress\x12\x10\n\x03uid\x18\x04\x20\x01(\tR\x03uid\"\
    \xc4\x01\n\x20MediatedPayoutTxSignatureMessage\x12\x10\n\x03uid\x18\x01\
    \x20\x01(\tR\x03uid\x12\x19\n\x08trade_id\x18\x03\x20\x01(\tR\x07tradeId\
    \x12!\n\x0ctx_signature\x18\x02\x20\x01(\x0cR\x0btxSignature\x12P\n\x13s\
    ender_node_address\x18\x04\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAdd\
    ressR\x11senderNodeAddress\"\xe9\x01\n\x15OpenNewDisputeMessage\x126\n\
    \x07dispute\x18\x01\x20\x01(\x0b2\x1c.io.bisq.protobuffer.DisputeR\x07di\
    spute\x12P\n\x13sender_node_address\x18\x02\x20\x01(\x0b2\x20.io.bisq.pr\
    otobuffer.NodeAddressR\x11senderNodeAddress\x12\x10\n\x03uid\x18\x03\x20\
    \x01(\tR\x03uid\x124\n\x04type\x18\x04\x20\x01(\x0e2\x20.io.bisq.protobu\
    ffer.SupportTypeR\x04type\"\xec\x01\n\x18PeerOpenedDisputeMessage\x126\n\
    \x07dispute\x18\x01\x20\x01(\x0b2\x1c.io.bisq.protobuffer.DisputeR\x07di\
    spute\x12P\n\x13sender_node_address\x18\x02\x20\x01(\x0b2\x20.io.bisq.pr\
    otobuffer.NodeAddressR\x11senderNodeAddress\x12\x10\n\x03uid\x18\x03\x20\
    \x01(\tR\x03uid\x124\n\x04type\x18\x04\x20\x01(\x0e2\x20.io.bisq.protobu\
    ffer.SupportTypeR\x04type\"\x80\x05\n\x0bChatMessage\x12\x12\n\x04date\
    \x18\x01\x20\x01(\x03R\x04date\x12\x19\n\x08trade_id\x18\x02\x20\x01(\tR\
    \x07tradeId\x12\x1b\n\ttrader_id\x18\x03\x20\x01(\x05R\x08traderId\x12(\
    \n\x10sender_is_trader\x18\x04\x20\x01(\x08R\x0esenderIsTrader\x12\x18\n\
    \x07message\x18\x05\x20\x01(\tR\x07message\x12A\n\x0battachments\x18\x06\
    \x20\x03(\x0b2\x1f.io.bisq.protobuffer.AttachmentR\x0battachments\x12\
    \x18\n\x07arrived\x18\x07\x20\x01(\x08R\x07arrived\x12*\n\x11stored_in_m\
    ailbox\x18\x08\x20\x01(\x08R\x0fstoredInMailbox\x12*\n\x11is_system_mess\
    age\x18\t\x20\x01(\x08R\x0fisSystemMessage\x12P\n\x13sender_node_address\
    \x18\n\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x11senderNodeA\
    ddress\x12\x10\n\x03uid\x18\x0b\x20\x01(\tR\x03uid\x12,\n\x12send_messag\
    e_error\x18\x0c\x20\x01(\tR\x10sendMessageError\x12\"\n\x0cacknowledged\
    \x18\r\x20\x01(\x08R\x0cacknowledged\x12\x1b\n\tack_error\x18\x0e\x20\
    \x01(\tR\x08ackError\x124\n\x04type\x18\x0f\x20\x01(\x0e2\x20.io.bisq.pr\
    otobuffer.SupportTypeR\x04type\x12#\n\rwas_displayed\x18\x10\x20\x01(\
    \x08R\x0cwasDisplayed\"\xfb\x01\n\x14DisputeResultMessage\x12\x10\n\x03u\
    id\x18\x01\x20\x01(\tR\x03uid\x12I\n\x0edispute_result\x18\x02\x20\x01(\
    \x0b2\".io.bisq.protobuffer.DisputeResultR\rdisputeResult\x12P\n\x13send\
    er_node_address\x18\x03\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddres\
    sR\x11senderNodeAddress\x124\n\x04type\x18\x04\x20\x01(\x0e2\x20.io.bisq\
    .protobuffer.SupportTypeR\x04type\"\xfc\x01\n#PeerPublishedDisputePayout\
    TxMessage\x12\x10\n\x03uid\x18\x01\x20\x01(\tR\x03uid\x12\x20\n\x0btrans\
    action\x18\x02\x20\x01(\x0cR\x0btransaction\x12\x19\n\x08trade_id\x18\
    \x03\x20\x01(\tR\x07tradeId\x12P\n\x13sender_node_address\x18\x04\x20\
    \x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x11senderNodeAddress\x12\
    4\n\x04type\x18\x05\x20\x01(\x0e2\x20.io.bisq.protobuffer.SupportTypeR\
    \x04type\"\xf3\x01\n\x1aPrivateNotificationMessage\x12\x10\n\x03uid\x18\
    \x01\x20\x01(\tR\x03uid\x12P\n\x13sender_node_address\x18\x02\x20\x01(\
    \x0b2\x20.io.bisq.protobuffer.NodeAddressR\x11senderNodeAddress\x12q\n\
    \x1cprivate_notification_payload\x18\x03\x20\x01(\x0b2/.io.bisq.protobuf\
    fer.PrivateNotificationPayloadR\x1aprivateNotificationPayload\"\xdd\x01\
    \n\x10GetBlocksRequest\x12*\n\x11from_block_height\x18\x01\x20\x01(\x05R\
    \x0ffromBlockHeight\x12\x14\n\x05nonce\x18\x02\x20\x01(\x05R\x05nonce\
    \x12P\n\x13sender_node_address\x18\x03\x20\x01(\x0b2\x20.io.bisq.protobu\
    ffer.NodeAddressR\x11senderNodeAddress\x125\n\x16supported_capabilities\
    \x18\x04\x20\x03(\x05R\x15supportedCapabilities\"w\n\x11GetBlocksRespons\
    e\x12=\n\nraw_blocks\x18\x01\x20\x03(\x0b2\x1e.io.bisq.protobuffer.BaseB\
    lockR\trawBlocks\x12#\n\rrequest_nonce\x18\x02\x20\x01(\x05R\x0crequestN\
    once\"W\n\x18NewBlockBroadcastMessage\x12;\n\traw_block\x18\x01\x20\x01(\
    \x0b2\x1e.io.bisq.protobuffer.BaseBlockR\x08rawBlock\"\x20\n\x1eRepublis\
    hGovernanceDataRequest\"Z\n\x16NewDaoStateHashMessage\x12@\n\nstate_hash\
    \x18\x01\x20\x01(\x0b2!.io.bisq.protobuffer.DaoStateHashR\tstateHash\"d\
    \n\x1bNewProposalStateHashMessage\x12E\n\nstate_hash\x18\x01\x20\x01(\
    \x0b2&.io.bisq.protobuffer.ProposalStateHashR\tstateHash\"f\n\x1cNewBlin\
    dVoteStateHashMessage\x12F\n\nstate_hash\x18\x01\x20\x01(\x0b2'.io.bisq.\
    protobuffer.BlindVoteStateHashR\tstateHash\"H\n\x18GetDaoStateHashesRequ\
    est\x12\x16\n\x06height\x18\x01\x20\x01(\x05R\x06height\x12\x14\n\x05non\
    ce\x18\x02\x20\x01(\x05R\x05nonce\"M\n\x1dGetProposalStateHashesRequest\
    \x12\x16\n\x06height\x18\x01\x20\x01(\x05R\x06height\x12\x14\n\x05nonce\
    \x18\x02\x20\x01(\x05R\x05nonce\"N\n\x1eGetBlindVoteStateHashesRequest\
    \x12\x16\n\x06height\x18\x01\x20\x01(\x05R\x06height\x12\x14\n\x05nonce\
    \x18\x02\x20\x01(\x05R\x05nonce\"\x86\x01\n\x19GetDaoStateHashesResponse\
    \x12D\n\x0cstate_hashes\x18\x01\x20\x03(\x0b2!.io.bisq.protobuffer.DaoSt\
    ateHashR\x0bstateHashes\x12#\n\rrequest_nonce\x18\x02\x20\x01(\x05R\x0cr\
    equestNonce\"\x90\x01\n\x1eGetProposalStateHashesResponse\x12I\n\x0cstat\
    e_hashes\x18\x01\x20\x03(\x0b2&.io.bisq.protobuffer.ProposalStateHashR\
    \x0bstateHashes\x12#\n\rrequest_nonce\x18\x02\x20\x01(\x05R\x0crequestNo\
    nce\"\x92\x01\n\x1fGetBlindVoteStateHashesResponse\x12J\n\x0cstate_hashe\
    s\x18\x01\x20\x03(\x0b2'.io.bisq.protobuffer.BlindVoteStateHashR\x0bstat\
    eHashes\x12#\n\rrequest_nonce\x18\x02\x20\x01(\x05R\x0crequestNonce\">\n\
    \x0bNodeAddress\x12\x1b\n\thost_name\x18\x01\x20\x01(\tR\x08hostName\x12\
    \x12\n\x04port\x18\x02\x20\x01(\x05R\x04port\"\x96\x01\n\x04Peer\x12C\n\
    \x0cnode_address\x18\x01\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddre\
    ssR\x0bnodeAddress\x12\x12\n\x04date\x18\x02\x20\x01(\x03R\x04date\x125\
    \n\x16supported_capabilities\x18\x03\x20\x03(\x05R\x15supportedCapabilit\
    ies\"\x82\x01\n\nPubKeyRing\x125\n\x17signature_pub_key_bytes\x18\x01\
    \x20\x01(\x0cR\x14signaturePubKeyBytes\x127\n\x18encryption_pub_key_byte\
    s\x18\x02\x20\x01(\x0cR\x15encryptionPubKeyBytesJ\x04\x08\x03\x10\x04\"\
    \xd1\x01\n\x0fSealedAndSigned\x120\n\x14encrypted_secret_key\x18\x01\x20\
    \x01(\x0cR\x12encryptedSecretKey\x12=\n\x1bencrypted_payload_with_hmac\
    \x18\x02\x20\x01(\x0cR\x18encryptedPayloadWithHmac\x12\x1c\n\tsignature\
    \x18\x03\x20\x01(\x0cR\tsignature\x12/\n\x14sig_public_key_bytes\x18\x04\
    \x20\x01(\x0cR\x11sigPublicKeyBytes\"\xb4\x05\n\x0eStoragePayload\x122\n\
    \x05alert\x18\x01\x20\x01(\x0b2\x1a.io.bisq.protobuffer.AlertH\0R\x05ale\
    rt\x12A\n\narbitrator\x18\x02\x20\x01(\x0b2\x1f.io.bisq.protobuffer.Arbi\
    tratorH\0R\narbitrator\x12;\n\x08mediator\x18\x03\x20\x01(\x0b2\x1d.io.b\
    isq.protobuffer.MediatorH\0R\x08mediator\x125\n\x06filter\x18\x04\x20\
    \x01(\x0b2\x1b.io.bisq.protobuffer.FilterH\0R\x06filter\x12U\n\x10trade_\
    statistics\x18\x05\x20\x01(\x0b2$.io.bisq.protobuffer.TradeStatisticsH\0\
    R\x0ftradeStatisticsB\x02\x18\x01\x12d\n\x17mailbox_storage_payload\x18\
    \x06\x20\x01(\x0b2*.io.bisq.protobuffer.MailboxStoragePayloadH\0R\x15mai\
    lboxStoragePayload\x12H\n\roffer_payload\x18\x07\x20\x01(\x0b2!.io.bisq.\
    protobuffer.OfferPayloadH\0R\x0cofferPayload\x12^\n\x15temp_proposal_pay\
    load\x18\x08\x20\x01(\x0b2(.io.bisq.protobuffer.TempProposalPayloadH\0R\
    \x13tempProposalPayload\x12E\n\x0crefund_agent\x18\t\x20\x01(\x0b2\x20.i\
    o.bisq.protobuffer.RefundAgentH\0R\x0brefundAgentB\t\n\x07message\"\xcd\
    \x03\n\x19PersistableNetworkPayload\x12X\n\x13account_age_witness\x18\
    \x01\x20\x01(\x0b2&.io.bisq.protobuffer.AccountAgeWitnessH\0R\x11account\
    AgeWitness\x12T\n\x11trade_statistics2\x18\x02\x20\x01(\x0b2%.io.bisq.pr\
    otobuffer.TradeStatistics2H\0R\x10tradeStatistics2\x12Q\n\x10proposal_pa\
    yload\x18\x03\x20\x01(\x0b2$.io.bisq.protobuffer.ProposalPayloadH\0R\x0f\
    proposalPayload\x12U\n\x12blind_vote_payload\x18\x04\x20\x01(\x0b2%.io.b\
    isq.protobuffer.BlindVotePayloadH\0R\x10blindVotePayload\x12K\n\x0esigne\
    d_witness\x18\x05\x20\x01(\x0b2\".io.bisq.protobuffer.SignedWitnessH\0R\
    \rsignedWitnessB\t\n\x07message\"\x8a\x02\n\x15ProtectedStorageEntry\x12\
    K\n\x0estoragePayload\x18\x01\x20\x01(\x0b2#.io.bisq.protobuffer.Storage\
    PayloadR\x0estoragePayload\x12-\n\x13owner_pub_key_bytes\x18\x02\x20\x01\
    (\x0cR\x10ownerPubKeyBytes\x12'\n\x0fsequence_number\x18\x03\x20\x01(\
    \x05R\x0esequenceNumber\x12\x1c\n\tsignature\x18\x04\x20\x01(\x0cR\tsign\
    ature\x12.\n\x13creation_time_stamp\x18\x05\x20\x01(\x03R\x11creationTim\
    eStamp\"\x82\x02\n\x13StorageEntryWrapper\x12d\n\x17protected_storage_en\
    try\x18\x01\x20\x01(\x0b2*.io.bisq.protobuffer.ProtectedStorageEntryH\0R\
    \x15protectedStorageEntry\x12z\n\x1fprotected_mailbox_storage_entry\x18\
    \x02\x20\x01(\x0b21.io.bisq.protobuffer.ProtectedMailboxStorageEntryH\0R\
    \x1cprotectedMailboxStorageEntryB\t\n\x07message\"\x97\x01\n\x1cProtecte\
    dMailboxStorageEntry\x12@\n\x05entry\x18\x01\x20\x01(\x0b2*.io.bisq.prot\
    obuffer.ProtectedStorageEntryR\x05entry\x125\n\x17receivers_pub_key_byte\
    s\x18\x02\x20\x01(\x0cR\x14receiversPubKeyBytes\"z\n\x10DataAndSeqNrPair\
    \x12=\n\x07payload\x18\x01\x20\x01(\x0b2#.io.bisq.protobuffer.StoragePay\
    loadR\x07payload\x12'\n\x0fsequence_number\x18\x02\x20\x01(\x05R\x0esequ\
    enceNumber\"\x97\x01\n\x1aPrivateNotificationPayload\x12\x18\n\x07messag\
    e\x18\x01\x20\x01(\tR\x07message\x12.\n\x13signature_as_base64\x18\x02\
    \x20\x01(\tR\x11signatureAsBase64\x12/\n\x14sig_public_key_bytes\x18\x03\
    \x20\x01(\x0cR\x11sigPublicKeyBytes\"\x80\x01\n\x14PaymentAccountFilter\
    \x12*\n\x11payment_method_id\x18\x01\x20\x01(\tR\x0fpaymentMethodId\x12&\
    \n\x0fget_method_name\x18\x02\x20\x01(\tR\rgetMethodName\x12\x14\n\x05va\
    lue\x18\x03\x20\x01(\tR\x05value\"\xc8\x02\n\x05Alert\x12\x18\n\x07messa\
    ge\x18\x01\x20\x01(\tR\x07message\x12\x18\n\x07version\x18\x02\x20\x01(\
    \tR\x07version\x12$\n\x0eis_update_info\x18\x03\x20\x01(\x08R\x0cisUpdat\
    eInfo\x12.\n\x13signature_as_base64\x18\x04\x20\x01(\tR\x11signatureAsBa\
    se64\x12-\n\x13owner_pub_key_bytes\x18\x05\x20\x01(\x0cR\x10ownerPubKeyB\
    ytes\x12H\n\nextra_data\x18\x06\x20\x03(\x0b2).io.bisq.protobuffer.Alert\
    .ExtraDataEntryR\textraData\x1a<\n\x0eExtraDataEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"\xd8\x04\n\nArbitrator\x12C\n\x0cnode_address\x18\x01\x20\
    \x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x0bnodeAddress\x12%\n\
    \x0elanguage_codes\x18\x02\x20\x03(\tR\rlanguageCodes\x12+\n\x11registra\
    tion_date\x18\x03\x20\x01(\x03R\x10registrationDate\x125\n\x16registrati\
    on_signature\x18\x04\x20\x01(\tR\x15registrationSignature\x120\n\x14regi\
    stration_pub_key\x18\x05\x20\x01(\x0cR\x12registrationPubKey\x12A\n\x0cp\
    ub_key_ring\x18\x06\x20\x01(\x0b2\x1f.io.bisq.protobuffer.PubKeyRingR\np\
    ubKeyRing\x12\x1e\n\x0bbtc_pub_key\x18\x07\x20\x01(\x0cR\tbtcPubKey\x12\
    \x1f\n\x0bbtc_address\x18\x08\x20\x01(\tR\nbtcAddress\x12#\n\remail_addr\
    ess\x18\t\x20\x01(\tR\x0cemailAddress\x12\x12\n\x04info\x18\n\x20\x01(\t\
    R\x04info\x12M\n\nextra_data\x18\x0b\x20\x03(\x0b2..io.bisq.protobuffer.\
    Arbitrator.ExtraDataEntryR\textraData\x1a<\n\x0eExtraDataEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\"\x93\x04\n\x08Mediator\x12C\n\x0cnode_address\x18\
    \x01\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x0bnodeAddress\
    \x12%\n\x0elanguage_codes\x18\x02\x20\x03(\tR\rlanguageCodes\x12+\n\x11r\
    egistration_date\x18\x03\x20\x01(\x03R\x10registrationDate\x125\n\x16reg\
    istration_signature\x18\x04\x20\x01(\tR\x15registrationSignature\x120\n\
    \x14registration_pub_key\x18\x05\x20\x01(\x0cR\x12registrationPubKey\x12\
    A\n\x0cpub_key_ring\x18\x06\x20\x01(\x0b2\x1f.io.bisq.protobuffer.PubKey\
    RingR\npubKeyRing\x12#\n\remail_address\x18\x07\x20\x01(\tR\x0cemailAddr\
    ess\x12\x12\n\x04info\x18\x08\x20\x01(\tR\x04info\x12K\n\nextra_data\x18\
    \t\x20\x03(\x0b2,.io.bisq.protobuffer.Mediator.ExtraDataEntryR\textraDat\
    a\x1a<\n\x0eExtraDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x99\x04\n\
    \x0bRefundAgent\x12C\n\x0cnode_address\x18\x01\x20\x01(\x0b2\x20.io.bisq\
    .protobuffer.NodeAddressR\x0bnodeAddress\x12%\n\x0elanguage_codes\x18\
    \x02\x20\x03(\tR\rlanguageCodes\x12+\n\x11registration_date\x18\x03\x20\
    \x01(\x03R\x10registrationDate\x125\n\x16registration_signature\x18\x04\
    \x20\x01(\tR\x15registrationSignature\x120\n\x14registration_pub_key\x18\
    \x05\x20\x01(\x0cR\x12registrationPubKey\x12A\n\x0cpub_key_ring\x18\x06\
    \x20\x01(\x0b2\x1f.io.bisq.protobuffer.PubKeyRingR\npubKeyRing\x12#\n\re\
    mail_address\x18\x07\x20\x01(\tR\x0cemailAddress\x12\x12\n\x04info\x18\
    \x08\x20\x01(\tR\x04info\x12N\n\nextra_data\x18\t\x20\x03(\x0b2/.io.bisq\
    .protobuffer.RefundAgent.ExtraDataEntryR\textraData\x1a<\n\x0eExtraDataE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"\xb4\x07\n\x06Filter\x12.\n\x13bann\
    ed_node_address\x18\x01\x20\x03(\tR\x11bannedNodeAddress\x12(\n\x10banne\
    d_offer_ids\x18\x02\x20\x03(\tR\x0ebannedOfferIds\x12a\n\x17banned_payme\
    nt_accounts\x18\x03\x20\x03(\x0b2).io.bisq.protobuffer.PaymentAccountFil\
    terR\x15bannedPaymentAccounts\x12.\n\x13signature_as_base64\x18\x04\x20\
    \x01(\tR\x11signatureAsBase64\x12-\n\x13owner_pub_key_bytes\x18\x05\x20\
    \x01(\x0cR\x10ownerPubKeyBytes\x12I\n\nextra_data\x18\x06\x20\x03(\x0b2*\
    .io.bisq.protobuffer.Filter.ExtraDataEntryR\textraData\x12+\n\x11banned_\
    currencies\x18\x07\x20\x03(\tR\x10bannedCurrencies\x124\n\x16banned_paym\
    ent_methods\x18\x08\x20\x03(\tR\x14bannedPaymentMethods\x12\x20\n\x0barb\
    itrators\x18\t\x20\x03(\tR\x0barbitrators\x12\x1d\n\nseed_nodes\x18\n\
    \x20\x03(\tR\tseedNodes\x12*\n\x11price_relay_nodes\x18\x0b\x20\x03(\tR\
    \x0fpriceRelayNodes\x12;\n\x1aprevent_public_btc_network\x18\x0c\x20\x01\
    (\x08R\x17preventPublicBtcNetwork\x12\x1b\n\tbtc_nodes\x18\r\x20\x03(\tR\
    \x08btcNodes\x12\x1f\n\x0bdisable_dao\x18\x0e\x20\x01(\x08R\ndisableDao\
    \x129\n\x19disable_dao_below_version\x18\x0f\x20\x01(\tR\x16disableDaoBe\
    lowVersion\x12=\n\x1bdisable_trade_below_version\x18\x10\x20\x01(\tR\x18\
    disableTradeBelowVersion\x12\x1c\n\tmediators\x18\x11\x20\x03(\tR\tmedia\
    tors\x12\"\n\x0crefundAgents\x18\x12\x20\x03(\tR\x0crefundAgents\x1a<\n\
    \x0eExtraDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xaa\x06\n\x0fTradeSta\
    tistics\x12#\n\rbase_currency\x18\x01\x20\x01(\tR\x0cbaseCurrency\x12)\n\
    \x10counter_currency\x18\x02\x20\x01(\tR\x0fcounterCurrency\x12I\n\tdire\
    ction\x18\x03\x20\x01(\x0e2+.io.bisq.protobuffer.OfferPayload.DirectionR\
    \tdirection\x12\x1f\n\x0btrade_price\x18\x04\x20\x01(\x03R\ntradePrice\
    \x12!\n\x0ctrade_amount\x18\x05\x20\x01(\x03R\x0btradeAmount\x12\x1d\n\n\
    trade_date\x18\x06\x20\x01(\x03R\ttradeDate\x12*\n\x11payment_method_id\
    \x18\x07\x20\x01(\tR\x0fpaymentMethodId\x12\x1d\n\noffer_date\x18\x08\
    \x20\x01(\x03R\tofferDate\x12>\n\x1coffer_use_market_based_price\x18\t\
    \x20\x01(\x08R\x18offerUseMarketBasedPrice\x129\n\x19offer_market_price_\
    margin\x18\n\x20\x01(\x01R\x16offerMarketPriceMargin\x12!\n\x0coffer_amo\
    unt\x18\x0b\x20\x01(\x03R\x0bofferAmount\x12(\n\x10offer_min_amount\x18\
    \x0c\x20\x01(\x03R\x0eofferMinAmount\x12\x19\n\x08offer_id\x18\r\x20\x01\
    (\tR\x07offerId\x12\"\n\rdeposit_tx_id\x18\x0e\x20\x01(\tR\x0bdepositTxI\
    d\x125\n\x17signature_pub_key_bytes\x18\x0f\x20\x01(\x0cR\x14signaturePu\
    bKeyBytes\x12R\n\nextra_data\x18\x10\x20\x03(\x0b23.io.bisq.protobuffer.\
    TradeStatistics.ExtraDataEntryR\textraData\x1a<\n\x0eExtraDataEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\"\x89\x06\n\x10TradeStatistics2\x12#\n\rbase\
    _currency\x18\x01\x20\x01(\tR\x0cbaseCurrency\x12)\n\x10counter_currency\
    \x18\x02\x20\x01(\tR\x0fcounterCurrency\x12I\n\tdirection\x18\x03\x20\
    \x01(\x0e2+.io.bisq.protobuffer.OfferPayload.DirectionR\tdirection\x12\
    \x1f\n\x0btrade_price\x18\x04\x20\x01(\x03R\ntradePrice\x12!\n\x0ctrade_\
    amount\x18\x05\x20\x01(\x03R\x0btradeAmount\x12\x1d\n\ntrade_date\x18\
    \x06\x20\x01(\x03R\ttradeDate\x12*\n\x11payment_method_id\x18\x07\x20\
    \x01(\tR\x0fpaymentMethodId\x12\x1d\n\noffer_date\x18\x08\x20\x01(\x03R\
    \tofferDate\x12>\n\x1coffer_use_market_based_price\x18\t\x20\x01(\x08R\
    \x18offerUseMarketBasedPrice\x129\n\x19offer_market_price_margin\x18\n\
    \x20\x01(\x01R\x16offerMarketPriceMargin\x12!\n\x0coffer_amount\x18\x0b\
    \x20\x01(\x03R\x0bofferAmount\x12(\n\x10offer_min_amount\x18\x0c\x20\x01\
    (\x03R\x0eofferMinAmount\x12\x19\n\x08offer_id\x18\r\x20\x01(\tR\x07offe\
    rId\x12\"\n\rdeposit_tx_id\x18\x0e\x20\x01(\tR\x0bdepositTxId\x12\x12\n\
    \x04hash\x18\x0f\x20\x01(\x0cR\x04hash\x12S\n\nextra_data\x18\x10\x20\
    \x03(\x0b24.io.bisq.protobuffer.TradeStatistics2.ExtraDataEntryR\textraD\
    ata\x1a<\n\x0eExtraDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xb1\x03\n\
    \x15MailboxStoragePayload\x12\x7f\n\"prefixed_sealed_and_signed_message\
    \x18\x01\x20\x01(\x0b23.io.bisq.protobuffer.PrefixedSealedAndSignedMessa\
    geR\x1eprefixedSealedAndSignedMessage\x12P\n&sender_pub_key_for_add_oper\
    ation_bytes\x18\x02\x20\x01(\x0cR\x20senderPubKeyForAddOperationBytes\
    \x12-\n\x13owner_pub_key_bytes\x18\x03\x20\x01(\x0cR\x10ownerPubKeyBytes\
    \x12X\n\nextra_data\x18\x04\x20\x03(\x0b29.io.bisq.protobuffer.MailboxSt\
    oragePayload.ExtraDataEntryR\textraData\x1a<\n\x0eExtraDataEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01\"\xb0\x0f\n\x0cOfferPayload\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12\x12\n\x04date\x18\x02\x20\x01(\x03R\x04date\
    \x12N\n\x12owner_node_address\x18\x03\x20\x01(\x0b2\x20.io.bisq.protobuf\
    fer.NodeAddressR\x10ownerNodeAddress\x12A\n\x0cpub_key_ring\x18\x04\x20\
    \x01(\x0b2\x1f.io.bisq.protobuffer.PubKeyRingR\npubKeyRing\x12I\n\tdirec\
    tion\x18\x05\x20\x01(\x0e2+.io.bisq.protobuffer.OfferPayload.DirectionR\
    \tdirection\x12\x14\n\x05price\x18\x06\x20\x01(\x03R\x05price\x12.\n\x13\
    market_price_margin\x18\x07\x20\x01(\x01R\x11marketPriceMargin\x123\n\
    \x16use_market_based_price\x18\x08\x20\x01(\x08R\x13useMarketBasedPrice\
    \x12\x16\n\x06amount\x18\t\x20\x01(\x03R\x06amount\x12\x1d\n\nmin_amount\
    \x18\n\x20\x01(\x03R\tminAmount\x12,\n\x12base_currency_code\x18\x0b\x20\
    \x01(\tR\x10baseCurrencyCode\x122\n\x15counter_currency_code\x18\x0c\x20\
    \x01(\tR\x13counterCurrencyCode\x12`\n\x19arbitrator_node_addresses\x18\
    \r\x20\x03(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x17arbitratorNodeA\
    ddressesB\x02\x18\x01\x12\\\n\x17mediator_node_addresses\x18\x0e\x20\x03\
    (\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x15mediatorNodeAddressesB\
    \x02\x18\x01\x12*\n\x11payment_method_id\x18\x0f\x20\x01(\tR\x0fpaymentM\
    ethodId\x127\n\x18maker_payment_account_id\x18\x10\x20\x01(\tR\x15makerP\
    aymentAccountId\x124\n\x17offer_fee_payment_tx_id\x18\x11\x20\x01(\tR\
    \x13offerFeePaymentTxId\x12!\n\x0ccountry_code\x18\x12\x20\x01(\tR\x0bco\
    untryCode\x124\n\x16accepted_country_codes\x18\x13\x20\x03(\tR\x14accept\
    edCountryCodes\x12\x17\n\x07bank_id\x18\x14\x20\x01(\tR\x06bankId\x12*\n\
    \x11accepted_bank_ids\x18\x15\x20\x03(\tR\x0facceptedBankIds\x12\x1d\n\n\
    version_nr\x18\x16\x20\x01(\tR\tversionNr\x12B\n\x1eblock_height_at_offe\
    r_creation\x18\x17\x20\x01(\x03R\x1ablockHeightAtOfferCreation\x12\x15\n\
    \x06tx_fee\x18\x18\x20\x01(\x03R\x05txFee\x12\x1b\n\tmaker_fee\x18\x19\
    \x20\x01(\x03R\x08makerFee\x12?\n\x1dis_currency_for_maker_fee_btc\x18\
    \x1a\x20\x01(\x08R\x18isCurrencyForMakerFeeBtc\x124\n\x16buyer_security_\
    deposit\x18\x1b\x20\x01(\x03R\x14buyerSecurityDeposit\x126\n\x17seller_s\
    ecurity_deposit\x18\x1c\x20\x01(\x03R\x15sellerSecurityDeposit\x12&\n\
    \x0fmax_trade_limit\x18\x1d\x20\x01(\x03R\rmaxTradeLimit\x12(\n\x10max_t\
    rade_period\x18\x1e\x20\x01(\x03R\x0emaxTradePeriod\x12$\n\x0euse_auto_c\
    lose\x18\x1f\x20\x01(\x08R\x0cuseAutoClose\x12=\n\x1cuse_re_open_after_a\
    uto_close\x18\x20\x20\x01(\x08R\x17useReOpenAfterAutoClose\x12*\n\x11low\
    er_close_price\x18!\x20\x01(\x03R\x0flowerClosePrice\x12*\n\x11upper_clo\
    se_price\x18\"\x20\x01(\x03R\x0fupperClosePrice\x12(\n\x10is_private_off\
    er\x18#\x20\x01(\x08R\x0eisPrivateOffer\x12*\n\x11hash_of_challenge\x18$\
    \x20\x01(\tR\x0fhashOfChallenge\x12O\n\nextra_data\x18%\x20\x03(\x0b20.i\
    o.bisq.protobuffer.OfferPayload.ExtraDataEntryR\textraData\x12)\n\x10pro\
    tocol_version\x18&\x20\x01(\x05R\x0fprotocolVersion\x1a<\n\x0eExtraDataE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\",\n\tDirection\x12\x0c\n\x08PB_ERRO\
    R\x10\0\x12\x07\n\x03BUY\x10\x01\x12\x08\n\x04SELL\x10\x02\";\n\x11Accou\
    ntAgeWitness\x12\x12\n\x04hash\x18\x01\x20\x01(\x0cR\x04hash\x12\x12\n\
    \x04date\x18\x02\x20\x01(\x03R\x04date\"\x9d\x03\n\rSignedWitness\x12f\n\
    \x13verification_method\x18\x01\x20\x01(\x0e25.io.bisq.protobuffer.Signe\
    dWitness.VerificationMethodR\x12verificationMethod\x127\n\x18account_age\
    _witness_hash\x18\x02\x20\x01(\x0cR\x15accountAgeWitnessHash\x12\x1c\n\t\
    signature\x18\x03\x20\x01(\x0cR\tsignature\x12$\n\x0esigner_pub_key\x18\
    \x04\x20\x01(\x0cR\x0csignerPubKey\x121\n\x15witness_owner_pub_key\x18\
    \x05\x20\x01(\x0cR\x12witnessOwnerPubKey\x12\x12\n\x04date\x18\x06\x20\
    \x01(\x03R\x04date\x12!\n\x0ctrade_amount\x18\x07\x20\x01(\x03R\x0btrade\
    Amount\"=\n\x12VerificationMethod\x12\x0c\n\x08PB_ERROR\x10\0\x12\x0e\n\
    \nARBITRATOR\x10\x01\x12\t\n\x05TRADE\x10\x02\"\x83\n\n\x07Dispute\x12\
    \x19\n\x08trade_id\x18\x01\x20\x01(\tR\x07tradeId\x12\x0e\n\x02id\x18\
    \x02\x20\x01(\tR\x02id\x12\x1b\n\ttrader_id\x18\x03\x20\x01(\x05R\x08tra\
    derId\x125\n\x17dispute_opener_is_buyer\x18\x04\x20\x01(\x08R\x14dispute\
    OpenerIsBuyer\x125\n\x17dispute_opener_is_maker\x18\x05\x20\x01(\x08R\
    \x14disputeOpenerIsMaker\x12!\n\x0copening_date\x18\x06\x20\x01(\x03R\
    \x0bopeningDate\x12N\n\x13trader_pub_key_ring\x18\x07\x20\x01(\x0b2\x1f.\
    io.bisq.protobuffer.PubKeyRingR\x10traderPubKeyRing\x12\x1d\n\ntrade_dat\
    e\x18\x08\x20\x01(\x03R\ttradeDate\x129\n\x08contract\x18\t\x20\x01(\x0b\
    2\x1d.io.bisq.protobuffer.ContractR\x08contract\x12#\n\rcontract_hash\
    \x18\n\x20\x01(\x0cR\x0ccontractHash\x122\n\x15deposit_tx_serialized\x18\
    \x0b\x20\x01(\x0cR\x13depositTxSerialized\x120\n\x14payout_tx_serialized\
    \x18\x0c\x20\x01(\x0cR\x12payoutTxSerialized\x12\"\n\rdeposit_tx_id\x18\
    \r\x20\x01(\tR\x0bdepositTxId\x12\x20\n\x0cpayout_tx_id\x18\x0e\x20\x01(\
    \tR\npayoutTxId\x12(\n\x10contract_as_json\x18\x0f\x20\x01(\tR\x0econtra\
    ctAsJson\x128\n\x18maker_contract_signature\x18\x10\x20\x01(\tR\x16maker\
    ContractSignature\x128\n\x18taker_contract_signature\x18\x11\x20\x01(\tR\
    \x16takerContractSignature\x12L\n\x12agent_pub_key_ring\x18\x12\x20\x01(\
    \x0b2\x1f.io.bisq.protobuffer.PubKeyRingR\x0fagentPubKeyRing\x12*\n\x11i\
    s_support_ticket\x18\x13\x20\x01(\x08R\x0fisSupportTicket\x12C\n\x0cchat\
    _message\x18\x14\x20\x03(\x0b2\x20.io.bisq.protobuffer.ChatMessageR\x0bc\
    hatMessage\x12\x1b\n\tis_closed\x18\x15\x20\x01(\x08R\x08isClosed\x12I\n\
    \x0edispute_result\x18\x16\x20\x01(\x0b2\".io.bisq.protobuffer.DisputeRe\
    sultR\rdisputeResult\x12/\n\x14dispute_payout_tx_id\x18\x17\x20\x01(\tR\
    \x11disputePayoutTxId\x12C\n\x0csupport_type\x18\x18\x20\x01(\x0e2\x20.i\
    o.bisq.protobuffer.SupportTypeR\x0bsupportType\x128\n\x18mediators_dispu\
    te_result\x18\x19\x20\x01(\tR\x16mediatorsDisputeResult\x12/\n\x14delaye\
    d_payout_tx_id\x18\x1a\x20\x01(\tR\x11delayedPayoutTxId\"?\n\nAttachment\
    \x12\x1b\n\tfile_name\x18\x01\x20\x01(\tR\x08fileName\x12\x14\n\x05bytes\
    \x18\x02\x20\x01(\x0cR\x05bytes\"\xe5\x06\n\rDisputeResult\x12\x19\n\x08\
    trade_id\x18\x01\x20\x01(\tR\x07tradeId\x12\x1b\n\ttrader_id\x18\x02\x20\
    \x01(\x05R\x08traderId\x12A\n\x06winner\x18\x03\x20\x01(\x0e2).io.bisq.p\
    rotobuffer.DisputeResult.WinnerR\x06winner\x12%\n\x0ereason_ordinal\x18\
    \x04\x20\x01(\x05R\rreasonOrdinal\x122\n\x15tamper_proof_evidence\x18\
    \x05\x20\x01(\x08R\x13tamperProofEvidence\x12'\n\x0fid_verification\x18\
    \x06\x20\x01(\x08R\x0eidVerification\x12\x1f\n\x0bscreen_cast\x18\x07\
    \x20\x01(\x08R\nscreenCast\x12#\n\rsummary_notes\x18\x08\x20\x01(\tR\x0c\
    summaryNotes\x12C\n\x0cchat_message\x18\t\x20\x01(\x0b2\x20.io.bisq.prot\
    obuffer.ChatMessageR\x0bchatMessage\x121\n\x14arbitrator_signature\x18\n\
    \x20\x01(\x0cR\x13arbitratorSignature\x12.\n\x13buyer_payout_amount\x18\
    \x0b\x20\x01(\x03R\x11buyerPayoutAmount\x120\n\x14seller_payout_amount\
    \x18\x0c\x20\x01(\x03R\x12sellerPayoutAmount\x12,\n\x12arbitrator_pub_ke\
    y\x18\r\x20\x01(\x0cR\x10arbitratorPubKey\x12\x1d\n\nclose_date\x18\x0e\
    \x20\x01(\x03R\tcloseDate\x12,\n\x12is_loser_publisher\x18\x0f\x20\x01(\
    \x08R\x10isLoserPublisher\"4\n\x06Winner\x12\x13\n\x0fPB_ERROR_WINNER\
    \x10\0\x12\t\n\x05BUYER\x10\x01\x12\n\n\x06SELLER\x10\x02\"\x83\x01\n\
    \x06Reason\x12\x13\n\x0fPB_ERROR_REASON\x10\0\x12\t\n\x05OTHER\x10\x01\
    \x12\x07\n\x03BUG\x10\x02\x12\r\n\tUSABILITY\x10\x03\x12\x08\n\x04SCAM\
    \x10\x04\x12\x16\n\x12PROTOCOL_VIOLATION\x10\x05\x12\x0c\n\x08NO_REPLY\
    \x10\x06\x12\x11\n\rBANK_PROBLEMS\x10\x07\"\xb2\n\n\x08Contract\x12F\n\r\
    offer_payload\x18\x01\x20\x01(\x0b2!.io.bisq.protobuffer.OfferPayloadR\
    \x0cofferPayload\x12!\n\x0ctrade_amount\x18\x02\x20\x01(\x03R\x0btradeAm\
    ount\x12\x1f\n\x0btrade_price\x18\x03\x20\x01(\x03R\ntradePrice\x12%\n\
    \x0ftaker_fee_tx_id\x18\x04\x20\x01(\tR\x0ctakerFeeTxId\x12C\n\x1fis_buy\
    er_maker_and_seller_taker\x18\x06\x20\x01(\x08R\x1aisBuyerMakerAndSeller\
    Taker\x12(\n\x10maker_account_id\x18\x07\x20\x01(\tR\x0emakerAccountId\
    \x12(\n\x10taker_account_id\x18\x08\x20\x01(\tR\x0etakerAccountId\x12m\n\
    \x1dmaker_payment_account_payload\x18\t\x20\x01(\x0b2*.io.bisq.protobuff\
    er.PaymentAccountPayloadR\x1amakerPaymentAccountPayload\x12m\n\x1dtaker_\
    payment_account_payload\x18\n\x20\x01(\x0b2*.io.bisq.protobuffer.Payment\
    AccountPayloadR\x1atakerPaymentAccountPayload\x12L\n\x12maker_pub_key_ri\
    ng\x18\x0b\x20\x01(\x0b2\x1f.io.bisq.protobuffer.PubKeyRingR\x0fmakerPub\
    KeyRing\x12L\n\x12taker_pub_key_ring\x18\x0c\x20\x01(\x0b2\x1f.io.bisq.p\
    rotobuffer.PubKeyRingR\x0ftakerPubKeyRing\x12N\n\x12buyer_node_address\
    \x18\r\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x10buyerNodeAd\
    dress\x12P\n\x13seller_node_address\x18\x0e\x20\x01(\x0b2\x20.io.bisq.pr\
    otobuffer.NodeAddressR\x11sellerNodeAddress\x12=\n\x1bmaker_payout_addre\
    ss_string\x18\x0f\x20\x01(\tR\x18makerPayoutAddressString\x12=\n\x1btake\
    r_payout_address_string\x18\x10\x20\x01(\tR\x18takerPayoutAddressString\
    \x124\n\x17maker_multi_sig_pub_key\x18\x11\x20\x01(\x0cR\x13makerMultiSi\
    gPubKey\x124\n\x17taker_multi_sig_pub_key\x18\x12\x20\x01(\x0cR\x13taker\
    MultiSigPubKey\x12T\n\x15mediator_node_address\x18\x13\x20\x01(\x0b2\x20\
    .io.bisq.protobuffer.NodeAddressR\x13mediatorNodeAddress\x12\x1b\n\tlock\
    _time\x18\x14\x20\x01(\x03R\x08lockTime\x12[\n\x19refund_agent_node_addr\
    ess\x18\x15\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x16refund\
    AgentNodeAddressJ\x04\x08\x05\x10\x06\"p\n\x13RawTransactionInput\x12\
    \x14\n\x05index\x18\x01\x20\x01(\x03R\x05index\x12-\n\x12parent_transact\
    ion\x18\x02\x20\x01(\x0cR\x11parentTransaction\x12\x14\n\x05value\x18\
    \x03\x20\x01(\x03R\x05value\"\x86\x18\n\x15PaymentAccountPayload\x12\x0e\
    \n\x02id\x18\x01\x20\x01(\tR\x02id\x12*\n\x11payment_method_id\x18\x02\
    \x20\x01(\tR\x0fpaymentMethodId\x12,\n\x10max_trade_period\x18\x03\x20\
    \x01(\x03R\x0emaxTradePeriodB\x02\x18\x01\x12b\n\x17ali_pay_account_payl\
    oad\x18\x04\x20\x01(\x0b2).io.bisq.protobuffer.AliPayAccountPayloadH\0R\
    \x14aliPayAccountPayload\x12x\n\x1fchase_quick_pay_account_payload\x18\
    \x05\x20\x01(\x0b20.io.bisq.protobuffer.ChaseQuickPayAccountPayloadH\0R\
    \x1bchaseQuickPayAccountPayload\x12t\n\x1dclear_xchange_account_payload\
    \x18\x06\x20\x01(\x0b2/.io.bisq.protobuffer.ClearXchangeAccountPayloadH\
    \0R\x1aclearXchangeAccountPayload\x12\x8a\x01\n%country_based_payment_ac\
    count_payload\x18\x07\x20\x01(\x0b26.io.bisq.protobuffer.CountryBasedPay\
    mentAccountPayloadH\0R!countryBasedPaymentAccountPayload\x12z\n\x1fcrypt\
    o_currency_account_payload\x18\x08\x20\x01(\x0b21.io.bisq.protobuffer.Cr\
    yptoCurrencyAccountPayloadH\0R\x1ccryptoCurrencyAccountPayload\x12z\n\
    \x1ffaster_payments_account_payload\x18\t\x20\x01(\x0b21.io.bisq.protobu\
    ffer.FasterPaymentsAccountPayloadH\0R\x1cfasterPaymentsAccountPayload\
    \x12\x81\x01\n\"interac_e_transfer_account_payload\x18\n\x20\x01(\x0b23.\
    io.bisq.protobuffer.InteracETransferAccountPayloadH\0R\x1einteracETransf\
    erAccountPayload\x12d\n\x17o_k_pay_account_payload\x18\x0b\x20\x01(\x0b2\
    (.io.bisq.protobuffer.OKPayAccountPayloadH\0R\x13oKPayAccountPayloadB\
    \x02\x18\x01\x12t\n\x1dperfect_money_account_payload\x18\x0c\x20\x01(\
    \x0b2/.io.bisq.protobuffer.PerfectMoneyAccountPayloadH\0R\x1aperfectMone\
    yAccountPayload\x12^\n\x15swish_account_payload\x18\r\x20\x01(\x0b2(.io.\
    bisq.protobuffer.SwishAccountPayloadH\0R\x13swishAccountPayload\x12\x89\
    \x01\n&u_s_postal_money_order_account_payload\x18\x0e\x20\x01(\x0b25.io.\
    bisq.protobuffer.USPostalMoneyOrderAccountPayloadH\0R\x20uSPostalMoneyOr\
    derAccountPayload\x12a\n\x16uphold_account_payload\x18\x10\x20\x01(\x0b2\
    ).io.bisq.protobuffer.UpholdAccountPayloadH\0R\x14upholdAccountPayload\
    \x12i\n\x18cash_app_account_payload\x18\x11\x20\x01(\x0b2*.io.bisq.proto\
    buffer.CashAppAccountPayloadH\0R\x15cashAppAccountPayloadB\x02\x18\x01\
    \x12k\n\x1amoney_beam_account_payload\x18\x12\x20\x01(\x0b2,.io.bisq.pro\
    tobuffer.MoneyBeamAccountPayloadH\0R\x17moneyBeamAccountPayload\x12b\n\
    \x15venmo_account_payload\x18\x13\x20\x01(\x0b2(.io.bisq.protobuffer.Ven\
    moAccountPayloadH\0R\x13venmoAccountPayloadB\x02\x18\x01\x12g\n\x18popmo\
    ney_account_payload\x18\x14\x20\x01(\x0b2+.io.bisq.protobuffer.PopmoneyA\
    ccountPayloadH\0R\x16popmoneyAccountPayload\x12d\n\x17revolut_account_pa\
    yload\x18\x15\x20\x01(\x0b2*.io.bisq.protobuffer.RevolutAccountPayloadH\
    \0R\x15revolutAccountPayload\x12l\n\x1bwe_chat_pay_account_payload\x18\
    \x16\x20\x01(\x0b2,.io.bisq.protobuffer.WeChatPayAccountPayloadH\0R\x17w\
    eChatPayAccountPayload\x12k\n\x1amoney_gram_account_payload\x18\x17\x20\
    \x01(\x0b2,.io.bisq.protobuffer.MoneyGramAccountPayloadH\0R\x17moneyGram\
    AccountPayload\x12e\n\x18hal_cash_account_payload\x18\x18\x20\x01(\x0b2*\
    .io.bisq.protobuffer.HalCashAccountPayloadH\0R\x15halCashAccountPayload\
    \x12k\n\x1aprompt_pay_account_payload\x18\x19\x20\x01(\x0b2,.io.bisq.pro\
    tobuffer.PromptPayAccountPayloadH\0R\x17promptPayAccountPayload\x12t\n\
    \x1dadvanced_cash_account_payload\x18\x1a\x20\x01(\x0b2/.io.bisq.protobu\
    ffer.AdvancedCashAccountPayloadH\0R\x1aadvancedCashAccountPayload\x12\
    \x90\x01\n'instant_crypto_currency_account_payload\x18\x1b\x20\x01(\x0b2\
    8.io.bisq.protobuffer.InstantCryptoCurrencyAccountPayloadH\0R#instantCry\
    ptoCurrencyAccountPayload\x12k\n\x1ajapan_bank_account_payload\x18\x1c\
    \x20\x01(\x0b2,.io.bisq.protobuffer.JapanBankAccountPayloadH\0R\x17japan\
    BankAccountPayload\x12x\n\x16exclude_from_json_data\x18\x0f\x20\x03(\x0b\
    2C.io.bisq.protobuffer.PaymentAccountPayload.ExcludeFromJsonDataEntryR\
    \x13excludeFromJsonData\x1aF\n\x18ExcludeFromJsonDataEntry\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\
    \x05value:\x028\x01B\t\n\x07message\"5\n\x14AliPayAccountPayload\x12\x1d\
    \n\naccount_nr\x18\x01\x20\x01(\tR\taccountNr\"8\n\x17WeChatPayAccountPa\
    yload\x12\x1d\n\naccount_nr\x18\x01\x20\x01(\tR\taccountNr\"T\n\x1bChase\
    QuickPayAccountPayload\x12\x14\n\x05email\x18\x01\x20\x01(\tR\x05email\
    \x12\x1f\n\x0bholder_name\x18\x02\x20\x01(\tR\nholderName\"j\n\x1aClearX\
    changeAccountPayload\x12\x1f\n\x0bholder_name\x18\x01\x20\x01(\tR\nholde\
    rName\x12+\n\x12email_or_mobile_nr\x18\x02\x20\x01(\tR\x0femailOrMobileN\
    r\"\xc0\x05\n!CountryBasedPaymentAccountPayload\x12\x20\n\x0bcountryCode\
    \x18\x01\x20\x01(\tR\x0bcountryCode\x12[\n\x14bank_account_payload\x18\
    \x02\x20\x01(\x0b2'.io.bisq.protobuffer.BankAccountPayloadH\0R\x12bankAc\
    countPayload\x12q\n\x1ccash_deposit_account_payload\x18\x03\x20\x01(\x0b\
    2..io.bisq.protobuffer.CashDepositAccountPayloadH\0R\x19cashDepositAccou\
    ntPayload\x12[\n\x14sepa_account_payload\x18\x04\x20\x01(\x0b2'.io.bisq.\
    protobuffer.SepaAccountPayloadH\0R\x12sepaAccountPayload\x12t\n\x1dweste\
    rn_union_account_payload\x18\x05\x20\x01(\x0b2/.io.bisq.protobuffer.West\
    ernUnionAccountPayloadH\0R\x1awesternUnionAccountPayload\x12q\n\x1csepa_\
    instant_account_payload\x18\x06\x20\x01(\x0b2..io.bisq.protobuffer.SepaI\
    nstantAccountPayloadH\0R\x19sepaInstantAccountPayload\x12X\n\x13f2f_acco\
    unt_payload\x18\x07\x20\x01(\x0b2&.io.bisq.protobuffer.F2FAccountPayload\
    H\0R\x11f2fAccountPayloadB\t\n\x07message\"\x9a\x05\n\x12BankAccountPayl\
    oad\x12\x1f\n\x0bholder_name\x18\x01\x20\x01(\tR\nholderName\x12\x1b\n\t\
    bank_name\x18\x02\x20\x01(\tR\x08bankName\x12\x17\n\x07bank_id\x18\x03\
    \x20\x01(\tR\x06bankId\x12\x1b\n\tbranch_id\x18\x04\x20\x01(\tR\x08branc\
    hId\x12\x1d\n\naccount_nr\x18\x05\x20\x01(\tR\taccountNr\x12!\n\x0caccou\
    nt_type\x18\x06\x20\x01(\tR\x0baccountType\x12\"\n\rholder_tax_id\x18\
    \x07\x20\x01(\tR\x0bholderTaxId\x12\x18\n\x05email\x18\x08\x20\x01(\tR\
    \x05emailB\x02\x18\x01\x12t\n\x1dnational_bank_account_payload\x18\t\x20\
    \x01(\x0b2/.io.bisq.protobuffer.NationalBankAccountPayloadH\0R\x1anation\
    alBankAccountPayload\x12f\n\x18same_bank_accont_payload\x18\n\x20\x01(\
    \x0b2+.io.bisq.protobuffer.SameBankAccountPayloadH\0R\x15sameBankAccontP\
    ayload\x12w\n\x1especific_banks_account_payload\x18\x0b\x20\x01(\x0b20.i\
    o.bisq.protobuffer.SpecificBanksAccountPayloadH\0R\x1bspecificBanksAccou\
    ntPayload\x12.\n\x13national_account_id\x18\x0c\x20\x01(\tR\x11nationalA\
    ccountIdB\t\n\x07message\"\x1c\n\x1aNationalBankAccountPayload\"\x18\n\
    \x16SameBankAccountPayload\"\xaf\x02\n\x17JapanBankAccountPayload\x12\
    \x1b\n\tbank_name\x18\x01\x20\x01(\tR\x08bankName\x12\x1b\n\tbank_code\
    \x18\x02\x20\x01(\tR\x08bankCode\x12(\n\x10bank_branch_name\x18\x03\x20\
    \x01(\tR\x0ebankBranchName\x12(\n\x10bank_branch_code\x18\x04\x20\x01(\t\
    R\x0ebankBranchCode\x12*\n\x11bank_account_type\x18\x05\x20\x01(\tR\x0fb\
    ankAccountType\x12*\n\x11bank_account_name\x18\x06\x20\x01(\tR\x0fbankAc\
    countName\x12.\n\x13bank_account_number\x18\x07\x20\x01(\tR\x11bankAccou\
    ntNumber\"D\n\x1bSpecificBanksAccountPayload\x12%\n\x0eaccepted_banks\
    \x18\x01\x20\x03(\tR\racceptedBanks\"\xec\x02\n\x19CashDepositAccountPay\
    load\x12\x1f\n\x0bholder_name\x18\x01\x20\x01(\tR\nholderName\x12!\n\x0c\
    holder_email\x18\x02\x20\x01(\tR\x0bholderEmail\x12\x1b\n\tbank_name\x18\
    \x03\x20\x01(\tR\x08bankName\x12\x17\n\x07bank_id\x18\x04\x20\x01(\tR\
    \x06bankId\x12\x1b\n\tbranch_id\x18\x05\x20\x01(\tR\x08branchId\x12\x1d\
    \n\naccount_nr\x18\x06\x20\x01(\tR\taccountNr\x12!\n\x0caccount_type\x18\
    \x07\x20\x01(\tR\x0baccountType\x12\"\n\x0crequirements\x18\x08\x20\x01(\
    \tR\x0crequirements\x12\"\n\rholder_tax_id\x18\t\x20\x01(\tR\x0bholderTa\
    xId\x12.\n\x13national_account_id\x18\n\x20\x01(\tR\x11nationalAccountId\
    \"\x89\x01\n\x17MoneyGramAccountPayload\x12\x1f\n\x0bholder_name\x18\x01\
    \x20\x01(\tR\nholderName\x12!\n\x0ccountry_code\x18\x02\x20\x01(\tR\x0bc\
    ountryCode\x12\x14\n\x05state\x18\x03\x20\x01(\tR\x05state\x12\x14\n\x05\
    email\x18\x04\x20\x01(\tR\x05email\"4\n\x15HalCashAccountPayload\x12\x1b\
    \n\tmobile_nr\x18\x01\x20\x01(\tR\x08mobileNr\"}\n\x1aWesternUnionAccoun\
    tPayload\x12\x1f\n\x0bholder_name\x18\x01\x20\x01(\tR\nholderName\x12\
    \x12\n\x04city\x18\x02\x20\x01(\tR\x04city\x12\x14\n\x05state\x18\x03\
    \x20\x01(\tR\x05state\x12\x14\n\x05email\x18\x04\x20\x01(\tR\x05email\"\
    \xab\x01\n\x12SepaAccountPayload\x12\x1f\n\x0bholder_name\x18\x01\x20\
    \x01(\tR\nholderName\x12\x12\n\x04iban\x18\x02\x20\x01(\tR\x04iban\x12\
    \x10\n\x03bic\x18\x03\x20\x01(\tR\x03bic\x12\x18\n\x05email\x18\x04\x20\
    \x01(\tR\x05emailB\x02\x18\x01\x124\n\x16accepted_country_codes\x18\x05\
    \x20\x03(\tR\x14acceptedCountryCodes\"\x98\x01\n\x19SepaInstantAccountPa\
    yload\x12\x1f\n\x0bholder_name\x18\x01\x20\x01(\tR\nholderName\x12\x12\n\
    \x04iban\x18\x02\x20\x01(\tR\x04iban\x12\x10\n\x03bic\x18\x03\x20\x01(\t\
    R\x03bic\x124\n\x16accepted_country_codes\x18\x04\x20\x03(\tR\x14accepte\
    dCountryCodes\"8\n\x1cCryptoCurrencyAccountPayload\x12\x18\n\x07address\
    \x18\x01\x20\x01(\tR\x07address\"?\n#InstantCryptoCurrencyAccountPayload\
    \x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07address\"t\n\x1cFasterPayme\
    ntsAccountPayload\x12\x1b\n\tsort_code\x18\x01\x20\x01(\tR\x08sortCode\
    \x12\x1d\n\naccount_nr\x18\x02\x20\x01(\tR\taccountNr\x12\x18\n\x05email\
    \x18\x03\x20\x01(\tR\x05emailB\x02\x18\x01\"\x8b\x01\n\x1eInteracETransf\
    erAccountPayload\x12\x14\n\x05email\x18\x01\x20\x01(\tR\x05email\x12\x1f\
    \n\x0bholder_name\x18\x02\x20\x01(\tR\nholderName\x12\x1a\n\x08question\
    \x18\x03\x20\x01(\tR\x08question\x12\x16\n\x06answer\x18\x04\x20\x01(\tR\
    \x06answer\"4\n\x13OKPayAccountPayload\x12\x1d\n\naccount_nr\x18\x01\x20\
    \x01(\tR\taccountNr\"5\n\x14UpholdAccountPayload\x12\x1d\n\naccount_id\
    \x18\x01\x20\x01(\tR\taccountId\"2\n\x15CashAppAccountPayload\x12\x19\n\
    \x08cash_tag\x18\x01\x20\x01(\tR\x07cashTag\"8\n\x17MoneyBeamAccountPayl\
    oad\x12\x1d\n\naccount_id\x18\x01\x20\x01(\tR\taccountId\"^\n\x13VenmoAc\
    countPayload\x12&\n\x0fvenmo_user_name\x18\x01\x20\x01(\tR\rvenmoUserNam\
    e\x12\x1f\n\x0bholder_name\x18\x02\x20\x01(\tR\nholderName\"X\n\x16Popmo\
    neyAccountPayload\x12\x1d\n\naccount_id\x18\x01\x20\x01(\tR\taccountId\
    \x12\x1f\n\x0bholder_name\x18\x02\x20\x01(\tR\nholderName\"6\n\x15Revolu\
    tAccountPayload\x12\x1d\n\naccount_id\x18\x01\x20\x01(\tR\taccountId\";\
    \n\x1aPerfectMoneyAccountPayload\x12\x1d\n\naccount_nr\x18\x01\x20\x01(\
    \tR\taccountNr\"S\n\x13SwishAccountPayload\x12\x1b\n\tmobile_nr\x18\x01\
    \x20\x01(\tR\x08mobileNr\x12\x1f\n\x0bholder_name\x18\x02\x20\x01(\tR\nh\
    olderName\"j\n\x20USPostalMoneyOrderAccountPayload\x12%\n\x0epostal_addr\
    ess\x18\x01\x20\x01(\tR\rpostalAddress\x12\x1f\n\x0bholder_name\x18\x02\
    \x20\x01(\tR\nholderName\"`\n\x11F2FAccountPayload\x12\x18\n\x07contact\
    \x18\x01\x20\x01(\tR\x07contact\x12\x12\n\x04city\x18\x02\x20\x01(\tR\
    \x04city\x12\x1d\n\nextra_info\x18\x03\x20\x01(\tR\textraInfo\"=\n\x17Pr\
    omptPayAccountPayload\x12\"\n\rprompt_pay_id\x18\x01\x20\x01(\tR\x0bprom\
    ptPayId\";\n\x1aAdvancedCashAccountPayload\x12\x1d\n\naccount_nr\x18\x01\
    \x20\x01(\tR\taccountNr\"\xaf\x14\n\x13PersistableEnvelope\x12X\n\x13seq\
    uence_number_map\x18\x01\x20\x01(\x0b2&.io.bisq.protobuffer.SequenceNumb\
    erMapH\0R\x11sequenceNumberMap\x12\\\n\x13persisted_entry_map\x18\x02\
    \x20\x01(\x0b2&.io.bisq.protobuffer.PersistedEntryMapH\0R\x11persistedEn\
    tryMapB\x02\x18\x01\x12<\n\tpeer_list\x18\x03\x20\x01(\x0b2\x1d.io.bisq.\
    protobuffer.PeerListH\0R\x08peerList\x12U\n\x12address_entry_list\x18\
    \x04\x20\x01(\x0b2%.io.bisq.protobuffer.AddressEntryListH\0R\x10addressE\
    ntryList\x12N\n\x0fnavigation_path\x18\x05\x20\x01(\x0b2#.io.bisq.protob\
    uffer.NavigationPathH\0R\x0enavigationPath\x12H\n\rtradable_list\x18\x06\
    \x20\x01(\x0b2!.io.bisq.protobuffer.TradableListH\0R\x0ctradableList\x12\
    b\n\x15trade_statistics_list\x18\x07\x20\x01(\x0b2(.io.bisq.protobuffer.\
    TradeStatisticsListH\0R\x13tradeStatisticsListB\x02\x18\x01\x12g\n\x18ar\
    bitration_dispute_list\x18\x08\x20\x01(\x0b2+.io.bisq.protobuffer.Arbitr\
    ationDisputeListH\0R\x16arbitrationDisputeList\x12Z\n\x13preferences_pay\
    load\x18\t\x20\x01(\x0b2'.io.bisq.protobuffer.PreferencesPayloadH\0R\x12\
    preferencesPayload\x12E\n\x0cuser_payload\x18\n\x20\x01(\x0b2\x20.io.bis\
    q.protobuffer.UserPayloadH\0R\x0buserPayload\x12[\n\x14payment_account_l\
    ist\x18\x0b\x20\x01(\x0b2'.io.bisq.protobuffer.PaymentAccountListH\0R\
    \x12paymentAccountList\x12h\n\x19account_age_witness_store\x18\r\x20\x01\
    (\x0b2+.io.bisq.protobuffer.AccountAgeWitnessStoreH\0R\x16accountAgeWitn\
    essStore\x12d\n\x17trade_statistics2_store\x18\x0e\x20\x01(\x0b2*.io.bis\
    q.protobuffer.TradeStatistics2StoreH\0R\x15tradeStatistics2Store\x12\x81\
    \x01\n\x20persistable_network_payload_list\x18\x0f\x20\x01(\x0b22.io.bis\
    q.protobuffer.PersistableNetworkPayloadListH\0R\x1dpersistableNetworkPay\
    loadListB\x02\x18\x01\x12K\n\x0eproposal_store\x18\x10\x20\x01(\x0b2\".i\
    o.bisq.protobuffer.ProposalStoreH\0R\rproposalStore\x12X\n\x13temp_propo\
    sal_store\x18\x11\x20\x01(\x0b2&.io.bisq.protobuffer.TempProposalStoreH\
    \0R\x11tempProposalStore\x12O\n\x10blind_vote_store\x18\x12\x20\x01(\x0b\
    2#.io.bisq.protobuffer.BlindVoteStoreH\0R\x0eblindVoteStore\x12O\n\x10my\
    _proposal_list\x18\x13\x20\x01(\x0b2#.io.bisq.protobuffer.MyProposalList\
    H\0R\x0emyProposalList\x12B\n\x0bballot_list\x18\x14\x20\x01(\x0b2\x1f.i\
    o.bisq.protobuffer.BallotListH\0R\nballotList\x12C\n\x0cmy_vote_list\x18\
    \x15\x20\x01(\x0b2\x1f.io.bisq.protobuffer.MyVoteListH\0R\nmyVoteList\
    \x12S\n\x12my_blind_vote_list\x18\x16\x20\x01(\x0b2$.io.bisq.protobuffer\
    .MyBlindVoteListH\0R\x0fmyBlindVoteList\x12?\n\nmerit_list\x18\x17\x20\
    \x01(\x0b2\x1e.io.bisq.protobuffer.MeritListH\0R\tmeritList\x12L\n\x0fda\
    o_state_store\x18\x18\x20\x01(\x0b2\".io.bisq.protobuffer.DaoStateStoreH\
    \0R\rdaoStateStore\x12U\n\x12my_reputation_list\x18\x19\x20\x01(\x0b2%.i\
    o.bisq.protobuffer.MyReputationListH\0R\x10myReputationList\x12Z\n\x15my\
    _proof_of_burn_list\x18\x1a\x20\x01(\x0b2&.io.bisq.protobuffer.MyProofOf\
    BurnListH\0R\x11myProofOfBurnList\x12\x81\x01\n\"unconfirmed_bsq_change_\
    output_list\x18\x1b\x20\x01(\x0b23.io.bisq.protobuffer.UnconfirmedBsqCha\
    ngeOutputListH\0R\x1eunconfirmedBsqChangeOutputList\x12[\n\x14signed_wit\
    ness_store\x18\x1c\x20\x01(\x0b2'.io.bisq.protobuffer.SignedWitnessStore\
    H\0R\x12signedWitnessStore\x12a\n\x16mediation_dispute_list\x18\x1d\x20\
    \x01(\x0b2).io.bisq.protobuffer.MediationDisputeListH\0R\x14mediationDis\
    puteList\x12X\n\x13refund_dispute_list\x18\x1e\x20\x01(\x0b2&.io.bisq.pr\
    otobuffer.RefundDisputeListH\0R\x11refundDisputeListB\t\n\x07message\"u\
    \n\x11SequenceNumberMap\x12`\n\x17sequence_number_entries\x18\x01\x20\
    \x03(\x0b2(.io.bisq.protobuffer.SequenceNumberEntryR\x15sequenceNumberEn\
    tries\"\x87\x01\n\x13SequenceNumberEntry\x124\n\x05bytes\x18\x01\x20\x01\
    (\x0b2\x1e.io.bisq.protobuffer.ByteArrayR\x05bytes\x12:\n\tmap_value\x18\
    \x02\x20\x01(\x0b2\x1d.io.bisq.protobuffer.MapValueR\x08mapValue\"!\n\tB\
    yteArray\x12\x14\n\x05bytes\x18\x01\x20\x01(\x0cR\x05bytes\"J\n\x08MapVa\
    lue\x12\x1f\n\x0bsequence_nr\x18\x01\x20\x01(\x05R\nsequenceNr\x12\x1d\n\
    \ntime_stamp\x18\x02\x20\x01(\x03R\ttimeStamp\"\xf4\x01\n\x11PersistedEn\
    tryMap\x12m\n\x13persisted_entry_map\x18\x01\x20\x03(\x0b2=.io.bisq.prot\
    obuffer.PersistedEntryMap.PersistedEntryMapEntryR\x11persistedEntryMap\
    \x1ap\n\x16PersistedEntryMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12@\n\x05value\x18\x02\x20\x01(\x0b2*.io.bisq.protobuffer.Prote\
    ctedStorageEntryR\x05value:\x028\x01\"e\n\x1dPersistableNetworkPayloadLi\
    st\x12D\n\x05items\x18\x01\x20\x03(\x0b2..io.bisq.protobuffer.Persistabl\
    eNetworkPayloadR\x05items\"V\n\x16AccountAgeWitnessStore\x12<\n\x05items\
    \x18\x01\x20\x03(\x0b2&.io.bisq.protobuffer.AccountAgeWitnessR\x05items\
    \"N\n\x12SignedWitnessStore\x128\n\x05items\x18\x01\x20\x03(\x0b2\".io.b\
    isq.protobuffer.SignedWitnessR\x05items\"T\n\x15TradeStatistics2Store\
    \x12;\n\x05items\x18\x01\x20\x03(\x0b2%.io.bisq.protobuffer.TradeStatist\
    ics2R\x05items\"9\n\x08PeerList\x12-\n\x04peer\x18\x01\x20\x03(\x0b2\x19\
    .io.bisq.protobuffer.PeerR\x04peer\"Z\n\x10AddressEntryList\x12F\n\raddr\
    ess_entry\x18\x01\x20\x03(\x0b2!.io.bisq.protobuffer.AddressEntryR\x0cad\
    dressEntry\"\xe6\x02\n\x0cAddressEntry\x12\x19\n\x08offer_id\x18\x07\x20\
    \x01(\tR\x07offerId\x12C\n\x07context\x18\x08\x20\x01(\x0e2).io.bisq.pro\
    tobuffer.AddressEntry.ContextR\x07context\x12\x17\n\x07pub_key\x18\t\x20\
    \x01(\x0cR\x06pubKey\x12\x20\n\x0cpub_key_hash\x18\n\x20\x01(\x0cR\npubK\
    eyHash\x126\n\x18coin_locked_in_multi_sig\x18\x0b\x20\x01(\x03R\x14coinL\
    ockedInMultiSig\"\x82\x01\n\x07Context\x12\x0c\n\x08PB_ERROR\x10\0\x12\
    \x0e\n\nARBITRATOR\x10\x01\x12\r\n\tAVAILABLE\x10\x02\x12\x11\n\rOFFER_F\
    UNDING\x10\x03\x12\x16\n\x12RESERVED_FOR_TRADE\x10\x04\x12\r\n\tMULTI_SI\
    G\x10\x05\x12\x10\n\x0cTRADE_PAYOUT\x10\x06\"$\n\x0eNavigationPath\x12\
    \x12\n\x04path\x18\x01\x20\x03(\tR\x04path\"b\n\x12PaymentAccountList\
    \x12L\n\x0fpayment_account\x18\x01\x20\x03(\x0b2#.io.bisq.protobuffer.Pa\
    ymentAccountR\x0epaymentAccount\"I\n\x0cTradableList\x129\n\x08tradable\
    \x18\x01\x20\x03(\x0b2\x1d.io.bisq.protobuffer.TradableR\x08tradable\"f\
    \n\x13TradeStatisticsList\x12O\n\x10trade_statistics\x18\x01\x20\x03(\
    \x0b2$.io.bisq.protobuffer.TradeStatisticsR\x0ftradeStatistics\"\xc9\x01\
    \n\x05Offer\x12F\n\roffer_payload\x18\x01\x20\x01(\x0b2!.io.bisq.protobu\
    ffer.OfferPayloadR\x0cofferPayload\"x\n\x05State\x12\x0c\n\x08PB_ERROR\
    \x10\0\x12\x0b\n\x07UNKNOWN\x10\x01\x12\x12\n\x0eOFFER_FEE_PAID\x10\x02\
    \x12\r\n\tAVAILABLE\x10\x03\x12\x11\n\rNOT_AVAILABLE\x10\x04\x12\x0b\n\
    \x07REMOVED\x10\x05\x12\x11\n\rMAKER_OFFLINE\x10\x06\"\xe5\x03\n\tOpenOf\
    fer\x120\n\x05offer\x18\x01\x20\x01(\x0b2\x1a.io.bisq.protobuffer.OfferR\
    \x05offer\x12:\n\x05state\x18\x02\x20\x01(\x0e2$.io.bisq.protobuffer.Ope\
    nOffer.StateR\x05state\x12X\n\x17arbitrator_node_address\x18\x03\x20\x01\
    (\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x15arbitratorNodeAddress\x12\
    T\n\x15mediator_node_address\x18\x04\x20\x01(\x0b2\x20.io.bisq.protobuff\
    er.NodeAddressR\x13mediatorNodeAddress\x12[\n\x19refund_agent_node_addre\
    ss\x18\x05\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x16refundA\
    gentNodeAddress\"]\n\x05State\x12\x0c\n\x08PB_ERROR\x10\0\x12\r\n\tAVAIL\
    ABLE\x10\x01\x12\x0c\n\x08RESERVED\x10\x02\x12\n\n\x06CLOSED\x10\x03\x12\
    \x0c\n\x08CANCELED\x10\x04\x12\x0f\n\x0bDEACTIVATED\x10\x05\"\xc8\x03\n\
    \x08Tradable\x12?\n\nopen_offer\x18\x01\x20\x01(\x0b2\x1e.io.bisq.protob\
    uffer.OpenOfferH\0R\topenOffer\x12Y\n\x14buyer_as_maker_trade\x18\x02\
    \x20\x01(\x0b2&.io.bisq.protobuffer.BuyerAsMakerTradeH\0R\x11buyerAsMake\
    rTrade\x12Y\n\x14buyer_as_taker_trade\x18\x03\x20\x01(\x0b2&.io.bisq.pro\
    tobuffer.BuyerAsTakerTradeH\0R\x11buyerAsTakerTrade\x12\\\n\x15seller_as\
    _maker_trade\x18\x04\x20\x01(\x0b2'.io.bisq.protobuffer.SellerAsMakerTra\
    deH\0R\x12sellerAsMakerTrade\x12\\\n\x15seller_as_taker_trade\x18\x05\
    \x20\x01(\x0b2'.io.bisq.protobuffer.SellerAsTakerTradeH\0R\x12sellerAsTa\
    kerTradeB\t\n\x07message\"\xf2\x1f\n\x05Trade\x120\n\x05offer\x18\x01\
    \x20\x01(\x0b2\x1a.io.bisq.protobuffer.OfferR\x05offer\x12F\n\rprocess_m\
    odel\x18\x02\x20\x01(\x0b2!.io.bisq.protobuffer.ProcessModelR\x0cprocess\
    Model\x12%\n\x0ftaker_fee_tx_id\x18\x03\x20\x01(\tR\x0ctakerFeeTxId\x12\
    \"\n\rdeposit_tx_id\x18\x04\x20\x01(\tR\x0bdepositTxId\x12\x20\n\x0cpayo\
    ut_tx_id\x18\x05\x20\x01(\tR\npayoutTxId\x12/\n\x14trade_amount_as_long\
    \x18\x06\x20\x01(\x03R\x11tradeAmountAsLong\x12#\n\x0etx_fee_as_long\x18\
    \x07\x20\x01(\x03R\x0btxFeeAsLong\x12)\n\x11taker_fee_as_long\x18\x08\
    \x20\x01(\x03R\x0etakerFeeAsLong\x12&\n\x0ftake_offer_date\x18\t\x20\x01\
    (\x03R\rtakeOfferDate\x12?\n\x1dis_currency_for_taker_fee_btc\x18\n\x20\
    \x01(\x08R\x18isCurrencyForTakerFeeBtc\x12\x1f\n\x0btrade_price\x18\x0b\
    \x20\x01(\x03R\ntradePrice\x12[\n\x19trading_peer_node_address\x18\x0c\
    \x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x16tradingPeerNodeAd\
    dress\x126\n\x05state\x18\r\x20\x01(\x0e2\x20.io.bisq.protobuffer.Trade.\
    StateR\x05state\x12L\n\rdispute_state\x18\x0e\x20\x01(\x0e2'.io.bisq.pro\
    tobuffer.Trade.DisputeStateR\x0cdisputeState\x12Y\n\x12trade_period_stat\
    e\x18\x0f\x20\x01(\x0e2+.io.bisq.protobuffer.Trade.TradePeriodStateR\x10\
    tradePeriodState\x129\n\x08contract\x18\x10\x20\x01(\x0b2\x1d.io.bisq.pr\
    otobuffer.ContractR\x08contract\x12(\n\x10contract_as_json\x18\x11\x20\
    \x01(\tR\x0econtractAsJson\x12#\n\rcontract_hash\x18\x12\x20\x01(\x0cR\
    \x0ccontractHash\x128\n\x18taker_contract_signature\x18\x13\x20\x01(\tR\
    \x16takerContractSignature\x128\n\x18maker_contract_signature\x18\x14\
    \x20\x01(\tR\x16makerContractSignature\x12X\n\x17arbitrator_node_address\
    \x18\x15\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\x15arbitrato\
    rNodeAddress\x12T\n\x15mediator_node_address\x18\x16\x20\x01(\x0b2\x20.i\
    o.bisq.protobuffer.NodeAddressR\x13mediatorNodeAddress\x123\n\x16arbitra\
    tor_btc_pub_key\x18\x17\x20\x01(\x0cR\x13arbitratorBtcPubKey\x127\n\x18t\
    aker_payment_account_id\x18\x18\x20\x01(\tR\x15takerPaymentAccountId\x12\
    #\n\rerror_message\x18\x19\x20\x01(\tR\x0cerrorMessage\x12V\n\x17arbitra\
    tor_pub_key_ring\x18\x1a\x20\x01(\x0b2\x1f.io.bisq.protobuffer.PubKeyRin\
    gR\x14arbitratorPubKeyRing\x12R\n\x15mediator_pub_key_ring\x18\x1b\x20\
    \x01(\x0b2\x1f.io.bisq.protobuffer.PubKeyRingR\x12mediatorPubKeyRing\x12\
    3\n\x16counter_currency_tx_id\x18\x1c\x20\x01(\tR\x13counterCurrencyTxId\
    \x12C\n\x0cchat_message\x18\x1d\x20\x03(\x0b2\x20.io.bisq.protobuffer.Ch\
    atMessageR\x0bchatMessage\x12_\n\x16mediation_result_state\x18\x1e\x20\
    \x01(\x0e2).io.bisq.protobuffer.MediationResultStateR\x14mediationResult\
    State\x12\x1b\n\tlock_time\x18\x1f\x20\x01(\x03R\x08lockTime\x125\n\x17d\
    elayed_payout_tx_bytes\x18\x20\x20\x01(\x0cR\x14delayedPayoutTxBytes\x12\
    [\n\x19refund_agent_node_address\x18!\x20\x01(\x0b2\x20.io.bisq.protobuf\
    fer.NodeAddressR\x16refundAgentNodeAddress\x12Y\n\x19refund_agent_pub_ke\
    y_ring\x18\"\x20\x01(\x0b2\x1f.io.bisq.protobuffer.PubKeyRingR\x15refund\
    AgentPubKeyRing\x12V\n\x13refund_result_state\x18#\x20\x01(\x0e2&.io.bis\
    q.protobuffer.RefundResultStateR\x11refundResultState\"\xc1\n\n\x05State\
    \x12\x12\n\x0ePB_ERROR_STATE\x10\0\x12\x0f\n\x0bPREPARATION\x10\x01\x12\
    \x20\n\x1cTAKER_PUBLISHED_TAKER_FEE_TX\x10\x02\x12)\n%MAKER_SENT_PUBLISH\
    _DEPOSIT_TX_REQUEST\x10\x03\x120\n,MAKER_SAW_ARRIVED_PUBLISH_DEPOSIT_TX_\
    REQUEST\x10\x04\x126\n2MAKER_STORED_IN_MAILBOX_PUBLISH_DEPOSIT_TX_REQUES\
    T\x10\x05\x120\n,MAKER_SEND_FAILED_PUBLISH_DEPOSIT_TX_REQUEST\x10\x06\
    \x12-\n)TAKER_RECEIVED_PUBLISH_DEPOSIT_TX_REQUEST\x10\x07\x12\x1f\n\x1bS\
    ELLER_PUBLISHED_DEPOSIT_TX\x10\x08\x12(\n$SELLER_SENT_DEPOSIT_TX_PUBLISH\
    ED_MSG\x10\t\x12/\n+SELLER_SAW_ARRIVED_DEPOSIT_TX_PUBLISHED_MSG\x10\n\
    \x125\n1SELLER_STORED_IN_MAILBOX_DEPOSIT_TX_PUBLISHED_MSG\x10\x0b\x12/\n\
    +SELLER_SEND_FAILED_DEPOSIT_TX_PUBLISHED_MSG\x10\x0c\x12+\n'BUYER_RECEIV\
    ED_DEPOSIT_TX_PUBLISHED_MSG\x10\r\x12#\n\x1fBUYER_SAW_DEPOSIT_TX_IN_NETW\
    ORK\x10\x0e\x12$\n\x20DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN\x10\x0f\x120\n,BU\
    YER_CONFIRMED_IN_UI_FIAT_PAYMENT_INITIATED\x10\x10\x12)\n%BUYER_SENT_FIA\
    T_PAYMENT_INITIATED_MSG\x10\x11\x120\n,BUYER_SAW_ARRIVED_FIAT_PAYMENT_IN\
    ITIATED_MSG\x10\x12\x126\n2BUYER_STORED_IN_MAILBOX_FIAT_PAYMENT_INITIATE\
    D_MSG\x10\x13\x120\n,BUYER_SEND_FAILED_FIAT_PAYMENT_INITIATED_MSG\x10\
    \x14\x12.\n*SELLER_RECEIVED_FIAT_PAYMENT_INITIATED_MSG\x10\x15\x12/\n+SE\
    LLER_CONFIRMED_IN_UI_FIAT_PAYMENT_RECEIPT\x10\x16\x12\x1e\n\x1aSELLER_PU\
    BLISHED_PAYOUT_TX\x10\x17\x12'\n#SELLER_SENT_PAYOUT_TX_PUBLISHED_MSG\x10\
    \x18\x12.\n*SELLER_SAW_ARRIVED_PAYOUT_TX_PUBLISHED_MSG\x10\x19\x124\n0SE\
    LLER_STORED_IN_MAILBOX_PAYOUT_TX_PUBLISHED_MSG\x10\x1a\x12.\n*SELLER_SEN\
    D_FAILED_PAYOUT_TX_PUBLISHED_MSG\x10\x1b\x12*\n&BUYER_RECEIVED_PAYOUT_TX\
    _PUBLISHED_MSG\x10\x1c\x12\"\n\x1eBUYER_SAW_PAYOUT_TX_IN_NETWORK\x10\x1d\
    \x12\x16\n\x12WITHDRAW_COMPLETED\x10\x1e\"\xb3\x01\n\x05Phase\x12\x12\n\
    \x0ePB_ERROR_PHASE\x10\0\x12\x08\n\x04INIT\x10\x01\x12\x17\n\x13TAKER_FE\
    E_PUBLISHED\x10\x02\x12\x15\n\x11DEPOSIT_PUBLISHED\x10\x03\x12\x15\n\x11\
    DEPOSIT_CONFIRMED\x10\x04\x12\r\n\tFIAT_SENT\x10\x05\x12\x11\n\rFIAT_REC\
    EIVED\x10\x06\x12\x14\n\x10PAYOUT_PUBLISHED\x10\x07\x12\r\n\tWITHDRAWN\
    \x10\x08\"\xa5\x02\n\x0cDisputeState\x12\x1a\n\x16PB_ERROR_DISPUTE_STATE\
    \x10\0\x12\x0e\n\nNO_DISPUTE\x10\x01\x12\x15\n\x11DISPUTE_REQUESTED\x10\
    \x02\x12\x1b\n\x17DISPUTE_STARTED_BY_PEER\x10\x03\x12\x12\n\x0eDISPUTE_C\
    LOSED\x10\x04\x12\x17\n\x13MEDIATION_REQUESTED\x10\x05\x12\x1d\n\x19MEDI\
    ATION_STARTED_BY_PEER\x10\x06\x12\x14\n\x10MEDIATION_CLOSED\x10\x07\x12\
    \x14\n\x10REFUND_REQUESTED\x10\x08\x12\"\n\x1eREFUND_REQUEST_STARTED_BY_\
    PEER\x10\t\x12\x19\n\x15REFUND_REQUEST_CLOSED\x10\n\"k\n\x10TradePeriodS\
    tate\x12\x1f\n\x1bPB_ERROR_TRADE_PERIOD_STATE\x10\0\x12\x0e\n\nFIRST_HAL\
    F\x10\x01\x12\x0f\n\x0bSECOND_HALF\x10\x02\x12\x15\n\x11TRADE_PERIOD_OVE\
    R\x10\x03\"E\n\x11BuyerAsMakerTrade\x120\n\x05trade\x18\x01\x20\x01(\x0b\
    2\x1a.io.bisq.protobuffer.TradeR\x05trade\"E\n\x11BuyerAsTakerTrade\x120\
    \n\x05trade\x18\x01\x20\x01(\x0b2\x1a.io.bisq.protobuffer.TradeR\x05trad\
    e\"F\n\x12SellerAsMakerTrade\x120\n\x05trade\x18\x01\x20\x01(\x0b2\x1a.i\
    o.bisq.protobuffer.TradeR\x05trade\"F\n\x12SellerAsTakerTrade\x120\n\x05\
    trade\x18\x01\x20\x01(\x0b2\x1a.io.bisq.protobuffer.TradeR\x05trade\"\
    \xd5\x08\n\x0cProcessModel\x12C\n\x0ctrading_peer\x18\x01\x20\x01(\x0b2\
    \x20.io.bisq.protobuffer.TradingPeerR\x0btradingPeer\x12\x19\n\x08offer_\
    id\x18\x02\x20\x01(\tR\x07offerId\x12\x1d\n\naccount_id\x18\x03\x20\x01(\
    \tR\taccountId\x12A\n\x0cpub_key_ring\x18\x04\x20\x01(\x0b2\x1f.io.bisq.\
    protobuffer.PubKeyRingR\npubKeyRing\x12.\n\x14take_offer_fee_tx_id\x18\
    \x05\x20\x01(\tR\x10takeOfferFeeTxId\x12.\n\x13payout_tx_signature\x18\
    \x06\x20\x01(\x0cR\x11payoutTxSignature\x12.\n\x13prepared_deposit_tx\
    \x18\t\x20\x01(\x0cR\x11preparedDepositTx\x12^\n\x16raw_transaction_inpu\
    ts\x18\n\x20\x03(\x0b2(.io.bisq.protobuffer.RawTransactionInputR\x14rawT\
    ransactionInputs\x12.\n\x13change_output_value\x18\x0b\x20\x01(\x03R\x11\
    changeOutputValue\x122\n\x15change_output_address\x18\x0c\x20\x01(\tR\
    \x13changeOutputAddress\x12,\n\x12use_savings_wallet\x18\r\x20\x01(\x08R\
    \x10useSavingsWallet\x12A\n\x1efunds_needed_for_trade_as_long\x18\x0e\
    \x20\x01(\x03R\x19fundsNeededForTradeAsLong\x12.\n\x14my_multi_sig_pub_k\
    ey\x18\x0f\x20\x01(\x0cR\x10myMultiSigPubKey\x12d\n\x1etemp_trading_peer\
    _node_address\x18\x10\x20\x01(\x0b2\x20.io.bisq.protobuffer.NodeAddressR\
    \x1atempTradingPeerNodeAddress\x12A\n\x1dpayment_started_message_state\
    \x18\x11\x20\x01(\tR\x1apaymentStartedMessageState\x12?\n\x1cmediated_pa\
    yout_tx_signature\x18\x12\x20\x01(\x0cR\x19mediatedPayoutTxSignature\x12\
    J\n\"buyer_payout_amount_from_mediation\x18\x13\x20\x01(\x03R\x1ebuyerPa\
    youtAmountFromMediation\x12L\n#seller_payout_amount_from_mediation\x18\
    \x14\x20\x01(\x03R\x1fsellerPayoutAmountFromMediationJ\x04\x08\x07\x10\
    \x08J\x04\x08\x08\x10\t\"\xcf\x06\n\x0bTradingPeer\x12\x1d\n\naccount_id\
    \x18\x01\x20\x01(\tR\taccountId\x12b\n\x17payment_account_payload\x18\
    \x02\x20\x01(\x0b2*.io.bisq.protobuffer.PaymentAccountPayloadR\x15paymen\
    tAccountPayload\x122\n\x15payout_address_string\x18\x03\x20\x01(\tR\x13p\
    ayoutAddressString\x12(\n\x10contract_as_json\x18\x04\x20\x01(\tR\x0econ\
    tractAsJson\x12-\n\x12contract_signature\x18\x05\x20\x01(\tR\x11contract\
    Signature\x12\x1c\n\tsignature\x18\x06\x20\x01(\x0cR\tsignature\x12A\n\
    \x0cpub_key_ring\x18\x07\x20\x01(\x0b2\x1f.io.bisq.protobuffer.PubKeyRin\
    gR\npubKeyRing\x12)\n\x11multi_sig_pub_key\x18\x08\x20\x01(\x0cR\x0emult\
    iSigPubKey\x12^\n\x16raw_transaction_inputs\x18\t\x20\x03(\x0b2(.io.bisq\
    .protobuffer.RawTransactionInputR\x14rawTransactionInputs\x12.\n\x13chan\
    ge_output_value\x18\n\x20\x01(\x03R\x11changeOutputValue\x122\n\x15chang\
    e_output_address\x18\x0b\x20\x01(\tR\x13changeOutputAddress\x129\n\x19ac\
    count_age_witness_nonce\x18\x0c\x20\x01(\x0cR\x16accountAgeWitnessNonce\
    \x12A\n\x1daccount_age_witness_signature\x18\r\x20\x01(\x0cR\x1aaccountA\
    geWitnessSignature\x12!\n\x0ccurrent_date\x18\x0e\x20\x01(\x03R\x0bcurre\
    ntDate\x12?\n\x1cmediated_payout_tx_signature\x18\x0f\x20\x01(\x0cR\x19m\
    ediatedPayoutTxSignature\"P\n\x16ArbitrationDisputeList\x126\n\x07disput\
    e\x18\x01\x20\x03(\x0b2\x1c.io.bisq.protobuffer.DisputeR\x07dispute\"N\n\
    \x14MediationDisputeList\x126\n\x07dispute\x18\x01\x20\x03(\x0b2\x1c.io.\
    bisq.protobuffer.DisputeR\x07dispute\"K\n\x11RefundDisputeList\x126\n\
    \x07dispute\x18\x01\x20\x03(\x0b2\x1c.io.bisq.protobuffer.DisputeR\x07di\
    spute\"\xca\x1b\n\x12PreferencesPayload\x12#\n\ruser_language\x18\x01\
    \x20\x01(\tR\x0cuserLanguage\x12?\n\x0cuser_country\x18\x02\x20\x01(\x0b\
    2\x1c.io.bisq.protobuffer.CountryR\x0buserCountry\x12K\n\x0ffiat_currenc\
    ies\x18\x03\x20\x03(\x0b2\".io.bisq.protobuffer.TradeCurrencyR\x0efiatCu\
    rrencies\x12O\n\x11crypto_currencies\x18\x04\x20\x03(\x0b2\".io.bisq.pro\
    tobuffer.TradeCurrencyR\x10cryptoCurrencies\x12i\n\x1dblock_chain_explor\
    er_main_net\x18\x05\x20\x01(\x0b2'.io.bisq.protobuffer.BlockChainExplore\
    rR\x19blockChainExplorerMainNet\x12i\n\x1dblock_chain_explorer_test_net\
    \x18\x06\x20\x01(\x0b2'.io.bisq.protobuffer.BlockChainExplorerR\x19block\
    ChainExplorerTestNet\x12`\n\x18bsq_block_chain_explorer\x18\x07\x20\x01(\
    \x0b2'.io.bisq.protobuffer.BlockChainExplorerR\x15bsqBlockChainExplorer\
    \x12)\n\x10backup_directory\x18\x08\x20\x01(\tR\x0fbackupDirectory\x126\
    \n\x17auto_select_arbitrators\x18\t\x20\x01(\x08R\x15autoSelectArbitrato\
    rs\x12l\n\x13dont_show_again_map\x18\n\x20\x03(\x0b2=.io.bisq.protobuffe\
    r.PreferencesPayload.DontShowAgainMapEntryR\x10dontShowAgainMap\x12!\n\
    \x0ctac_accepted\x18\x0b\x20\x01(\x08R\x0btacAccepted\x120\n\x15use_tor_\
    for_bitcoin_j\x18\x0c\x20\x01(\x08R\x11useTorForBitcoinJ\x12?\n\x1dshow_\
    own_offers_in_offer_book\x18\r\x20\x01(\x08R\x18showOwnOffersInOfferBook\
    \x12\\\n\x18preferred_trade_currency\x18\x0e\x20\x01(\x0b2\".io.bisq.pro\
    tobuffer.TradeCurrencyR\x16preferredTradeCurrency\x12:\n\x1awithdrawal_t\
    x_fee_in_bytes\x18\x0f\x20\x01(\x03R\x16withdrawalTxFeeInBytes\x12>\n\
    \x1cuse_custom_withdrawal_tx_fee\x18\x10\x20\x01(\x08R\x18useCustomWithd\
    rawalTxFee\x12@\n\x1dmax_price_distance_in_percent\x18\x11\x20\x01(\x01R\
    \x19maxPriceDistanceInPercent\x12O\n%offer_book_chart_screen_currency_co\
    de\x18\x12\x20\x01(\tR\x20offerBookChartScreenCurrencyCode\x12H\n!trade_\
    charts_screen_currency_code\x18\x13\x20\x01(\tR\x1dtradeChartsScreenCurr\
    encyCode\x127\n\x18buy_screen_currency_code\x18\x14\x20\x01(\tR\x15buySc\
    reenCurrencyCode\x129\n\x19sell_screen_currency_code\x18\x15\x20\x01(\tR\
    \x16sellScreenCurrencyCode\x12F\n\x20trade_statistics_tick_unit_index\
    \x18\x16\x20\x01(\x05R\x1ctradeStatisticsTickUnitIndex\x120\n\x14resync_\
    Spv_requested\x18\x17\x20\x01(\x08R\x12resyncSpvRequested\x12K\n\"sort_m\
    arket_currencies_numerically\x18\x18\x20\x01(\x08R\x1fsortMarketCurrenci\
    esNumerically\x12;\n\x1ause_percentage_based_price\x18\x19\x20\x01(\x08R\
    \x17usePercentageBasedPrice\x12Y\n\x0cpeer_tag_map\x18\x1a\x20\x03(\x0b2\
    7.io.bisq.protobuffer.PreferencesPayload.PeerTagMapEntryR\npeerTagMap\
    \x12#\n\rbitcoin_nodes\x18\x1b\x20\x01(\tR\x0cbitcoinNodes\x12.\n\x13ign\
    ore_traders_list\x18\x1c\x20\x03(\tR\x11ignoreTradersList\x124\n\x16dire\
    ctory_chooser_path\x18\x1d\x20\x01(\tR\x14directoryChooserPath\x12F\n\
    \x1ebuyer_security_deposit_as_long\x18\x1e\x20\x01(\x03R\x1abuyerSecurit\
    yDepositAsLongB\x02\x18\x01\x12%\n\x0euse_animations\x18\x1f\x20\x01(\
    \x08R\ruseAnimations\x12z\n'selectedPayment_account_for_createOffer\x18\
    \x20\x20\x01(\x0b2#.io.bisq.protobuffer.PaymentAccountR$selectedPaymentA\
    ccountForCreateOffer\x12#\n\x0epay_fee_in_Btc\x18!\x20\x01(\x08R\x0bpayF\
    eeInBtc\x12)\n\x10bridge_addresses\x18\"\x20\x03(\tR\x0fbridgeAddresses\
    \x122\n\x15bridge_option_ordinal\x18#\x20\x01(\x05R\x13bridgeOptionOrdin\
    al\x122\n\x15tor_transport_ordinal\x18$\x20\x01(\x05R\x13torTransportOrd\
    inal\x12%\n\x0ecustom_bridges\x18%\x20\x01(\tR\rcustomBridges\x12?\n\x1c\
    bitcoin_nodes_option_ordinal\x18&\x20\x01(\x05R\x19bitcoinNodesOptionOrd\
    inal\x12\x1f\n\x0breferral_id\x18'\x20\x01(\tR\nreferralId\x12-\n\x13pho\
    ne_key_and_token\x18(\x20\x01(\tR\x10phoneKeyAndToken\x12J\n\"use_sound_\
    for_mobile_notifications\x18)\x20\x01(\x08R\x1euseSoundForMobileNotifica\
    tions\x126\n\x17use_trade_notifications\x18*\x20\x01(\x08R\x15useTradeNo\
    tifications\x128\n\x18use_market_notifications\x18+\x20\x01(\x08R\x16use\
    MarketNotifications\x126\n\x17use_price_notifications\x18,\x20\x01(\x08R\
    \x15usePriceNotifications\x12(\n\x10use_standby_mode\x18-\x20\x01(\x08R\
    \x0euseStandbyMode\x12'\n\x10is_dao_full_node\x18.\x20\x01(\x08R\risDaoF\
    ullNode\x12\x19\n\x08rpc_user\x18/\x20\x01(\tR\x07rpcUser\x12\x15\n\x06r\
    pc_pw\x180\x20\x01(\tR\x05rpcPw\x12Q\n&take_offer_selected_payment_accou\
    nt_id\x181\x20\x01(\tR!takeOfferSelectedPaymentAccountId\x12H\n!buyer_se\
    curity_deposit_as_percent\x182\x20\x01(\x01R\x1dbuyerSecurityDepositAsPe\
    rcent\x122\n\x15ignore_dust_threshold\x183\x20\x01(\x05R\x13ignoreDustTh\
    reshold\x12\\\n,buyer_security_deposit_as_percent_for_crypto\x184\x20\
    \x01(\x01R&buyerSecurityDepositAsPercentForCrypto\x12*\n\x11block_notify\
    _port\x185\x20\x01(\x05R\x0fblockNotifyPort\x12\x1b\n\tcss_theme\x186\
    \x20\x01(\x05R\x08cssTheme\x12*\n\x11tac_accepted_v120\x187\x20\x01(\x08\
    R\x0ftacAcceptedV120\x1aC\n\x15DontShowAgainMapEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x08R\x05\
    value:\x028\x01\x1a=\n\x0fPeerTagMapEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\"\x9d\t\n\x0bUserPayload\x12\x1d\n\naccount_id\x18\x01\x20\x01(\tR\
    \taccountId\x12N\n\x10payment_accounts\x18\x02\x20\x03(\x0b2#.io.bisq.pr\
    otobuffer.PaymentAccountR\x0fpaymentAccounts\x12[\n\x17current_payment_a\
    ccount\x18\x03\x20\x01(\x0b2#.io.bisq.protobuffer.PaymentAccountR\x15cur\
    rentPaymentAccount\x12C\n\x1eaccepted_language_locale_codes\x18\x04\x20\
    \x03(\tR\x1bacceptedLanguageLocaleCodes\x12E\n\x10developers_alert\x18\
    \x05\x20\x01(\x0b2\x1a.io.bisq.protobuffer.AlertR\x0fdevelopersAlert\x12\
    C\n\x0fdisplayed_alert\x18\x06\x20\x01(\x0b2\x1a.io.bisq.protobuffer.Ale\
    rtR\x0edisplayedAlert\x12H\n\x11developers_filter\x18\x07\x20\x01(\x0b2\
    \x1b.io.bisq.protobuffer.FilterR\x10developersFilter\x12R\n\x14accepted_\
    arbitrators\x18\x08\x20\x03(\x0b2\x1f.io.bisq.protobuffer.ArbitratorR\
    \x13acceptedArbitrators\x12L\n\x12accepted_mediators\x18\t\x20\x03(\x0b2\
    \x1d.io.bisq.protobuffer.MediatorR\x11acceptedMediators\x12T\n\x15regist\
    ered_arbitrator\x18\n\x20\x01(\x0b2\x1f.io.bisq.protobuffer.ArbitratorR\
    \x14registeredArbitrator\x12N\n\x13registered_mediator\x18\x0b\x20\x01(\
    \x0b2\x1d.io.bisq.protobuffer.MediatorR\x12registeredMediator\x12S\n\x12\
    price_alert_filter\x18\x0c\x20\x01(\x0b2%.io.bisq.protobuffer.PriceAlert\
    FilterR\x10priceAlertFilter\x12X\n\x14market_alert_filters\x18\r\x20\x03\
    (\x0b2&.io.bisq.protobuffer.MarketAlertFilterR\x12marketAlertFilters\x12\
    V\n\x16accepted_refund_agents\x18\x0e\x20\x03(\x0b2\x20.io.bisq.protobuf\
    fer.RefundAgentR\x14acceptedRefundAgents\x12X\n\x17registered_refund_age\
    nt\x18\x0f\x20\x01(\x0b2\x20.io.bisq.protobuffer.RefundAgentR\x15registe\
    redRefundAgent\"\xf8\x01\n\tBaseBlock\x12\x16\n\x06height\x18\x01\x20\
    \x01(\x05R\x06height\x12\x12\n\x04time\x18\x02\x20\x01(\x03R\x04time\x12\
    \x12\n\x04hash\x18\x03\x20\x01(\tR\x04hash\x12.\n\x13previous_block_hash\
    \x18\x04\x20\x01(\tR\x11previousBlockHash\x12<\n\traw_block\x18\x05\x20\
    \x01(\x0b2\x1d.io.bisq.protobuffer.RawBlockH\0R\x08rawBlock\x122\n\x05bl\
    ock\x18\x06\x20\x01(\x0b2\x1a.io.bisq.protobuffer.BlockH\0R\x05blockB\t\
    \n\x07message\"@\n\x08RawBlock\x124\n\x07raw_txs\x18\x01\x20\x03(\x0b2\
    \x1b.io.bisq.protobuffer.BaseTxR\x06rawTxs\"6\n\x05Block\x12-\n\x03txs\
    \x18\x01\x20\x03(\x0b2\x1b.io.bisq.protobuffer.BaseTxR\x03txs\"\xb3\x02\
    \n\x06BaseTx\x12\x1d\n\ntx_version\x18\x01\x20\x01(\tR\ttxVersion\x12\
    \x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x12!\n\x0cblock_height\x18\x03\
    \x20\x01(\x05R\x0bblockHeight\x12\x1d\n\nblock_hash\x18\x04\x20\x01(\tR\
    \tblockHash\x12\x12\n\x04time\x18\x05\x20\x01(\x03R\x04time\x129\n\ttx_i\
    nputs\x18\x06\x20\x03(\x0b2\x1c.io.bisq.protobuffer.TxInputR\x08txInputs\
    \x123\n\x06raw_tx\x18\x07\x20\x01(\x0b2\x1a.io.bisq.protobuffer.RawTxH\0\
    R\x05rawTx\x12)\n\x02tx\x18\x08\x20\x01(\x0b2\x17.io.bisq.protobuffer.Tx\
    H\0R\x02txB\t\n\x07message\"P\n\x05RawTx\x12G\n\x0eraw_tx_outputs\x18\
    \x01\x20\x03(\x0b2!.io.bisq.protobuffer.BaseTxOutputR\x0crawTxOutputs\"\
    \x98\x01\n\x02Tx\x12@\n\ntx_outputs\x18\x01\x20\x03(\x0b2!.io.bisq.proto\
    buffer.BaseTxOutputR\ttxOutputs\x123\n\x06txType\x18\x02\x20\x01(\x0e2\
    \x1b.io.bisq.protobuffer.TxTypeR\x06txType\x12\x1b\n\tburnt_bsq\x18\x03\
    \x20\x01(\x03R\x08burntBsq\"\x97\x01\n\x07TxInput\x128\n\x19connected_tx\
    _output_tx_id\x18\x01\x20\x01(\tR\x15connectedTxOutputTxId\x129\n\x19con\
    nected_tx_output_index\x18\x02\x20\x01(\x05R\x16connectedTxOutputIndex\
    \x12\x17\n\x07pub_key\x18\x03\x20\x01(\tR\x06pubKey\"\x8c\x03\n\x0cBaseT\
    xOutput\x12\x14\n\x05index\x18\x01\x20\x01(\x05R\x05index\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\x03R\x05value\x12\x13\n\x05tx_id\x18\x03\x20\x01(\
    \tR\x04txId\x12G\n\x0epub_key_script\x18\x04\x20\x01(\x0b2!.io.bisq.prot\
    obuffer.PubKeyScriptR\x0cpubKeyScript\x12\x18\n\x07address\x18\x05\x20\
    \x01(\tR\x07address\x12$\n\x0eop_return_data\x18\x06\x20\x01(\x0cR\x0cop\
    ReturnData\x12!\n\x0cblock_height\x18\x07\x20\x01(\x05R\x0bblockHeight\
    \x12F\n\rraw_tx_output\x18\x08\x20\x01(\x0b2\x20.io.bisq.protobuffer.Raw\
    TxOutputH\0R\x0brawTxOutput\x12<\n\ttx_output\x18\t\x20\x01(\x0b2\x1d.io\
    .bisq.protobuffer.TxOutputH\0R\x08txOutputB\t\n\x07message\"V\n\x13Uncon\
    firmedTxOutput\x12\x14\n\x05index\x18\x01\x20\x01(\x05R\x05index\x12\x14\
    \n\x05value\x18\x02\x20\x01(\x03R\x05value\x12\x13\n\x05tx_id\x18\x03\
    \x20\x01(\tR\x04txId\"\r\n\x0bRawTxOutput\"\xa0\x01\n\x08TxOutput\x12G\n\
    \x0etx_output_type\x18\x01\x20\x01(\x0e2!.io.bisq.protobuffer.TxOutputTy\
    peR\x0ctxOutputType\x12\x1b\n\tlock_time\x18\x02\x20\x01(\x05R\x08lockTi\
    me\x12.\n\x13unlock_block_height\x18\x03\x20\x01(\x05R\x11unlockBlockHei\
    ght\"d\n\tSpentInfo\x12!\n\x0cblock_height\x18\x01\x20\x01(\x03R\x0bbloc\
    kHeight\x12\x13\n\x05tx_id\x18\x02\x20\x01(\tR\x04txId\x12\x1f\n\x0binpu\
    t_index\x18\x03\x20\x01(\x05R\ninputIndex\"\xad\x01\n\x0cPubKeyScript\
    \x12\x19\n\x08req_sigs\x18\x01\x20\x01(\x05R\x07reqSigs\x12@\n\x0bscript\
    _type\x18\x02\x20\x01(\x0e2\x1f.io.bisq.protobuffer.ScriptTypeR\nscriptT\
    ype\x12\x1c\n\taddresses\x18\x03\x20\x03(\tR\taddresses\x12\x10\n\x03asm\
    \x18\x04\x20\x01(\tR\x03asm\x12\x10\n\x03hex\x18\x05\x20\x01(\tR\x03hex\
    \"K\n\x08DaoPhase\x12#\n\rphase_ordinal\x18\x01\x20\x01(\x05R\x0cphaseOr\
    dinal\x12\x1a\n\x08duration\x18\x02\x20\x01(\x05R\x08duration\"t\n\x05Cy\
    cle\x12/\n\x14height_of_first_lock\x18\x01\x20\x01(\x05R\x11heightOfFirs\
    tLock\x12:\n\tdao_phase\x18\x02\x20\x03(\x0b2\x1d.io.bisq.protobuffer.Da\
    oPhaseR\x08daoPhase\"\xbf\x08\n\x08DaoState\x12!\n\x0cchain_height\x18\
    \x01\x20\x01(\x05R\x0bchainHeight\x126\n\x06blocks\x18\x02\x20\x03(\x0b2\
    \x1e.io.bisq.protobuffer.BaseBlockR\x06blocks\x122\n\x06cycles\x18\x03\
    \x20\x03(\x0b2\x1a.io.bisq.protobuffer.CycleR\x06cycles\x12h\n\x15unspen\
    t_tx_output_map\x18\x04\x20\x03(\x0b25.io.bisq.protobuffer.DaoState.Unsp\
    entTxOutputMapEntryR\x12unspentTxOutputMap\x12Q\n\x0cissuance_map\x18\
    \x05\x20\x03(\x0b2..io.bisq.protobuffer.DaoState.IssuanceMapEntryR\x0bis\
    suanceMap\x12;\n\x1aconfiscated_lockup_tx_list\x18\x06\x20\x03(\tR\x17co\
    nfiscatedLockupTxList\x12U\n\x0espent_info_map\x18\x07\x20\x03(\x0b2/.io\
    .bisq.protobuffer.DaoState.SpentInfoMapEntryR\x0cspentInfoMap\x12L\n\x11\
    param_change_list\x18\x08\x20\x03(\x0b2\x20.io.bisq.protobuffer.ParamCha\
    ngeR\x0fparamChangeList\x12^\n\x17evaluated_proposal_list\x18\t\x20\x03(\
    \x0b2&.io.bisq.protobuffer.EvaluatedProposalR\x15evaluatedProposalList\
    \x12{\n\"decrypted_ballots_with_merits_list\x18\n\x20\x03(\x0b2/.io.bisq\
    .protobuffer.DecryptedBallotsWithMeritsR\x1edecryptedBallotsWithMeritsLi\
    st\x1ah\n\x17UnspentTxOutputMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\t\
    R\x03key\x127\n\x05value\x18\x02\x20\x01(\x0b2!.io.bisq.protobuffer.Base\
    TxOutputR\x05value:\x028\x01\x1a]\n\x10IssuanceMapEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x123\n\x05value\x18\x02\x20\x01(\x0b2\x1d.io\
    .bisq.protobuffer.IssuanceR\x05value:\x028\x01\x1a_\n\x11SpentInfoMapEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x124\n\x05value\x18\x02\
    \x20\x01(\x0b2\x1e.io.bisq.protobuffer.SpentInfoR\x05value:\x028\x01\"\
    \x98\x01\n\x08Issuance\x12\x13\n\x05tx_id\x18\x01\x20\x01(\tR\x04txId\
    \x12!\n\x0cchain_height\x18\x02\x20\x01(\x05R\x0bchainHeight\x12\x16\n\
    \x06amount\x18\x03\x20\x01(\x03R\x06amount\x12\x17\n\x07pub_key\x18\x04\
    \x20\x01(\tR\x06pubKey\x12#\n\rissuance_type\x18\x05\x20\x01(\tR\x0cissu\
    anceType\"\xa9\x07\n\x08Proposal\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12\x12\n\x04link\x18\x02\x20\x01(\tR\x04link\x12\x18\n\x07vers\
    ion\x18\x03\x20\x01(\rR\x07version\x12#\n\rcreation_date\x18\x04\x20\x01\
    (\x03R\x0ccreationDate\x12\x13\n\x05tx_id\x18\x05\x20\x01(\tR\x04txId\
    \x12`\n\x15compensation_proposal\x18\x06\x20\x01(\x0b2).io.bisq.protobuf\
    fer.CompensationProposalH\0R\x14compensationProposal\x12c\n\x16reimburse\
    ment_proposal\x18\x07\x20\x01(\x0b2*.io.bisq.protobuffer.ReimbursementPr\
    oposalH\0R\x15reimbursementProposal\x12^\n\x15change_param_proposal\x18\
    \x08\x20\x01(\x0b2(.io.bisq.protobuffer.ChangeParamProposalH\0R\x13chang\
    eParamProposal\x12H\n\rrole_proposal\x18\t\x20\x01(\x0b2!.io.bisq.protob\
    uffer.RoleProposalH\0R\x0croleProposal\x12g\n\x18confiscate_bond_proposa\
    l\x18\n\x20\x01(\x0b2+.io.bisq.protobuffer.ConfiscateBondProposalH\0R\
    \x16confiscateBondProposal\x12Q\n\x10generic_proposal\x18\x0b\x20\x01(\
    \x0b2$.io.bisq.protobuffer.GenericProposalH\0R\x0fgenericProposal\x12^\n\
    \x15remove_asset_proposal\x18\x0c\x20\x01(\x0b2(.io.bisq.protobuffer.Rem\
    oveAssetProposalH\0R\x13removeAssetProposal\x12K\n\nextra_data\x18\x14\
    \x20\x03(\x0b2,.io.bisq.protobuffer.Proposal.ExtraDataEntryR\textraData\
    \x1a<\n\x0eExtraDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\t\n\x07messa\
    ge\"\\\n\x14CompensationProposal\x12#\n\rrequested_bsq\x18\x01\x20\x01(\
    \x03R\x0crequestedBsq\x12\x1f\n\x0bbsq_address\x18\x02\x20\x01(\tR\nbsqA\
    ddress\"]\n\x15ReimbursementProposal\x12#\n\rrequested_bsq\x18\x01\x20\
    \x01(\x03R\x0crequestedBsq\x12\x1f\n\x0bbsq_address\x18\x02\x20\x01(\tR\
    \nbsqAddress\"L\n\x13ChangeParamProposal\x12\x14\n\x05param\x18\x01\x20\
    \x01(\tR\x05param\x12\x1f\n\x0bparam_value\x18\x02\x20\x01(\tR\nparamVal\
    ue\"\x8c\x01\n\x0cRoleProposal\x12-\n\x04role\x18\x01\x20\x01(\x0b2\x19.\
    io.bisq.protobuffer.RoleR\x04role\x12,\n\x12required_bond_unit\x18\x02\
    \x20\x01(\x03R\x10requiredBondUnit\x12\x1f\n\x0bunlock_time\x18\x03\x20\
    \x01(\x05R\nunlockTime\":\n\x16ConfiscateBondProposal\x12\x20\n\x0clocku\
    p_tx_id\x18\x01\x20\x01(\tR\nlockupTxId\"\x11\n\x0fGenericProposal\":\n\
    \x13RemoveAssetProposal\x12#\n\rticker_symbol\x18\x01\x20\x01(\tR\x0ctic\
    kerSymbol\"j\n\x04Role\x12\x10\n\x03uid\x18\x01\x20\x01(\tR\x03uid\x12\
    \x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04link\x18\x03\x20\
    \x01(\tR\x04link\x12(\n\x10bonded_role_type\x18\x04\x20\x01(\tR\x0ebonde\
    dRoleType\"4\n\x0cMyReputation\x12\x10\n\x03uid\x18\x01\x20\x01(\tR\x03u\
    id\x12\x12\n\x04salt\x18\x02\x20\x01(\x0cR\x04salt\"Z\n\x10MyReputationL\
    ist\x12F\n\rmy_reputation\x18\x01\x20\x03(\x0b2!.io.bisq.protobuffer.MyR\
    eputationR\x0cmyReputation\"A\n\rMyProofOfBurn\x12\x13\n\x05tx_id\x18\
    \x01\x20\x01(\tR\x04txId\x12\x1b\n\tpre_image\x18\x02\x20\x01(\tR\x08pre\
    Image\"`\n\x11MyProofOfBurnList\x12K\n\x10my_proof_of_burn\x18\x01\x20\
    \x03(\x0b2\".io.bisq.protobuffer.MyProofOfBurnR\rmyProofOfBurn\"~\n\x1eU\
    nconfirmedBsqChangeOutputList\x12\\\n\x15unconfirmed_tx_output\x18\x01\
    \x20\x03(\x0b2(.io.bisq.protobuffer.UnconfirmedTxOutputR\x13unconfirmedT\
    xOutput\"\x99\x02\n\x13TempProposalPayload\x129\n\x08proposal\x18\x01\
    \x20\x01(\x0b2\x1d.io.bisq.protobuffer.ProposalR\x08proposal\x121\n\x15o\
    wner_pub_key_encoded\x18\x02\x20\x01(\x0cR\x12ownerPubKeyEncoded\x12V\n\
    \nextra_data\x18\x03\x20\x03(\x0b27.io.bisq.protobuffer.TempProposalPayl\
    oad.ExtraDataEntryR\textraData\x1a<\n\x0eExtraDataEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"`\n\x0fProposalPayload\x129\n\x08proposal\x18\x01\x20\x01\
    (\x0b2\x1d.io.bisq.protobuffer.ProposalR\x08proposal\x12\x12\n\x04hash\
    \x18\x02\x20\x01(\x0cR\x04hash\"K\n\rProposalStore\x12:\n\x05items\x18\
    \x01\x20\x03(\x0b2$.io.bisq.protobuffer.ProposalPayloadR\x05items\"U\n\
    \x11TempProposalStore\x12@\n\x05items\x18\x01\x20\x03(\x0b2*.io.bisq.pro\
    tobuffer.ProtectedStorageEntryR\x05items\"r\n\x06Ballot\x129\n\x08propos\
    al\x18\x01\x20\x01(\x0b2\x1d.io.bisq.protobuffer.ProposalR\x08proposal\
    \x12-\n\x04vote\x18\x02\x20\x01(\x0b2\x19.io.bisq.protobuffer.VoteR\x04v\
    ote\"K\n\x0eMyProposalList\x129\n\x08proposal\x18\x01\x20\x03(\x0b2\x1d.\
    io.bisq.protobuffer.ProposalR\x08proposal\"A\n\nBallotList\x123\n\x06bal\
    lot\x18\x01\x20\x03(\x0b2\x1b.io.bisq.protobuffer.BallotR\x06ballot\"z\n\
    \x0bParamChange\x12\x1d\n\nparam_name\x18\x01\x20\x01(\tR\tparamName\x12\
    \x1f\n\x0bparam_value\x18\x02\x20\x01(\tR\nparamValue\x12+\n\x11activati\
    on_height\x18\x03\x20\x01(\x05R\x10activationHeight\"2\n\x0eConfiscateBo\
    nd\x12\x20\n\x0clockup_tx_id\x18\x01\x20\x01(\tR\nlockupTxId\"\x85\x02\n\
    \x06MyVote\x12\x16\n\x06height\x18\x01\x20\x01(\x05R\x06height\x12@\n\
    \x0bballot_list\x18\x02\x20\x01(\x0b2\x1f.io.bisq.protobuffer.BallotList\
    R\nballotList\x12,\n\x12secret_key_encoded\x18\x03\x20\x01(\x0cR\x10secr\
    etKeyEncoded\x12=\n\nblind_vote\x18\x04\x20\x01(\x0b2\x1e.io.bisq.protob\
    uffer.BlindVoteR\tblindVote\x12\x12\n\x04date\x18\x05\x20\x01(\x03R\x04d\
    ate\x12\x20\n\x0creveal_tx_id\x18\x06\x20\x01(\tR\nrevealTxId\"B\n\nMyVo\
    teList\x124\n\x07my_vote\x18\x01\x20\x03(\x0b2\x1b.io.bisq.protobuffer.M\
    yVoteR\x06myVote\"k\n\x14VoteWithProposalTxId\x12$\n\x0eproposal_tx_id\
    \x18\x01\x20\x01(\tR\x0cproposalTxId\x12-\n\x04vote\x18\x02\x20\x01(\x0b\
    2\x19.io.bisq.protobuffer.VoteR\x04vote\"Y\n\x18VoteWithProposalTxIdList\
    \x12=\n\x04item\x18\x01\x20\x03(\x0b2).io.bisq.protobuffer.VoteWithPropo\
    salTxIdR\x04item\"\xb1\x02\n\tBlindVote\x12'\n\x0fencrypted_votes\x18\
    \x01\x20\x01(\x0cR\x0eencryptedVotes\x12\x13\n\x05tx_id\x18\x02\x20\x01(\
    \tR\x04txId\x12\x14\n\x05stake\x18\x03\x20\x01(\x03R\x05stake\x120\n\x14\
    encrypted_merit_list\x18\x04\x20\x01(\x0cR\x12encryptedMeritList\x12\x12\
    \n\x04date\x18\x05\x20\x01(\x03R\x04date\x12L\n\nextra_data\x18\x06\x20\
    \x03(\x0b2-.io.bisq.protobuffer.BlindVote.ExtraDataEntryR\textraData\x1a\
    <\n\x0eExtraDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"P\n\x0fMyBlindVo\
    teList\x12=\n\nblind_vote\x18\x01\x20\x03(\x0b2\x1e.io.bisq.protobuffer.\
    BlindVoteR\tblindVote\"M\n\x0eBlindVoteStore\x12;\n\x05items\x18\x01\x20\
    \x03(\x0b2%.io.bisq.protobuffer.BlindVotePayloadR\x05items\"e\n\x10Blind\
    VotePayload\x12=\n\nblind_vote\x18\x01\x20\x01(\x0b2\x1e.io.bisq.protobu\
    ffer.BlindVoteR\tblindVote\x12\x12\n\x04hash\x18\x02\x20\x01(\x0cR\x04ha\
    sh\"\"\n\x04Vote\x12\x1a\n\x08accepted\x18\x01\x20\x01(\x08R\x08accepted\
    \"`\n\x05Merit\x129\n\x08issuance\x18\x01\x20\x01(\x0b2\x1d.io.bisq.prot\
    obuffer.IssuanceR\x08issuance\x12\x1c\n\tsignature\x18\x02\x20\x01(\x0cR\
    \tsignature\"=\n\tMeritList\x120\n\x05merit\x18\x01\x20\x03(\x0b2\x1a.io\
    .bisq.protobuffer.MeritR\x05merit\"\xc5\x02\n\x12ProposalVoteResult\x129\
    \n\x08proposal\x18\x01\x20\x01(\x0b2\x1d.io.bisq.protobuffer.ProposalR\
    \x08proposal\x125\n\x17stake_of_Accepted_votes\x18\x02\x20\x01(\x03R\x14\
    stakeOfAcceptedVotes\x125\n\x17stake_of_Rejected_votes\x18\x03\x20\x01(\
    \x03R\x14stakeOfRejectedVotes\x12,\n\x12num_accepted_votes\x18\x04\x20\
    \x01(\x05R\x10numAcceptedVotes\x12,\n\x12num_rejected_votes\x18\x05\x20\
    \x01(\x05R\x10numRejectedVotes\x12*\n\x11num_ignored_votes\x18\x06\x20\
    \x01(\x05R\x0fnumIgnoredVotes\"\x8f\x01\n\x11EvaluatedProposal\x12\x1f\n\
    \x0bis_accepted\x18\x01\x20\x01(\x08R\nisAccepted\x12Y\n\x14proposal_vot\
    e_result\x18\x02\x20\x01(\x0b2'.io.bisq.protobuffer.ProposalVoteResultR\
    \x12proposalVoteResult\"\xbd\x02\n\x1aDecryptedBallotsWithMerits\x124\n\
    \x17hash_of_blind_vote_list\x18\x01\x20\x01(\x0cR\x13hashOfBlindVoteList\
    \x12'\n\x10blind_vote_tx_id\x18\x02\x20\x01(\tR\rblindVoteTxId\x12)\n\
    \x11vote_reveal_tx_id\x18\x03\x20\x01(\tR\x0evoteRevealTxId\x12\x14\n\
    \x05stake\x18\x04\x20\x01(\x03R\x05stake\x12@\n\x0bballot_list\x18\x05\
    \x20\x01(\x0b2\x1f.io.bisq.protobuffer.BallotListR\nballotList\x12=\n\nm\
    erit_list\x18\x06\x20\x01(\x0b2\x1e.io.bisq.protobuffer.MeritListR\tmeri\
    tList\"\x94\x01\n\rDaoStateStore\x12:\n\tdao_state\x18\x01\x20\x01(\x0b2\
    \x1d.io.bisq.protobuffer.DaoStateR\x08daoState\x12G\n\x0edao_state_hash\
    \x18\x02\x20\x03(\x0b2!.io.bisq.protobuffer.DaoStateHashR\x0cdaoStateHas\
    h\"W\n\x0cDaoStateHash\x12\x16\n\x06height\x18\x01\x20\x01(\x05R\x06heig\
    ht\x12\x12\n\x04hash\x18\x02\x20\x01(\x0cR\x04hash\x12\x1b\n\tprev_hash\
    \x18\x03\x20\x01(\x0cR\x08prevHash\"\x81\x01\n\x11ProposalStateHash\x12\
    \x16\n\x06height\x18\x01\x20\x01(\x05R\x06height\x12\x12\n\x04hash\x18\
    \x02\x20\x01(\x0cR\x04hash\x12\x1b\n\tprev_hash\x18\x03\x20\x01(\x0cR\
    \x08prevHash\x12#\n\rnum_proposals\x18\x04\x20\x01(\x05R\x0cnumProposals\
    \"\x85\x01\n\x12BlindVoteStateHash\x12\x16\n\x06height\x18\x01\x20\x01(\
    \x05R\x06height\x12\x12\n\x04hash\x18\x02\x20\x01(\x0cR\x04hash\x12\x1b\
    \n\tprev_hash\x18\x03\x20\x01(\x0cR\x08prevHash\x12&\n\x0fnum_blind_vote\
    s\x18\x04\x20\x01(\x05R\rnumBlindVotes\"`\n\x12BlockChainExplorer\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x15\n\x06tx_url\x18\x02\
    \x20\x01(\tR\x05txUrl\x12\x1f\n\x0baddress_url\x18\x03\x20\x01(\tR\naddr\
    essUrl\"\xc2\x03\n\x0ePaymentAccount\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\x12#\n\rcreation_date\x18\x02\x20\x01(\x03R\x0ccreationDate\x12I\
    \n\x0epayment_method\x18\x03\x20\x01(\x0b2\".io.bisq.protobuffer.Payment\
    MethodR\rpaymentMethod\x12!\n\x0caccount_name\x18\x04\x20\x01(\tR\x0bacc\
    ountName\x12M\n\x10trade_currencies\x18\x05\x20\x03(\x0b2\".io.bisq.prot\
    obuffer.TradeCurrencyR\x0ftradeCurrencies\x12Z\n\x17selected_trade_curre\
    ncy\x18\x06\x20\x01(\x0b2\".io.bisq.protobuffer.TradeCurrencyR\x15select\
    edTradeCurrency\x12b\n\x17payment_account_payload\x18\x07\x20\x01(\x0b2*\
    .io.bisq.protobuffer.PaymentAccountPayloadR\x15paymentAccountPayload\"q\
    \n\rPaymentMethod\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12(\n\x10ma\
    x_trade_period\x18\x02\x20\x01(\x03R\x0emaxTradePeriod\x12&\n\x0fmax_tra\
    de_limit\x18\x03\x20\x01(\x03R\rmaxTradeLimit\"/\n\x08Currency\x12#\n\rc\
    urrency_code\x18\x01\x20\x01(\tR\x0ccurrencyCode\"\xdc\x01\n\rTradeCurre\
    ncy\x12\x12\n\x04code\x18\x01\x20\x01(\tR\x04code\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\x12N\n\x0fcrypto_currency\x18\x03\x20\x01(\x0b2\
    #.io.bisq.protobuffer.CryptoCurrencyH\0R\x0ecryptoCurrency\x12H\n\rfiat_\
    currency\x18\x04\x20\x01(\x0b2!.io.bisq.protobuffer.FiatCurrencyH\0R\x0c\
    fiatCurrencyB\t\n\x07message\"+\n\x0eCryptoCurrency\x12\x19\n\x08is_asse\
    t\x18\x01\x20\x01(\x08R\x07isAsset\"I\n\x0cFiatCurrency\x129\n\x08curren\
    cy\x18\x01\x20\x01(\x0b2\x1d.io.bisq.protobuffer.CurrencyR\x08currency\"\
    f\n\x07Country\x12\x12\n\x04code\x18\x01\x20\x01(\tR\x04code\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x123\n\x06region\x18\x03\x20\x01(\
    \x0b2\x1b.io.bisq.protobuffer.RegionR\x06region\"0\n\x06Region\x12\x12\n\
    \x04code\x18\x01\x20\x01(\tR\x04code\x12\x12\n\x04name\x18\x02\x20\x01(\
    \tR\x04name\"\\\n\x10PriceAlertFilter\x12\"\n\x0ccurrencyCode\x18\x01\
    \x20\x01(\tR\x0ccurrencyCode\x12\x12\n\x04high\x18\x02\x20\x01(\x03R\x04\
    high\x12\x10\n\x03low\x18\x03\x20\x01(\x03R\x03low\"\xc5\x01\n\x11Market\
    AlertFilter\x12L\n\x0fpayment_account\x18\x01\x20\x01(\x0b2#.io.bisq.pro\
    tobuffer.PaymentAccountR\x0epaymentAccount\x12#\n\rtrigger_value\x18\x02\
    \x20\x01(\x05R\x0ctriggerValue\x12\x20\n\x0cis_buy_offer\x18\x03\x20\x01\
    (\x08R\nisBuyOffer\x12\x1b\n\talert_ids\x18\x04\x20\x03(\tR\x08alertIds\
    \"\x92\x01\n\x12MockMailboxPayload\x12\x18\n\x07message\x18\x01\x20\x01(\
    \tR\x07message\x12P\n\x13sender_node_address\x18\x02\x20\x01(\x0b2\x20.i\
    o.bisq.protobuffer.NodeAddressR\x11senderNodeAddress\x12\x10\n\x03uid\
    \x18\x03\x20\x01(\tR\x03uid\"P\n\x0bMockPayload\x12'\n\x0fmessage_versio\
    n\x18\x01\x20\x01(\tR\x0emessageVersion\x12\x18\n\x07message\x18\x02\x20\
    \x01(\tR\x07message*D\n\x0bSupportType\x12\x0f\n\x0bARBITRATION\x10\0\
    \x12\r\n\tMEDIATION\x10\x01\x12\t\n\x05TRADE\x10\x02\x12\n\n\x06REFUND\
    \x10\x03*\x83\x02\n\x12AvailabilityResult\x12\x0c\n\x08PB_ERROR\x10\0\
    \x12\x13\n\x0fUNKNOWN_FAILURE\x10\x01\x12\r\n\tAVAILABLE\x10\x02\x12\x0f\
    \n\x0bOFFER_TAKEN\x10\x03\x12\x1a\n\x16PRICE_OUT_OF_TOLERANCE\x10\x04\
    \x12\x1e\n\x1aMARKET_PRICE_NOT_AVAILABLE\x10\x05\x12\x12\n\x0eNO_ARBITRA\
    TORS\x10\x06\x12\x10\n\x0cNO_MEDIATORS\x10\x07\x12\x10\n\x0cUSER_IGNORED\
    \x10\x08\x12\x20\n\x1cMISSING_MANDATORY_CAPABILITY\x10\t\x12\x14\n\x10NO\
    _REFUND_AGENTS\x10\n*\xf7\x03\n\x14MediationResultState\x12\x1d\n\x19PB_\
    ERROR_MEDIATION_RESULT\x10\0\x12\x1e\n\x1aUNDEFINED_MEDIATION_RESULT\x10\
    \x01\x12\x1d\n\x19MEDIATION_RESULT_ACCEPTED\x10\x02\x12\x1d\n\x19MEDIATI\
    ON_RESULT_REJECTED\x10\x03\x12\x10\n\x0cSIG_MSG_SENT\x10\x04\x12\x13\n\
    \x0fSIG_MSG_ARRIVED\x10\x05\x12\x16\n\x12SIG_MSG_IN_MAILBOX\x10\x06\x12\
    \x17\n\x13SIG_MSG_SEND_FAILED\x10\x07\x12\x14\n\x10RECEIVED_SIG_MSG\x10\
    \x08\x12\x17\n\x13PAYOUT_TX_PUBLISHED\x10\t\x12\x20\n\x1cPAYOUT_TX_PUBLI\
    SHED_MSG_SENT\x10\n\x12#\n\x1fPAYOUT_TX_PUBLISHED_MSG_ARRIVED\x10\x0b\
    \x12&\n\"PAYOUT_TX_PUBLISHED_MSG_IN_MAILBOX\x10\x0c\x12'\n#PAYOUT_TX_PUB\
    LISHED_MSG_SEND_FAILED\x10\r\x12$\n\x20RECEIVED_PAYOUT_TX_PUBLISHED_MSG\
    \x10\x0e\x12\x1d\n\x19PAYOUT_TX_SEEN_IN_NETWORK\x10\x0f*L\n\x11RefundRes\
    ultState\x12\x1a\n\x16PB_ERROR_REFUND_RESULT\x10\0\x12\x1b\n\x17UNDEFINE\
    D_REFUND_RESULT\x10\x01*\xb9\x02\n\x06TxType\x12\x14\n\x10PB_ERROR_TX_TY\
    PE\x10\0\x12\x15\n\x11UNDEFINED_TX_TYPE\x10\x01\x12\x0e\n\nUNVERIFIED\
    \x10\x02\x12\x0b\n\x07INVALID\x10\x03\x12\x0b\n\x07GENESIS\x10\x04\x12\
    \x10\n\x0cTRANSFER_BSQ\x10\x05\x12\x11\n\rPAY_TRADE_FEE\x10\x06\x12\x0c\
    \n\x08PROPOSAL\x10\x07\x12\x18\n\x14COMPENSATION_REQUEST\x10\x08\x12\x19\
    \n\x15REIMBURSEMENT_REQUEST\x10\t\x12\x0e\n\nBLIND_VOTE\x10\n\x12\x0f\n\
    \x0bVOTE_REVEAL\x10\x0b\x12\n\n\x06LOCKUP\x10\x0c\x12\n\n\x06UNLOCK\x10\
    \r\x12\x15\n\x11ASSET_LISTING_FEE\x10\x0e\x12\x11\n\rPROOF_OF_BURN\x10\
    \x0f\x12\r\n\tIRREGULAR\x10\x10*\xc9\x04\n\x0cTxOutputType\x12\x1b\n\x17\
    PB_ERROR_TX_OUTPUT_TYPE\x10\0\x12\x14\n\x10UNDEFINED_OUTPUT\x10\x01\x12\
    \x12\n\x0eGENESIS_OUTPUT\x10\x02\x12\x0e\n\nBSQ_OUTPUT\x10\x03\x12\x0e\n\
    \nBTC_OUTPUT\x10\x04\x12\x1d\n\x19PROPOSAL_OP_RETURN_OUTPUT\x10\x05\x12\
    \x1d\n\x19COMP_REQ_OP_RETURN_OUTPUT\x10\x06\x12\"\n\x1eREIMBURSEMENT_OP_\
    RETURN_OUTPUT\x10\x07\x12$\n\x20CONFISCATE_BOND_OP_RETURN_OUTPUT\x10\x08\
    \x12\x1d\n\x19ISSUANCE_CANDIDATE_OUTPUT\x10\t\x12\x20\n\x1cBLIND_VOTE_LO\
    CK_STAKE_OUTPUT\x10\n\x12\x1f\n\x1bBLIND_VOTE_OP_RETURN_OUTPUT\x10\x0b\
    \x12#\n\x1fVOTE_REVEAL_UNLOCK_STAKE_OUTPUT\x10\x0c\x12\x20\n\x1cVOTE_REV\
    EAL_OP_RETURN_OUTPUT\x10\r\x12&\n\"ASSET_LISTING_FEE_OP_RETURN_OUTPUT\
    \x10\x0e\x12\"\n\x1ePROOF_OF_BURN_OP_RETURN_OUTPUT\x10\x0f\x12\x11\n\rLO\
    CKUP_OUTPUT\x10\x10\x12\x1b\n\x17LOCKUP_OP_RETURN_OUTPUT\x10\x11\x12\x11\
    \n\rUNLOCK_OUTPUT\x10\x12\x12\x12\n\x0eINVALID_OUTPUT\x10\x13*\xb8\x01\n\
    \nScriptType\x12\x19\n\x15PB_ERROR_SCRIPT_TYPES\x10\0\x12\x0b\n\x07PUB_K\
    EY\x10\x01\x12\x10\n\x0cPUB_KEY_HASH\x10\x02\x12\x0f\n\x0bSCRIPT_HASH\
    \x10\x03\x12\x0c\n\x08MULTISIG\x10\x04\x12\r\n\tNULL_DATA\x10\x05\x12\
    \x16\n\x12WITNESS_V0_KEYHASH\x10\x06\x12\x19\n\x15WITNESS_V0_SCRIPTHASH\
    \x10\x07\x12\x0f\n\x0bNONSTANDARD\x10\x08J\xde\x99\x05\n\x07\x12\x05\0\0\
    \x99\x10\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\
    \0\x1c\n\x8a\x03\n\x02\x04\0\x12\x04\x0f\0N\x01\x1a#\x20Those\x20are\x20\
    messages\x20sent\x20over\x20wire\n2I\n\x20Protobuffer\x20v3\x20definitio\
    ns\x20of\x20network\x20messages\x20and\x20persisted\x20objects.\n\n2\x8d\
    \x02\x20option\x20java_package\x20=\x20\"protobuf\";\n\x20option\x20java\
    _multiple_files\x20=\x20true;\n/////////////////////////////////////////\
    ////////////////////////////////////////////////\n\x20Network\x20message\
    s\n/////////////////////////////////////////////////////////////////////\
    ////////////////////\n\n\n\n\x03\x04\0\x01\x12\x03\x0f\x08\x17\n\x0b\n\
    \x04\x04\0\x02\0\x12\x03\x10\x04\x1e\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\
    \x10\x04\t\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x10\n\x19\n\x0c\n\x05\x04\
    \0\x02\0\x03\x12\x03\x10\x1c\x1d\n\x0c\n\x04\x04\0\x08\0\x12\x04\x11\x04\
    M\x05\n\x0c\n\x05\x04\0\x08\0\x01\x12\x03\x11\n\x11\n\x0b\n\x04\x04\0\
    \x02\x01\x12\x03\x12\x08C\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x12\x08!\
    \n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x12\">\n\x0c\n\x05\x04\0\x02\x01\
    \x03\x12\x03\x12AB\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x13\x08.\n\x0c\n\
    \x05\x04\0\x02\x02\x06\x12\x03\x13\x08\x17\n\x0c\n\x05\x04\0\x02\x02\x01\
    \x12\x03\x13\x18)\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x13,-\n\x0b\n\
    \x04\x04\0\x02\x03\x12\x03\x14\x08;\n\x0c\n\x05\x04\0\x02\x03\x06\x12\
    \x03\x14\x08\x1d\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x14\x1e6\n\x0c\n\
    \x05\x04\0\x02\x03\x03\x12\x03\x149:\n\x0b\n\x04\x04\0\x02\x04\x12\x03\
    \x16\x08.\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03\x16\x08\x17\n\x0c\n\x05\
    \x04\0\x02\x04\x01\x12\x03\x16\x18)\n\x0c\n\x05\x04\0\x02\x04\x03\x12\
    \x03\x16,-\n\x0b\n\x04\x04\0\x02\x05\x12\x03\x17\x080\n\x0c\n\x05\x04\0\
    \x02\x05\x06\x12\x03\x17\x08\x18\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\
    \x17\x19+\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x17./\n\x0b\n\x04\x04\0\
    \x02\x06\x12\x03\x18\x08\x16\n\x0c\n\x05\x04\0\x02\x06\x06\x12\x03\x18\
    \x08\x0c\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03\x18\r\x11\n\x0c\n\x05\x04\
    \0\x02\x06\x03\x12\x03\x18\x14\x15\n\x0b\n\x04\x04\0\x02\x07\x12\x03\x19\
    \x08\x16\n\x0c\n\x05\x04\0\x02\x07\x06\x12\x03\x19\x08\x0c\n\x0c\n\x05\
    \x04\0\x02\x07\x01\x12\x03\x19\r\x11\n\x0c\n\x05\x04\0\x02\x07\x03\x12\
    \x03\x19\x14\x15\n\x0b\n\x04\x04\0\x02\x08\x12\x03\x1b\x08@\n\x0c\n\x05\
    \x04\0\x02\x08\x06\x12\x03\x1b\x08\x20\n\x0c\n\x05\x04\0\x02\x08\x01\x12\
    \x03\x1b!;\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03\x1b>?\n\x0b\n\x04\x04\0\
    \x02\t\x12\x03\x1c\x08C\n\x0c\n\x05\x04\0\x02\t\x06\x12\x03\x1c\x08!\n\
    \x0c\n\x05\x04\0\x02\t\x01\x12\x03\x1c\"=\n\x0c\n\x05\x04\0\x02\t\x03\
    \x12\x03\x1c@B\n\x0b\n\x04\x04\0\x02\n\x12\x03\x1d\x087\n\x0c\n\x05\x04\
    \0\x02\n\x06\x12\x03\x1d\x08\x1b\n\x0c\n\x05\x04\0\x02\n\x01\x12\x03\x1d\
    \x1c1\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03\x1d46\n\x0b\n\x04\x04\0\x02\
    \x0b\x12\x03\x1f\x08-\n\x0c\n\x05\x04\0\x02\x0b\x06\x12\x03\x1f\x08\x16\
    \n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x03\x1f\x17'\n\x0c\n\x05\x04\0\x02\
    \x0b\x03\x12\x03\x1f*,\n\x0b\n\x04\x04\0\x02\x0c\x12\x03\x20\x083\n\x0c\
    \n\x05\x04\0\x02\x0c\x06\x12\x03\x20\x08\x19\n\x0c\n\x05\x04\0\x02\x0c\
    \x01\x12\x03\x20\x1a-\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x03\x2002\n\x0b\
    \n\x04\x04\0\x02\r\x12\x03!\x08B\n\x0c\n\x05\x04\0\x02\r\x06\x12\x03!\
    \x08\x20\n\x0c\n\x05\x04\0\x02\r\x01\x12\x03!!<\n\x0c\n\x05\x04\0\x02\r\
    \x03\x12\x03!?A\n\x0b\n\x04\x04\0\x02\x0e\x12\x03#\x08=\n\x0c\n\x05\x04\
    \0\x02\x0e\x06\x12\x03#\x08\x1e\n\x0c\n\x05\x04\0\x02\x0e\x01\x12\x03#\
    \x1f7\n\x0c\n\x05\x04\0\x02\x0e\x03\x12\x03#:<\n\x0b\n\x04\x04\0\x02\x0f\
    \x12\x03$\x08O\n\x0c\n\x05\x04\0\x02\x0f\x06\x12\x03$\x08&\n\x0c\n\x05\
    \x04\0\x02\x0f\x01\x12\x03$'I\n\x0c\n\x05\x04\0\x02\x0f\x03\x12\x03$LN\n\
    \x0b\n\x04\x04\0\x02\x10\x12\x03&\x08E\n\x0c\n\x05\x04\0\x02\x10\x06\x12\
    \x03&\x08!\n\x0c\n\x05\x04\0\x02\x10\x01\x12\x03&\"?\n\x0c\n\x05\x04\0\
    \x02\x10\x03\x12\x03&BD\n\x0b\n\x04\x04\0\x02\x11\x12\x03'\x08G\n\x0c\n\
    \x05\x04\0\x02\x11\x06\x12\x03'\x08\"\n\x0c\n\x05\x04\0\x02\x11\x01\x12\
    \x03'#A\n\x0c\n\x05\x04\0\x02\x11\x03\x12\x03'DF\n\x0b\n\x04\x04\0\x02\
    \x12\x12\x03(\x081\n\x0c\n\x05\x04\0\x02\x12\x06\x12\x03(\x08\x18\n\x0c\
    \n\x05\x04\0\x02\x12\x01\x12\x03(\x19+\n\x0c\n\x05\x04\0\x02\x12\x03\x12\
    \x03(.0\n\x0b\n\x04\x04\0\x02\x13\x12\x03)\x08]\n\x0c\n\x05\x04\0\x02\
    \x13\x06\x12\x03)\x08-\n\x0c\n\x05\x04\0\x02\x13\x01\x12\x03).W\n\x0c\n\
    \x05\x04\0\x02\x13\x03\x12\x03)Z\\\n\x0b\n\x04\x04\0\x02\x14\x12\x03*\
    \x08B\n\x0c\n\x05\x04\0\x02\x14\x06\x12\x03*\x08\x20\n\x0c\n\x05\x04\0\
    \x02\x14\x01\x12\x03*!<\n\x0c\n\x05\x04\0\x02\x14\x03\x12\x03*?A\n\x0b\n\
    \x04\x04\0\x02\x15\x12\x03,\x08<\n\x0c\n\x05\x04\0\x02\x15\x06\x12\x03,\
    \x08\x1d\n\x0c\n\x05\x04\0\x02\x15\x01\x12\x03,\x1e6\n\x0c\n\x05\x04\0\
    \x02\x15\x03\x12\x03,9;\n\x0b\n\x04\x04\0\x02\x16\x12\x03-\x08B\n\x0c\n\
    \x05\x04\0\x02\x16\x06\x12\x03-\x08\x20\n\x0c\n\x05\x04\0\x02\x16\x01\
    \x12\x03-!<\n\x0c\n\x05\x04\0\x02\x16\x03\x12\x03-?A\n\x0b\n\x04\x04\0\
    \x02\x17\x12\x03.\x08&\n\x0c\n\x05\x04\0\x02\x17\x06\x12\x03.\x08\x13\n\
    \x0c\n\x05\x04\0\x02\x17\x01\x12\x03.\x14\x20\n\x0c\n\x05\x04\0\x02\x17\
    \x03\x12\x03.#%\n\x0b\n\x04\x04\0\x02\x18\x12\x03/\x089\n\x0c\n\x05\x04\
    \0\x02\x18\x06\x12\x03/\x08\x1c\n\x0c\n\x05\x04\0\x02\x18\x01\x12\x03/\
    \x1d3\n\x0c\n\x05\x04\0\x02\x18\x03\x12\x03/68\n\x0b\n\x04\x04\0\x02\x19\
    \x12\x030\x08Z\n\x0c\n\x05\x04\0\x02\x19\x06\x12\x030\x08+\n\x0c\n\x05\
    \x04\0\x02\x19\x01\x12\x030,T\n\x0c\n\x05\x04\0\x02\x19\x03\x12\x030WY\n\
    \x0b\n\x04\x04\0\x02\x1a\x12\x032\x08E\n\x0c\n\x05\x04\0\x02\x1a\x06\x12\
    \x032\x08\"\n\x0c\n\x05\x04\0\x02\x1a\x01\x12\x032#?\n\x0c\n\x05\x04\0\
    \x02\x1a\x03\x12\x032BD\n\x0b\n\x04\x04\0\x02\x1b\x12\x034\x081\n\x0c\n\
    \x05\x04\0\x02\x1b\x06\x12\x034\x08\x18\n\x0c\n\x05\x04\0\x02\x1b\x01\
    \x12\x034\x19+\n\x0c\n\x05\x04\0\x02\x1b\x03\x12\x034.0\n\x0b\n\x04\x04\
    \0\x02\x1c\x12\x035\x083\n\x0c\n\x05\x04\0\x02\x1c\x06\x12\x035\x08\x19\
    \n\x0c\n\x05\x04\0\x02\x1c\x01\x12\x035\x1a-\n\x0c\n\x05\x04\0\x02\x1c\
    \x03\x12\x03502\n\x0b\n\x04\x04\0\x02\x1d\x12\x036\x08B\n\x0c\n\x05\x04\
    \0\x02\x1d\x06\x12\x036\x08\x20\n\x0c\n\x05\x04\0\x02\x1d\x01\x12\x036!<\
    \n\x0c\n\x05\x04\0\x02\x1d\x03\x12\x036?A\n\x0b\n\x04\x04\0\x02\x1e\x12\
    \x038\x08Y\n\x0c\n\x05\x04\0\x02\x1e\x06\x12\x038\x08+\n\x0c\n\x05\x04\0\
    \x02\x1e\x01\x12\x038,S\n\x0c\n\x05\x04\0\x02\x1e\x03\x12\x038VX\n\x0b\n\
    \x04\x04\0\x02\x1f\x12\x039\x08$\n\x0c\n\x05\x04\0\x02\x1f\x06\x12\x039\
    \x08\x12\n\x0c\n\x05\x04\0\x02\x1f\x01\x12\x039\x13\x1e\n\x0c\n\x05\x04\
    \0\x02\x1f\x03\x12\x039!#\n\x0b\n\x04\x04\0\x02\x20\x12\x03:\x08N\n\x0c\
    \n\x05\x04\0\x02\x20\x06\x12\x03:\x08&\n\x0c\n\x05\x04\0\x02\x20\x01\x12\
    \x03:'H\n\x0c\n\x05\x04\0\x02\x20\x03\x12\x03:KM\n\x0b\n\x04\x04\0\x02!\
    \x12\x03;\x08?\n\x0c\n\x05\x04\0\x02!\x06\x12\x03;\x08\x1e\n\x0c\n\x05\
    \x04\0\x02!\x01\x12\x03;\x1f9\n\x0c\n\x05\x04\0\x02!\x03\x12\x03;<>\n\
    \x0b\n\x04\x04\0\x02\"\x12\x03<\x08C\n\x0c\n\x05\x04\0\x02\"\x06\x12\x03\
    <\x08\x20\n\x0c\n\x05\x04\0\x02\"\x01\x12\x03<!=\n\x0c\n\x05\x04\0\x02\"\
    \x03\x12\x03<@B\n\x0b\n\x04\x04\0\x02#\x12\x03=\x08E\n\x0c\n\x05\x04\0\
    \x02#\x06\x12\x03=\x08!\n\x0c\n\x05\x04\0\x02#\x01\x12\x03=\"?\n\x0c\n\
    \x05\x04\0\x02#\x03\x12\x03=BD\n\x0b\n\x04\x04\0\x02$\x12\x03>\x08I\n\
    \x0c\n\x05\x04\0\x02$\x06\x12\x03>\x08#\n\x0c\n\x05\x04\0\x02$\x01\x12\
    \x03>$C\n\x0c\n\x05\x04\0\x02$\x03\x12\x03>FH\n\x0b\n\x04\x04\0\x02%\x12\
    \x03?\x08M\n\x0c\n\x05\x04\0\x02%\x06\x12\x03?\x08%\n\x0c\n\x05\x04\0\
    \x02%\x01\x12\x03?&G\n\x0c\n\x05\x04\0\x02%\x03\x12\x03?JL\n\x0b\n\x04\
    \x04\0\x02&\x12\x03@\x08O\n\x0c\n\x05\x04\0\x02&\x06\x12\x03@\x08&\n\x0c\
    \n\x05\x04\0\x02&\x01\x12\x03@'I\n\x0c\n\x05\x04\0\x02&\x03\x12\x03@LN\n\
    \x0b\n\x04\x04\0\x02'\x12\x03A\x08L\n\x0c\n\x05\x04\0\x02'\x06\x12\x03A\
    \x08$\n\x0c\n\x05\x04\0\x02'\x01\x12\x03A%F\n\x0c\n\x05\x04\0\x02'\x03\
    \x12\x03AIK\n\x0b\n\x04\x04\0\x02(\x12\x03B\x08P\n\x0c\n\x05\x04\0\x02(\
    \x06\x12\x03B\x08&\n\x0c\n\x05\x04\0\x02(\x01\x12\x03B'J\n\x0c\n\x05\x04\
    \0\x02(\x03\x12\x03BMO\n\x0b\n\x04\x04\0\x02)\x12\x03C\x08R\n\x0c\n\x05\
    \x04\0\x02)\x06\x12\x03C\x08'\n\x0c\n\x05\x04\0\x02)\x01\x12\x03C(L\n\
    \x0c\n\x05\x04\0\x02)\x03\x12\x03COQ\n\x0b\n\x04\x04\0\x02*\x12\x03E\x08\
    3\n\x0c\n\x05\x04\0\x02*\x06\x12\x03E\x08\x19\n\x0c\n\x05\x04\0\x02*\x01\
    \x12\x03E\x1a-\n\x0c\n\x05\x04\0\x02*\x03\x12\x03E02\n\x0b\n\x04\x04\0\
    \x02+\x12\x03F\x08S\n\x0c\n\x05\x04\0\x02+\x06\x12\x03F\x08(\n\x0c\n\x05\
    \x04\0\x02+\x01\x12\x03F)M\n\x0c\n\x05\x04\0\x02+\x03\x12\x03FPR\n\x0b\n\
    \x04\x04\0\x02,\x12\x03G\x08S\n\x0c\n\x05\x04\0\x02,\x06\x12\x03G\x08(\n\
    \x0c\n\x05\x04\0\x02,\x01\x12\x03G)M\n\x0c\n\x05\x04\0\x02,\x03\x12\x03G\
    PR\n\x0b\n\x04\x04\0\x02-\x12\x03I\x08Q\n\x0c\n\x05\x04\0\x02-\x06\x12\
    \x03I\x08'\n\x0c\n\x05\x04\0\x02-\x01\x12\x03I(K\n\x0c\n\x05\x04\0\x02-\
    \x03\x12\x03INP\n\x0b\n\x04\x04\0\x02.\x12\x03J\x08S\n\x0c\n\x05\x04\0\
    \x02.\x06\x12\x03J\x08(\n\x0c\n\x05\x04\0\x02.\x01\x12\x03J)M\n\x0c\n\
    \x05\x04\0\x02.\x03\x12\x03JPR\n\x0b\n\x04\x04\0\x02/\x12\x03K\x08Y\n\
    \x0c\n\x05\x04\0\x02/\x06\x12\x03K\x08*\n\x0c\n\x05\x04\0\x02/\x01\x12\
    \x03K+S\n\x0c\n\x05\x04\0\x02/\x03\x12\x03KVX\n\x0b\n\x04\x04\0\x020\x12\
    \x03L\x08Z\n\x0c\n\x05\x04\0\x020\x06\x12\x03L\x08+\n\x0c\n\x05\x04\0\
    \x020\x01\x12\x03L,T\n\x0c\n\x05\x04\0\x020\x03\x12\x03LWY\n\xe5\x01\n\
    \x02\x04\x01\x12\x04T\0V\x012\xd8\x01///////////////////////////////////\
    //////////////////////////////////////////////////////\n\x20Implementati\
    ons\x20of\x20NetworkEnvelope\n//////////////////////////////////////////\
    ///////////////////////////////////////////////\n\n\n\n\x03\x04\x01\x01\
    \x12\x03T\x08\x19\n\x0b\n\x04\x04\x01\x02\0\x12\x03U\x04+\n\x0c\n\x05\
    \x04\x01\x02\0\x04\x12\x03U\x04\x0c\n\x0c\n\x05\x04\x01\x02\0\x06\x12\
    \x03U\r\x1c\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03U\x1d&\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03U)*\n\x16\n\x02\x04\x02\x12\x04Z\0^\x012\n\x20get\
    \x20data\n\n\n\n\x03\x04\x02\x01\x12\x03Z\x08!\n\x0b\n\x04\x04\x02\x02\0\
    \x12\x03[\x04\x15\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03[\x04\t\n\x0c\n\
    \x05\x04\x02\x02\0\x01\x12\x03[\n\x0f\n\x0c\n\x05\x04\x02\x02\0\x03\x12\
    \x03[\x12\x14\n\x0b\n\x04\x04\x02\x02\x01\x12\x03\\\x04%\n\x0c\n\x05\x04\
    \x02\x02\x01\x04\x12\x03\\\x04\x0c\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\
    \x03\\\r\x12\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\\\x13\x20\n\x0c\n\
    \x05\x04\x02\x02\x01\x03\x12\x03\\#$\n\x0b\n\x04\x04\x02\x02\x02\x12\x03\
    ]\x04.\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03]\x04\x0c\n\x0c\n\x05\x04\
    \x02\x02\x02\x05\x12\x03]\r\x12\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03]\
    \x13)\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03],-\n\n\n\x02\x04\x03\x12\
    \x04`\0f\x01\n\n\n\x03\x04\x03\x01\x12\x03`\x08\x17\n\x0b\n\x04\x04\x03\
    \x02\0\x12\x03a\x04\x1c\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03a\x04\t\n\
    \x0c\n\x05\x04\x03\x02\0\x01\x12\x03a\n\x17\n\x0c\n\x05\x04\x03\x02\0\
    \x03\x12\x03a\x1a\x1b\n\x0b\n\x04\x04\x03\x02\x01\x12\x03b\x04*\n\x0c\n\
    \x05\x04\x03\x02\x01\x05\x12\x03b\x04\x08\n\x0c\n\x05\x04\x03\x02\x01\
    \x01\x12\x03b\t%\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03b()\n\x0b\n\x04\
    \x04\x03\x02\x02\x12\x03c\x04.\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03c\
    \x04\x0c\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\x03c\r\x20\n\x0c\n\x05\x04\
    \x03\x02\x02\x01\x12\x03c!)\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03c,-\n\
    \x0b\n\x04\x04\x03\x02\x03\x12\x03d\x04.\n\x0c\n\x05\x04\x03\x02\x03\x04\
    \x12\x03d\x04\x0c\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03d\r\x12\n\x0c\n\
    \x05\x04\x03\x02\x03\x01\x12\x03d\x13)\n\x0c\n\x05\x04\x03\x02\x03\x03\
    \x12\x03d,-\n\x0b\n\x04\x04\x03\x02\x04\x12\x03e\x04M\n\x0c\n\x05\x04\
    \x03\x02\x04\x04\x12\x03e\x04\x0c\n\x0c\n\x05\x04\x03\x02\x04\x06\x12\
    \x03e\r&\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03e'H\n\x0c\n\x05\x04\x03\
    \x02\x04\x03\x12\x03eKL\n\n\n\x02\x04\x04\x12\x04h\0l\x01\n\n\n\x03\x04\
    \x04\x01\x12\x03h\x08\x1d\n\x0b\n\x04\x04\x04\x02\0\x12\x03i\x04(\n\x0c\
    \n\x05\x04\x04\x02\0\x06\x12\x03i\x04\x0f\n\x0c\n\x05\x04\x04\x02\0\x01\
    \x12\x03i\x10#\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03i&'\n\x0b\n\x04\x04\
    \x04\x02\x01\x12\x03j\x04\x14\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03j\
    \x04\t\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03j\n\x0f\n\x0c\n\x05\x04\
    \x04\x02\x01\x03\x12\x03j\x12\x13\n\x0b\n\x04\x04\x04\x02\x02\x12\x03k\
    \x04%\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x03k\x04\x0c\n\x0c\n\x05\x04\
    \x04\x02\x02\x05\x12\x03k\r\x12\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03k\
    \x13\x20\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03k#$\n\x13\n\x02\x04\x05\
    \x12\x04p\0u\x012\x07\x20peers\n\n\n\n\x03\x04\x05\x01\x12\x03p\x08\x17\
    \n\x0b\n\x04\x04\x05\x02\0\x12\x03q\x04(\n\x0c\n\x05\x04\x05\x02\0\x06\
    \x12\x03q\x04\x0f\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03q\x10#\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x03q&'\n\x0b\n\x04\x04\x05\x02\x01\x12\x03r\
    \x04\x14\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03r\x04\t\n\x0c\n\x05\x04\
    \x05\x02\x01\x01\x12\x03r\n\x0f\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03r\
    \x12\x13\n\x0b\n\x04\x04\x05\x02\x02\x12\x03s\x04.\n\x0c\n\x05\x04\x05\
    \x02\x02\x04\x12\x03s\x04\x0c\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\x03s\r\
    \x12\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03s\x13)\n\x0c\n\x05\x04\x05\
    \x02\x02\x03\x12\x03s,-\n\x0b\n\x04\x04\x05\x02\x03\x12\x03t\x04%\n\x0c\
    \n\x05\x04\x05\x02\x03\x04\x12\x03t\x04\x0c\n\x0c\n\x05\x04\x05\x02\x03\
    \x06\x12\x03t\r\x11\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03t\x12\x20\n\
    \x0c\n\x05\x04\x05\x02\x03\x03\x12\x03t#$\n\n\n\x02\x04\x06\x12\x04w\0{\
    \x01\n\n\n\x03\x04\x06\x01\x12\x03w\x08\x18\n\x0b\n\x04\x04\x06\x02\0\
    \x12\x03x\x04\x1c\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03x\x04\t\n\x0c\n\
    \x05\x04\x06\x02\0\x01\x12\x03x\n\x17\n\x0c\n\x05\x04\x06\x02\0\x03\x12\
    \x03x\x1a\x1b\n\x0b\n\x04\x04\x06\x02\x01\x12\x03y\x04%\n\x0c\n\x05\x04\
    \x06\x02\x01\x04\x12\x03y\x04\x0c\n\x0c\n\x05\x04\x06\x02\x01\x06\x12\
    \x03y\r\x11\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03y\x12\x20\n\x0c\n\x05\
    \x04\x06\x02\x01\x03\x12\x03y#$\n\x0b\n\x04\x04\x06\x02\x02\x12\x03z\x04\
    .\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\x03z\x04\x0c\n\x0c\n\x05\x04\x06\
    \x02\x02\x05\x12\x03z\r\x12\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03z\x13\
    )\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03z,-\n\x0b\n\x02\x04\x07\x12\x05\
    }\0\x80\x01\x01\n\n\n\x03\x04\x07\x01\x12\x03}\x08\x0c\n\x0b\n\x04\x04\
    \x07\x02\0\x12\x03~\x04\x14\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03~\x04\t\
    \n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03~\n\x0f\n\x0c\n\x05\x04\x07\x02\0\
    \x03\x12\x03~\x12\x13\n\x0b\n\x04\x04\x07\x02\x01\x12\x03\x7f\x04#\n\x0c\
    \n\x05\x04\x07\x02\x01\x05\x12\x03\x7f\x04\t\n\x0c\n\x05\x04\x07\x02\x01\
    \x01\x12\x03\x7f\n\x1e\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03\x7f!\"\n\
    \x0c\n\x02\x04\x08\x12\x06\x82\x01\0\x84\x01\x01\n\x0b\n\x03\x04\x08\x01\
    \x12\x04\x82\x01\x08\x0c\n\x0c\n\x04\x04\x08\x02\0\x12\x04\x83\x01\x04\
    \x1c\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\x83\x01\x04\t\n\r\n\x05\x04\x08\
    \x02\0\x01\x12\x04\x83\x01\n\x17\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x83\
    \x01\x1a\x1b\n\x15\n\x02\x04\t\x12\x06\x88\x01\0\x8e\x01\x012\x07\x20off\
    er\n\n\x0b\n\x03\x04\t\x01\x12\x04\x88\x01\x08\x20\n\x0c\n\x04\x04\t\x02\
    \0\x12\x04\x89\x01\x04\x18\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x89\x01\x04\
    \n\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x89\x01\x0b\x13\n\r\n\x05\x04\t\x02\
    \0\x03\x12\x04\x89\x01\x16\x17\n\x0c\n\x04\x04\t\x02\x01\x12\x04\x8a\x01\
    \x04\x20\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\x8a\x01\x04\x0e\n\r\n\x05\
    \x04\t\x02\x01\x01\x12\x04\x8a\x01\x0f\x1b\n\r\n\x05\x04\t\x02\x01\x03\
    \x12\x04\x8a\x01\x1e\x1f\n\x0c\n\x04\x04\t\x02\x02\x12\x04\x8b\x01\x04!\
    \n\r\n\x05\x04\t\x02\x02\x05\x12\x04\x8b\x01\x04\t\n\r\n\x05\x04\t\x02\
    \x02\x01\x12\x04\x8b\x01\n\x1c\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\x8b\
    \x01\x1f\x20\n\x0c\n\x04\x04\t\x02\x03\x12\x04\x8c\x01\x04.\n\r\n\x05\
    \x04\t\x02\x03\x04\x12\x04\x8c\x01\x04\x0c\n\r\n\x05\x04\t\x02\x03\x05\
    \x12\x04\x8c\x01\r\x12\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\x8c\x01\x13)\
    \n\r\n\x05\x04\t\x02\x03\x03\x12\x04\x8c\x01,-\n\x0c\n\x04\x04\t\x02\x04\
    \x12\x04\x8d\x01\x04\x13\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\x8d\x01\x04\
    \n\n\r\n\x05\x04\t\x02\x04\x01\x12\x04\x8d\x01\x0b\x0e\n\r\n\x05\x04\t\
    \x02\x04\x03\x12\x04\x8d\x01\x11\x12\n\x0c\n\x02\x04\n\x12\x06\x90\x01\0\
    \x98\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\x90\x01\x08!\n\x0c\n\x04\x04\
    \n\x02\0\x12\x04\x91\x01\x04\x18\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x91\
    \x01\x04\n\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x91\x01\x0b\x13\n\r\n\x05\
    \x04\n\x02\0\x03\x12\x04\x91\x01\x16\x17\n\x0c\n\x04\x04\n\x02\x01\x12\
    \x04\x92\x01\x04/\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\x92\x01\x04\x16\n\
    \r\n\x05\x04\n\x02\x01\x01\x12\x04\x92\x01\x17*\n\r\n\x05\x04\n\x02\x01\
    \x03\x12\x04\x92\x01-.\n\x0c\n\x04\x04\n\x02\x02\x12\x04\x93\x01\x04.\n\
    \r\n\x05\x04\n\x02\x02\x04\x12\x04\x93\x01\x04\x0c\n\r\n\x05\x04\n\x02\
    \x02\x05\x12\x04\x93\x01\r\x12\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\x93\
    \x01\x13)\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\x93\x01,-\n\x0c\n\x04\x04\
    \n\x02\x03\x12\x04\x94\x01\x04\x13\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\
    \x94\x01\x04\n\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\x94\x01\x0b\x0e\n\r\n\
    \x05\x04\n\x02\x03\x03\x12\x04\x94\x01\x11\x12\n\x0c\n\x04\x04\n\x02\x04\
    \x12\x04\x95\x01\x04\x1f\n\r\n\x05\x04\n\x02\x04\x06\x12\x04\x95\x01\x04\
    \x0f\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\x95\x01\x10\x1a\n\r\n\x05\x04\n\
    \x02\x04\x03\x12\x04\x95\x01\x1d\x1e\n\x0c\n\x04\x04\n\x02\x05\x12\x04\
    \x96\x01\x04\x1d\n\r\n\x05\x04\n\x02\x05\x06\x12\x04\x96\x01\x04\x0f\n\r\
    \n\x05\x04\n\x02\x05\x01\x12\x04\x96\x01\x10\x18\n\r\n\x05\x04\n\x02\x05\
    \x03\x12\x04\x96\x01\x1b\x1c\n\x0c\n\x04\x04\n\x02\x06\x12\x04\x97\x01\
    \x04!\n\r\n\x05\x04\n\x02\x06\x06\x12\x04\x97\x01\x04\x0f\n\r\n\x05\x04\
    \n\x02\x06\x01\x12\x04\x97\x01\x10\x1c\n\r\n\x05\x04\n\x02\x06\x03\x12\
    \x04\x97\x01\x1f\x20\n\x0c\n\x02\x04\x0b\x12\x06\x9a\x01\0\x9f\x01\x01\n\
    \x0b\n\x03\x04\x0b\x01\x12\x04\x9a\x01\x08\x1b\n\x0c\n\x04\x04\x0b\x02\0\
    \x12\x04\x9b\x01\x04&\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x9b\x01\x04\t\
    \n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x9b\x01\n!\n\r\n\x05\x04\x0b\x02\0\
    \x03\x12\x04\x9b\x01$%\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x9c\x01\x04\
    \x18\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\x9c\x01\x04\t\n\r\n\x05\x04\
    \x0b\x02\x01\x01\x12\x04\x9c\x01\n\x13\n\r\n\x05\x04\x0b\x02\x01\x03\x12\
    \x04\x9c\x01\x16\x17\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\x9d\x01\x04\x1e\
    \n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\x9d\x01\x04\t\n\r\n\x05\x04\x0b\
    \x02\x02\x01\x12\x04\x9d\x01\n\x19\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\
    \x9d\x01\x1c\x1d\n\x0c\n\x04\x04\x0b\x02\x03\x12\x04\x9e\x01\x04\x1e\n\r\
    \n\x05\x04\x0b\x02\x03\x05\x12\x04\x9e\x01\x04\t\n\r\n\x05\x04\x0b\x02\
    \x03\x01\x12\x04\x9e\x01\n\x19\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\x9e\
    \x01\x1c\x1d\n\x17\n\x02\x04\x0c\x12\x06\xa3\x01\0\xa5\x01\x012\t\x20sto\
    rage\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xa3\x01\x08\x16\n\x0c\n\x04\x04\
    \x0c\x02\0\x12\x04\xa4\x01\x04\"\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\xa4\
    \x01\x04\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xa4\x01\x18\x1d\n\r\n\
    \x05\x04\x0c\x02\0\x03\x12\x04\xa4\x01\x20!\n\x0c\n\x02\x04\r\x12\x06\
    \xa7\x01\0\xa9\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xa7\x01\x08\x19\n\
    \x0c\n\x04\x04\r\x02\0\x12\x04\xa8\x01\x046\n\r\n\x05\x04\r\x02\0\x06\
    \x12\x04\xa8\x01\x04\x19\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xa8\x01\x1a1\
    \n\r\n\x05\x04\r\x02\0\x03\x12\x04\xa8\x0145\n\x0c\n\x02\x04\x0e\x12\x06\
    \xab\x01\0\xad\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xab\x01\x08\x20\n\
    \x0c\n\x04\x04\x0e\x02\0\x12\x04\xac\x01\x04=\n\r\n\x05\x04\x0e\x02\0\
    \x06\x12\x04\xac\x01\x04\x20\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xac\x01\
    !8\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xac\x01;<\n\x0c\n\x02\x04\x0f\x12\
    \x06\xaf\x01\0\xb1\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xaf\x01\x08+\
    \n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xb0\x01\x04*\n\r\n\x05\x04\x0f\x02\0\
    \x06\x12\x04\xb0\x01\x04\x1d\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xb0\x01\
    \x1e%\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xb0\x01()\n\x14\n\x02\x04\x10\
    \x12\x06\xb5\x01\0\xb7\x01\x012\x06\x20misc\n\n\x0b\n\x03\x04\x10\x01\
    \x12\x04\xb5\x01\x08\x1e\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xb6\x01\x04\
    \x16\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xb6\x01\x04\n\n\r\n\x05\x04\x10\
    \x02\0\x01\x12\x04\xb6\x01\x0b\x11\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\
    \xb6\x01\x14\x15\n\x0c\n\x02\x04\x11\x12\x06\xb9\x01\0\xc2\x01\x01\n\x0b\
    \n\x03\x04\x11\x01\x12\x04\xb9\x01\x08\x12\n\x0c\n\x04\x04\x11\x02\0\x12\
    \x04\xba\x01\x04\x13\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xba\x01\x04\n\n\
    \r\n\x05\x04\x11\x02\0\x01\x12\x04\xba\x01\x0b\x0e\n\r\n\x05\x04\x11\x02\
    \0\x03\x12\x04\xba\x01\x11\x12\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xbb\
    \x01\x04(\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\xbb\x01\x04\x0f\n\r\n\
    \x05\x04\x11\x02\x01\x01\x12\x04\xbb\x01\x10#\n\r\n\x05\x04\x11\x02\x01\
    \x03\x12\x04\xbb\x01&'\nA\n\x04\x04\x11\x02\x02\x12\x04\xbc\x01\x04\x1b\
    \"3\x20enum\x20name.\x20e.g.\x20\x20TradeMessage,\x20DisputeMessage,...\
    \n\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xbc\x01\x04\n\n\r\n\x05\x04\x11\
    \x02\x02\x01\x12\x04\xbc\x01\x0b\x16\n\r\n\x05\x04\x11\x02\x02\x03\x12\
    \x04\xbc\x01\x19\x1a\n\x0c\n\x04\x04\x11\x02\x03\x12\x04\xbd\x01\x04%\n\
    \r\n\x05\x04\x11\x02\x03\x05\x12\x04\xbd\x01\x04\n\n\r\n\x05\x04\x11\x02\
    \x03\x01\x12\x04\xbd\x01\x0b\x20\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\
    \xbd\x01#$\n,\n\x04\x04\x11\x02\x04\x12\x04\xbe\x01\x04\x1a\"\x1e\x20uid\
    \x20of\x20source\x20(TradeMessage)\n\n\r\n\x05\x04\x11\x02\x04\x05\x12\
    \x04\xbe\x01\x04\n\n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\xbe\x01\x0b\x15\
    \n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\xbe\x01\x18\x19\n1\n\x04\x04\x11\
    \x02\x05\x12\x04\xbf\x01\x04\x19\"#\x20id\x20of\x20source\x20(tradeId,\
    \x20disputeId)\n\n\r\n\x05\x04\x11\x02\x05\x05\x12\x04\xbf\x01\x04\n\n\r\
    \n\x05\x04\x11\x02\x05\x01\x12\x04\xbf\x01\x0b\x14\n\r\n\x05\x04\x11\x02\
    \x05\x03\x12\x04\xbf\x01\x17\x18\nA\n\x04\x04\x11\x02\x06\x12\x04\xc0\
    \x01\x04\x15\"3\x20true\x20if\x20source\x20message\x20was\x20processed\
    \x20successfully\n\n\r\n\x05\x04\x11\x02\x06\x05\x12\x04\xc0\x01\x04\x08\
    \n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\xc0\x01\t\x10\n\r\n\x05\x04\x11\
    \x02\x06\x03\x12\x04\xc0\x01\x13\x14\nJ\n\x04\x04\x11\x02\x07\x12\x04\
    \xc1\x01\x04\x1d\"<\x20optional\x20error\x20message\x20if\x20source\x20m\
    essage\x20processing\x20failed\n\n\r\n\x05\x04\x11\x02\x07\x05\x12\x04\
    \xc1\x01\x04\n\n\r\n\x05\x04\x11\x02\x07\x01\x12\x04\xc1\x01\x0b\x18\n\r\
    \n\x05\x04\x11\x02\x07\x03\x12\x04\xc1\x01\x1b\x1c\n\x0c\n\x02\x04\x12\
    \x12\x06\xc4\x01\0\xc9\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xc4\x01\
    \x08&\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xc5\x01\x04!\n\r\n\x05\x04\x12\
    \x02\0\x06\x12\x04\xc5\x01\x04\x0f\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \xc5\x01\x10\x1c\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xc5\x01\x1f\x20\n\
    \x0c\n\x04\x04\x12\x02\x01\x12\x04\xc6\x01\x04*\n\r\n\x05\x04\x12\x02\
    \x01\x06\x12\x04\xc6\x01\x04\x13\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\
    \xc6\x01\x14%\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xc6\x01()\n\x0c\n\
    \x04\x04\x12\x02\x02\x12\x04\xc7\x01\x04\"\n\r\n\x05\x04\x12\x02\x02\x05\
    \x12\x04\xc7\x01\x04\t\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xc7\x01\n\
    \x1d\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xc7\x01\x20!\n\x0c\n\x04\x04\
    \x12\x02\x03\x12\x04\xc8\x01\x04\x13\n\r\n\x05\x04\x12\x02\x03\x05\x12\
    \x04\xc8\x01\x04\n\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xc8\x01\x0b\x0e\
    \n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xc8\x01\x11\x12\n\x15\n\x02\x04\
    \x13\x12\x06\xcd\x01\0\xe7\x01\x012\x07\x20trade\n\n\x0b\n\x03\x04\x13\
    \x01\x12\x04\xcd\x01\x08!\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xce\x01\x04\
    \x18\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xce\x01\x04\n\n\r\n\x05\x04\x13\
    \x02\0\x01\x12\x04\xce\x01\x0b\x13\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\
    \xce\x01\x16\x17\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xcf\x01\x04(\n\r\n\
    \x05\x04\x13\x02\x01\x06\x12\x04\xcf\x01\x04\x0f\n\r\n\x05\x04\x13\x02\
    \x01\x01\x12\x04\xcf\x01\x10#\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xcf\
    \x01&'\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\xd0\x01\x04\x1b\n\r\n\x05\x04\
    \x13\x02\x02\x05\x12\x04\xd0\x01\x04\t\n\r\n\x05\x04\x13\x02\x02\x01\x12\
    \x04\xd0\x01\n\x16\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xd0\x01\x19\x1a\
    \n\x0c\n\x04\x04\x13\x02\x03\x12\x04\xd1\x01\x04\x1a\n\r\n\x05\x04\x13\
    \x02\x03\x05\x12\x04\xd1\x01\x04\t\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\
    \xd1\x01\n\x15\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\xd1\x01\x18\x19\n\
    \x0c\n\x04\x04\x13\x02\x04\x12\x04\xd2\x01\x04\x15\n\r\n\x05\x04\x13\x02\
    \x04\x05\x12\x04\xd2\x01\x04\t\n\r\n\x05\x04\x13\x02\x04\x01\x12\x04\xd2\
    \x01\n\x10\n\r\n\x05\x04\x13\x02\x04\x03\x12\x04\xd2\x01\x13\x14\n\x0c\n\
    \x04\x04\x13\x02\x05\x12\x04\xd3\x01\x04\x18\n\r\n\x05\x04\x13\x02\x05\
    \x05\x12\x04\xd3\x01\x04\t\n\r\n\x05\x04\x13\x02\x05\x01\x12\x04\xd3\x01\
    \n\x13\n\r\n\x05\x04\x13\x02\x05\x03\x12\x04\xd3\x01\x16\x17\n\x0c\n\x04\
    \x04\x13\x02\x06\x12\x04\xd4\x01\x04+\n\r\n\x05\x04\x13\x02\x06\x05\x12\
    \x04\xd4\x01\x04\x08\n\r\n\x05\x04\x13\x02\x06\x01\x12\x04\xd4\x01\t&\n\
    \r\n\x05\x04\x13\x02\x06\x03\x12\x04\xd4\x01)*\n\x0c\n\x04\x04\x13\x02\
    \x07\x12\x04\xd5\x01\x04<\n\r\n\x05\x04\x13\x02\x07\x04\x12\x04\xd5\x01\
    \x04\x0c\n\r\n\x05\x04\x13\x02\x07\x06\x12\x04\xd5\x01\r\x20\n\r\n\x05\
    \x04\x13\x02\x07\x01\x12\x04\xd5\x01!7\n\r\n\x05\x04\x13\x02\x07\x03\x12\
    \x04\xd5\x01:;\n\x0c\n\x04\x04\x13\x02\x08\x12\x04\xd6\x01\x04\"\n\r\n\
    \x05\x04\x13\x02\x08\x05\x12\x04\xd6\x01\x04\t\n\r\n\x05\x04\x13\x02\x08\
    \x01\x12\x04\xd6\x01\n\x1d\n\r\n\x05\x04\x13\x02\x08\x03\x12\x04\xd6\x01\
    \x20!\n\x0c\n\x04\x04\x13\x02\t\x12\x04\xd7\x01\x04&\n\r\n\x05\x04\x13\
    \x02\t\x05\x12\x04\xd7\x01\x04\n\n\r\n\x05\x04\x13\x02\t\x01\x12\x04\xd7\
    \x01\x0b\x20\n\r\n\x05\x04\x13\x02\t\x03\x12\x04\xd7\x01#%\n\x0c\n\x04\
    \x04\x13\x02\n\x12\x04\xd8\x01\x04'\n\r\n\x05\x04\x13\x02\n\x05\x12\x04\
    \xd8\x01\x04\t\n\r\n\x05\x04\x13\x02\n\x01\x12\x04\xd8\x01\n!\n\r\n\x05\
    \x04\x13\x02\n\x03\x12\x04\xd8\x01$&\n\x0c\n\x04\x04\x13\x02\x0b\x12\x04\
    \xd9\x01\x04,\n\r\n\x05\x04\x13\x02\x0b\x05\x12\x04\xd9\x01\x04\n\n\r\n\
    \x05\x04\x13\x02\x0b\x01\x12\x04\xd9\x01\x0b&\n\r\n\x05\x04\x13\x02\x0b\
    \x03\x12\x04\xd9\x01)+\n\x0c\n\x04\x04\x13\x02\x0c\x12\x04\xda\x01\x04'\
    \n\r\n\x05\x04\x13\x02\x0c\x06\x12\x04\xda\x01\x04\x0e\n\r\n\x05\x04\x13\
    \x02\x0c\x01\x12\x04\xda\x01\x0f!\n\r\n\x05\x04\x13\x02\x0c\x03\x12\x04\
    \xda\x01$&\n\x0c\n\x04\x04\x13\x02\r\x12\x04\xdb\x01\x04=\n\r\n\x05\x04\
    \x13\x02\r\x06\x12\x04\xdb\x01\x04\x19\n\r\n\x05\x04\x13\x02\r\x01\x12\
    \x04\xdb\x01\x1a7\n\r\n\x05\x04\x13\x02\r\x03\x12\x04\xdb\x01:<\n\x0c\n\
    \x04\x04\x13\x02\x0e\x12\x04\xdc\x01\x04!\n\r\n\x05\x04\x13\x02\x0e\x05\
    \x12\x04\xdc\x01\x04\n\n\r\n\x05\x04\x13\x02\x0e\x01\x12\x04\xdc\x01\x0b\
    \x1b\n\r\n\x05\x04\x13\x02\x0e\x03\x12\x04\xdc\x01\x1e\x20\n\x0c\n\x04\
    \x04\x13\x02\x0f\x12\x04\xdd\x01\x04\x20\n\r\n\x05\x04\x13\x02\x0f\x05\
    \x12\x04\xdd\x01\x04\n\n\r\n\x05\x04\x13\x02\x0f\x01\x12\x04\xdd\x01\x0b\
    \x1a\n\r\n\x05\x04\x13\x02\x0f\x03\x12\x04\xdd\x01\x1d\x1f\n\x0c\n\x04\
    \x04\x13\x02\x10\x12\x04\xde\x01\x04A\n\r\n\x05\x04\x13\x02\x10\x04\x12\
    \x04\xde\x01\x04\x0c\n\r\n\x05\x04\x13\x02\x10\x06\x12\x04\xde\x01\r\x18\
    \n\r\n\x05\x04\x13\x02\x10\x01\x12\x04\xde\x01\x19;\n\r\n\x05\x04\x13\
    \x02\x10\x03\x12\x04\xde\x01>@\n\x0c\n\x04\x04\x13\x02\x11\x12\x04\xdf\
    \x01\x04?\n\r\n\x05\x04\x13\x02\x11\x04\x12\x04\xdf\x01\x04\x0c\n\r\n\
    \x05\x04\x13\x02\x11\x06\x12\x04\xdf\x01\r\x18\n\r\n\x05\x04\x13\x02\x11\
    \x01\x12\x04\xdf\x01\x199\n\r\n\x05\x04\x13\x02\x11\x03\x12\x04\xdf\x01<\
    >\n\x0c\n\x04\x04\x13\x02\x12\x12\x04\xe0\x01\x04-\n\r\n\x05\x04\x13\x02\
    \x12\x06\x12\x04\xe0\x01\x04\x0f\n\r\n\x05\x04\x13\x02\x12\x01\x12\x04\
    \xe0\x01\x10'\n\r\n\x05\x04\x13\x02\x12\x03\x12\x04\xe0\x01*,\n\x0c\n\
    \x04\x04\x13\x02\x13\x12\x04\xe1\x01\x04+\n\r\n\x05\x04\x13\x02\x13\x06\
    \x12\x04\xe1\x01\x04\x0f\n\r\n\x05\x04\x13\x02\x13\x01\x12\x04\xe1\x01\
    \x10%\n\r\n\x05\x04\x13\x02\x13\x03\x12\x04\xe1\x01(*\n\x0c\n\x04\x04\
    \x13\x02\x14\x12\x04\xe2\x01\x04\x14\n\r\n\x05\x04\x13\x02\x14\x05\x12\
    \x04\xe2\x01\x04\n\n\r\n\x05\x04\x13\x02\x14\x01\x12\x04\xe2\x01\x0b\x0e\
    \n\r\n\x05\x04\x13\x02\x14\x03\x12\x04\xe2\x01\x11\x13\n\x0c\n\x04\x04\
    \x13\x02\x15\x12\x04\xe3\x01\x049\n\r\n\x05\x04\x13\x02\x15\x05\x12\x04\
    \xe3\x01\x04\t\n\r\n\x05\x04\x13\x02\x15\x01\x12\x04\xe3\x01\n3\n\r\n\
    \x05\x04\x13\x02\x15\x03\x12\x04\xe3\x0168\n\x0c\n\x04\x04\x13\x02\x16\
    \x12\x04\xe4\x01\x04\x1c\n\r\n\x05\x04\x13\x02\x16\x05\x12\x04\xe4\x01\
    \x04\t\n\r\n\x05\x04\x13\x02\x16\x01\x12\x04\xe4\x01\n\x16\n\r\n\x05\x04\
    \x13\x02\x16\x03\x12\x04\xe4\x01\x19\x1b\n\x0c\n\x04\x04\x13\x02\x17\x12\
    \x04\xe5\x01\x04C\n\r\n\x05\x04\x13\x02\x17\x04\x12\x04\xe5\x01\x04\x0c\
    \n\r\n\x05\x04\x13\x02\x17\x06\x12\x04\xe5\x01\r\x18\n\r\n\x05\x04\x13\
    \x02\x17\x01\x12\x04\xe5\x01\x19=\n\r\n\x05\x04\x13\x02\x17\x03\x12\x04\
    \xe5\x01@B\n\x0c\n\x04\x04\x13\x02\x18\x12\x04\xe6\x01\x04/\n\r\n\x05\
    \x04\x13\x02\x18\x06\x12\x04\xe6\x01\x04\x0f\n\r\n\x05\x04\x13\x02\x18\
    \x01\x12\x04\xe6\x01\x10)\n\r\n\x05\x04\x13\x02\x18\x03\x12\x04\xe6\x01,\
    .\n\x0c\n\x02\x04\x14\x12\x06\xe9\x01\0\xf8\x01\x01\n\x0b\n\x03\x04\x14\
    \x01\x12\x04\xe9\x01\x08\"\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xea\x01\x04\
    \x18\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xea\x01\x04\n\n\r\n\x05\x04\x14\
    \x02\0\x01\x12\x04\xea\x01\x0b\x13\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\
    \xea\x01\x16\x17\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xeb\x01\x04<\n\r\n\
    \x05\x04\x14\x02\x01\x06\x12\x04\xeb\x01\x04\x19\n\r\n\x05\x04\x14\x02\
    \x01\x01\x12\x04\xeb\x01\x1a7\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xeb\
    \x01:;\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\xec\x01\x04\x20\n\r\n\x05\x04\
    \x14\x02\x02\x05\x12\x04\xec\x01\x04\n\n\r\n\x05\x04\x14\x02\x02\x01\x12\
    \x04\xec\x01\x0b\x1b\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xec\x01\x1e\
    \x1f\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\xed\x01\x04&\n\r\n\x05\x04\x14\
    \x02\x03\x05\x12\x04\xed\x01\x04\n\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\
    \xed\x01\x0b!\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xed\x01$%\n\x0c\n\
    \x04\x04\x14\x02\x04\x12\x04\xee\x01\x04(\n\r\n\x05\x04\x14\x02\x04\x05\
    \x12\x04\xee\x01\x04\n\n\r\n\x05\x04\x14\x02\x04\x01\x12\x04\xee\x01\x0b\
    #\n\r\n\x05\x04\x14\x02\x04\x03\x12\x04\xee\x01&'\n\x0c\n\x04\x04\x14\
    \x02\x05\x12\x04\xef\x01\x04+\n\r\n\x05\x04\x14\x02\x05\x05\x12\x04\xef\
    \x01\x04\n\n\r\n\x05\x04\x14\x02\x05\x01\x12\x04\xef\x01\x0b&\n\r\n\x05\
    \x04\x14\x02\x05\x03\x12\x04\xef\x01)*\n\x0c\n\x04\x04\x14\x02\x06\x12\
    \x04\xf0\x01\x04\"\n\r\n\x05\x04\x14\x02\x06\x05\x12\x04\xf0\x01\x04\t\n\
    \r\n\x05\x04\x14\x02\x06\x01\x12\x04\xf0\x01\n\x1d\n\r\n\x05\x04\x14\x02\
    \x06\x03\x12\x04\xf0\x01\x20!\n\x0c\n\x04\x04\x14\x02\x07\x12\x04\xf1\
    \x01\x042\n\r\n\x05\x04\x14\x02\x07\x04\x12\x04\xf1\x01\x04\x0c\n\r\n\
    \x05\x04\x14\x02\x07\x06\x12\x04\xf1\x01\r\x20\n\r\n\x05\x04\x14\x02\x07\
    \x01\x12\x04\xf1\x01!-\n\r\n\x05\x04\x14\x02\x07\x03\x12\x04\xf1\x0101\n\
    \x0c\n\x04\x04\x14\x02\x08\x12\x04\xf2\x01\x04&\n\r\n\x05\x04\x14\x02\
    \x08\x05\x12\x04\xf2\x01\x04\t\n\r\n\x05\x04\x14\x02\x08\x01\x12\x04\xf2\
    \x01\n!\n\r\n\x05\x04\x14\x02\x08\x03\x12\x04\xf2\x01$%\n\x0c\n\x04\x04\
    \x14\x02\t\x12\x04\xf3\x01\x04)\n\r\n\x05\x04\x14\x02\t\x06\x12\x04\xf3\
    \x01\x04\x0f\n\r\n\x05\x04\x14\x02\t\x01\x12\x04\xf3\x01\x10#\n\r\n\x05\
    \x04\x14\x02\t\x03\x12\x04\xf3\x01&(\n\x0c\n\x04\x04\x14\x02\n\x12\x04\
    \xf4\x01\x04\x14\n\r\n\x05\x04\x14\x02\n\x05\x12\x04\xf4\x01\x04\n\n\r\n\
    \x05\x04\x14\x02\n\x01\x12\x04\xf4\x01\x0b\x0e\n\r\n\x05\x04\x14\x02\n\
    \x03\x12\x04\xf4\x01\x11\x13\n\x0c\n\x04\x04\x14\x02\x0b\x12\x04\xf5\x01\
    \x04D\n\r\n\x05\x04\x14\x02\x0b\x05\x12\x04\xf5\x01\x04\t\n\r\n\x05\x04\
    \x14\x02\x0b\x01\x12\x04\xf5\x01\n>\n\r\n\x05\x04\x14\x02\x0b\x03\x12\
    \x04\xf5\x01AC\n\x0c\n\x04\x04\x14\x02\x0c\x12\x04\xf6\x01\x04\x1c\n\r\n\
    \x05\x04\x14\x02\x0c\x05\x12\x04\xf6\x01\x04\t\n\r\n\x05\x04\x14\x02\x0c\
    \x01\x12\x04\xf6\x01\n\x16\n\r\n\x05\x04\x14\x02\x0c\x03\x12\x04\xf6\x01\
    \x19\x1b\n\x0c\n\x04\x04\x14\x02\r\x12\x04\xf7\x01\x04\x19\n\r\n\x05\x04\
    \x14\x02\r\x05\x12\x04\xf7\x01\x04\t\n\r\n\x05\x04\x14\x02\r\x01\x12\x04\
    \xf7\x01\n\x13\n\r\n\x05\x04\x14\x02\r\x03\x12\x04\xf7\x01\x16\x18\n\x0c\
    \n\x02\x04\x15\x12\x06\xfa\x01\0\xff\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\
    \x04\xfa\x01\x08'\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xfb\x01\x04\x13\n\r\
    \n\x05\x04\x15\x02\0\x05\x12\x04\xfb\x01\x04\n\n\r\n\x05\x04\x15\x02\0\
    \x01\x12\x04\xfb\x01\x0b\x0e\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xfb\x01\
    \x11\x12\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xfc\x01\x04\x18\n\r\n\x05\
    \x04\x15\x02\x01\x05\x12\x04\xfc\x01\x04\n\n\r\n\x05\x04\x15\x02\x01\x01\
    \x12\x04\xfc\x01\x0b\x13\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xfc\x01\
    \x16\x17\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xfd\x01\x04(\n\r\n\x05\x04\
    \x15\x02\x02\x06\x12\x04\xfd\x01\x04\x0f\n\r\n\x05\x04\x15\x02\x02\x01\
    \x12\x04\xfd\x01\x10#\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\xfd\x01&'\n\
    \x0c\n\x04\x04\x15\x02\x03\x12\x04\xfe\x01\x04\x20\n\r\n\x05\x04\x15\x02\
    \x03\x05\x12\x04\xfe\x01\x04\t\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\xfe\
    \x01\n\x1b\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\xfe\x01\x1e\x1f\n\x0c\n\
    \x02\x04\x16\x12\x06\x81\x02\0\x86\x02\x01\n\x0b\n\x03\x04\x16\x01\x12\
    \x04\x81\x02\x08(\n\x0c\n\x04\x04\x16\x02\0\x12\x04\x82\x02\x04\x13\n\r\
    \n\x05\x04\x16\x02\0\x05\x12\x04\x82\x02\x04\n\n\r\n\x05\x04\x16\x02\0\
    \x01\x12\x04\x82\x02\x0b\x0e\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x82\x02\
    \x11\x12\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\x83\x02\x04\x18\n\r\n\x05\
    \x04\x16\x02\x01\x05\x12\x04\x83\x02\x04\n\n\r\n\x05\x04\x16\x02\x01\x01\
    \x12\x04\x83\x02\x0b\x13\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\x83\x02\
    \x16\x17\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\x84\x02\x04(\n\r\n\x05\x04\
    \x16\x02\x02\x06\x12\x04\x84\x02\x04\x0f\n\r\n\x05\x04\x16\x02\x02\x01\
    \x12\x04\x84\x02\x10#\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\x84\x02&'\n\
    \x0c\n\x04\x04\x16\x02\x03\x12\x04\x85\x02\x04*\n\r\n\x05\x04\x16\x02\
    \x03\x05\x12\x04\x85\x02\x04\t\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\x85\
    \x02\n%\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\x85\x02()\n\x0c\n\x02\x04\
    \x17\x12\x06\x88\x02\0\x8e\x02\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\x88\
    \x02\x08*\n\x0c\n\x04\x04\x17\x02\0\x12\x04\x89\x02\x04\x13\n\r\n\x05\
    \x04\x17\x02\0\x05\x12\x04\x89\x02\x04\n\n\r\n\x05\x04\x17\x02\0\x01\x12\
    \x04\x89\x02\x0b\x0e\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\x89\x02\x11\x12\
    \n\x0c\n\x04\x04\x17\x02\x01\x12\x04\x8a\x02\x04\x18\n\r\n\x05\x04\x17\
    \x02\x01\x05\x12\x04\x8a\x02\x04\n\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\
    \x8a\x02\x0b\x13\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\x8a\x02\x16\x17\n\
    \x0c\n\x04\x04\x17\x02\x02\x12\x04\x8b\x02\x04(\n\r\n\x05\x04\x17\x02\
    \x02\x06\x12\x04\x8b\x02\x04\x0f\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\
    \x8b\x02\x10#\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\x8b\x02&'\n\x0c\n\
    \x04\x04\x17\x02\x03\x12\x04\x8c\x02\x04\x19\n\r\n\x05\x04\x17\x02\x03\
    \x05\x12\x04\x8c\x02\x04\t\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\x8c\x02\
    \n\x14\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\x8c\x02\x17\x18\n\x0c\n\x04\
    \x04\x17\x02\x04\x12\x04\x8d\x02\x04\x20\n\r\n\x05\x04\x17\x02\x04\x05\
    \x12\x04\x8d\x02\x04\t\n\r\n\x05\x04\x17\x02\x04\x01\x12\x04\x8d\x02\n\
    \x1b\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\x8d\x02\x1e\x1f\n\x0c\n\x02\
    \x04\x18\x12\x06\x90\x02\0\x95\x02\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\
    \x90\x02\x08\x18\n\x0c\n\x04\x04\x18\x02\0\x12\x04\x91\x02\x04\x13\n\r\n\
    \x05\x04\x18\x02\0\x05\x12\x04\x91\x02\x04\n\n\r\n\x05\x04\x18\x02\0\x01\
    \x12\x04\x91\x02\x0b\x0e\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x91\x02\x11\
    \x12\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\x92\x02\x04\x18\n\r\n\x05\x04\
    \x18\x02\x01\x05\x12\x04\x92\x02\x04\n\n\r\n\x05\x04\x18\x02\x01\x01\x12\
    \x04\x92\x02\x0b\x13\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\x92\x02\x16\
    \x17\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\x93\x02\x04(\n\r\n\x05\x04\x18\
    \x02\x02\x06\x12\x04\x93\x02\x04\x0f\n\r\n\x05\x04\x18\x02\x02\x01\x12\
    \x04\x93\x02\x10#\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\x93\x02&'\n\x0c\
    \n\x04\x04\x18\x02\x03\x12\x04\x94\x02\x04\x19\n\r\n\x05\x04\x18\x02\x03\
    \x05\x12\x04\x94\x02\x04\t\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\x94\x02\
    \n\x14\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\x94\x02\x17\x18\n\x0c\n\x02\
    \x04\x19\x12\x06\x97\x02\0\x9b\x02\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\
    \x97\x02\x08+\n\x0c\n\x04\x04\x19\x02\0\x12\x04\x98\x02\x04\x13\n\r\n\
    \x05\x04\x19\x02\0\x05\x12\x04\x98\x02\x04\n\n\r\n\x05\x04\x19\x02\0\x01\
    \x12\x04\x98\x02\x0b\x0e\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\x98\x02\x11\
    \x12\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\x99\x02\x04\x18\n\r\n\x05\x04\
    \x19\x02\x01\x05\x12\x04\x99\x02\x04\n\n\r\n\x05\x04\x19\x02\x01\x01\x12\
    \x04\x99\x02\x0b\x13\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\x99\x02\x16\
    \x17\n\x0c\n\x04\x04\x19\x02\x02\x12\x04\x9a\x02\x04(\n\r\n\x05\x04\x19\
    \x02\x02\x06\x12\x04\x9a\x02\x04\x0f\n\r\n\x05\x04\x19\x02\x02\x01\x12\
    \x04\x9a\x02\x10#\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\x9a\x02&'\n\x0c\
    \n\x02\x04\x1a\x12\x06\x9d\x02\0\xa4\x02\x01\n\x0b\n\x03\x04\x1a\x01\x12\
    \x04\x9d\x02\x08-\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\x9e\x02\x04\x18\n\r\
    \n\x05\x04\x1a\x02\0\x05\x12\x04\x9e\x02\x04\n\n\r\n\x05\x04\x1a\x02\0\
    \x01\x12\x04\x9e\x02\x0b\x13\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\x9e\x02\
    \x16\x17\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\x9f\x02\x04$\n\r\n\x05\x04\
    \x1a\x02\x01\x05\x12\x04\x9f\x02\x04\n\n\r\n\x05\x04\x1a\x02\x01\x01\x12\
    \x04\x9f\x02\x0b\x1f\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\x9f\x02\"#\n\
    \x0c\n\x04\x04\x1a\x02\x02\x12\x04\xa0\x02\x04(\n\r\n\x05\x04\x1a\x02\
    \x02\x06\x12\x04\xa0\x02\x04\x0f\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\
    \xa0\x02\x10#\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\xa0\x02&'\n\x0c\n\
    \x04\x04\x1a\x02\x03\x12\x04\xa1\x02\x04\x1e\n\r\n\x05\x04\x1a\x02\x03\
    \x05\x12\x04\xa1\x02\x04\t\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\xa1\x02\
    \n\x19\n\r\n\x05\x04\x1a\x02\x03\x03\x12\x04\xa1\x02\x1c\x1d\n\x0c\n\x04\
    \x04\x1a\x02\x04\x12\x04\xa2\x02\x04&\n\r\n\x05\x04\x1a\x02\x04\x05\x12\
    \x04\xa2\x02\x04\n\n\r\n\x05\x04\x1a\x02\x04\x01\x12\x04\xa2\x02\x0b!\n\
    \r\n\x05\x04\x1a\x02\x04\x03\x12\x04\xa2\x02$%\n\x0c\n\x04\x04\x1a\x02\
    \x05\x12\x04\xa3\x02\x04\x13\n\r\n\x05\x04\x1a\x02\x05\x05\x12\x04\xa3\
    \x02\x04\n\n\r\n\x05\x04\x1a\x02\x05\x01\x12\x04\xa3\x02\x0b\x0e\n\r\n\
    \x05\x04\x1a\x02\x05\x03\x12\x04\xa3\x02\x11\x12\n\x0c\n\x02\x04\x1b\x12\
    \x06\xa6\x02\0\xac\x02\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xa6\x02\x08\
    \x1f\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xa7\x02\x04\x18\n\r\n\x05\x04\x1b\
    \x02\0\x05\x12\x04\xa7\x02\x04\n\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xa7\
    \x02\x0b\x13\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xa7\x02\x16\x17\n\x0c\n\
    \x04\x04\x1b\x02\x01\x12\x04\xa8\x02\x04\x1f\n\r\n\x05\x04\x1b\x02\x01\
    \x05\x12\x04\xa8\x02\x04\t\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xa8\x02\
    \n\x1a\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xa8\x02\x1d\x1e\n\x0c\n\x04\
    \x04\x1b\x02\x02\x12\x04\xa9\x02\x04%\n\r\n\x05\x04\x1b\x02\x02\x05\x12\
    \x04\xa9\x02\x04\n\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xa9\x02\x0b\x20\
    \n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xa9\x02#$\n\x0c\n\x04\x04\x1b\x02\
    \x03\x12\x04\xaa\x02\x04(\n\r\n\x05\x04\x1b\x02\x03\x06\x12\x04\xaa\x02\
    \x04\x0f\n\r\n\x05\x04\x1b\x02\x03\x01\x12\x04\xaa\x02\x10#\n\r\n\x05\
    \x04\x1b\x02\x03\x03\x12\x04\xaa\x02&'\n\x0c\n\x04\x04\x1b\x02\x04\x12\
    \x04\xab\x02\x04\x13\n\r\n\x05\x04\x1b\x02\x04\x05\x12\x04\xab\x02\x04\n\
    \n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\xab\x02\x0b\x0e\n\r\n\x05\x04\x1b\
    \x02\x04\x03\x12\x04\xab\x02\x11\x12\n\x0c\n\x02\x04\x1c\x12\x06\xae\x02\
    \0\xb3\x02\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xae\x02\x08\x20\n\x0c\n\
    \x04\x04\x1c\x02\0\x12\x04\xaf\x02\x04\x18\n\r\n\x05\x04\x1c\x02\0\x05\
    \x12\x04\xaf\x02\x04\n\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xaf\x02\x0b\
    \x13\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xaf\x02\x16\x17\n\x0c\n\x04\x04\
    \x1c\x02\x01\x12\x04\xb0\x02\x04\x18\n\r\n\x05\x04\x1c\x02\x01\x05\x12\
    \x04\xb0\x02\x04\t\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xb0\x02\n\x13\n\
    \r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xb0\x02\x16\x17\n\x0c\n\x04\x04\x1c\
    \x02\x02\x12\x04\xb1\x02\x04(\n\r\n\x05\x04\x1c\x02\x02\x06\x12\x04\xb1\
    \x02\x04\x0f\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xb1\x02\x10#\n\r\n\
    \x05\x04\x1c\x02\x02\x03\x12\x04\xb1\x02&'\n\x0c\n\x04\x04\x1c\x02\x03\
    \x12\x04\xb2\x02\x04\x13\n\r\n\x05\x04\x1c\x02\x03\x05\x12\x04\xb2\x02\
    \x04\n\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\xb2\x02\x0b\x0e\n\r\n\x05\
    \x04\x1c\x02\x03\x03\x12\x04\xb2\x02\x11\x12\n\x0c\n\x02\x04\x1d\x12\x06\
    \xb5\x02\0\xba\x02\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xb5\x02\x08(\n\
    \x0c\n\x04\x04\x1d\x02\0\x12\x04\xb6\x02\x04\x18\n\r\n\x05\x04\x1d\x02\0\
    \x05\x12\x04\xb6\x02\x04\n\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xb6\x02\
    \x0b\x13\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xb6\x02\x16\x17\n\x0c\n\x04\
    \x04\x1d\x02\x01\x12\x04\xb7\x02\x04\x18\n\r\n\x05\x04\x1d\x02\x01\x05\
    \x12\x04\xb7\x02\x04\t\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xb7\x02\n\
    \x13\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xb7\x02\x16\x17\n\x0c\n\x04\
    \x04\x1d\x02\x02\x12\x04\xb8\x02\x04(\n\r\n\x05\x04\x1d\x02\x02\x06\x12\
    \x04\xb8\x02\x04\x0f\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\xb8\x02\x10#\
    \n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xb8\x02&'\n\x0c\n\x04\x04\x1d\x02\
    \x03\x12\x04\xb9\x02\x04\x13\n\r\n\x05\x04\x1d\x02\x03\x05\x12\x04\xb9\
    \x02\x04\n\n\r\n\x05\x04\x1d\x02\x03\x01\x12\x04\xb9\x02\x0b\x0e\n\r\n\
    \x05\x04\x1d\x02\x03\x03\x12\x04\xb9\x02\x11\x12\n\x0c\n\x02\x04\x1e\x12\
    \x06\xbc\x02\0\xc1\x02\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xbc\x02\x08(\
    \n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xbd\x02\x04\x13\n\r\n\x05\x04\x1e\x02\
    \0\x05\x12\x04\xbd\x02\x04\n\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xbd\x02\
    \x0b\x0e\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xbd\x02\x11\x12\n\x0c\n\x04\
    \x04\x1e\x02\x01\x12\x04\xbe\x02\x04\x18\n\r\n\x05\x04\x1e\x02\x01\x05\
    \x12\x04\xbe\x02\x04\n\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xbe\x02\x0b\
    \x13\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xbe\x02\x16\x17\n\x0c\n\x04\
    \x04\x1e\x02\x02\x12\x04\xbf\x02\x04\x1b\n\r\n\x05\x04\x1e\x02\x02\x05\
    \x12\x04\xbf\x02\x04\t\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\xbf\x02\n\
    \x16\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xbf\x02\x19\x1a\n\x0c\n\x04\
    \x04\x1e\x02\x03\x12\x04\xc0\x02\x04(\n\r\n\x05\x04\x1e\x02\x03\x06\x12\
    \x04\xc0\x02\x04\x0f\n\r\n\x05\x04\x1e\x02\x03\x01\x12\x04\xc0\x02\x10#\
    \n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\xc0\x02&'\n\x17\n\x02\x05\0\x12\
    \x06\xc5\x02\0\xca\x02\x012\t\x20dispute\n\n\x0b\n\x03\x05\0\x01\x12\x04\
    \xc5\x02\x05\x10\n\x0c\n\x04\x05\0\x02\0\x12\x04\xc6\x02\x04\x14\n\r\n\
    \x05\x05\0\x02\0\x01\x12\x04\xc6\x02\x04\x0f\n\r\n\x05\x05\0\x02\0\x02\
    \x12\x04\xc6\x02\x12\x13\n\x0c\n\x04\x05\0\x02\x01\x12\x04\xc7\x02\x04\
    \x12\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xc7\x02\x04\r\n\r\n\x05\x05\0\
    \x02\x01\x02\x12\x04\xc7\x02\x10\x11\n\x0c\n\x04\x05\0\x02\x02\x12\x04\
    \xc8\x02\x04\x0e\n\r\n\x05\x05\0\x02\x02\x01\x12\x04\xc8\x02\x04\t\n\r\n\
    \x05\x05\0\x02\x02\x02\x12\x04\xc8\x02\x0c\r\n\x0c\n\x04\x05\0\x02\x03\
    \x12\x04\xc9\x02\x04\x0f\n\r\n\x05\x05\0\x02\x03\x01\x12\x04\xc9\x02\x04\
    \n\n\r\n\x05\x05\0\x02\x03\x02\x12\x04\xc9\x02\r\x0e\n\x0c\n\x02\x04\x1f\
    \x12\x06\xcc\x02\0\xd1\x02\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xcc\x02\
    \x08\x1d\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xcd\x02\x04\x18\n\r\n\x05\x04\
    \x1f\x02\0\x06\x12\x04\xcd\x02\x04\x0b\n\r\n\x05\x04\x1f\x02\0\x01\x12\
    \x04\xcd\x02\x0c\x13\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xcd\x02\x16\x17\
    \n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\xce\x02\x04(\n\r\n\x05\x04\x1f\x02\
    \x01\x06\x12\x04\xce\x02\x04\x0f\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\
    \xce\x02\x10#\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xce\x02&'\n\x0c\n\
    \x04\x04\x1f\x02\x02\x12\x04\xcf\x02\x04\x13\n\r\n\x05\x04\x1f\x02\x02\
    \x05\x12\x04\xcf\x02\x04\n\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\xcf\x02\
    \x0b\x0e\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\xcf\x02\x11\x12\n\x0c\n\
    \x04\x04\x1f\x02\x03\x12\x04\xd0\x02\x04\x19\n\r\n\x05\x04\x1f\x02\x03\
    \x06\x12\x04\xd0\x02\x04\x0f\n\r\n\x05\x04\x1f\x02\x03\x01\x12\x04\xd0\
    \x02\x10\x14\n\r\n\x05\x04\x1f\x02\x03\x03\x12\x04\xd0\x02\x17\x18\n\x0c\
    \n\x02\x04\x20\x12\x06\xd3\x02\0\xd8\x02\x01\n\x0b\n\x03\x04\x20\x01\x12\
    \x04\xd3\x02\x08\x20\n\x0c\n\x04\x04\x20\x02\0\x12\x04\xd4\x02\x04\x18\n\
    \r\n\x05\x04\x20\x02\0\x06\x12\x04\xd4\x02\x04\x0b\n\r\n\x05\x04\x20\x02\
    \0\x01\x12\x04\xd4\x02\x0c\x13\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xd4\
    \x02\x16\x17\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\xd5\x02\x04(\n\r\n\x05\
    \x04\x20\x02\x01\x06\x12\x04\xd5\x02\x04\x0f\n\r\n\x05\x04\x20\x02\x01\
    \x01\x12\x04\xd5\x02\x10#\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\xd5\x02&\
    '\n\x0c\n\x04\x04\x20\x02\x02\x12\x04\xd6\x02\x04\x13\n\r\n\x05\x04\x20\
    \x02\x02\x05\x12\x04\xd6\x02\x04\n\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\
    \xd6\x02\x0b\x0e\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\xd6\x02\x11\x12\n\
    \x0c\n\x04\x04\x20\x02\x03\x12\x04\xd7\x02\x04\x19\n\r\n\x05\x04\x20\x02\
    \x03\x06\x12\x04\xd7\x02\x04\x0f\n\r\n\x05\x04\x20\x02\x03\x01\x12\x04\
    \xd7\x02\x10\x14\n\r\n\x05\x04\x20\x02\x03\x03\x12\x04\xd7\x02\x17\x18\n\
    \x0c\n\x02\x04!\x12\x06\xda\x02\0\xeb\x02\x01\n\x0b\n\x03\x04!\x01\x12\
    \x04\xda\x02\x08\x13\n\x0c\n\x04\x04!\x02\0\x12\x04\xdb\x02\x04\x13\n\r\
    \n\x05\x04!\x02\0\x05\x12\x04\xdb\x02\x04\t\n\r\n\x05\x04!\x02\0\x01\x12\
    \x04\xdb\x02\n\x0e\n\r\n\x05\x04!\x02\0\x03\x12\x04\xdb\x02\x11\x12\n\
    \x0c\n\x04\x04!\x02\x01\x12\x04\xdc\x02\x04\x18\n\r\n\x05\x04!\x02\x01\
    \x05\x12\x04\xdc\x02\x04\n\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xdc\x02\
    \x0b\x13\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xdc\x02\x16\x17\n\x0c\n\x04\
    \x04!\x02\x02\x12\x04\xdd\x02\x04\x18\n\r\n\x05\x04!\x02\x02\x05\x12\x04\
    \xdd\x02\x04\t\n\r\n\x05\x04!\x02\x02\x01\x12\x04\xdd\x02\n\x13\n\r\n\
    \x05\x04!\x02\x02\x03\x12\x04\xdd\x02\x16\x17\n\x0c\n\x04\x04!\x02\x03\
    \x12\x04\xde\x02\x04\x1e\n\r\n\x05\x04!\x02\x03\x05\x12\x04\xde\x02\x04\
    \x08\n\r\n\x05\x04!\x02\x03\x01\x12\x04\xde\x02\t\x19\n\r\n\x05\x04!\x02\
    \x03\x03\x12\x04\xde\x02\x1c\x1d\n\x0c\n\x04\x04!\x02\x04\x12\x04\xdf\
    \x02\x04\x17\n\r\n\x05\x04!\x02\x04\x05\x12\x04\xdf\x02\x04\n\n\r\n\x05\
    \x04!\x02\x04\x01\x12\x04\xdf\x02\x0b\x12\n\r\n\x05\x04!\x02\x04\x03\x12\
    \x04\xdf\x02\x15\x16\n\x0c\n\x04\x04!\x02\x05\x12\x04\xe0\x02\x04(\n\r\n\
    \x05\x04!\x02\x05\x04\x12\x04\xe0\x02\x04\x0c\n\r\n\x05\x04!\x02\x05\x06\
    \x12\x04\xe0\x02\r\x17\n\r\n\x05\x04!\x02\x05\x01\x12\x04\xe0\x02\x18#\n\
    \r\n\x05\x04!\x02\x05\x03\x12\x04\xe0\x02&'\n\x0c\n\x04\x04!\x02\x06\x12\
    \x04\xe1\x02\x04\x15\n\r\n\x05\x04!\x02\x06\x05\x12\x04\xe1\x02\x04\x08\
    \n\r\n\x05\x04!\x02\x06\x01\x12\x04\xe1\x02\t\x10\n\r\n\x05\x04!\x02\x06\
    \x03\x12\x04\xe1\x02\x13\x14\n\x0c\n\x04\x04!\x02\x07\x12\x04\xe2\x02\
    \x04\x1f\n\r\n\x05\x04!\x02\x07\x05\x12\x04\xe2\x02\x04\x08\n\r\n\x05\
    \x04!\x02\x07\x01\x12\x04\xe2\x02\t\x1a\n\r\n\x05\x04!\x02\x07\x03\x12\
    \x04\xe2\x02\x1d\x1e\n\x0c\n\x04\x04!\x02\x08\x12\x04\xe3\x02\x04\x1f\n\
    \r\n\x05\x04!\x02\x08\x05\x12\x04\xe3\x02\x04\x08\n\r\n\x05\x04!\x02\x08\
    \x01\x12\x04\xe3\x02\t\x1a\n\r\n\x05\x04!\x02\x08\x03\x12\x04\xe3\x02\
    \x1d\x1e\n\x0c\n\x04\x04!\x02\t\x12\x04\xe4\x02\x04)\n\r\n\x05\x04!\x02\
    \t\x06\x12\x04\xe4\x02\x04\x0f\n\r\n\x05\x04!\x02\t\x01\x12\x04\xe4\x02\
    \x10#\n\r\n\x05\x04!\x02\t\x03\x12\x04\xe4\x02&(\n\x0c\n\x04\x04!\x02\n\
    \x12\x04\xe5\x02\x04\x14\n\r\n\x05\x04!\x02\n\x05\x12\x04\xe5\x02\x04\n\
    \n\r\n\x05\x04!\x02\n\x01\x12\x04\xe5\x02\x0b\x0e\n\r\n\x05\x04!\x02\n\
    \x03\x12\x04\xe5\x02\x11\x13\n\x0c\n\x04\x04!\x02\x0b\x12\x04\xe6\x02\
    \x04#\n\r\n\x05\x04!\x02\x0b\x05\x12\x04\xe6\x02\x04\n\n\r\n\x05\x04!\
    \x02\x0b\x01\x12\x04\xe6\x02\x0b\x1d\n\r\n\x05\x04!\x02\x0b\x03\x12\x04\
    \xe6\x02\x20\"\n\x0c\n\x04\x04!\x02\x0c\x12\x04\xe7\x02\x04\x1b\n\r\n\
    \x05\x04!\x02\x0c\x05\x12\x04\xe7\x02\x04\x08\n\r\n\x05\x04!\x02\x0c\x01\
    \x12\x04\xe7\x02\t\x15\n\r\n\x05\x04!\x02\x0c\x03\x12\x04\xe7\x02\x18\
    \x1a\n\x0c\n\x04\x04!\x02\r\x12\x04\xe8\x02\x04\x1a\n\r\n\x05\x04!\x02\r\
    \x05\x12\x04\xe8\x02\x04\n\n\r\n\x05\x04!\x02\r\x01\x12\x04\xe8\x02\x0b\
    \x14\n\r\n\x05\x04!\x02\r\x03\x12\x04\xe8\x02\x17\x19\n\x0c\n\x04\x04!\
    \x02\x0e\x12\x04\xe9\x02\x04\x1a\n\r\n\x05\x04!\x02\x0e\x06\x12\x04\xe9\
    \x02\x04\x0f\n\r\n\x05\x04!\x02\x0e\x01\x12\x04\xe9\x02\x10\x14\n\r\n\
    \x05\x04!\x02\x0e\x03\x12\x04\xe9\x02\x17\x19\n\x0c\n\x04\x04!\x02\x0f\
    \x12\x04\xea\x02\x04\x1c\n\r\n\x05\x04!\x02\x0f\x05\x12\x04\xea\x02\x04\
    \x08\n\r\n\x05\x04!\x02\x0f\x01\x12\x04\xea\x02\t\x16\n\r\n\x05\x04!\x02\
    \x0f\x03\x12\x04\xea\x02\x19\x1b\n\x0c\n\x02\x04\"\x12\x06\xed\x02\0\xf2\
    \x02\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xed\x02\x08\x1c\n\x0c\n\x04\x04\"\
    \x02\0\x12\x04\xee\x02\x04\x13\n\r\n\x05\x04\"\x02\0\x05\x12\x04\xee\x02\
    \x04\n\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xee\x02\x0b\x0e\n\r\n\x05\x04\"\
    \x02\0\x03\x12\x04\xee\x02\x11\x12\n\x0c\n\x04\x04\"\x02\x01\x12\x04\xef\
    \x02\x04%\n\r\n\x05\x04\"\x02\x01\x06\x12\x04\xef\x02\x04\x11\n\r\n\x05\
    \x04\"\x02\x01\x01\x12\x04\xef\x02\x12\x20\n\r\n\x05\x04\"\x02\x01\x03\
    \x12\x04\xef\x02#$\n\x0c\n\x04\x04\"\x02\x02\x12\x04\xf0\x02\x04(\n\r\n\
    \x05\x04\"\x02\x02\x06\x12\x04\xf0\x02\x04\x0f\n\r\n\x05\x04\"\x02\x02\
    \x01\x12\x04\xf0\x02\x10#\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xf0\x02&'\
    \n\x0c\n\x04\x04\"\x02\x03\x12\x04\xf1\x02\x04\x19\n\r\n\x05\x04\"\x02\
    \x03\x06\x12\x04\xf1\x02\x04\x0f\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\xf1\
    \x02\x10\x14\n\r\n\x05\x04\"\x02\x03\x03\x12\x04\xf1\x02\x17\x18\n\x0c\n\
    \x02\x04#\x12\x06\xf4\x02\0\xfa\x02\x01\n\x0b\n\x03\x04#\x01\x12\x04\xf4\
    \x02\x08+\n\x0c\n\x04\x04#\x02\0\x12\x04\xf5\x02\x04\x13\n\r\n\x05\x04#\
    \x02\0\x05\x12\x04\xf5\x02\x04\n\n\r\n\x05\x04#\x02\0\x01\x12\x04\xf5\
    \x02\x0b\x0e\n\r\n\x05\x04#\x02\0\x03\x12\x04\xf5\x02\x11\x12\n\x0c\n\
    \x04\x04#\x02\x01\x12\x04\xf6\x02\x04\x1a\n\r\n\x05\x04#\x02\x01\x05\x12\
    \x04\xf6\x02\x04\t\n\r\n\x05\x04#\x02\x01\x01\x12\x04\xf6\x02\n\x15\n\r\
    \n\x05\x04#\x02\x01\x03\x12\x04\xf6\x02\x18\x19\n\x0c\n\x04\x04#\x02\x02\
    \x12\x04\xf7\x02\x04\x18\n\r\n\x05\x04#\x02\x02\x05\x12\x04\xf7\x02\x04\
    \n\n\r\n\x05\x04#\x02\x02\x01\x12\x04\xf7\x02\x0b\x13\n\r\n\x05\x04#\x02\
    \x02\x03\x12\x04\xf7\x02\x16\x17\n\x0c\n\x04\x04#\x02\x03\x12\x04\xf8\
    \x02\x04(\n\r\n\x05\x04#\x02\x03\x06\x12\x04\xf8\x02\x04\x0f\n\r\n\x05\
    \x04#\x02\x03\x01\x12\x04\xf8\x02\x10#\n\r\n\x05\x04#\x02\x03\x03\x12\
    \x04\xf8\x02&'\n\x0c\n\x04\x04#\x02\x04\x12\x04\xf9\x02\x04\x19\n\r\n\
    \x05\x04#\x02\x04\x06\x12\x04\xf9\x02\x04\x0f\n\r\n\x05\x04#\x02\x04\x01\
    \x12\x04\xf9\x02\x10\x14\n\r\n\x05\x04#\x02\x04\x03\x12\x04\xf9\x02\x17\
    \x18\n\x0c\n\x02\x04$\x12\x06\xfc\x02\0\x80\x03\x01\n\x0b\n\x03\x04$\x01\
    \x12\x04\xfc\x02\x08\"\n\x0c\n\x04\x04$\x02\0\x12\x04\xfd\x02\x04\x13\n\
    \r\n\x05\x04$\x02\0\x05\x12\x04\xfd\x02\x04\n\n\r\n\x05\x04$\x02\0\x01\
    \x12\x04\xfd\x02\x0b\x0e\n\r\n\x05\x04$\x02\0\x03\x12\x04\xfd\x02\x11\
    \x12\n\x0c\n\x04\x04$\x02\x01\x12\x04\xfe\x02\x04(\n\r\n\x05\x04$\x02\
    \x01\x06\x12\x04\xfe\x02\x04\x0f\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xfe\
    \x02\x10#\n\r\n\x05\x04$\x02\x01\x03\x12\x04\xfe\x02&'\n\x0c\n\x04\x04$\
    \x02\x02\x12\x04\xff\x02\x04@\n\r\n\x05\x04$\x02\x02\x06\x12\x04\xff\x02\
    \x04\x1e\n\r\n\x05\x04$\x02\x02\x01\x12\x04\xff\x02\x1f;\n\r\n\x05\x04$\
    \x02\x02\x03\x12\x04\xff\x02>?\n\x13\n\x02\x04%\x12\x06\x84\x03\0\x89\
    \x03\x012\x05\x20DAO\n\n\x0b\n\x03\x04%\x01\x12\x04\x84\x03\x08\x18\n\
    \x0c\n\x04\x04%\x02\0\x12\x04\x85\x03\x04\x20\n\r\n\x05\x04%\x02\0\x05\
    \x12\x04\x85\x03\x04\t\n\r\n\x05\x04%\x02\0\x01\x12\x04\x85\x03\n\x1b\n\
    \r\n\x05\x04%\x02\0\x03\x12\x04\x85\x03\x1e\x1f\n\x0c\n\x04\x04%\x02\x01\
    \x12\x04\x86\x03\x04\x14\n\r\n\x05\x04%\x02\x01\x05\x12\x04\x86\x03\x04\
    \t\n\r\n\x05\x04%\x02\x01\x01\x12\x04\x86\x03\n\x0f\n\r\n\x05\x04%\x02\
    \x01\x03\x12\x04\x86\x03\x12\x13\n\x0c\n\x04\x04%\x02\x02\x12\x04\x87\
    \x03\x04(\n\r\n\x05\x04%\x02\x02\x06\x12\x04\x87\x03\x04\x0f\n\r\n\x05\
    \x04%\x02\x02\x01\x12\x04\x87\x03\x10#\n\r\n\x05\x04%\x02\x02\x03\x12\
    \x04\x87\x03&'\n\x0c\n\x04\x04%\x02\x03\x12\x04\x88\x03\x04.\n\r\n\x05\
    \x04%\x02\x03\x04\x12\x04\x88\x03\x04\x0c\n\r\n\x05\x04%\x02\x03\x05\x12\
    \x04\x88\x03\r\x12\n\r\n\x05\x04%\x02\x03\x01\x12\x04\x88\x03\x13)\n\r\n\
    \x05\x04%\x02\x03\x03\x12\x04\x88\x03,-\n\x0c\n\x02\x04&\x12\x06\x8b\x03\
    \0\x8f\x03\x01\n\x0b\n\x03\x04&\x01\x12\x04\x8b\x03\x08\x19\ng\n\x04\x04\
    &\x02\0\x12\x04\x8d\x03\x04&\x1aY\x20Because\x20of\x20the\x20way\x20how\
    \x20PB\x20implements\x20inheritance\x20we\x20need\x20to\x20use\x20the\
    \x20super\x20class\x20as\x20type\n\n\r\n\x05\x04&\x02\0\x04\x12\x04\x8d\
    \x03\x04\x0c\n\r\n\x05\x04&\x02\0\x06\x12\x04\x8d\x03\r\x16\n\r\n\x05\
    \x04&\x02\0\x01\x12\x04\x8d\x03\x17!\n\r\n\x05\x04&\x02\0\x03\x12\x04\
    \x8d\x03$%\n\x0c\n\x04\x04&\x02\x01\x12\x04\x8e\x03\x04\x1c\n\r\n\x05\
    \x04&\x02\x01\x05\x12\x04\x8e\x03\x04\t\n\r\n\x05\x04&\x02\x01\x01\x12\
    \x04\x8e\x03\n\x17\n\r\n\x05\x04&\x02\x01\x03\x12\x04\x8e\x03\x1a\x1b\n\
    \x0c\n\x02\x04'\x12\x06\x91\x03\0\x94\x03\x01\n\x0b\n\x03\x04'\x01\x12\
    \x04\x91\x03\x08\x20\ng\n\x04\x04'\x02\0\x12\x04\x93\x03\x04\x1c\x1aY\
    \x20Because\x20of\x20the\x20way\x20how\x20PB\x20implements\x20inheritanc\
    e\x20we\x20need\x20to\x20use\x20the\x20super\x20class\x20as\x20type\n\n\
    \r\n\x05\x04'\x02\0\x06\x12\x04\x93\x03\x04\r\n\r\n\x05\x04'\x02\0\x01\
    \x12\x04\x93\x03\x0e\x17\n\r\n\x05\x04'\x02\0\x03\x12\x04\x93\x03\x1a\
    \x1b\n\x0c\n\x02\x04(\x12\x06\x96\x03\0\x97\x03\x01\n\x0b\n\x03\x04(\x01\
    \x12\x04\x96\x03\x08&\n\x0c\n\x02\x04)\x12\x06\x99\x03\0\x9b\x03\x01\n\
    \x0b\n\x03\x04)\x01\x12\x04\x99\x03\x08\x1e\n\x0c\n\x04\x04)\x02\0\x12\
    \x04\x9a\x03\x04\x20\n\r\n\x05\x04)\x02\0\x06\x12\x04\x9a\x03\x04\x10\n\
    \r\n\x05\x04)\x02\0\x01\x12\x04\x9a\x03\x11\x1b\n\r\n\x05\x04)\x02\0\x03\
    \x12\x04\x9a\x03\x1e\x1f\n\x0c\n\x02\x04*\x12\x06\x9d\x03\0\x9f\x03\x01\
    \n\x0b\n\x03\x04*\x01\x12\x04\x9d\x03\x08#\n\x0c\n\x04\x04*\x02\0\x12\
    \x04\x9e\x03\x04%\n\r\n\x05\x04*\x02\0\x06\x12\x04\x9e\x03\x04\x15\n\r\n\
    \x05\x04*\x02\0\x01\x12\x04\x9e\x03\x16\x20\n\r\n\x05\x04*\x02\0\x03\x12\
    \x04\x9e\x03#$\n\x0c\n\x02\x04+\x12\x06\xa1\x03\0\xa3\x03\x01\n\x0b\n\
    \x03\x04+\x01\x12\x04\xa1\x03\x08$\n\x0c\n\x04\x04+\x02\0\x12\x04\xa2\
    \x03\x04&\n\r\n\x05\x04+\x02\0\x06\x12\x04\xa2\x03\x04\x16\n\r\n\x05\x04\
    +\x02\0\x01\x12\x04\xa2\x03\x17!\n\r\n\x05\x04+\x02\0\x03\x12\x04\xa2\
    \x03$%\n\x0c\n\x02\x04,\x12\x06\xa5\x03\0\xa8\x03\x01\n\x0b\n\x03\x04,\
    \x01\x12\x04\xa5\x03\x08\x20\n\x0c\n\x04\x04,\x02\0\x12\x04\xa6\x03\x04\
    \x15\n\r\n\x05\x04,\x02\0\x05\x12\x04\xa6\x03\x04\t\n\r\n\x05\x04,\x02\0\
    \x01\x12\x04\xa6\x03\n\x10\n\r\n\x05\x04,\x02\0\x03\x12\x04\xa6\x03\x13\
    \x14\n\x0c\n\x04\x04,\x02\x01\x12\x04\xa7\x03\x04\x14\n\r\n\x05\x04,\x02\
    \x01\x05\x12\x04\xa7\x03\x04\t\n\r\n\x05\x04,\x02\x01\x01\x12\x04\xa7\
    \x03\n\x0f\n\r\n\x05\x04,\x02\x01\x03\x12\x04\xa7\x03\x12\x13\n\x0c\n\
    \x02\x04-\x12\x06\xaa\x03\0\xad\x03\x01\n\x0b\n\x03\x04-\x01\x12\x04\xaa\
    \x03\x08%\n\x0c\n\x04\x04-\x02\0\x12\x04\xab\x03\x04\x15\n\r\n\x05\x04-\
    \x02\0\x05\x12\x04\xab\x03\x04\t\n\r\n\x05\x04-\x02\0\x01\x12\x04\xab\
    \x03\n\x10\n\r\n\x05\x04-\x02\0\x03\x12\x04\xab\x03\x13\x14\n\x0c\n\x04\
    \x04-\x02\x01\x12\x04\xac\x03\x04\x14\n\r\n\x05\x04-\x02\x01\x05\x12\x04\
    \xac\x03\x04\t\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xac\x03\n\x0f\n\r\n\
    \x05\x04-\x02\x01\x03\x12\x04\xac\x03\x12\x13\n\x0c\n\x02\x04.\x12\x06\
    \xaf\x03\0\xb2\x03\x01\n\x0b\n\x03\x04.\x01\x12\x04\xaf\x03\x08&\n\x0c\n\
    \x04\x04.\x02\0\x12\x04\xb0\x03\x04\x15\n\r\n\x05\x04.\x02\0\x05\x12\x04\
    \xb0\x03\x04\t\n\r\n\x05\x04.\x02\0\x01\x12\x04\xb0\x03\n\x10\n\r\n\x05\
    \x04.\x02\0\x03\x12\x04\xb0\x03\x13\x14\n\x0c\n\x04\x04.\x02\x01\x12\x04\
    \xb1\x03\x04\x14\n\r\n\x05\x04.\x02\x01\x05\x12\x04\xb1\x03\x04\t\n\r\n\
    \x05\x04.\x02\x01\x01\x12\x04\xb1\x03\n\x0f\n\r\n\x05\x04.\x02\x01\x03\
    \x12\x04\xb1\x03\x12\x13\n\x0c\n\x02\x04/\x12\x06\xb4\x03\0\xb7\x03\x01\
    \n\x0b\n\x03\x04/\x01\x12\x04\xb4\x03\x08!\n\x0c\n\x04\x04/\x02\0\x12\
    \x04\xb5\x03\x04+\n\r\n\x05\x04/\x02\0\x04\x12\x04\xb5\x03\x04\x0c\n\r\n\
    \x05\x04/\x02\0\x06\x12\x04\xb5\x03\r\x19\n\r\n\x05\x04/\x02\0\x01\x12\
    \x04\xb5\x03\x1a&\n\r\n\x05\x04/\x02\0\x03\x12\x04\xb5\x03)*\n\x0c\n\x04\
    \x04/\x02\x01\x12\x04\xb6\x03\x04\x1c\n\r\n\x05\x04/\x02\x01\x05\x12\x04\
    \xb6\x03\x04\t\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xb6\x03\n\x17\n\r\n\
    \x05\x04/\x02\x01\x03\x12\x04\xb6\x03\x1a\x1b\n\x0c\n\x02\x040\x12\x06\
    \xb9\x03\0\xbc\x03\x01\n\x0b\n\x03\x040\x01\x12\x04\xb9\x03\x08&\n\x0c\n\
    \x04\x040\x02\0\x12\x04\xba\x03\x040\n\r\n\x05\x040\x02\0\x04\x12\x04\
    \xba\x03\x04\x0c\n\r\n\x05\x040\x02\0\x06\x12\x04\xba\x03\r\x1e\n\r\n\
    \x05\x040\x02\0\x01\x12\x04\xba\x03\x1f+\n\r\n\x05\x040\x02\0\x03\x12\
    \x04\xba\x03./\n\x0c\n\x04\x040\x02\x01\x12\x04\xbb\x03\x04\x1c\n\r\n\
    \x05\x040\x02\x01\x05\x12\x04\xbb\x03\x04\t\n\r\n\x05\x040\x02\x01\x01\
    \x12\x04\xbb\x03\n\x17\n\r\n\x05\x040\x02\x01\x03\x12\x04\xbb\x03\x1a\
    \x1b\n\x0c\n\x02\x041\x12\x06\xbe\x03\0\xc1\x03\x01\n\x0b\n\x03\x041\x01\
    \x12\x04\xbe\x03\x08'\n\x0c\n\x04\x041\x02\0\x12\x04\xbf\x03\x041\n\r\n\
    \x05\x041\x02\0\x04\x12\x04\xbf\x03\x04\x0c\n\r\n\x05\x041\x02\0\x06\x12\
    \x04\xbf\x03\r\x1f\n\r\n\x05\x041\x02\0\x01\x12\x04\xbf\x03\x20,\n\r\n\
    \x05\x041\x02\0\x03\x12\x04\xbf\x03/0\n\x0c\n\x04\x041\x02\x01\x12\x04\
    \xc0\x03\x04\x1c\n\r\n\x05\x041\x02\x01\x05\x12\x04\xc0\x03\x04\t\n\r\n\
    \x05\x041\x02\x01\x01\x12\x04\xc0\x03\n\x17\n\r\n\x05\x041\x02\x01\x03\
    \x12\x04\xc0\x03\x1a\x1b\n\xd4\x01\n\x02\x042\x12\x06\xc9\x03\0\xcc\x03\
    \x012\xbd\x01///////////////////////////////////////////////////////////\
    //////////////////////////////\n\x20Payload\n///////////////////////////\
    //////////////////////////////////////////////////////////////\n2\x06\
    \x20core\n\n\x0b\n\x03\x042\x01\x12\x04\xc9\x03\x08\x13\n\x0c\n\x04\x042\
    \x02\0\x12\x04\xca\x03\x04\x19\n\r\n\x05\x042\x02\0\x05\x12\x04\xca\x03\
    \x04\n\n\r\n\x05\x042\x02\0\x01\x12\x04\xca\x03\x0b\x14\n\r\n\x05\x042\
    \x02\0\x03\x12\x04\xca\x03\x17\x18\n\x0c\n\x04\x042\x02\x01\x12\x04\xcb\
    \x03\x04\x13\n\r\n\x05\x042\x02\x01\x05\x12\x04\xcb\x03\x04\t\n\r\n\x05\
    \x042\x02\x01\x01\x12\x04\xcb\x03\n\x0e\n\r\n\x05\x042\x02\x01\x03\x12\
    \x04\xcb\x03\x11\x12\n\x0c\n\x02\x043\x12\x06\xce\x03\0\xd2\x03\x01\n\
    \x0b\n\x03\x043\x01\x12\x04\xce\x03\x08\x0c\n\x0c\n\x04\x043\x02\0\x12\
    \x04\xcf\x03\x04!\n\r\n\x05\x043\x02\0\x06\x12\x04\xcf\x03\x04\x0f\n\r\n\
    \x05\x043\x02\0\x01\x12\x04\xcf\x03\x10\x1c\n\r\n\x05\x043\x02\0\x03\x12\
    \x04\xcf\x03\x1f\x20\n\x0c\n\x04\x043\x02\x01\x12\x04\xd0\x03\x04\x13\n\
    \r\n\x05\x043\x02\x01\x05\x12\x04\xd0\x03\x04\t\n\r\n\x05\x043\x02\x01\
    \x01\x12\x04\xd0\x03\n\x0e\n\r\n\x05\x043\x02\x01\x03\x12\x04\xd0\x03\
    \x11\x12\n\x0c\n\x04\x043\x02\x02\x12\x04\xd1\x03\x04.\n\r\n\x05\x043\
    \x02\x02\x04\x12\x04\xd1\x03\x04\x0c\n\r\n\x05\x043\x02\x02\x05\x12\x04\
    \xd1\x03\r\x12\n\r\n\x05\x043\x02\x02\x01\x12\x04\xd1\x03\x13)\n\r\n\x05\
    \x043\x02\x02\x03\x12\x04\xd1\x03,-\n\x0c\n\x02\x044\x12\x06\xd4\x03\0\
    \xd8\x03\x01\n\x0b\n\x03\x044\x01\x12\x04\xd4\x03\x08\x12\n\x0c\n\x04\
    \x044\x02\0\x12\x04\xd5\x03\x04&\n\r\n\x05\x044\x02\0\x05\x12\x04\xd5\
    \x03\x04\t\n\r\n\x05\x044\x02\0\x01\x12\x04\xd5\x03\n!\n\r\n\x05\x044\
    \x02\0\x03\x12\x04\xd5\x03$%\n\x0c\n\x04\x044\x02\x01\x12\x04\xd6\x03\
    \x04'\n\r\n\x05\x044\x02\x01\x05\x12\x04\xd6\x03\x04\t\n\r\n\x05\x044\
    \x02\x01\x01\x12\x04\xd6\x03\n\"\n\r\n\x05\x044\x02\x01\x03\x12\x04\xd6\
    \x03%&\n2\n\x03\x044\t\x12\x04\xd7\x03\x04\x0f\"%\x20WAS:\x20string\x20p\
    gp_pub_key_as_pem\x20=\x203;\n\n\x0c\n\x04\x044\t\0\x12\x04\xd7\x03\r\
    \x0e\n\r\n\x05\x044\t\0\x01\x12\x04\xd7\x03\r\x0e\n\r\n\x05\x044\t\0\x02\
    \x12\x04\xd7\x03\r\x0e\n\x0c\n\x02\x045\x12\x06\xda\x03\0\xdf\x03\x01\n\
    \x0b\n\x03\x045\x01\x12\x04\xda\x03\x08\x17\n\x0c\n\x04\x045\x02\0\x12\
    \x04\xdb\x03\x04#\n\r\n\x05\x045\x02\0\x05\x12\x04\xdb\x03\x04\t\n\r\n\
    \x05\x045\x02\0\x01\x12\x04\xdb\x03\n\x1e\n\r\n\x05\x045\x02\0\x03\x12\
    \x04\xdb\x03!\"\n\x0c\n\x04\x045\x02\x01\x12\x04\xdc\x03\x04*\n\r\n\x05\
    \x045\x02\x01\x05\x12\x04\xdc\x03\x04\t\n\r\n\x05\x045\x02\x01\x01\x12\
    \x04\xdc\x03\n%\n\r\n\x05\x045\x02\x01\x03\x12\x04\xdc\x03()\n\x0c\n\x04\
    \x045\x02\x02\x12\x04\xdd\x03\x04\x18\n\r\n\x05\x045\x02\x02\x05\x12\x04\
    \xdd\x03\x04\t\n\r\n\x05\x045\x02\x02\x01\x12\x04\xdd\x03\n\x13\n\r\n\
    \x05\x045\x02\x02\x03\x12\x04\xdd\x03\x16\x17\n\x0c\n\x04\x045\x02\x03\
    \x12\x04\xde\x03\x04#\n\r\n\x05\x045\x02\x03\x05\x12\x04\xde\x03\x04\t\n\
    \r\n\x05\x045\x02\x03\x01\x12\x04\xde\x03\n\x1e\n\r\n\x05\x045\x02\x03\
    \x03\x12\x04\xde\x03!\"\n\x17\n\x02\x046\x12\x06\xe3\x03\0\xf3\x03\x012\
    \t\x20storage\n\n\x0b\n\x03\x046\x01\x12\x04\xe3\x03\x08\x16\n\x0e\n\x04\
    \x046\x08\0\x12\x06\xe4\x03\x04\xf2\x03\x05\n\r\n\x05\x046\x08\0\x01\x12\
    \x04\xe4\x03\n\x11\n\x0c\n\x04\x046\x02\0\x12\x04\xe5\x03\x08\x18\n\r\n\
    \x05\x046\x02\0\x06\x12\x04\xe5\x03\x08\r\n\r\n\x05\x046\x02\0\x01\x12\
    \x04\xe5\x03\x0e\x13\n\r\n\x05\x046\x02\0\x03\x12\x04\xe5\x03\x16\x17\n\
    \x0c\n\x04\x046\x02\x01\x12\x04\xe6\x03\x08\"\n\r\n\x05\x046\x02\x01\x06\
    \x12\x04\xe6\x03\x08\x12\n\r\n\x05\x046\x02\x01\x01\x12\x04\xe6\x03\x13\
    \x1d\n\r\n\x05\x046\x02\x01\x03\x12\x04\xe6\x03\x20!\n\x0c\n\x04\x046\
    \x02\x02\x12\x04\xe7\x03\x08\x1e\n\r\n\x05\x046\x02\x02\x06\x12\x04\xe7\
    \x03\x08\x10\n\r\n\x05\x046\x02\x02\x01\x12\x04\xe7\x03\x11\x19\n\r\n\
    \x05\x046\x02\x02\x03\x12\x04\xe7\x03\x1c\x1d\n\x0c\n\x04\x046\x02\x03\
    \x12\x04\xe8\x03\x08\x1a\n\r\n\x05\x046\x02\x03\x06\x12\x04\xe8\x03\x08\
    \x0e\n\r\n\x05\x046\x02\x03\x01\x12\x04\xe8\x03\x0f\x15\n\r\n\x05\x046\
    \x02\x03\x03\x12\x04\xe8\x03\x18\x19\n\xa3\x01\n\x04\x046\x02\x04\x12\
    \x04\xec\x03\x08A\x1a\x94\x01\x20not\x20used\x20anymore\x20from\x20v0.6\
    \x20on.\x20But\x20leave\x20it\x20for\x20receiving\x20TradeStatistics\x20\
    objects\x20from\x20older\n\x20versions\x20and\x20convert\x20it\x20to\x20\
    TradeStatistics2\x20objects.\n\n\r\n\x05\x046\x02\x04\x06\x12\x04\xec\
    \x03\x08\x17\n\r\n\x05\x046\x02\x04\x01\x12\x04\xec\x03\x18(\n\r\n\x05\
    \x046\x02\x04\x03\x12\x04\xec\x03+,\n\r\n\x05\x046\x02\x04\x08\x12\x04\
    \xec\x03-@\n\x0e\n\x06\x046\x02\x04\x08\x03\x12\x04\xec\x03.?\n\x0c\n\
    \x04\x046\x02\x05\x12\x04\xee\x03\x08:\n\r\n\x05\x046\x02\x05\x06\x12\
    \x04\xee\x03\x08\x1d\n\r\n\x05\x046\x02\x05\x01\x12\x04\xee\x03\x1e5\n\r\
    \n\x05\x046\x02\x05\x03\x12\x04\xee\x0389\n\x0c\n\x04\x046\x02\x06\x12\
    \x04\xef\x03\x08'\n\r\n\x05\x046\x02\x06\x06\x12\x04\xef\x03\x08\x14\n\r\
    \n\x05\x046\x02\x06\x01\x12\x04\xef\x03\x15\"\n\r\n\x05\x046\x02\x06\x03\
    \x12\x04\xef\x03%&\n\x0c\n\x04\x046\x02\x07\x12\x04\xf0\x03\x086\n\r\n\
    \x05\x046\x02\x07\x06\x12\x04\xf0\x03\x08\x1b\n\r\n\x05\x046\x02\x07\x01\
    \x12\x04\xf0\x03\x1c1\n\r\n\x05\x046\x02\x07\x03\x12\x04\xf0\x0345\n\x0c\
    \n\x04\x046\x02\x08\x12\x04\xf1\x03\x08%\n\r\n\x05\x046\x02\x08\x06\x12\
    \x04\xf1\x03\x08\x13\n\r\n\x05\x046\x02\x08\x01\x12\x04\xf1\x03\x14\x20\
    \n\r\n\x05\x046\x02\x08\x03\x12\x04\xf1\x03#$\n\x0c\n\x02\x047\x12\x06\
    \xf5\x03\0\xfd\x03\x01\n\x0b\n\x03\x047\x01\x12\x04\xf5\x03\x08!\n\x0e\n\
    \x04\x047\x08\0\x12\x06\xf6\x03\x04\xfc\x03\x05\n\r\n\x05\x047\x08\0\x01\
    \x12\x04\xf6\x03\n\x11\n\x0c\n\x04\x047\x02\0\x12\x04\xf7\x03\x082\n\r\n\
    \x05\x047\x02\0\x06\x12\x04\xf7\x03\x08\x19\n\r\n\x05\x047\x02\0\x01\x12\
    \x04\xf7\x03\x1a-\n\r\n\x05\x047\x02\0\x03\x12\x04\xf7\x0301\n\x0c\n\x04\
    \x047\x02\x01\x12\x04\xf8\x03\x08/\n\r\n\x05\x047\x02\x01\x06\x12\x04\
    \xf8\x03\x08\x18\n\r\n\x05\x047\x02\x01\x01\x12\x04\xf8\x03\x19*\n\r\n\
    \x05\x047\x02\x01\x03\x12\x04\xf8\x03-.\n\x0c\n\x04\x047\x02\x02\x12\x04\
    \xf9\x03\x08-\n\r\n\x05\x047\x02\x02\x06\x12\x04\xf9\x03\x08\x17\n\r\n\
    \x05\x047\x02\x02\x01\x12\x04\xf9\x03\x18(\n\r\n\x05\x047\x02\x02\x03\
    \x12\x04\xf9\x03+,\n\x0c\n\x04\x047\x02\x03\x12\x04\xfa\x03\x080\n\r\n\
    \x05\x047\x02\x03\x06\x12\x04\xfa\x03\x08\x18\n\r\n\x05\x047\x02\x03\x01\
    \x12\x04\xfa\x03\x19+\n\r\n\x05\x047\x02\x03\x03\x12\x04\xfa\x03./\n\x0c\
    \n\x04\x047\x02\x04\x12\x04\xfb\x03\x08)\n\r\n\x05\x047\x02\x04\x06\x12\
    \x04\xfb\x03\x08\x15\n\r\n\x05\x047\x02\x04\x01\x12\x04\xfb\x03\x16$\n\r\
    \n\x05\x047\x02\x04\x03\x12\x04\xfb\x03'(\n\x0c\n\x02\x048\x12\x06\xff\
    \x03\0\x85\x04\x01\n\x0b\n\x03\x048\x01\x12\x04\xff\x03\x08\x1d\n\x0c\n\
    \x04\x048\x02\0\x12\x04\x80\x04\x04&\n\r\n\x05\x048\x02\0\x06\x12\x04\
    \x80\x04\x04\x12\n\r\n\x05\x048\x02\0\x01\x12\x04\x80\x04\x13!\n\r\n\x05\
    \x048\x02\0\x03\x12\x04\x80\x04$%\n\x0c\n\x04\x048\x02\x01\x12\x04\x81\
    \x04\x04\"\n\r\n\x05\x048\x02\x01\x05\x12\x04\x81\x04\x04\t\n\r\n\x05\
    \x048\x02\x01\x01\x12\x04\x81\x04\n\x1d\n\r\n\x05\x048\x02\x01\x03\x12\
    \x04\x81\x04\x20!\n\x0c\n\x04\x048\x02\x02\x12\x04\x82\x04\x04\x1e\n\r\n\
    \x05\x048\x02\x02\x05\x12\x04\x82\x04\x04\t\n\r\n\x05\x048\x02\x02\x01\
    \x12\x04\x82\x04\n\x19\n\r\n\x05\x048\x02\x02\x03\x12\x04\x82\x04\x1c\
    \x1d\n\x0c\n\x04\x048\x02\x03\x12\x04\x83\x04\x04\x18\n\r\n\x05\x048\x02\
    \x03\x05\x12\x04\x83\x04\x04\t\n\r\n\x05\x048\x02\x03\x01\x12\x04\x83\
    \x04\n\x13\n\r\n\x05\x048\x02\x03\x03\x12\x04\x83\x04\x16\x17\n\x0c\n\
    \x04\x048\x02\x04\x12\x04\x84\x04\x04\"\n\r\n\x05\x048\x02\x04\x05\x12\
    \x04\x84\x04\x04\t\n\r\n\x05\x048\x02\x04\x01\x12\x04\x84\x04\n\x1d\n\r\
    \n\x05\x048\x02\x04\x03\x12\x04\x84\x04\x20!\n\x17\n\x02\x049\x12\x06\
    \x89\x04\0\x8e\x04\x012\t\x20mailbox\n\n\x0b\n\x03\x049\x01\x12\x04\x89\
    \x04\x08\x1b\n\x0e\n\x04\x049\x08\0\x12\x06\x8a\x04\x04\x8d\x04\x05\n\r\
    \n\x05\x049\x08\0\x01\x12\x04\x8a\x04\n\x11\n\x0c\n\x04\x049\x02\0\x12\
    \x04\x8b\x04\x08:\n\r\n\x05\x049\x02\0\x06\x12\x04\x8b\x04\x08\x1d\n\r\n\
    \x05\x049\x02\0\x01\x12\x04\x8b\x04\x1e5\n\r\n\x05\x049\x02\0\x03\x12\
    \x04\x8b\x0489\n\x0c\n\x04\x049\x02\x01\x12\x04\x8c\x04\x08I\n\r\n\x05\
    \x049\x02\x01\x06\x12\x04\x8c\x04\x08$\n\r\n\x05\x049\x02\x01\x01\x12\
    \x04\x8c\x04%D\n\r\n\x05\x049\x02\x01\x03\x12\x04\x8c\x04GH\n\x0c\n\x02\
    \x04:\x12\x06\x90\x04\0\x93\x04\x01\n\x0b\n\x03\x04:\x01\x12\x04\x90\x04\
    \x08$\n\x0c\n\x04\x04:\x02\0\x12\x04\x91\x04\x04$\n\r\n\x05\x04:\x02\0\
    \x06\x12\x04\x91\x04\x04\x19\n\r\n\x05\x04:\x02\0\x01\x12\x04\x91\x04\
    \x1a\x1f\n\r\n\x05\x04:\x02\0\x03\x12\x04\x91\x04\"#\n\x0c\n\x04\x04:\
    \x02\x01\x12\x04\x92\x04\x04&\n\r\n\x05\x04:\x02\x01\x05\x12\x04\x92\x04\
    \x04\t\n\r\n\x05\x04:\x02\x01\x01\x12\x04\x92\x04\n!\n\r\n\x05\x04:\x02\
    \x01\x03\x12\x04\x92\x04$%\n\x0c\n\x02\x04;\x12\x06\x95\x04\0\x98\x04\
    \x01\n\x0b\n\x03\x04;\x01\x12\x04\x95\x04\x08\x18\n\x0c\n\x04\x04;\x02\0\
    \x12\x04\x96\x04\x04\x1f\n\r\n\x05\x04;\x02\0\x06\x12\x04\x96\x04\x04\
    \x12\n\r\n\x05\x04;\x02\0\x01\x12\x04\x96\x04\x13\x1a\n\r\n\x05\x04;\x02\
    \0\x03\x12\x04\x96\x04\x1d\x1e\n\x0c\n\x04\x04;\x02\x01\x12\x04\x97\x04\
    \x04\x1e\n\r\n\x05\x04;\x02\x01\x05\x12\x04\x97\x04\x04\t\n\r\n\x05\x04;\
    \x02\x01\x01\x12\x04\x97\x04\n\x19\n\r\n\x05\x04;\x02\x01\x03\x12\x04\
    \x97\x04\x1c\x1d\n\x14\n\x02\x04<\x12\x06\x9c\x04\0\xa0\x04\x012\x06\x20\
    misc\n\n\x0b\n\x03\x04<\x01\x12\x04\x9c\x04\x08\"\n\x0c\n\x04\x04<\x02\0\
    \x12\x04\x9d\x04\x04\x17\n\r\n\x05\x04<\x02\0\x05\x12\x04\x9d\x04\x04\n\
    \n\r\n\x05\x04<\x02\0\x01\x12\x04\x9d\x04\x0b\x12\n\r\n\x05\x04<\x02\0\
    \x03\x12\x04\x9d\x04\x15\x16\n\x0c\n\x04\x04<\x02\x01\x12\x04\x9e\x04\
    \x04#\n\r\n\x05\x04<\x02\x01\x05\x12\x04\x9e\x04\x04\n\n\r\n\x05\x04<\
    \x02\x01\x01\x12\x04\x9e\x04\x0b\x1e\n\r\n\x05\x04<\x02\x01\x03\x12\x04\
    \x9e\x04!\"\n\x0c\n\x04\x04<\x02\x02\x12\x04\x9f\x04\x04#\n\r\n\x05\x04<\
    \x02\x02\x05\x12\x04\x9f\x04\x04\t\n\r\n\x05\x04<\x02\x02\x01\x12\x04\
    \x9f\x04\n\x1e\n\r\n\x05\x04<\x02\x02\x03\x12\x04\x9f\x04!\"\n\x0c\n\x02\
    \x04=\x12\x06\xa2\x04\0\xa6\x04\x01\n\x0b\n\x03\x04=\x01\x12\x04\xa2\x04\
    \x08\x1c\n\x0c\n\x04\x04=\x02\0\x12\x04\xa3\x04\x04!\n\r\n\x05\x04=\x02\
    \0\x05\x12\x04\xa3\x04\x04\n\n\r\n\x05\x04=\x02\0\x01\x12\x04\xa3\x04\
    \x0b\x1c\n\r\n\x05\x04=\x02\0\x03\x12\x04\xa3\x04\x1f\x20\n\x0c\n\x04\
    \x04=\x02\x01\x12\x04\xa4\x04\x04\x1f\n\r\n\x05\x04=\x02\x01\x05\x12\x04\
    \xa4\x04\x04\n\n\r\n\x05\x04=\x02\x01\x01\x12\x04\xa4\x04\x0b\x1a\n\r\n\
    \x05\x04=\x02\x01\x03\x12\x04\xa4\x04\x1d\x1e\n\x0c\n\x04\x04=\x02\x02\
    \x12\x04\xa5\x04\x04\x15\n\r\n\x05\x04=\x02\x02\x05\x12\x04\xa5\x04\x04\
    \n\n\r\n\x05\x04=\x02\x02\x01\x12\x04\xa5\x04\x0b\x10\n\r\n\x05\x04=\x02\
    \x02\x03\x12\x04\xa5\x04\x13\x14\n\xd4\x01\n\x02\x04>\x12\x06\xac\x04\0\
    \xb3\x04\x012\xc5\x01///////////////////////////////////////////////////\
    //////////////////////////////////////\n\x20Storage\x20payload\n////////\
    ////////////////////////////////////////////////////////////////////////\
    /////////\n\n\x0b\n\x03\x04>\x01\x12\x04\xac\x04\x08\r\n\x0c\n\x04\x04>\
    \x02\0\x12\x04\xad\x04\x04\x17\n\r\n\x05\x04>\x02\0\x05\x12\x04\xad\x04\
    \x04\n\n\r\n\x05\x04>\x02\0\x01\x12\x04\xad\x04\x0b\x12\n\r\n\x05\x04>\
    \x02\0\x03\x12\x04\xad\x04\x15\x16\n\x0c\n\x04\x04>\x02\x01\x12\x04\xae\
    \x04\x04\x17\n\r\n\x05\x04>\x02\x01\x05\x12\x04\xae\x04\x04\n\n\r\n\x05\
    \x04>\x02\x01\x01\x12\x04\xae\x04\x0b\x12\n\r\n\x05\x04>\x02\x01\x03\x12\
    \x04\xae\x04\x15\x16\n\x0c\n\x04\x04>\x02\x02\x12\x04\xaf\x04\x04\x1c\n\
    \r\n\x05\x04>\x02\x02\x05\x12\x04\xaf\x04\x04\x08\n\r\n\x05\x04>\x02\x02\
    \x01\x12\x04\xaf\x04\t\x17\n\r\n\x05\x04>\x02\x02\x03\x12\x04\xaf\x04\
    \x1a\x1b\n\x0c\n\x04\x04>\x02\x03\x12\x04\xb0\x04\x04#\n\r\n\x05\x04>\
    \x02\x03\x05\x12\x04\xb0\x04\x04\n\n\r\n\x05\x04>\x02\x03\x01\x12\x04\
    \xb0\x04\x0b\x1e\n\r\n\x05\x04>\x02\x03\x03\x12\x04\xb0\x04!\"\n\x0c\n\
    \x04\x04>\x02\x04\x12\x04\xb1\x04\x04\"\n\r\n\x05\x04>\x02\x04\x05\x12\
    \x04\xb1\x04\x04\t\n\r\n\x05\x04>\x02\x04\x01\x12\x04\xb1\x04\n\x1d\n\r\
    \n\x05\x04>\x02\x04\x03\x12\x04\xb1\x04\x20!\n\x0c\n\x04\x04>\x02\x05\
    \x12\x04\xb2\x04\x04'\n\r\n\x05\x04>\x02\x05\x06\x12\x04\xb2\x04\x04\x17\
    \n\r\n\x05\x04>\x02\x05\x01\x12\x04\xb2\x04\x18\"\n\r\n\x05\x04>\x02\x05\
    \x03\x12\x04\xb2\x04%&\n\x0c\n\x02\x04?\x12\x06\xb5\x04\0\xc1\x04\x01\n\
    \x0b\n\x03\x04?\x01\x12\x04\xb5\x04\x08\x12\n\x0c\n\x04\x04?\x02\0\x12\
    \x04\xb6\x04\x04!\n\r\n\x05\x04?\x02\0\x06\x12\x04\xb6\x04\x04\x0f\n\r\n\
    \x05\x04?\x02\0\x01\x12\x04\xb6\x04\x10\x1c\n\r\n\x05\x04?\x02\0\x03\x12\
    \x04\xb6\x04\x1f\x20\n\x0c\n\x04\x04?\x02\x01\x12\x04\xb7\x04\x04'\n\r\n\
    \x05\x04?\x02\x01\x04\x12\x04\xb7\x04\x04\x0c\n\r\n\x05\x04?\x02\x01\x05\
    \x12\x04\xb7\x04\r\x13\n\r\n\x05\x04?\x02\x01\x01\x12\x04\xb7\x04\x14\"\
    \n\r\n\x05\x04?\x02\x01\x03\x12\x04\xb7\x04%&\n\x0c\n\x04\x04?\x02\x02\
    \x12\x04\xb8\x04\x04\x20\n\r\n\x05\x04?\x02\x02\x05\x12\x04\xb8\x04\x04\
    \t\n\r\n\x05\x04?\x02\x02\x01\x12\x04\xb8\x04\n\x1b\n\r\n\x05\x04?\x02\
    \x02\x03\x12\x04\xb8\x04\x1e\x1f\n\x0c\n\x04\x04?\x02\x03\x12\x04\xb9\
    \x04\x04&\n\r\n\x05\x04?\x02\x03\x05\x12\x04\xb9\x04\x04\n\n\r\n\x05\x04\
    ?\x02\x03\x01\x12\x04\xb9\x04\x0b!\n\r\n\x05\x04?\x02\x03\x03\x12\x04\
    \xb9\x04$%\n\x0c\n\x04\x04?\x02\x04\x12\x04\xba\x04\x04#\n\r\n\x05\x04?\
    \x02\x04\x05\x12\x04\xba\x04\x04\t\n\r\n\x05\x04?\x02\x04\x01\x12\x04\
    \xba\x04\n\x1e\n\r\n\x05\x04?\x02\x04\x03\x12\x04\xba\x04!\"\n\x0c\n\x04\
    \x04?\x02\x05\x12\x04\xbb\x04\x04\x20\n\r\n\x05\x04?\x02\x05\x06\x12\x04\
    \xbb\x04\x04\x0e\n\r\n\x05\x04?\x02\x05\x01\x12\x04\xbb\x04\x0f\x1b\n\r\
    \n\x05\x04?\x02\x05\x03\x12\x04\xbb\x04\x1e\x1f\n\x0c\n\x04\x04?\x02\x06\
    \x12\x04\xbc\x04\x04\x1a\n\r\n\x05\x04?\x02\x06\x05\x12\x04\xbc\x04\x04\
    \t\n\r\n\x05\x04?\x02\x06\x01\x12\x04\xbc\x04\n\x15\n\r\n\x05\x04?\x02\
    \x06\x03\x12\x04\xbc\x04\x18\x19\n\x0c\n\x04\x04?\x02\x07\x12\x04\xbd\
    \x04\x04\x1b\n\r\n\x05\x04?\x02\x07\x05\x12\x04\xbd\x04\x04\n\n\r\n\x05\
    \x04?\x02\x07\x01\x12\x04\xbd\x04\x0b\x16\n\r\n\x05\x04?\x02\x07\x03\x12\
    \x04\xbd\x04\x19\x1a\n\x0c\n\x04\x04?\x02\x08\x12\x04\xbe\x04\x04\x1d\n\
    \r\n\x05\x04?\x02\x08\x05\x12\x04\xbe\x04\x04\n\n\r\n\x05\x04?\x02\x08\
    \x01\x12\x04\xbe\x04\x0b\x18\n\r\n\x05\x04?\x02\x08\x03\x12\x04\xbe\x04\
    \x1b\x1c\n\x0c\n\x04\x04?\x02\t\x12\x04\xbf\x04\x04\x15\n\r\n\x05\x04?\
    \x02\t\x05\x12\x04\xbf\x04\x04\n\n\r\n\x05\x04?\x02\t\x01\x12\x04\xbf\
    \x04\x0b\x0f\n\r\n\x05\x04?\x02\t\x03\x12\x04\xbf\x04\x12\x14\n\x0c\n\
    \x04\x04?\x02\n\x12\x04\xc0\x04\x04(\n\r\n\x05\x04?\x02\n\x06\x12\x04\
    \xc0\x04\x04\x17\n\r\n\x05\x04?\x02\n\x01\x12\x04\xc0\x04\x18\"\n\r\n\
    \x05\x04?\x02\n\x03\x12\x04\xc0\x04%'\n\x0c\n\x02\x04@\x12\x06\xc3\x04\0\
    \xcd\x04\x01\n\x0b\n\x03\x04@\x01\x12\x04\xc3\x04\x08\x10\n\x0c\n\x04\
    \x04@\x02\0\x12\x04\xc4\x04\x04!\n\r\n\x05\x04@\x02\0\x06\x12\x04\xc4\
    \x04\x04\x0f\n\r\n\x05\x04@\x02\0\x01\x12\x04\xc4\x04\x10\x1c\n\r\n\x05\
    \x04@\x02\0\x03\x12\x04\xc4\x04\x1f\x20\n\x0c\n\x04\x04@\x02\x01\x12\x04\
    \xc5\x04\x04'\n\r\n\x05\x04@\x02\x01\x04\x12\x04\xc5\x04\x04\x0c\n\r\n\
    \x05\x04@\x02\x01\x05\x12\x04\xc5\x04\r\x13\n\r\n\x05\x04@\x02\x01\x01\
    \x12\x04\xc5\x04\x14\"\n\r\n\x05\x04@\x02\x01\x03\x12\x04\xc5\x04%&\n\
    \x0c\n\x04\x04@\x02\x02\x12\x04\xc6\x04\x04\x20\n\r\n\x05\x04@\x02\x02\
    \x05\x12\x04\xc6\x04\x04\t\n\r\n\x05\x04@\x02\x02\x01\x12\x04\xc6\x04\n\
    \x1b\n\r\n\x05\x04@\x02\x02\x03\x12\x04\xc6\x04\x1e\x1f\n\x0c\n\x04\x04@\
    \x02\x03\x12\x04\xc7\x04\x04&\n\r\n\x05\x04@\x02\x03\x05\x12\x04\xc7\x04\
    \x04\n\n\r\n\x05\x04@\x02\x03\x01\x12\x04\xc7\x04\x0b!\n\r\n\x05\x04@\
    \x02\x03\x03\x12\x04\xc7\x04$%\n\x0c\n\x04\x04@\x02\x04\x12\x04\xc8\x04\
    \x04#\n\r\n\x05\x04@\x02\x04\x05\x12\x04\xc8\x04\x04\t\n\r\n\x05\x04@\
    \x02\x04\x01\x12\x04\xc8\x04\n\x1e\n\r\n\x05\x04@\x02\x04\x03\x12\x04\
    \xc8\x04!\"\n\x0c\n\x04\x04@\x02\x05\x12\x04\xc9\x04\x04\x20\n\r\n\x05\
    \x04@\x02\x05\x06\x12\x04\xc9\x04\x04\x0e\n\r\n\x05\x04@\x02\x05\x01\x12\
    \x04\xc9\x04\x0f\x1b\n\r\n\x05\x04@\x02\x05\x03\x12\x04\xc9\x04\x1e\x1f\
    \n\x0c\n\x04\x04@\x02\x06\x12\x04\xca\x04\x04\x1d\n\r\n\x05\x04@\x02\x06\
    \x05\x12\x04\xca\x04\x04\n\n\r\n\x05\x04@\x02\x06\x01\x12\x04\xca\x04\
    \x0b\x18\n\r\n\x05\x04@\x02\x06\x03\x12\x04\xca\x04\x1b\x1c\n\x0c\n\x04\
    \x04@\x02\x07\x12\x04\xcb\x04\x04\x14\n\r\n\x05\x04@\x02\x07\x05\x12\x04\
    \xcb\x04\x04\n\n\r\n\x05\x04@\x02\x07\x01\x12\x04\xcb\x04\x0b\x0f\n\r\n\
    \x05\x04@\x02\x07\x03\x12\x04\xcb\x04\x12\x13\n\x0c\n\x04\x04@\x02\x08\
    \x12\x04\xcc\x04\x04'\n\r\n\x05\x04@\x02\x08\x06\x12\x04\xcc\x04\x04\x17\
    \n\r\n\x05\x04@\x02\x08\x01\x12\x04\xcc\x04\x18\"\n\r\n\x05\x04@\x02\x08\
    \x03\x12\x04\xcc\x04%&\n\x0c\n\x02\x04A\x12\x06\xcf\x04\0\xd9\x04\x01\n\
    \x0b\n\x03\x04A\x01\x12\x04\xcf\x04\x08\x13\n\x0c\n\x04\x04A\x02\0\x12\
    \x04\xd0\x04\x04!\n\r\n\x05\x04A\x02\0\x06\x12\x04\xd0\x04\x04\x0f\n\r\n\
    \x05\x04A\x02\0\x01\x12\x04\xd0\x04\x10\x1c\n\r\n\x05\x04A\x02\0\x03\x12\
    \x04\xd0\x04\x1f\x20\n\x0c\n\x04\x04A\x02\x01\x12\x04\xd1\x04\x04'\n\r\n\
    \x05\x04A\x02\x01\x04\x12\x04\xd1\x04\x04\x0c\n\r\n\x05\x04A\x02\x01\x05\
    \x12\x04\xd1\x04\r\x13\n\r\n\x05\x04A\x02\x01\x01\x12\x04\xd1\x04\x14\"\
    \n\r\n\x05\x04A\x02\x01\x03\x12\x04\xd1\x04%&\n\x0c\n\x04\x04A\x02\x02\
    \x12\x04\xd2\x04\x04\x20\n\r\n\x05\x04A\x02\x02\x05\x12\x04\xd2\x04\x04\
    \t\n\r\n\x05\x04A\x02\x02\x01\x12\x04\xd2\x04\n\x1b\n\r\n\x05\x04A\x02\
    \x02\x03\x12\x04\xd2\x04\x1e\x1f\n\x0c\n\x04\x04A\x02\x03\x12\x04\xd3\
    \x04\x04&\n\r\n\x05\x04A\x02\x03\x05\x12\x04\xd3\x04\x04\n\n\r\n\x05\x04\
    A\x02\x03\x01\x12\x04\xd3\x04\x0b!\n\r\n\x05\x04A\x02\x03\x03\x12\x04\
    \xd3\x04$%\n\x0c\n\x04\x04A\x02\x04\x12\x04\xd4\x04\x04#\n\r\n\x05\x04A\
    \x02\x04\x05\x12\x04\xd4\x04\x04\t\n\r\n\x05\x04A\x02\x04\x01\x12\x04\
    \xd4\x04\n\x1e\n\r\n\x05\x04A\x02\x04\x03\x12\x04\xd4\x04!\"\n\x0c\n\x04\
    \x04A\x02\x05\x12\x04\xd5\x04\x04\x20\n\r\n\x05\x04A\x02\x05\x06\x12\x04\
    \xd5\x04\x04\x0e\n\r\n\x05\x04A\x02\x05\x01\x12\x04\xd5\x04\x0f\x1b\n\r\
    \n\x05\x04A\x02\x05\x03\x12\x04\xd5\x04\x1e\x1f\n\x0c\n\x04\x04A\x02\x06\
    \x12\x04\xd6\x04\x04\x1d\n\r\n\x05\x04A\x02\x06\x05\x12\x04\xd6\x04\x04\
    \n\n\r\n\x05\x04A\x02\x06\x01\x12\x04\xd6\x04\x0b\x18\n\r\n\x05\x04A\x02\
    \x06\x03\x12\x04\xd6\x04\x1b\x1c\n\x0c\n\x04\x04A\x02\x07\x12\x04\xd7\
    \x04\x04\x14\n\r\n\x05\x04A\x02\x07\x05\x12\x04\xd7\x04\x04\n\n\r\n\x05\
    \x04A\x02\x07\x01\x12\x04\xd7\x04\x0b\x0f\n\r\n\x05\x04A\x02\x07\x03\x12\
    \x04\xd7\x04\x12\x13\n\x0c\n\x04\x04A\x02\x08\x12\x04\xd8\x04\x04'\n\r\n\
    \x05\x04A\x02\x08\x06\x12\x04\xd8\x04\x04\x17\n\r\n\x05\x04A\x02\x08\x01\
    \x12\x04\xd8\x04\x18\"\n\r\n\x05\x04A\x02\x08\x03\x12\x04\xd8\x04%&\n\
    \x0c\n\x02\x04B\x12\x06\xdb\x04\0\xee\x04\x01\n\x0b\n\x03\x04B\x01\x12\
    \x04\xdb\x04\x08\x0e\n\x0c\n\x04\x04B\x02\0\x12\x04\xdc\x04\x04,\n\r\n\
    \x05\x04B\x02\0\x04\x12\x04\xdc\x04\x04\x0c\n\r\n\x05\x04B\x02\0\x05\x12\
    \x04\xdc\x04\r\x13\n\r\n\x05\x04B\x02\0\x01\x12\x04\xdc\x04\x14'\n\r\n\
    \x05\x04B\x02\0\x03\x12\x04\xdc\x04*+\n\x0c\n\x04\x04B\x02\x01\x12\x04\
    \xdd\x04\x04)\n\r\n\x05\x04B\x02\x01\x04\x12\x04\xdd\x04\x04\x0c\n\r\n\
    \x05\x04B\x02\x01\x05\x12\x04\xdd\x04\r\x13\n\r\n\x05\x04B\x02\x01\x01\
    \x12\x04\xdd\x04\x14$\n\r\n\x05\x04B\x02\x01\x03\x12\x04\xdd\x04'(\n\x0c\
    \n\x04\x04B\x02\x02\x12\x04\xde\x04\x04>\n\r\n\x05\x04B\x02\x02\x04\x12\
    \x04\xde\x04\x04\x0c\n\r\n\x05\x04B\x02\x02\x06\x12\x04\xde\x04\r!\n\r\n\
    \x05\x04B\x02\x02\x01\x12\x04\xde\x04\"9\n\r\n\x05\x04B\x02\x02\x03\x12\
    \x04\xde\x04<=\n\x0c\n\x04\x04B\x02\x03\x12\x04\xdf\x04\x04#\n\r\n\x05\
    \x04B\x02\x03\x05\x12\x04\xdf\x04\x04\n\n\r\n\x05\x04B\x02\x03\x01\x12\
    \x04\xdf\x04\x0b\x1e\n\r\n\x05\x04B\x02\x03\x03\x12\x04\xdf\x04!\"\n\x0c\
    \n\x04\x04B\x02\x04\x12\x04\xe0\x04\x04\"\n\r\n\x05\x04B\x02\x04\x05\x12\
    \x04\xe0\x04\x04\t\n\r\n\x05\x04B\x02\x04\x01\x12\x04\xe0\x04\n\x1d\n\r\
    \n\x05\x04B\x02\x04\x03\x12\x04\xe0\x04\x20!\n\x0c\n\x04\x04B\x02\x05\
    \x12\x04\xe1\x04\x04'\n\r\n\x05\x04B\x02\x05\x06\x12\x04\xe1\x04\x04\x17\
    \n\r\n\x05\x04B\x02\x05\x01\x12\x04\xe1\x04\x18\"\n\r\n\x05\x04B\x02\x05\
    \x03\x12\x04\xe1\x04%&\n\x0c\n\x04\x04B\x02\x06\x12\x04\xe2\x04\x04*\n\r\
    \n\x05\x04B\x02\x06\x04\x12\x04\xe2\x04\x04\x0c\n\r\n\x05\x04B\x02\x06\
    \x05\x12\x04\xe2\x04\r\x13\n\r\n\x05\x04B\x02\x06\x01\x12\x04\xe2\x04\
    \x14%\n\r\n\x05\x04B\x02\x06\x03\x12\x04\xe2\x04()\n\x0c\n\x04\x04B\x02\
    \x07\x12\x04\xe3\x04\x04/\n\r\n\x05\x04B\x02\x07\x04\x12\x04\xe3\x04\x04\
    \x0c\n\r\n\x05\x04B\x02\x07\x05\x12\x04\xe3\x04\r\x13\n\r\n\x05\x04B\x02\
    \x07\x01\x12\x04\xe3\x04\x14*\n\r\n\x05\x04B\x02\x07\x03\x12\x04\xe3\x04\
    -.\n\x0c\n\x04\x04B\x02\x08\x12\x04\xe4\x04\x04$\n\r\n\x05\x04B\x02\x08\
    \x04\x12\x04\xe4\x04\x04\x0c\n\r\n\x05\x04B\x02\x08\x05\x12\x04\xe4\x04\
    \r\x13\n\r\n\x05\x04B\x02\x08\x01\x12\x04\xe4\x04\x14\x1f\n\r\n\x05\x04B\
    \x02\x08\x03\x12\x04\xe4\x04\"#\n\x0c\n\x04\x04B\x02\t\x12\x04\xe5\x04\
    \x04$\n\r\n\x05\x04B\x02\t\x04\x12\x04\xe5\x04\x04\x0c\n\r\n\x05\x04B\
    \x02\t\x05\x12\x04\xe5\x04\r\x13\n\r\n\x05\x04B\x02\t\x01\x12\x04\xe5\
    \x04\x14\x1e\n\r\n\x05\x04B\x02\t\x03\x12\x04\xe5\x04!#\n\x0c\n\x04\x04B\
    \x02\n\x12\x04\xe6\x04\x04+\n\r\n\x05\x04B\x02\n\x04\x12\x04\xe6\x04\x04\
    \x0c\n\r\n\x05\x04B\x02\n\x05\x12\x04\xe6\x04\r\x13\n\r\n\x05\x04B\x02\n\
    \x01\x12\x04\xe6\x04\x14%\n\r\n\x05\x04B\x02\n\x03\x12\x04\xe6\x04(*\n\
    \x0c\n\x04\x04B\x02\x0b\x12\x04\xe7\x04\x04)\n\r\n\x05\x04B\x02\x0b\x05\
    \x12\x04\xe7\x04\x04\x08\n\r\n\x05\x04B\x02\x0b\x01\x12\x04\xe7\x04\t#\n\
    \r\n\x05\x04B\x02\x0b\x03\x12\x04\xe7\x04&(\n\x0c\n\x04\x04B\x02\x0c\x12\
    \x04\xe8\x04\x04#\n\r\n\x05\x04B\x02\x0c\x04\x12\x04\xe8\x04\x04\x0c\n\r\
    \n\x05\x04B\x02\x0c\x05\x12\x04\xe8\x04\r\x13\n\r\n\x05\x04B\x02\x0c\x01\
    \x12\x04\xe8\x04\x14\x1d\n\r\n\x05\x04B\x02\x0c\x03\x12\x04\xe8\x04\x20\
    \"\n\x0c\n\x04\x04B\x02\r\x12\x04\xe9\x04\x04\x1a\n\r\n\x05\x04B\x02\r\
    \x05\x12\x04\xe9\x04\x04\x08\n\r\n\x05\x04B\x02\r\x01\x12\x04\xe9\x04\t\
    \x14\n\r\n\x05\x04B\x02\r\x03\x12\x04\xe9\x04\x17\x19\n\x0c\n\x04\x04B\
    \x02\x0e\x12\x04\xea\x04\x04*\n\r\n\x05\x04B\x02\x0e\x05\x12\x04\xea\x04\
    \x04\n\n\r\n\x05\x04B\x02\x0e\x01\x12\x04\xea\x04\x0b$\n\r\n\x05\x04B\
    \x02\x0e\x03\x12\x04\xea\x04')\n\x0c\n\x04\x04B\x02\x0f\x12\x04\xeb\x04\
    \x04,\n\r\n\x05\x04B\x02\x0f\x05\x12\x04\xeb\x04\x04\n\n\r\n\x05\x04B\
    \x02\x0f\x01\x12\x04\xeb\x04\x0b&\n\r\n\x05\x04B\x02\x0f\x03\x12\x04\xeb\
    \x04)+\n\x0c\n\x04\x04B\x02\x10\x12\x04\xec\x04\x04#\n\r\n\x05\x04B\x02\
    \x10\x04\x12\x04\xec\x04\x04\x0c\n\r\n\x05\x04B\x02\x10\x05\x12\x04\xec\
    \x04\r\x13\n\r\n\x05\x04B\x02\x10\x01\x12\x04\xec\x04\x14\x1d\n\r\n\x05\
    \x04B\x02\x10\x03\x12\x04\xec\x04\x20\"\n\x0c\n\x04\x04B\x02\x11\x12\x04\
    \xed\x04\x04&\n\r\n\x05\x04B\x02\x11\x04\x12\x04\xed\x04\x04\x0c\n\r\n\
    \x05\x04B\x02\x11\x05\x12\x04\xed\x04\r\x13\n\r\n\x05\x04B\x02\x11\x01\
    \x12\x04\xed\x04\x14\x20\n\r\n\x05\x04B\x02\x11\x03\x12\x04\xed\x04#%\n\
    \xa3\x01\n\x02\x04C\x12\x06\xf2\x04\0\x83\x05\x01\x1a\x94\x01\x20not\x20\
    used\x20anymore\x20from\x20v0.6\x20on.\x20But\x20leave\x20it\x20for\x20r\
    eceiving\x20TradeStatistics\x20objects\x20from\x20older\n\x20versions\
    \x20and\x20convert\x20it\x20to\x20TradeStatistics2\x20objects.\n\n\x0b\n\
    \x03\x04C\x01\x12\x04\xf2\x04\x08\x17\n\x0c\n\x04\x04C\x02\0\x12\x04\xf3\
    \x04\x04\x1d\n\r\n\x05\x04C\x02\0\x05\x12\x04\xf3\x04\x04\n\n\r\n\x05\
    \x04C\x02\0\x01\x12\x04\xf3\x04\x0b\x18\n\r\n\x05\x04C\x02\0\x03\x12\x04\
    \xf3\x04\x1b\x1c\n\x0c\n\x04\x04C\x02\x01\x12\x04\xf4\x04\x04\x20\n\r\n\
    \x05\x04C\x02\x01\x05\x12\x04\xf4\x04\x04\n\n\r\n\x05\x04C\x02\x01\x01\
    \x12\x04\xf4\x04\x0b\x1b\n\r\n\x05\x04C\x02\x01\x03\x12\x04\xf4\x04\x1e\
    \x1f\n\x0c\n\x04\x04C\x02\x02\x12\x04\xf5\x04\x04)\n\r\n\x05\x04C\x02\
    \x02\x06\x12\x04\xf5\x04\x04\x1a\n\r\n\x05\x04C\x02\x02\x01\x12\x04\xf5\
    \x04\x1b$\n\r\n\x05\x04C\x02\x02\x03\x12\x04\xf5\x04'(\n\x0c\n\x04\x04C\
    \x02\x03\x12\x04\xf6\x04\x04\x1a\n\r\n\x05\x04C\x02\x03\x05\x12\x04\xf6\
    \x04\x04\t\n\r\n\x05\x04C\x02\x03\x01\x12\x04\xf6\x04\n\x15\n\r\n\x05\
    \x04C\x02\x03\x03\x12\x04\xf6\x04\x18\x19\n\x0c\n\x04\x04C\x02\x04\x12\
    \x04\xf7\x04\x04\x1b\n\r\n\x05\x04C\x02\x04\x05\x12\x04\xf7\x04\x04\t\n\
    \r\n\x05\x04C\x02\x04\x01\x12\x04\xf7\x04\n\x16\n\r\n\x05\x04C\x02\x04\
    \x03\x12\x04\xf7\x04\x19\x1a\n\x0c\n\x04\x04C\x02\x05\x12\x04\xf8\x04\
    \x04\x19\n\r\n\x05\x04C\x02\x05\x05\x12\x04\xf8\x04\x04\t\n\r\n\x05\x04C\
    \x02\x05\x01\x12\x04\xf8\x04\n\x14\n\r\n\x05\x04C\x02\x05\x03\x12\x04\
    \xf8\x04\x17\x18\n\x0c\n\x04\x04C\x02\x06\x12\x04\xf9\x04\x04!\n\r\n\x05\
    \x04C\x02\x06\x05\x12\x04\xf9\x04\x04\n\n\r\n\x05\x04C\x02\x06\x01\x12\
    \x04\xf9\x04\x0b\x1c\n\r\n\x05\x04C\x02\x06\x03\x12\x04\xf9\x04\x1f\x20\
    \n\x0c\n\x04\x04C\x02\x07\x12\x04\xfa\x04\x04\x19\n\r\n\x05\x04C\x02\x07\
    \x05\x12\x04\xfa\x04\x04\t\n\r\n\x05\x04C\x02\x07\x01\x12\x04\xfa\x04\n\
    \x14\n\r\n\x05\x04C\x02\x07\x03\x12\x04\xfa\x04\x17\x18\n\x0c\n\x04\x04C\
    \x02\x08\x12\x04\xfb\x04\x04*\n\r\n\x05\x04C\x02\x08\x05\x12\x04\xfb\x04\
    \x04\x08\n\r\n\x05\x04C\x02\x08\x01\x12\x04\xfb\x04\t%\n\r\n\x05\x04C\
    \x02\x08\x03\x12\x04\xfb\x04()\n\x0c\n\x04\x04C\x02\t\x12\x04\xfc\x04\
    \x04*\n\r\n\x05\x04C\x02\t\x05\x12\x04\xfc\x04\x04\n\n\r\n\x05\x04C\x02\
    \t\x01\x12\x04\xfc\x04\x0b$\n\r\n\x05\x04C\x02\t\x03\x12\x04\xfc\x04')\n\
    \x0c\n\x04\x04C\x02\n\x12\x04\xfd\x04\x04\x1c\n\r\n\x05\x04C\x02\n\x05\
    \x12\x04\xfd\x04\x04\t\n\r\n\x05\x04C\x02\n\x01\x12\x04\xfd\x04\n\x16\n\
    \r\n\x05\x04C\x02\n\x03\x12\x04\xfd\x04\x19\x1b\n\x0c\n\x04\x04C\x02\x0b\
    \x12\x04\xfe\x04\x04\x20\n\r\n\x05\x04C\x02\x0b\x05\x12\x04\xfe\x04\x04\
    \t\n\r\n\x05\x04C\x02\x0b\x01\x12\x04\xfe\x04\n\x1a\n\r\n\x05\x04C\x02\
    \x0b\x03\x12\x04\xfe\x04\x1d\x1f\n\x0c\n\x04\x04C\x02\x0c\x12\x04\xff\
    \x04\x04\x19\n\r\n\x05\x04C\x02\x0c\x05\x12\x04\xff\x04\x04\n\n\r\n\x05\
    \x04C\x02\x0c\x01\x12\x04\xff\x04\x0b\x13\n\r\n\x05\x04C\x02\x0c\x03\x12\
    \x04\xff\x04\x16\x18\n\x0c\n\x04\x04C\x02\r\x12\x04\x80\x05\x04\x1e\n\r\
    \n\x05\x04C\x02\r\x05\x12\x04\x80\x05\x04\n\n\r\n\x05\x04C\x02\r\x01\x12\
    \x04\x80\x05\x0b\x18\n\r\n\x05\x04C\x02\r\x03\x12\x04\x80\x05\x1b\x1d\n\
    \x0c\n\x04\x04C\x02\x0e\x12\x04\x81\x05\x04'\n\r\n\x05\x04C\x02\x0e\x05\
    \x12\x04\x81\x05\x04\t\n\r\n\x05\x04C\x02\x0e\x01\x12\x04\x81\x05\n!\n\r\
    \n\x05\x04C\x02\x0e\x03\x12\x04\x81\x05$&\n\x0c\n\x04\x04C\x02\x0f\x12\
    \x04\x82\x05\x04(\n\r\n\x05\x04C\x02\x0f\x06\x12\x04\x82\x05\x04\x17\n\r\
    \n\x05\x04C\x02\x0f\x01\x12\x04\x82\x05\x18\"\n\r\n\x05\x04C\x02\x0f\x03\
    \x12\x04\x82\x05%'\n\x0c\n\x02\x04D\x12\x06\x85\x05\0\x96\x05\x01\n\x0b\
    \n\x03\x04D\x01\x12\x04\x85\x05\x08\x18\n\x0c\n\x04\x04D\x02\0\x12\x04\
    \x86\x05\x04\x1d\n\r\n\x05\x04D\x02\0\x05\x12\x04\x86\x05\x04\n\n\r\n\
    \x05\x04D\x02\0\x01\x12\x04\x86\x05\x0b\x18\n\r\n\x05\x04D\x02\0\x03\x12\
    \x04\x86\x05\x1b\x1c\n\x0c\n\x04\x04D\x02\x01\x12\x04\x87\x05\x04\x20\n\
    \r\n\x05\x04D\x02\x01\x05\x12\x04\x87\x05\x04\n\n\r\n\x05\x04D\x02\x01\
    \x01\x12\x04\x87\x05\x0b\x1b\n\r\n\x05\x04D\x02\x01\x03\x12\x04\x87\x05\
    \x1e\x1f\n\x0c\n\x04\x04D\x02\x02\x12\x04\x88\x05\x04)\n\r\n\x05\x04D\
    \x02\x02\x06\x12\x04\x88\x05\x04\x1a\n\r\n\x05\x04D\x02\x02\x01\x12\x04\
    \x88\x05\x1b$\n\r\n\x05\x04D\x02\x02\x03\x12\x04\x88\x05'(\n\x0c\n\x04\
    \x04D\x02\x03\x12\x04\x89\x05\x04\x1a\n\r\n\x05\x04D\x02\x03\x05\x12\x04\
    \x89\x05\x04\t\n\r\n\x05\x04D\x02\x03\x01\x12\x04\x89\x05\n\x15\n\r\n\
    \x05\x04D\x02\x03\x03\x12\x04\x89\x05\x18\x19\n\x0c\n\x04\x04D\x02\x04\
    \x12\x04\x8a\x05\x04\x1b\n\r\n\x05\x04D\x02\x04\x05\x12\x04\x8a\x05\x04\
    \t\n\r\n\x05\x04D\x02\x04\x01\x12\x04\x8a\x05\n\x16\n\r\n\x05\x04D\x02\
    \x04\x03\x12\x04\x8a\x05\x19\x1a\n\x0c\n\x04\x04D\x02\x05\x12\x04\x8b\
    \x05\x04\x19\n\r\n\x05\x04D\x02\x05\x05\x12\x04\x8b\x05\x04\t\n\r\n\x05\
    \x04D\x02\x05\x01\x12\x04\x8b\x05\n\x14\n\r\n\x05\x04D\x02\x05\x03\x12\
    \x04\x8b\x05\x17\x18\n\x0c\n\x04\x04D\x02\x06\x12\x04\x8c\x05\x04!\n\r\n\
    \x05\x04D\x02\x06\x05\x12\x04\x8c\x05\x04\n\n\r\n\x05\x04D\x02\x06\x01\
    \x12\x04\x8c\x05\x0b\x1c\n\r\n\x05\x04D\x02\x06\x03\x12\x04\x8c\x05\x1f\
    \x20\n\x0c\n\x04\x04D\x02\x07\x12\x04\x8d\x05\x04\x19\n\r\n\x05\x04D\x02\
    \x07\x05\x12\x04\x8d\x05\x04\t\n\r\n\x05\x04D\x02\x07\x01\x12\x04\x8d\
    \x05\n\x14\n\r\n\x05\x04D\x02\x07\x03\x12\x04\x8d\x05\x17\x18\n\x0c\n\
    \x04\x04D\x02\x08\x12\x04\x8e\x05\x04*\n\r\n\x05\x04D\x02\x08\x05\x12\
    \x04\x8e\x05\x04\x08\n\r\n\x05\x04D\x02\x08\x01\x12\x04\x8e\x05\t%\n\r\n\
    \x05\x04D\x02\x08\x03\x12\x04\x8e\x05()\n\x0c\n\x04\x04D\x02\t\x12\x04\
    \x8f\x05\x04*\n\r\n\x05\x04D\x02\t\x05\x12\x04\x8f\x05\x04\n\n\r\n\x05\
    \x04D\x02\t\x01\x12\x04\x8f\x05\x0b$\n\r\n\x05\x04D\x02\t\x03\x12\x04\
    \x8f\x05')\n\x0c\n\x04\x04D\x02\n\x12\x04\x90\x05\x04\x1c\n\r\n\x05\x04D\
    \x02\n\x05\x12\x04\x90\x05\x04\t\n\r\n\x05\x04D\x02\n\x01\x12\x04\x90\
    \x05\n\x16\n\r\n\x05\x04D\x02\n\x03\x12\x04\x90\x05\x19\x1b\n\x0c\n\x04\
    \x04D\x02\x0b\x12\x04\x91\x05\x04\x20\n\r\n\x05\x04D\x02\x0b\x05\x12\x04\
    \x91\x05\x04\t\n\r\n\x05\x04D\x02\x0b\x01\x12\x04\x91\x05\n\x1a\n\r\n\
    \x05\x04D\x02\x0b\x03\x12\x04\x91\x05\x1d\x1f\n\x0c\n\x04\x04D\x02\x0c\
    \x12\x04\x92\x05\x04\x19\n\r\n\x05\x04D\x02\x0c\x05\x12\x04\x92\x05\x04\
    \n\n\r\n\x05\x04D\x02\x0c\x01\x12\x04\x92\x05\x0b\x13\n\r\n\x05\x04D\x02\
    \x0c\x03\x12\x04\x92\x05\x16\x18\n\x0c\n\x04\x04D\x02\r\x12\x04\x93\x05\
    \x04\x1e\n\r\n\x05\x04D\x02\r\x05\x12\x04\x93\x05\x04\n\n\r\n\x05\x04D\
    \x02\r\x01\x12\x04\x93\x05\x0b\x18\n\r\n\x05\x04D\x02\r\x03\x12\x04\x93\
    \x05\x1b\x1d\n\x0c\n\x04\x04D\x02\x0e\x12\x04\x94\x05\x04\x14\n\r\n\x05\
    \x04D\x02\x0e\x05\x12\x04\x94\x05\x04\t\n\r\n\x05\x04D\x02\x0e\x01\x12\
    \x04\x94\x05\n\x0e\n\r\n\x05\x04D\x02\x0e\x03\x12\x04\x94\x05\x11\x13\n\
    \x0c\n\x04\x04D\x02\x0f\x12\x04\x95\x05\x04(\n\r\n\x05\x04D\x02\x0f\x06\
    \x12\x04\x95\x05\x04\x17\n\r\n\x05\x04D\x02\x0f\x01\x12\x04\x95\x05\x18\
    \"\n\r\n\x05\x04D\x02\x0f\x03\x12\x04\x95\x05%'\n\x0c\n\x02\x04E\x12\x06\
    \x98\x05\0\x9d\x05\x01\n\x0b\n\x03\x04E\x01\x12\x04\x98\x05\x08\x1d\n\
    \x0c\n\x04\x04E\x02\0\x12\x04\x99\x05\x04J\n\r\n\x05\x04E\x02\0\x06\x12\
    \x04\x99\x05\x04\"\n\r\n\x05\x04E\x02\0\x01\x12\x04\x99\x05#E\n\r\n\x05\
    \x04E\x02\0\x03\x12\x04\x99\x05HI\n\x0c\n\x04\x04E\x02\x01\x12\x04\x9a\
    \x05\x045\n\r\n\x05\x04E\x02\x01\x05\x12\x04\x9a\x05\x04\t\n\r\n\x05\x04\
    E\x02\x01\x01\x12\x04\x9a\x05\n0\n\r\n\x05\x04E\x02\x01\x03\x12\x04\x9a\
    \x0534\n\x0c\n\x04\x04E\x02\x02\x12\x04\x9b\x05\x04\"\n\r\n\x05\x04E\x02\
    \x02\x05\x12\x04\x9b\x05\x04\t\n\r\n\x05\x04E\x02\x02\x01\x12\x04\x9b\
    \x05\n\x1d\n\r\n\x05\x04E\x02\x02\x03\x12\x04\x9b\x05\x20!\n\x0c\n\x04\
    \x04E\x02\x03\x12\x04\x9c\x05\x04'\n\r\n\x05\x04E\x02\x03\x06\x12\x04\
    \x9c\x05\x04\x17\n\r\n\x05\x04E\x02\x03\x01\x12\x04\x9c\x05\x18\"\n\r\n\
    \x05\x04E\x02\x03\x03\x12\x04\x9c\x05%&\n\x0c\n\x02\x04F\x12\x06\x9f\x05\
    \0\xcc\x05\x01\n\x0b\n\x03\x04F\x01\x12\x04\x9f\x05\x08\x14\n\x0e\n\x04\
    \x04F\x04\0\x12\x06\xa0\x05\x04\xa4\x05\x05\n\r\n\x05\x04F\x04\0\x01\x12\
    \x04\xa0\x05\t\x12\n\x0e\n\x06\x04F\x04\0\x02\0\x12\x04\xa1\x05\x08\x15\
    \n\x0f\n\x07\x04F\x04\0\x02\0\x01\x12\x04\xa1\x05\x08\x10\n\x0f\n\x07\
    \x04F\x04\0\x02\0\x02\x12\x04\xa1\x05\x13\x14\n\x0e\n\x06\x04F\x04\0\x02\
    \x01\x12\x04\xa2\x05\x08\x10\n\x0f\n\x07\x04F\x04\0\x02\x01\x01\x12\x04\
    \xa2\x05\x08\x0b\n\x0f\n\x07\x04F\x04\0\x02\x01\x02\x12\x04\xa2\x05\x0e\
    \x0f\n\x0e\n\x06\x04F\x04\0\x02\x02\x12\x04\xa3\x05\x08\x11\n\x0f\n\x07\
    \x04F\x04\0\x02\x02\x01\x12\x04\xa3\x05\x08\x0c\n\x0f\n\x07\x04F\x04\0\
    \x02\x02\x02\x12\x04\xa3\x05\x0f\x10\n\x0c\n\x04\x04F\x02\0\x12\x04\xa6\
    \x05\x04\x12\n\r\n\x05\x04F\x02\0\x05\x12\x04\xa6\x05\x04\n\n\r\n\x05\
    \x04F\x02\0\x01\x12\x04\xa6\x05\x0b\r\n\r\n\x05\x04F\x02\0\x03\x12\x04\
    \xa6\x05\x10\x11\n\x0c\n\x04\x04F\x02\x01\x12\x04\xa7\x05\x04\x13\n\r\n\
    \x05\x04F\x02\x01\x05\x12\x04\xa7\x05\x04\t\n\r\n\x05\x04F\x02\x01\x01\
    \x12\x04\xa7\x05\n\x0e\n\r\n\x05\x04F\x02\x01\x03\x12\x04\xa7\x05\x11\
    \x12\n\x0c\n\x04\x04F\x02\x02\x12\x04\xa8\x05\x04'\n\r\n\x05\x04F\x02\
    \x02\x06\x12\x04\xa8\x05\x04\x0f\n\r\n\x05\x04F\x02\x02\x01\x12\x04\xa8\
    \x05\x10\"\n\r\n\x05\x04F\x02\x02\x03\x12\x04\xa8\x05%&\n\x0c\n\x04\x04F\
    \x02\x03\x12\x04\xa9\x05\x04\x20\n\r\n\x05\x04F\x02\x03\x06\x12\x04\xa9\
    \x05\x04\x0e\n\r\n\x05\x04F\x02\x03\x01\x12\x04\xa9\x05\x0f\x1b\n\r\n\
    \x05\x04F\x02\x03\x03\x12\x04\xa9\x05\x1e\x1f\n\x0c\n\x04\x04F\x02\x04\
    \x12\x04\xaa\x05\x04\x1c\n\r\n\x05\x04F\x02\x04\x06\x12\x04\xaa\x05\x04\
    \r\n\r\n\x05\x04F\x02\x04\x01\x12\x04\xaa\x05\x0e\x17\n\r\n\x05\x04F\x02\
    \x04\x03\x12\x04\xaa\x05\x1a\x1b\n\x0c\n\x04\x04F\x02\x05\x12\x04\xab\
    \x05\x04\x14\n\r\n\x05\x04F\x02\x05\x05\x12\x04\xab\x05\x04\t\n\r\n\x05\
    \x04F\x02\x05\x01\x12\x04\xab\x05\n\x0f\n\r\n\x05\x04F\x02\x05\x03\x12\
    \x04\xab\x05\x12\x13\n\x0c\n\x04\x04F\x02\x06\x12\x04\xac\x05\x04#\n\r\n\
    \x05\x04F\x02\x06\x05\x12\x04\xac\x05\x04\n\n\r\n\x05\x04F\x02\x06\x01\
    \x12\x04\xac\x05\x0b\x1e\n\r\n\x05\x04F\x02\x06\x03\x12\x04\xac\x05!\"\n\
    \x0c\n\x04\x04F\x02\x07\x12\x04\xad\x05\x04$\n\r\n\x05\x04F\x02\x07\x05\
    \x12\x04\xad\x05\x04\x08\n\r\n\x05\x04F\x02\x07\x01\x12\x04\xad\x05\t\
    \x1f\n\r\n\x05\x04F\x02\x07\x03\x12\x04\xad\x05\"#\n\x0c\n\x04\x04F\x02\
    \x08\x12\x04\xae\x05\x04\x15\n\r\n\x05\x04F\x02\x08\x05\x12\x04\xae\x05\
    \x04\t\n\r\n\x05\x04F\x02\x08\x01\x12\x04\xae\x05\n\x10\n\r\n\x05\x04F\
    \x02\x08\x03\x12\x04\xae\x05\x13\x14\n\x0c\n\x04\x04F\x02\t\x12\x04\xaf\
    \x05\x04\x1a\n\r\n\x05\x04F\x02\t\x05\x12\x04\xaf\x05\x04\t\n\r\n\x05\
    \x04F\x02\t\x01\x12\x04\xaf\x05\n\x14\n\r\n\x05\x04F\x02\t\x03\x12\x04\
    \xaf\x05\x17\x19\n\x0c\n\x04\x04F\x02\n\x12\x04\xb0\x05\x04#\n\r\n\x05\
    \x04F\x02\n\x05\x12\x04\xb0\x05\x04\n\n\r\n\x05\x04F\x02\n\x01\x12\x04\
    \xb0\x05\x0b\x1d\n\r\n\x05\x04F\x02\n\x03\x12\x04\xb0\x05\x20\"\n\x0c\n\
    \x04\x04F\x02\x0b\x12\x04\xb1\x05\x04&\n\r\n\x05\x04F\x02\x0b\x05\x12\
    \x04\xb1\x05\x04\n\n\r\n\x05\x04F\x02\x0b\x01\x12\x04\xb1\x05\x0b\x20\n\
    \r\n\x05\x04F\x02\x0b\x03\x12\x04\xb1\x05#%\nT\n\x04\x04F\x02\x0c\x12\
    \x04\xb2\x05\x04L\"F\x20not\x20used\x20anymore\x20but\x20still\x20requir\
    ed\x20as\x20old\x20clients\x20check\x20for\x20nonNull\n\n\r\n\x05\x04F\
    \x02\x0c\x04\x12\x04\xb2\x05\x04\x0c\n\r\n\x05\x04F\x02\x0c\x06\x12\x04\
    \xb2\x05\r\x18\n\r\n\x05\x04F\x02\x0c\x01\x12\x04\xb2\x05\x192\n\r\n\x05\
    \x04F\x02\x0c\x03\x12\x04\xb2\x0557\n\r\n\x05\x04F\x02\x0c\x08\x12\x04\
    \xb2\x058K\n\x0e\n\x06\x04F\x02\x0c\x08\x03\x12\x04\xb2\x059J\nT\n\x04\
    \x04F\x02\r\x12\x04\xb3\x05\x04J\"F\x20not\x20used\x20anymore\x20but\x20\
    still\x20required\x20as\x20old\x20clients\x20check\x20for\x20nonNull\n\n\
    \r\n\x05\x04F\x02\r\x04\x12\x04\xb3\x05\x04\x0c\n\r\n\x05\x04F\x02\r\x06\
    \x12\x04\xb3\x05\r\x18\n\r\n\x05\x04F\x02\r\x01\x12\x04\xb3\x05\x190\n\r\
    \n\x05\x04F\x02\r\x03\x12\x04\xb3\x0535\n\r\n\x05\x04F\x02\r\x08\x12\x04\
    \xb3\x056I\n\x0e\n\x06\x04F\x02\r\x08\x03\x12\x04\xb3\x057H\n\x0c\n\x04\
    \x04F\x02\x0e\x12\x04\xb4\x05\x04\"\n\r\n\x05\x04F\x02\x0e\x05\x12\x04\
    \xb4\x05\x04\n\n\r\n\x05\x04F\x02\x0e\x01\x12\x04\xb4\x05\x0b\x1c\n\r\n\
    \x05\x04F\x02\x0e\x03\x12\x04\xb4\x05\x1f!\n\x0c\n\x04\x04F\x02\x0f\x12\
    \x04\xb5\x05\x04)\n\r\n\x05\x04F\x02\x0f\x05\x12\x04\xb5\x05\x04\n\n\r\n\
    \x05\x04F\x02\x0f\x01\x12\x04\xb5\x05\x0b#\n\r\n\x05\x04F\x02\x0f\x03\
    \x12\x04\xb5\x05&(\n\x0c\n\x04\x04F\x02\x10\x12\x04\xb6\x05\x04(\n\r\n\
    \x05\x04F\x02\x10\x05\x12\x04\xb6\x05\x04\n\n\r\n\x05\x04F\x02\x10\x01\
    \x12\x04\xb6\x05\x0b\"\n\r\n\x05\x04F\x02\x10\x03\x12\x04\xb6\x05%'\n\
    \x0c\n\x04\x04F\x02\x11\x12\x04\xb7\x05\x04\x1d\n\r\n\x05\x04F\x02\x11\
    \x05\x12\x04\xb7\x05\x04\n\n\r\n\x05\x04F\x02\x11\x01\x12\x04\xb7\x05\
    \x0b\x17\n\r\n\x05\x04F\x02\x11\x03\x12\x04\xb7\x05\x1a\x1c\n\x0c\n\x04\
    \x04F\x02\x12\x12\x04\xb8\x05\x040\n\r\n\x05\x04F\x02\x12\x04\x12\x04\
    \xb8\x05\x04\x0c\n\r\n\x05\x04F\x02\x12\x05\x12\x04\xb8\x05\r\x13\n\r\n\
    \x05\x04F\x02\x12\x01\x12\x04\xb8\x05\x14*\n\r\n\x05\x04F\x02\x12\x03\
    \x12\x04\xb8\x05-/\n\x0c\n\x04\x04F\x02\x13\x12\x04\xb9\x05\x04\x18\n\r\
    \n\x05\x04F\x02\x13\x05\x12\x04\xb9\x05\x04\n\n\r\n\x05\x04F\x02\x13\x01\
    \x12\x04\xb9\x05\x0b\x12\n\r\n\x05\x04F\x02\x13\x03\x12\x04\xb9\x05\x15\
    \x17\n\x0c\n\x04\x04F\x02\x14\x12\x04\xba\x05\x04+\n\r\n\x05\x04F\x02\
    \x14\x04\x12\x04\xba\x05\x04\x0c\n\r\n\x05\x04F\x02\x14\x05\x12\x04\xba\
    \x05\r\x13\n\r\n\x05\x04F\x02\x14\x01\x12\x04\xba\x05\x14%\n\r\n\x05\x04\
    F\x02\x14\x03\x12\x04\xba\x05(*\n\x0c\n\x04\x04F\x02\x15\x12\x04\xbb\x05\
    \x04\x1b\n\r\n\x05\x04F\x02\x15\x05\x12\x04\xbb\x05\x04\n\n\r\n\x05\x04F\
    \x02\x15\x01\x12\x04\xbb\x05\x0b\x15\n\r\n\x05\x04F\x02\x15\x03\x12\x04\
    \xbb\x05\x18\x1a\n\x0c\n\x04\x04F\x02\x16\x12\x04\xbc\x05\x04.\n\r\n\x05\
    \x04F\x02\x16\x05\x12\x04\xbc\x05\x04\t\n\r\n\x05\x04F\x02\x16\x01\x12\
    \x04\xbc\x05\n(\n\r\n\x05\x04F\x02\x16\x03\x12\x04\xbc\x05+-\n\x0c\n\x04\
    \x04F\x02\x17\x12\x04\xbd\x05\x04\x16\n\r\n\x05\x04F\x02\x17\x05\x12\x04\
    \xbd\x05\x04\t\n\r\n\x05\x04F\x02\x17\x01\x12\x04\xbd\x05\n\x10\n\r\n\
    \x05\x04F\x02\x17\x03\x12\x04\xbd\x05\x13\x15\n\x0c\n\x04\x04F\x02\x18\
    \x12\x04\xbe\x05\x04\x19\n\r\n\x05\x04F\x02\x18\x05\x12\x04\xbe\x05\x04\
    \t\n\r\n\x05\x04F\x02\x18\x01\x12\x04\xbe\x05\n\x13\n\r\n\x05\x04F\x02\
    \x18\x03\x12\x04\xbe\x05\x16\x18\n\x0c\n\x04\x04F\x02\x19\x12\x04\xbf\
    \x05\x04,\n\r\n\x05\x04F\x02\x19\x05\x12\x04\xbf\x05\x04\x08\n\r\n\x05\
    \x04F\x02\x19\x01\x12\x04\xbf\x05\t&\n\r\n\x05\x04F\x02\x19\x03\x12\x04\
    \xbf\x05)+\n\x0c\n\x04\x04F\x02\x1a\x12\x04\xc0\x05\x04&\n\r\n\x05\x04F\
    \x02\x1a\x05\x12\x04\xc0\x05\x04\t\n\r\n\x05\x04F\x02\x1a\x01\x12\x04\
    \xc0\x05\n\x20\n\r\n\x05\x04F\x02\x1a\x03\x12\x04\xc0\x05#%\n\x0c\n\x04\
    \x04F\x02\x1b\x12\x04\xc1\x05\x04'\n\r\n\x05\x04F\x02\x1b\x05\x12\x04\
    \xc1\x05\x04\t\n\r\n\x05\x04F\x02\x1b\x01\x12\x04\xc1\x05\n!\n\r\n\x05\
    \x04F\x02\x1b\x03\x12\x04\xc1\x05$&\n\x0c\n\x04\x04F\x02\x1c\x12\x04\xc2\
    \x05\x04\x1f\n\r\n\x05\x04F\x02\x1c\x05\x12\x04\xc2\x05\x04\t\n\r\n\x05\
    \x04F\x02\x1c\x01\x12\x04\xc2\x05\n\x19\n\r\n\x05\x04F\x02\x1c\x03\x12\
    \x04\xc2\x05\x1c\x1e\n\x0c\n\x04\x04F\x02\x1d\x12\x04\xc3\x05\x04\x20\n\
    \r\n\x05\x04F\x02\x1d\x05\x12\x04\xc3\x05\x04\t\n\r\n\x05\x04F\x02\x1d\
    \x01\x12\x04\xc3\x05\n\x1a\n\r\n\x05\x04F\x02\x1d\x03\x12\x04\xc3\x05\
    \x1d\x1f\n\x0c\n\x04\x04F\x02\x1e\x12\x04\xc4\x05\x04\x1d\n\r\n\x05\x04F\
    \x02\x1e\x05\x12\x04\xc4\x05\x04\x08\n\r\n\x05\x04F\x02\x1e\x01\x12\x04\
    \xc4\x05\t\x17\n\r\n\x05\x04F\x02\x1e\x03\x12\x04\xc4\x05\x1a\x1c\n\x0c\
    \n\x04\x04F\x02\x1f\x12\x04\xc5\x05\x04+\n\r\n\x05\x04F\x02\x1f\x05\x12\
    \x04\xc5\x05\x04\x08\n\r\n\x05\x04F\x02\x1f\x01\x12\x04\xc5\x05\t%\n\r\n\
    \x05\x04F\x02\x1f\x03\x12\x04\xc5\x05(*\n\x0c\n\x04\x04F\x02\x20\x12\x04\
    \xc6\x05\x04!\n\r\n\x05\x04F\x02\x20\x05\x12\x04\xc6\x05\x04\t\n\r\n\x05\
    \x04F\x02\x20\x01\x12\x04\xc6\x05\n\x1b\n\r\n\x05\x04F\x02\x20\x03\x12\
    \x04\xc6\x05\x1e\x20\n\x0c\n\x04\x04F\x02!\x12\x04\xc7\x05\x04!\n\r\n\
    \x05\x04F\x02!\x05\x12\x04\xc7\x05\x04\t\n\r\n\x05\x04F\x02!\x01\x12\x04\
    \xc7\x05\n\x1b\n\r\n\x05\x04F\x02!\x03\x12\x04\xc7\x05\x1e\x20\n\x0c\n\
    \x04\x04F\x02\"\x12\x04\xc8\x05\x04\x1f\n\r\n\x05\x04F\x02\"\x05\x12\x04\
    \xc8\x05\x04\x08\n\r\n\x05\x04F\x02\"\x01\x12\x04\xc8\x05\t\x19\n\r\n\
    \x05\x04F\x02\"\x03\x12\x04\xc8\x05\x1c\x1e\n\x0c\n\x04\x04F\x02#\x12\
    \x04\xc9\x05\x04\"\n\r\n\x05\x04F\x02#\x05\x12\x04\xc9\x05\x04\n\n\r\n\
    \x05\x04F\x02#\x01\x12\x04\xc9\x05\x0b\x1c\n\r\n\x05\x04F\x02#\x03\x12\
    \x04\xc9\x05\x1f!\n\x0c\n\x04\x04F\x02$\x12\x04\xca\x05\x04(\n\r\n\x05\
    \x04F\x02$\x06\x12\x04\xca\x05\x04\x17\n\r\n\x05\x04F\x02$\x01\x12\x04\
    \xca\x05\x18\"\n\r\n\x05\x04F\x02$\x03\x12\x04\xca\x05%'\n\x0c\n\x04\x04\
    F\x02%\x12\x04\xcb\x05\x04\x20\n\r\n\x05\x04F\x02%\x05\x12\x04\xcb\x05\
    \x04\t\n\r\n\x05\x04F\x02%\x01\x12\x04\xcb\x05\n\x1a\n\r\n\x05\x04F\x02%\
    \x03\x12\x04\xcb\x05\x1d\x1f\n\x0c\n\x02\x04G\x12\x06\xce\x05\0\xd1\x05\
    \x01\n\x0b\n\x03\x04G\x01\x12\x04\xce\x05\x08\x19\n\x0c\n\x04\x04G\x02\0\
    \x12\x04\xcf\x05\x04\x13\n\r\n\x05\x04G\x02\0\x05\x12\x04\xcf\x05\x04\t\
    \n\r\n\x05\x04G\x02\0\x01\x12\x04\xcf\x05\n\x0e\n\r\n\x05\x04G\x02\0\x03\
    \x12\x04\xcf\x05\x11\x12\n\x0c\n\x04\x04G\x02\x01\x12\x04\xd0\x05\x04\
    \x13\n\r\n\x05\x04G\x02\x01\x05\x12\x04\xd0\x05\x04\t\n\r\n\x05\x04G\x02\
    \x01\x01\x12\x04\xd0\x05\n\x0e\n\r\n\x05\x04G\x02\x01\x03\x12\x04\xd0\
    \x05\x11\x12\n\x0c\n\x02\x04H\x12\x06\xd3\x05\0\xe1\x05\x01\n\x0b\n\x03\
    \x04H\x01\x12\x04\xd3\x05\x08\x15\n\x0e\n\x04\x04H\x04\0\x12\x06\xd4\x05\
    \x04\xd8\x05\x05\n\r\n\x05\x04H\x04\0\x01\x12\x04\xd4\x05\t\x1b\n\x0e\n\
    \x06\x04H\x04\0\x02\0\x12\x04\xd5\x05\x08\x15\n\x0f\n\x07\x04H\x04\0\x02\
    \0\x01\x12\x04\xd5\x05\x08\x10\n\x0f\n\x07\x04H\x04\0\x02\0\x02\x12\x04\
    \xd5\x05\x13\x14\n\x0e\n\x06\x04H\x04\0\x02\x01\x12\x04\xd6\x05\x08\x17\
    \n\x0f\n\x07\x04H\x04\0\x02\x01\x01\x12\x04\xd6\x05\x08\x12\n\x0f\n\x07\
    \x04H\x04\0\x02\x01\x02\x12\x04\xd6\x05\x15\x16\n\x0e\n\x06\x04H\x04\0\
    \x02\x02\x12\x04\xd7\x05\x08\x12\n\x0f\n\x07\x04H\x04\0\x02\x02\x01\x12\
    \x04\xd7\x05\x08\r\n\x0f\n\x07\x04H\x04\0\x02\x02\x02\x12\x04\xd7\x05\
    \x10\x11\n\x0c\n\x04\x04H\x02\0\x12\x04\xda\x05\x04/\n\r\n\x05\x04H\x02\
    \0\x06\x12\x04\xda\x05\x04\x16\n\r\n\x05\x04H\x02\0\x01\x12\x04\xda\x05\
    \x17*\n\r\n\x05\x04H\x02\0\x03\x12\x04\xda\x05-.\n\x0c\n\x04\x04H\x02\
    \x01\x12\x04\xdb\x05\x04'\n\r\n\x05\x04H\x02\x01\x05\x12\x04\xdb\x05\x04\
    \t\n\r\n\x05\x04H\x02\x01\x01\x12\x04\xdb\x05\n\"\n\r\n\x05\x04H\x02\x01\
    \x03\x12\x04\xdb\x05%&\n\x0c\n\x04\x04H\x02\x02\x12\x04\xdc\x05\x04\x18\
    \n\r\n\x05\x04H\x02\x02\x05\x12\x04\xdc\x05\x04\t\n\r\n\x05\x04H\x02\x02\
    \x01\x12\x04\xdc\x05\n\x13\n\r\n\x05\x04H\x02\x02\x03\x12\x04\xdc\x05\
    \x16\x17\n\x0c\n\x04\x04H\x02\x03\x12\x04\xdd\x05\x04\x1d\n\r\n\x05\x04H\
    \x02\x03\x05\x12\x04\xdd\x05\x04\t\n\r\n\x05\x04H\x02\x03\x01\x12\x04\
    \xdd\x05\n\x18\n\r\n\x05\x04H\x02\x03\x03\x12\x04\xdd\x05\x1b\x1c\n\x0c\
    \n\x04\x04H\x02\x04\x12\x04\xde\x05\x04$\n\r\n\x05\x04H\x02\x04\x05\x12\
    \x04\xde\x05\x04\t\n\r\n\x05\x04H\x02\x04\x01\x12\x04\xde\x05\n\x1f\n\r\
    \n\x05\x04H\x02\x04\x03\x12\x04\xde\x05\"#\n\x0c\n\x04\x04H\x02\x05\x12\
    \x04\xdf\x05\x04\x13\n\r\n\x05\x04H\x02\x05\x05\x12\x04\xdf\x05\x04\t\n\
    \r\n\x05\x04H\x02\x05\x01\x12\x04\xdf\x05\n\x0e\n\r\n\x05\x04H\x02\x05\
    \x03\x12\x04\xdf\x05\x11\x12\n\x0c\n\x04\x04H\x02\x06\x12\x04\xe0\x05\
    \x04\x1b\n\r\n\x05\x04H\x02\x06\x05\x12\x04\xe0\x05\x04\t\n\r\n\x05\x04H\
    \x02\x06\x01\x12\x04\xe0\x05\n\x16\n\r\n\x05\x04H\x02\x06\x03\x12\x04\
    \xe0\x05\x19\x1a\n\xd4\x01\n\x02\x04I\x12\x06\xe8\x05\0\x83\x06\x012\xc5\
    \x01////////////////////////////////////////////////////////////////////\
    /////////////////////\n\x20Dispute\x20payload\n/////////////////////////\
    ////////////////////////////////////////////////////////////////\n\n\x0b\
    \n\x03\x04I\x01\x12\x04\xe8\x05\x08\x0f\n\x0c\n\x04\x04I\x02\0\x12\x04\
    \xe9\x05\x04\x18\n\r\n\x05\x04I\x02\0\x05\x12\x04\xe9\x05\x04\n\n\r\n\
    \x05\x04I\x02\0\x01\x12\x04\xe9\x05\x0b\x13\n\r\n\x05\x04I\x02\0\x03\x12\
    \x04\xe9\x05\x16\x17\n\x0c\n\x04\x04I\x02\x01\x12\x04\xea\x05\x04\x12\n\
    \r\n\x05\x04I\x02\x01\x05\x12\x04\xea\x05\x04\n\n\r\n\x05\x04I\x02\x01\
    \x01\x12\x04\xea\x05\x0b\r\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xea\x05\
    \x10\x11\n\x0c\n\x04\x04I\x02\x02\x12\x04\xeb\x05\x04\x18\n\r\n\x05\x04I\
    \x02\x02\x05\x12\x04\xeb\x05\x04\t\n\r\n\x05\x04I\x02\x02\x01\x12\x04\
    \xeb\x05\n\x13\n\r\n\x05\x04I\x02\x02\x03\x12\x04\xeb\x05\x16\x17\n\x0c\
    \n\x04\x04I\x02\x03\x12\x04\xec\x05\x04%\n\r\n\x05\x04I\x02\x03\x05\x12\
    \x04\xec\x05\x04\x08\n\r\n\x05\x04I\x02\x03\x01\x12\x04\xec\x05\t\x20\n\
    \r\n\x05\x04I\x02\x03\x03\x12\x04\xec\x05#$\n\x0c\n\x04\x04I\x02\x04\x12\
    \x04\xed\x05\x04%\n\r\n\x05\x04I\x02\x04\x05\x12\x04\xed\x05\x04\x08\n\r\
    \n\x05\x04I\x02\x04\x01\x12\x04\xed\x05\t\x20\n\r\n\x05\x04I\x02\x04\x03\
    \x12\x04\xed\x05#$\n\x0c\n\x04\x04I\x02\x05\x12\x04\xee\x05\x04\x1b\n\r\
    \n\x05\x04I\x02\x05\x05\x12\x04\xee\x05\x04\t\n\r\n\x05\x04I\x02\x05\x01\
    \x12\x04\xee\x05\n\x16\n\r\n\x05\x04I\x02\x05\x03\x12\x04\xee\x05\x19\
    \x1a\n\x0c\n\x04\x04I\x02\x06\x12\x04\xef\x05\x04'\n\r\n\x05\x04I\x02\
    \x06\x06\x12\x04\xef\x05\x04\x0e\n\r\n\x05\x04I\x02\x06\x01\x12\x04\xef\
    \x05\x0f\"\n\r\n\x05\x04I\x02\x06\x03\x12\x04\xef\x05%&\n\x0c\n\x04\x04I\
    \x02\x07\x12\x04\xf0\x05\x04\x19\n\r\n\x05\x04I\x02\x07\x05\x12\x04\xf0\
    \x05\x04\t\n\r\n\x05\x04I\x02\x07\x01\x12\x04\xf0\x05\n\x14\n\r\n\x05\
    \x04I\x02\x07\x03\x12\x04\xf0\x05\x17\x18\n\x0c\n\x04\x04I\x02\x08\x12\
    \x04\xf1\x05\x04\x1a\n\r\n\x05\x04I\x02\x08\x06\x12\x04\xf1\x05\x04\x0c\
    \n\r\n\x05\x04I\x02\x08\x01\x12\x04\xf1\x05\r\x15\n\r\n\x05\x04I\x02\x08\
    \x03\x12\x04\xf1\x05\x18\x19\n\x0c\n\x04\x04I\x02\t\x12\x04\xf2\x05\x04\
    \x1d\n\r\n\x05\x04I\x02\t\x05\x12\x04\xf2\x05\x04\t\n\r\n\x05\x04I\x02\t\
    \x01\x12\x04\xf2\x05\n\x17\n\r\n\x05\x04I\x02\t\x03\x12\x04\xf2\x05\x1a\
    \x1c\n\x0c\n\x04\x04I\x02\n\x12\x04\xf3\x05\x04%\n\r\n\x05\x04I\x02\n\
    \x05\x12\x04\xf3\x05\x04\t\n\r\n\x05\x04I\x02\n\x01\x12\x04\xf3\x05\n\
    \x1f\n\r\n\x05\x04I\x02\n\x03\x12\x04\xf3\x05\"$\n\x0c\n\x04\x04I\x02\
    \x0b\x12\x04\xf4\x05\x04$\n\r\n\x05\x04I\x02\x0b\x05\x12\x04\xf4\x05\x04\
    \t\n\r\n\x05\x04I\x02\x0b\x01\x12\x04\xf4\x05\n\x1e\n\r\n\x05\x04I\x02\
    \x0b\x03\x12\x04\xf4\x05!#\n\x0c\n\x04\x04I\x02\x0c\x12\x04\xf5\x05\x04\
    \x1e\n\r\n\x05\x04I\x02\x0c\x05\x12\x04\xf5\x05\x04\n\n\r\n\x05\x04I\x02\
    \x0c\x01\x12\x04\xf5\x05\x0b\x18\n\r\n\x05\x04I\x02\x0c\x03\x12\x04\xf5\
    \x05\x1b\x1d\n\x0c\n\x04\x04I\x02\r\x12\x04\xf6\x05\x04\x1d\n\r\n\x05\
    \x04I\x02\r\x05\x12\x04\xf6\x05\x04\n\n\r\n\x05\x04I\x02\r\x01\x12\x04\
    \xf6\x05\x0b\x17\n\r\n\x05\x04I\x02\r\x03\x12\x04\xf6\x05\x1a\x1c\n\x0c\
    \n\x04\x04I\x02\x0e\x12\x04\xf7\x05\x04!\n\r\n\x05\x04I\x02\x0e\x05\x12\
    \x04\xf7\x05\x04\n\n\r\n\x05\x04I\x02\x0e\x01\x12\x04\xf7\x05\x0b\x1b\n\
    \r\n\x05\x04I\x02\x0e\x03\x12\x04\xf7\x05\x1e\x20\n\x0c\n\x04\x04I\x02\
    \x0f\x12\x04\xf8\x05\x04)\n\r\n\x05\x04I\x02\x0f\x05\x12\x04\xf8\x05\x04\
    \n\n\r\n\x05\x04I\x02\x0f\x01\x12\x04\xf8\x05\x0b#\n\r\n\x05\x04I\x02\
    \x0f\x03\x12\x04\xf8\x05&(\n\x0c\n\x04\x04I\x02\x10\x12\x04\xf9\x05\x04)\
    \n\r\n\x05\x04I\x02\x10\x05\x12\x04\xf9\x05\x04\n\n\r\n\x05\x04I\x02\x10\
    \x01\x12\x04\xf9\x05\x0b#\n\r\n\x05\x04I\x02\x10\x03\x12\x04\xf9\x05&(\n\
    \x0c\n\x04\x04I\x02\x11\x12\x04\xfa\x05\x04'\n\r\n\x05\x04I\x02\x11\x06\
    \x12\x04\xfa\x05\x04\x0e\n\r\n\x05\x04I\x02\x11\x01\x12\x04\xfa\x05\x0f!\
    \n\r\n\x05\x04I\x02\x11\x03\x12\x04\xfa\x05$&\n\x0c\n\x04\x04I\x02\x12\
    \x12\x04\xfb\x05\x04\x20\n\r\n\x05\x04I\x02\x12\x05\x12\x04\xfb\x05\x04\
    \x08\n\r\n\x05\x04I\x02\x12\x01\x12\x04\xfb\x05\t\x1a\n\r\n\x05\x04I\x02\
    \x12\x03\x12\x04\xfb\x05\x1d\x1f\n\x0c\n\x04\x04I\x02\x13\x12\x04\xfc\
    \x05\x04+\n\r\n\x05\x04I\x02\x13\x04\x12\x04\xfc\x05\x04\x0c\n\r\n\x05\
    \x04I\x02\x13\x06\x12\x04\xfc\x05\r\x18\n\r\n\x05\x04I\x02\x13\x01\x12\
    \x04\xfc\x05\x19%\n\r\n\x05\x04I\x02\x13\x03\x12\x04\xfc\x05(*\n\x0c\n\
    \x04\x04I\x02\x14\x12\x04\xfd\x05\x04\x18\n\r\n\x05\x04I\x02\x14\x05\x12\
    \x04\xfd\x05\x04\x08\n\r\n\x05\x04I\x02\x14\x01\x12\x04\xfd\x05\t\x12\n\
    \r\n\x05\x04I\x02\x14\x03\x12\x04\xfd\x05\x15\x17\n\x0c\n\x04\x04I\x02\
    \x15\x12\x04\xfe\x05\x04&\n\r\n\x05\x04I\x02\x15\x06\x12\x04\xfe\x05\x04\
    \x11\n\r\n\x05\x04I\x02\x15\x01\x12\x04\xfe\x05\x12\x20\n\r\n\x05\x04I\
    \x02\x15\x03\x12\x04\xfe\x05#%\n\x0c\n\x04\x04I\x02\x16\x12\x04\xff\x05\
    \x04%\n\r\n\x05\x04I\x02\x16\x05\x12\x04\xff\x05\x04\n\n\r\n\x05\x04I\
    \x02\x16\x01\x12\x04\xff\x05\x0b\x1f\n\r\n\x05\x04I\x02\x16\x03\x12\x04\
    \xff\x05\"$\n\x0c\n\x04\x04I\x02\x17\x12\x04\x80\x06\x04\"\n\r\n\x05\x04\
    I\x02\x17\x06\x12\x04\x80\x06\x04\x0f\n\r\n\x05\x04I\x02\x17\x01\x12\x04\
    \x80\x06\x10\x1c\n\r\n\x05\x04I\x02\x17\x03\x12\x04\x80\x06\x1f!\n\x0c\n\
    \x04\x04I\x02\x18\x12\x04\x81\x06\x04)\n\r\n\x05\x04I\x02\x18\x05\x12\
    \x04\x81\x06\x04\n\n\r\n\x05\x04I\x02\x18\x01\x12\x04\x81\x06\x0b#\n\r\n\
    \x05\x04I\x02\x18\x03\x12\x04\x81\x06&(\n\x0c\n\x04\x04I\x02\x19\x12\x04\
    \x82\x06\x04%\n\r\n\x05\x04I\x02\x19\x05\x12\x04\x82\x06\x04\n\n\r\n\x05\
    \x04I\x02\x19\x01\x12\x04\x82\x06\x0b\x1f\n\r\n\x05\x04I\x02\x19\x03\x12\
    \x04\x82\x06\"$\n\x0c\n\x02\x04J\x12\x06\x85\x06\0\x88\x06\x01\n\x0b\n\
    \x03\x04J\x01\x12\x04\x85\x06\x08\x12\n\x0c\n\x04\x04J\x02\0\x12\x04\x86\
    \x06\x04\x19\n\r\n\x05\x04J\x02\0\x05\x12\x04\x86\x06\x04\n\n\r\n\x05\
    \x04J\x02\0\x01\x12\x04\x86\x06\x0b\x14\n\r\n\x05\x04J\x02\0\x03\x12\x04\
    \x86\x06\x17\x18\n\x0c\n\x04\x04J\x02\x01\x12\x04\x87\x06\x04\x14\n\r\n\
    \x05\x04J\x02\x01\x05\x12\x04\x87\x06\x04\t\n\r\n\x05\x04J\x02\x01\x01\
    \x12\x04\x87\x06\n\x0f\n\r\n\x05\x04J\x02\x01\x03\x12\x04\x87\x06\x12\
    \x13\n\x0c\n\x02\x04K\x12\x06\x8a\x06\0\xab\x06\x01\n\x0b\n\x03\x04K\x01\
    \x12\x04\x8a\x06\x08\x15\n\x0e\n\x04\x04K\x04\0\x12\x06\x8b\x06\x04\x8f\
    \x06\x05\n\r\n\x05\x04K\x04\0\x01\x12\x04\x8b\x06\t\x0f\n\x0e\n\x06\x04K\
    \x04\0\x02\0\x12\x04\x8c\x06\x08\x1c\n\x0f\n\x07\x04K\x04\0\x02\0\x01\
    \x12\x04\x8c\x06\x08\x17\n\x0f\n\x07\x04K\x04\0\x02\0\x02\x12\x04\x8c\
    \x06\x1a\x1b\n\x0e\n\x06\x04K\x04\0\x02\x01\x12\x04\x8d\x06\x08\x12\n\
    \x0f\n\x07\x04K\x04\0\x02\x01\x01\x12\x04\x8d\x06\x08\r\n\x0f\n\x07\x04K\
    \x04\0\x02\x01\x02\x12\x04\x8d\x06\x10\x11\n\x0e\n\x06\x04K\x04\0\x02\
    \x02\x12\x04\x8e\x06\x08\x13\n\x0f\n\x07\x04K\x04\0\x02\x02\x01\x12\x04\
    \x8e\x06\x08\x0e\n\x0f\n\x07\x04K\x04\0\x02\x02\x02\x12\x04\x8e\x06\x11\
    \x12\n\x0e\n\x04\x04K\x04\x01\x12\x06\x91\x06\x04\x9a\x06\x05\n\r\n\x05\
    \x04K\x04\x01\x01\x12\x04\x91\x06\t\x0f\n\x0e\n\x06\x04K\x04\x01\x02\0\
    \x12\x04\x92\x06\x08\x1c\n\x0f\n\x07\x04K\x04\x01\x02\0\x01\x12\x04\x92\
    \x06\x08\x17\n\x0f\n\x07\x04K\x04\x01\x02\0\x02\x12\x04\x92\x06\x1a\x1b\
    \n\x0e\n\x06\x04K\x04\x01\x02\x01\x12\x04\x93\x06\x08\x12\n\x0f\n\x07\
    \x04K\x04\x01\x02\x01\x01\x12\x04\x93\x06\x08\r\n\x0f\n\x07\x04K\x04\x01\
    \x02\x01\x02\x12\x04\x93\x06\x10\x11\n\x0e\n\x06\x04K\x04\x01\x02\x02\
    \x12\x04\x94\x06\x08\x10\n\x0f\n\x07\x04K\x04\x01\x02\x02\x01\x12\x04\
    \x94\x06\x08\x0b\n\x0f\n\x07\x04K\x04\x01\x02\x02\x02\x12\x04\x94\x06\
    \x0e\x0f\n\x0e\n\x06\x04K\x04\x01\x02\x03\x12\x04\x95\x06\x08\x16\n\x0f\
    \n\x07\x04K\x04\x01\x02\x03\x01\x12\x04\x95\x06\x08\x11\n\x0f\n\x07\x04K\
    \x04\x01\x02\x03\x02\x12\x04\x95\x06\x14\x15\n\x0e\n\x06\x04K\x04\x01\
    \x02\x04\x12\x04\x96\x06\x08\x11\n\x0f\n\x07\x04K\x04\x01\x02\x04\x01\
    \x12\x04\x96\x06\x08\x0c\n\x0f\n\x07\x04K\x04\x01\x02\x04\x02\x12\x04\
    \x96\x06\x0f\x10\n\x0e\n\x06\x04K\x04\x01\x02\x05\x12\x04\x97\x06\x08\
    \x1f\n\x0f\n\x07\x04K\x04\x01\x02\x05\x01\x12\x04\x97\x06\x08\x1a\n\x0f\
    \n\x07\x04K\x04\x01\x02\x05\x02\x12\x04\x97\x06\x1d\x1e\n\x0e\n\x06\x04K\
    \x04\x01\x02\x06\x12\x04\x98\x06\x08\x15\n\x0f\n\x07\x04K\x04\x01\x02\
    \x06\x01\x12\x04\x98\x06\x08\x10\n\x0f\n\x07\x04K\x04\x01\x02\x06\x02\
    \x12\x04\x98\x06\x13\x14\n\x0e\n\x06\x04K\x04\x01\x02\x07\x12\x04\x99\
    \x06\x08\x1a\n\x0f\n\x07\x04K\x04\x01\x02\x07\x01\x12\x04\x99\x06\x08\
    \x15\n\x0f\n\x07\x04K\x04\x01\x02\x07\x02\x12\x04\x99\x06\x18\x19\n\x0c\
    \n\x04\x04K\x02\0\x12\x04\x9c\x06\x04\x18\n\r\n\x05\x04K\x02\0\x05\x12\
    \x04\x9c\x06\x04\n\n\r\n\x05\x04K\x02\0\x01\x12\x04\x9c\x06\x0b\x13\n\r\
    \n\x05\x04K\x02\0\x03\x12\x04\x9c\x06\x16\x17\n\x0c\n\x04\x04K\x02\x01\
    \x12\x04\x9d\x06\x04\x18\n\r\n\x05\x04K\x02\x01\x05\x12\x04\x9d\x06\x04\
    \t\n\r\n\x05\x04K\x02\x01\x01\x12\x04\x9d\x06\n\x13\n\r\n\x05\x04K\x02\
    \x01\x03\x12\x04\x9d\x06\x16\x17\n\x0c\n\x04\x04K\x02\x02\x12\x04\x9e\
    \x06\x04\x16\n\r\n\x05\x04K\x02\x02\x06\x12\x04\x9e\x06\x04\n\n\r\n\x05\
    \x04K\x02\x02\x01\x12\x04\x9e\x06\x0b\x11\n\r\n\x05\x04K\x02\x02\x03\x12\
    \x04\x9e\x06\x14\x15\n\x0c\n\x04\x04K\x02\x03\x12\x04\x9f\x06\x04\x1d\n\
    \r\n\x05\x04K\x02\x03\x05\x12\x04\x9f\x06\x04\t\n\r\n\x05\x04K\x02\x03\
    \x01\x12\x04\x9f\x06\n\x18\n\r\n\x05\x04K\x02\x03\x03\x12\x04\x9f\x06\
    \x1b\x1c\n\x0c\n\x04\x04K\x02\x04\x12\x04\xa0\x06\x04#\n\r\n\x05\x04K\
    \x02\x04\x05\x12\x04\xa0\x06\x04\x08\n\r\n\x05\x04K\x02\x04\x01\x12\x04\
    \xa0\x06\t\x1e\n\r\n\x05\x04K\x02\x04\x03\x12\x04\xa0\x06!\"\n\x0c\n\x04\
    \x04K\x02\x05\x12\x04\xa1\x06\x04\x1d\n\r\n\x05\x04K\x02\x05\x05\x12\x04\
    \xa1\x06\x04\x08\n\r\n\x05\x04K\x02\x05\x01\x12\x04\xa1\x06\t\x18\n\r\n\
    \x05\x04K\x02\x05\x03\x12\x04\xa1\x06\x1b\x1c\n\x0c\n\x04\x04K\x02\x06\
    \x12\x04\xa2\x06\x04\x19\n\r\n\x05\x04K\x02\x06\x05\x12\x04\xa2\x06\x04\
    \x08\n\r\n\x05\x04K\x02\x06\x01\x12\x04\xa2\x06\t\x14\n\r\n\x05\x04K\x02\
    \x06\x03\x12\x04\xa2\x06\x17\x18\n\x0c\n\x04\x04K\x02\x07\x12\x04\xa3\
    \x06\x04\x1d\n\r\n\x05\x04K\x02\x07\x05\x12\x04\xa3\x06\x04\n\n\r\n\x05\
    \x04K\x02\x07\x01\x12\x04\xa3\x06\x0b\x18\n\r\n\x05\x04K\x02\x07\x03\x12\
    \x04\xa3\x06\x1b\x1c\n\x0c\n\x04\x04K\x02\x08\x12\x04\xa4\x06\x04!\n\r\n\
    \x05\x04K\x02\x08\x06\x12\x04\xa4\x06\x04\x0f\n\r\n\x05\x04K\x02\x08\x01\
    \x12\x04\xa4\x06\x10\x1c\n\r\n\x05\x04K\x02\x08\x03\x12\x04\xa4\x06\x1f\
    \x20\n\x0c\n\x04\x04K\x02\t\x12\x04\xa5\x06\x04$\n\r\n\x05\x04K\x02\t\
    \x05\x12\x04\xa5\x06\x04\t\n\r\n\x05\x04K\x02\t\x01\x12\x04\xa5\x06\n\
    \x1e\n\r\n\x05\x04K\x02\t\x03\x12\x04\xa5\x06!#\n\x0c\n\x04\x04K\x02\n\
    \x12\x04\xa6\x06\x04#\n\r\n\x05\x04K\x02\n\x05\x12\x04\xa6\x06\x04\t\n\r\
    \n\x05\x04K\x02\n\x01\x12\x04\xa6\x06\n\x1d\n\r\n\x05\x04K\x02\n\x03\x12\
    \x04\xa6\x06\x20\"\n\x0c\n\x04\x04K\x02\x0b\x12\x04\xa7\x06\x04$\n\r\n\
    \x05\x04K\x02\x0b\x05\x12\x04\xa7\x06\x04\t\n\r\n\x05\x04K\x02\x0b\x01\
    \x12\x04\xa7\x06\n\x1e\n\r\n\x05\x04K\x02\x0b\x03\x12\x04\xa7\x06!#\n\
    \x0c\n\x04\x04K\x02\x0c\x12\x04\xa8\x06\x04\"\n\r\n\x05\x04K\x02\x0c\x05\
    \x12\x04\xa8\x06\x04\t\n\r\n\x05\x04K\x02\x0c\x01\x12\x04\xa8\x06\n\x1c\
    \n\r\n\x05\x04K\x02\x0c\x03\x12\x04\xa8\x06\x1f!\n\x0c\n\x04\x04K\x02\r\
    \x12\x04\xa9\x06\x04\x1a\n\r\n\x05\x04K\x02\r\x05\x12\x04\xa9\x06\x04\t\
    \n\r\n\x05\x04K\x02\r\x01\x12\x04\xa9\x06\n\x14\n\r\n\x05\x04K\x02\r\x03\
    \x12\x04\xa9\x06\x17\x19\n\x0c\n\x04\x04K\x02\x0e\x12\x04\xaa\x06\x04!\n\
    \r\n\x05\x04K\x02\x0e\x05\x12\x04\xaa\x06\x04\x08\n\r\n\x05\x04K\x02\x0e\
    \x01\x12\x04\xaa\x06\t\x1b\n\r\n\x05\x04K\x02\x0e\x03\x12\x04\xaa\x06\
    \x1e\x20\n\xd2\x01\n\x02\x04L\x12\x06\xb1\x06\0\xc7\x06\x012\xc3\x01////\
    ////////////////////////////////////////////////////////////////////////\
    /////////////\n\x20Trade\x20payload\n///////////////////////////////////\
    //////////////////////////////////////////////////////\n\n\x0b\n\x03\x04\
    L\x01\x12\x04\xb1\x06\x08\x10\n\x0c\n\x04\x04L\x02\0\x12\x04\xb2\x06\x04\
    #\n\r\n\x05\x04L\x02\0\x06\x12\x04\xb2\x06\x04\x10\n\r\n\x05\x04L\x02\0\
    \x01\x12\x04\xb2\x06\x11\x1e\n\r\n\x05\x04L\x02\0\x03\x12\x04\xb2\x06!\"\
    \n\x0c\n\x04\x04L\x02\x01\x12\x04\xb3\x06\x04\x1b\n\r\n\x05\x04L\x02\x01\
    \x05\x12\x04\xb3\x06\x04\t\n\r\n\x05\x04L\x02\x01\x01\x12\x04\xb3\x06\n\
    \x16\n\r\n\x05\x04L\x02\x01\x03\x12\x04\xb3\x06\x19\x1a\n\x0c\n\x04\x04L\
    \x02\x02\x12\x04\xb4\x06\x04\x1a\n\r\n\x05\x04L\x02\x02\x05\x12\x04\xb4\
    \x06\x04\t\n\r\n\x05\x04L\x02\x02\x01\x12\x04\xb4\x06\n\x15\n\r\n\x05\
    \x04L\x02\x02\x03\x12\x04\xb4\x06\x18\x19\n\x0c\n\x04\x04L\x02\x03\x12\
    \x04\xb5\x06\x04\x1f\n\r\n\x05\x04L\x02\x03\x05\x12\x04\xb5\x06\x04\n\n\
    \r\n\x05\x04L\x02\x03\x01\x12\x04\xb5\x06\x0b\x1a\n\r\n\x05\x04L\x02\x03\
    \x03\x12\x04\xb5\x06\x1d\x1e\n+\n\x03\x04L\t\x12\x04\xb6\x06\x04\x0f\"\
    \x1e\x20WAS:\x20arbitrator_node_address\n\n\x0c\n\x04\x04L\t\0\x12\x04\
    \xb6\x06\r\x0e\n\r\n\x05\x04L\t\0\x01\x12\x04\xb6\x06\r\x0e\n\r\n\x05\
    \x04L\t\0\x02\x12\x04\xb6\x06\r\x0e\n\x0c\n\x04\x04L\x02\x04\x12\x04\xb7\
    \x06\x04-\n\r\n\x05\x04L\x02\x04\x05\x12\x04\xb7\x06\x04\x08\n\r\n\x05\
    \x04L\x02\x04\x01\x12\x04\xb7\x06\t(\n\r\n\x05\x04L\x02\x04\x03\x12\x04\
    \xb7\x06+,\n\x0c\n\x04\x04L\x02\x05\x12\x04\xb8\x06\x04\x20\n\r\n\x05\
    \x04L\x02\x05\x05\x12\x04\xb8\x06\x04\n\n\r\n\x05\x04L\x02\x05\x01\x12\
    \x04\xb8\x06\x0b\x1b\n\r\n\x05\x04L\x02\x05\x03\x12\x04\xb8\x06\x1e\x1f\
    \n\x0c\n\x04\x04L\x02\x06\x12\x04\xb9\x06\x04\x20\n\r\n\x05\x04L\x02\x06\
    \x05\x12\x04\xb9\x06\x04\n\n\r\n\x05\x04L\x02\x06\x01\x12\x04\xb9\x06\
    \x0b\x1b\n\r\n\x05\x04L\x02\x06\x03\x12\x04\xb9\x06\x1e\x1f\n\x0c\n\x04\
    \x04L\x02\x07\x12\x04\xba\x06\x04<\n\r\n\x05\x04L\x02\x07\x06\x12\x04\
    \xba\x06\x04\x19\n\r\n\x05\x04L\x02\x07\x01\x12\x04\xba\x06\x1a7\n\r\n\
    \x05\x04L\x02\x07\x03\x12\x04\xba\x06:;\n\x0c\n\x04\x04L\x02\x08\x12\x04\
    \xbb\x06\x04=\n\r\n\x05\x04L\x02\x08\x06\x12\x04\xbb\x06\x04\x19\n\r\n\
    \x05\x04L\x02\x08\x01\x12\x04\xbb\x06\x1a7\n\r\n\x05\x04L\x02\x08\x03\
    \x12\x04\xbb\x06:<\n\x0c\n\x04\x04L\x02\t\x12\x04\xbc\x06\x04'\n\r\n\x05\
    \x04L\x02\t\x06\x12\x04\xbc\x06\x04\x0e\n\r\n\x05\x04L\x02\t\x01\x12\x04\
    \xbc\x06\x0f!\n\r\n\x05\x04L\x02\t\x03\x12\x04\xbc\x06$&\n\x0c\n\x04\x04\
    L\x02\n\x12\x04\xbd\x06\x04'\n\r\n\x05\x04L\x02\n\x06\x12\x04\xbd\x06\
    \x04\x0e\n\r\n\x05\x04L\x02\n\x01\x12\x04\xbd\x06\x0f!\n\r\n\x05\x04L\
    \x02\n\x03\x12\x04\xbd\x06$&\n\x0c\n\x04\x04L\x02\x0b\x12\x04\xbe\x06\
    \x04(\n\r\n\x05\x04L\x02\x0b\x06\x12\x04\xbe\x06\x04\x0f\n\r\n\x05\x04L\
    \x02\x0b\x01\x12\x04\xbe\x06\x10\"\n\r\n\x05\x04L\x02\x0b\x03\x12\x04\
    \xbe\x06%'\n\x0c\n\x04\x04L\x02\x0c\x12\x04\xbf\x06\x04)\n\r\n\x05\x04L\
    \x02\x0c\x06\x12\x04\xbf\x06\x04\x0f\n\r\n\x05\x04L\x02\x0c\x01\x12\x04\
    \xbf\x06\x10#\n\r\n\x05\x04L\x02\x0c\x03\x12\x04\xbf\x06&(\n\x0c\n\x04\
    \x04L\x02\r\x12\x04\xc0\x06\x04,\n\r\n\x05\x04L\x02\r\x05\x12\x04\xc0\
    \x06\x04\n\n\r\n\x05\x04L\x02\r\x01\x12\x04\xc0\x06\x0b&\n\r\n\x05\x04L\
    \x02\r\x03\x12\x04\xc0\x06)+\n\x0c\n\x04\x04L\x02\x0e\x12\x04\xc1\x06\
    \x04,\n\r\n\x05\x04L\x02\x0e\x05\x12\x04\xc1\x06\x04\n\n\r\n\x05\x04L\
    \x02\x0e\x01\x12\x04\xc1\x06\x0b&\n\r\n\x05\x04L\x02\x0e\x03\x12\x04\xc1\
    \x06)+\n\x0c\n\x04\x04L\x02\x0f\x12\x04\xc2\x06\x04'\n\r\n\x05\x04L\x02\
    \x0f\x05\x12\x04\xc2\x06\x04\t\n\r\n\x05\x04L\x02\x0f\x01\x12\x04\xc2\
    \x06\n!\n\r\n\x05\x04L\x02\x0f\x03\x12\x04\xc2\x06$&\n\x0c\n\x04\x04L\
    \x02\x10\x12\x04\xc3\x06\x04'\n\r\n\x05\x04L\x02\x10\x05\x12\x04\xc3\x06\
    \x04\t\n\r\n\x05\x04L\x02\x10\x01\x12\x04\xc3\x06\n!\n\r\n\x05\x04L\x02\
    \x10\x03\x12\x04\xc3\x06$&\n\x0c\n\x04\x04L\x02\x11\x12\x04\xc4\x06\x04+\
    \n\r\n\x05\x04L\x02\x11\x06\x12\x04\xc4\x06\x04\x0f\n\r\n\x05\x04L\x02\
    \x11\x01\x12\x04\xc4\x06\x10%\n\r\n\x05\x04L\x02\x11\x03\x12\x04\xc4\x06\
    (*\n\x0c\n\x04\x04L\x02\x12\x12\x04\xc5\x06\x04\x19\n\r\n\x05\x04L\x02\
    \x12\x05\x12\x04\xc5\x06\x04\t\n\r\n\x05\x04L\x02\x12\x01\x12\x04\xc5\
    \x06\n\x13\n\r\n\x05\x04L\x02\x12\x03\x12\x04\xc5\x06\x16\x18\n\x0c\n\
    \x04\x04L\x02\x13\x12\x04\xc6\x06\x04/\n\r\n\x05\x04L\x02\x13\x06\x12\
    \x04\xc6\x06\x04\x0f\n\r\n\x05\x04L\x02\x13\x01\x12\x04\xc6\x06\x10)\n\r\
    \n\x05\x04L\x02\x13\x03\x12\x04\xc6\x06,.\n\x0c\n\x02\x04M\x12\x06\xc9\
    \x06\0\xcd\x06\x01\n\x0b\n\x03\x04M\x01\x12\x04\xc9\x06\x08\x1b\n\x0c\n\
    \x04\x04M\x02\0\x12\x04\xca\x06\x04\x14\n\r\n\x05\x04M\x02\0\x05\x12\x04\
    \xca\x06\x04\t\n\r\n\x05\x04M\x02\0\x01\x12\x04\xca\x06\n\x0f\n\r\n\x05\
    \x04M\x02\0\x03\x12\x04\xca\x06\x12\x13\n\x0c\n\x04\x04M\x02\x01\x12\x04\
    \xcb\x06\x04!\n\r\n\x05\x04M\x02\x01\x05\x12\x04\xcb\x06\x04\t\n\r\n\x05\
    \x04M\x02\x01\x01\x12\x04\xcb\x06\n\x1c\n\r\n\x05\x04M\x02\x01\x03\x12\
    \x04\xcb\x06\x1f\x20\n\x0c\n\x04\x04M\x02\x02\x12\x04\xcc\x06\x04\x14\n\
    \r\n\x05\x04M\x02\x02\x05\x12\x04\xcc\x06\x04\t\n\r\n\x05\x04M\x02\x02\
    \x01\x12\x04\xcc\x06\n\x0f\n\r\n\x05\x04M\x02\x02\x03\x12\x04\xcc\x06\
    \x12\x13\n\x0c\n\x02\x05\x01\x12\x06\xcf\x06\0\xdb\x06\x01\n\x0b\n\x03\
    \x05\x01\x01\x12\x04\xcf\x06\x05\x17\n\x0c\n\x04\x05\x01\x02\0\x12\x04\
    \xd0\x06\x04\x11\n\r\n\x05\x05\x01\x02\0\x01\x12\x04\xd0\x06\x04\x0c\n\r\
    \n\x05\x05\x01\x02\0\x02\x12\x04\xd0\x06\x0f\x10\n\x0c\n\x04\x05\x01\x02\
    \x01\x12\x04\xd1\x06\x04\x18\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\xd1\
    \x06\x04\x13\n\r\n\x05\x05\x01\x02\x01\x02\x12\x04\xd1\x06\x16\x17\n\x0c\
    \n\x04\x05\x01\x02\x02\x12\x04\xd2\x06\x04\x12\n\r\n\x05\x05\x01\x02\x02\
    \x01\x12\x04\xd2\x06\x04\r\n\r\n\x05\x05\x01\x02\x02\x02\x12\x04\xd2\x06\
    \x10\x11\n\x0c\n\x04\x05\x01\x02\x03\x12\x04\xd3\x06\x04\x14\n\r\n\x05\
    \x05\x01\x02\x03\x01\x12\x04\xd3\x06\x04\x0f\n\r\n\x05\x05\x01\x02\x03\
    \x02\x12\x04\xd3\x06\x12\x13\n\x0c\n\x04\x05\x01\x02\x04\x12\x04\xd4\x06\
    \x04\x1f\n\r\n\x05\x05\x01\x02\x04\x01\x12\x04\xd4\x06\x04\x1a\n\r\n\x05\
    \x05\x01\x02\x04\x02\x12\x04\xd4\x06\x1d\x1e\n\x0c\n\x04\x05\x01\x02\x05\
    \x12\x04\xd5\x06\x04#\n\r\n\x05\x05\x01\x02\x05\x01\x12\x04\xd5\x06\x04\
    \x1e\n\r\n\x05\x05\x01\x02\x05\x02\x12\x04\xd5\x06!\"\n\x0c\n\x04\x05\
    \x01\x02\x06\x12\x04\xd6\x06\x04\x17\n\r\n\x05\x05\x01\x02\x06\x01\x12\
    \x04\xd6\x06\x04\x12\n\r\n\x05\x05\x01\x02\x06\x02\x12\x04\xd6\x06\x15\
    \x16\n\x0c\n\x04\x05\x01\x02\x07\x12\x04\xd7\x06\x04\x15\n\r\n\x05\x05\
    \x01\x02\x07\x01\x12\x04\xd7\x06\x04\x10\n\r\n\x05\x05\x01\x02\x07\x02\
    \x12\x04\xd7\x06\x13\x14\n\x0c\n\x04\x05\x01\x02\x08\x12\x04\xd8\x06\x04\
    \x15\n\r\n\x05\x05\x01\x02\x08\x01\x12\x04\xd8\x06\x04\x10\n\r\n\x05\x05\
    \x01\x02\x08\x02\x12\x04\xd8\x06\x13\x14\n\x0c\n\x04\x05\x01\x02\t\x12\
    \x04\xd9\x06\x04%\n\r\n\x05\x05\x01\x02\t\x01\x12\x04\xd9\x06\x04\x20\n\
    \r\n\x05\x05\x01\x02\t\x02\x12\x04\xd9\x06#$\n\x0c\n\x04\x05\x01\x02\n\
    \x12\x04\xda\x06\x04\x1a\n\r\n\x05\x05\x01\x02\n\x01\x12\x04\xda\x06\x04\
    \x14\n\r\n\x05\x05\x01\x02\n\x02\x12\x04\xda\x06\x17\x19\n\xdb\x01\n\x02\
    \x04N\x12\x06\xe2\x06\0\x81\x07\x012\xcc\x01////////////////////////////\
    /////////////////////////////////////////////////////////////\n\x20Payme\
    ntAccount\x20payload\n//////////////////////////////////////////////////\
    ///////////////////////////////////////\n\n\x0b\n\x03\x04N\x01\x12\x04\
    \xe2\x06\x08\x1d\n\x0c\n\x04\x04N\x02\0\x12\x04\xe3\x06\x04\x12\n\r\n\
    \x05\x04N\x02\0\x05\x12\x04\xe3\x06\x04\n\n\r\n\x05\x04N\x02\0\x01\x12\
    \x04\xe3\x06\x0b\r\n\r\n\x05\x04N\x02\0\x03\x12\x04\xe3\x06\x10\x11\n\
    \x0c\n\x04\x04N\x02\x01\x12\x04\xe4\x06\x04!\n\r\n\x05\x04N\x02\x01\x05\
    \x12\x04\xe4\x06\x04\n\n\r\n\x05\x04N\x02\x01\x01\x12\x04\xe4\x06\x0b\
    \x1c\n\r\n\x05\x04N\x02\x01\x03\x12\x04\xe4\x06\x1f\x20\nX\n\x04\x04N\
    \x02\x02\x12\x04\xe5\x06\x043\"J\x20not\x20used\x20anymore\x20but\x20we\
    \x20need\x20to\x20keep\x20it\x20in\x20PB\x20for\x20backward\x20compatibi\
    lity\n\n\r\n\x05\x04N\x02\x02\x05\x12\x04\xe5\x06\x04\t\n\r\n\x05\x04N\
    \x02\x02\x01\x12\x04\xe5\x06\n\x1a\n\r\n\x05\x04N\x02\x02\x03\x12\x04\
    \xe5\x06\x1d\x1e\n\r\n\x05\x04N\x02\x02\x08\x12\x04\xe5\x06\x1f2\n\x0e\n\
    \x06\x04N\x02\x02\x08\x03\x12\x04\xe5\x06\x201\n\x0e\n\x04\x04N\x08\0\
    \x12\x06\xe6\x06\x04\xff\x06\x05\n\r\n\x05\x04N\x08\0\x01\x12\x04\xe6\
    \x06\n\x11\n\x0c\n\x04\x04N\x02\x03\x12\x04\xe7\x06\x089\n\r\n\x05\x04N\
    \x02\x03\x06\x12\x04\xe7\x06\x08\x1c\n\r\n\x05\x04N\x02\x03\x01\x12\x04\
    \xe7\x06\x1d4\n\r\n\x05\x04N\x02\x03\x03\x12\x04\xe7\x0678\n\x0c\n\x04\
    \x04N\x02\x04\x12\x04\xe8\x06\x08H\n\r\n\x05\x04N\x02\x04\x06\x12\x04\
    \xe8\x06\x08#\n\r\n\x05\x04N\x02\x04\x01\x12\x04\xe8\x06$C\n\r\n\x05\x04\
    N\x02\x04\x03\x12\x04\xe8\x06FG\n\x0c\n\x04\x04N\x02\x05\x12\x04\xe9\x06\
    \x08E\n\r\n\x05\x04N\x02\x05\x06\x12\x04\xe9\x06\x08\"\n\r\n\x05\x04N\
    \x02\x05\x01\x12\x04\xe9\x06#@\n\r\n\x05\x04N\x02\x05\x03\x12\x04\xe9\
    \x06CD\n\x0c\n\x04\x04N\x02\x06\x12\x04\xea\x06\x08T\n\r\n\x05\x04N\x02\
    \x06\x06\x12\x04\xea\x06\x08)\n\r\n\x05\x04N\x02\x06\x01\x12\x04\xea\x06\
    *O\n\r\n\x05\x04N\x02\x06\x03\x12\x04\xea\x06RS\n\x0c\n\x04\x04N\x02\x07\
    \x12\x04\xeb\x06\x08I\n\r\n\x05\x04N\x02\x07\x06\x12\x04\xeb\x06\x08$\n\
    \r\n\x05\x04N\x02\x07\x01\x12\x04\xeb\x06%D\n\r\n\x05\x04N\x02\x07\x03\
    \x12\x04\xeb\x06GH\n\x0c\n\x04\x04N\x02\x08\x12\x04\xec\x06\x08I\n\r\n\
    \x05\x04N\x02\x08\x06\x12\x04\xec\x06\x08$\n\r\n\x05\x04N\x02\x08\x01\
    \x12\x04\xec\x06%D\n\r\n\x05\x04N\x02\x08\x03\x12\x04\xec\x06GH\n\x0c\n\
    \x04\x04N\x02\t\x12\x04\xed\x06\x08O\n\r\n\x05\x04N\x02\t\x06\x12\x04\
    \xed\x06\x08&\n\r\n\x05\x04N\x02\t\x01\x12\x04\xed\x06'I\n\r\n\x05\x04N\
    \x02\t\x03\x12\x04\xed\x06LN\n\x0c\n\x04\x04N\x02\n\x12\x04\xee\x06\x08M\
    \n\r\n\x05\x04N\x02\n\x06\x12\x04\xee\x06\x08\x1b\n\r\n\x05\x04N\x02\n\
    \x01\x12\x04\xee\x06\x1c3\n\r\n\x05\x04N\x02\n\x03\x12\x04\xee\x0668\n\r\
    \n\x05\x04N\x02\n\x08\x12\x04\xee\x069L\n\x0e\n\x06\x04N\x02\n\x08\x03\
    \x12\x04\xee\x06:K\n\x0c\n\x04\x04N\x02\x0b\x12\x04\xef\x06\x08F\n\r\n\
    \x05\x04N\x02\x0b\x06\x12\x04\xef\x06\x08\"\n\r\n\x05\x04N\x02\x0b\x01\
    \x12\x04\xef\x06#@\n\r\n\x05\x04N\x02\x0b\x03\x12\x04\xef\x06CE\n\x0c\n\
    \x04\x04N\x02\x0c\x12\x04\xf0\x06\x087\n\r\n\x05\x04N\x02\x0c\x06\x12\
    \x04\xf0\x06\x08\x1b\n\r\n\x05\x04N\x02\x0c\x01\x12\x04\xf0\x06\x1c1\n\r\
    \n\x05\x04N\x02\x0c\x03\x12\x04\xf0\x0646\n\x0c\n\x04\x04N\x02\r\x12\x04\
    \xf1\x06\x08U\n\r\n\x05\x04N\x02\r\x06\x12\x04\xf1\x06\x08(\n\r\n\x05\
    \x04N\x02\r\x01\x12\x04\xf1\x06)O\n\r\n\x05\x04N\x02\r\x03\x12\x04\xf1\
    \x06RT\n\x0c\n\x04\x04N\x02\x0e\x12\x04\xf2\x06\x089\n\r\n\x05\x04N\x02\
    \x0e\x06\x12\x04\xf2\x06\x08\x1c\n\r\n\x05\x04N\x02\x0e\x01\x12\x04\xf2\
    \x06\x1d3\n\r\n\x05\x04N\x02\x0e\x03\x12\x04\xf2\x0668\n\x0c\n\x04\x04N\
    \x02\x0f\x12\x04\xf3\x06\x08P\n\r\n\x05\x04N\x02\x0f\x06\x12\x04\xf3\x06\
    \x08\x1d\n\r\n\x05\x04N\x02\x0f\x01\x12\x04\xf3\x06\x1e6\n\r\n\x05\x04N\
    \x02\x0f\x03\x12\x04\xf3\x069;\n\r\n\x05\x04N\x02\x0f\x08\x12\x04\xf3\
    \x06<O\n\x0e\n\x06\x04N\x02\x0f\x08\x03\x12\x04\xf3\x06=N\n\x0c\n\x04\
    \x04N\x02\x10\x12\x04\xf4\x06\x08@\n\r\n\x05\x04N\x02\x10\x06\x12\x04\
    \xf4\x06\x08\x1f\n\r\n\x05\x04N\x02\x10\x01\x12\x04\xf4\x06\x20:\n\r\n\
    \x05\x04N\x02\x10\x03\x12\x04\xf4\x06=?\n\x0c\n\x04\x04N\x02\x11\x12\x04\
    \xf5\x06\x08K\n\r\n\x05\x04N\x02\x11\x06\x12\x04\xf5\x06\x08\x1b\n\r\n\
    \x05\x04N\x02\x11\x01\x12\x04\xf5\x06\x1c1\n\r\n\x05\x04N\x02\x11\x03\
    \x12\x04\xf5\x0646\n\r\n\x05\x04N\x02\x11\x08\x12\x04\xf5\x067J\n\x0e\n\
    \x06\x04N\x02\x11\x08\x03\x12\x04\xf5\x068I\n\x0c\n\x04\x04N\x02\x12\x12\
    \x04\xf6\x06\x08=\n\r\n\x05\x04N\x02\x12\x06\x12\x04\xf6\x06\x08\x1e\n\r\
    \n\x05\x04N\x02\x12\x01\x12\x04\xf6\x06\x1f7\n\r\n\x05\x04N\x02\x12\x03\
    \x12\x04\xf6\x06:<\n\x0c\n\x04\x04N\x02\x13\x12\x04\xf7\x06\x08;\n\r\n\
    \x05\x04N\x02\x13\x06\x12\x04\xf7\x06\x08\x1d\n\r\n\x05\x04N\x02\x13\x01\
    \x12\x04\xf7\x06\x1e5\n\r\n\x05\x04N\x02\x13\x03\x12\x04\xf7\x068:\n\x0c\
    \n\x04\x04N\x02\x14\x12\x04\xf8\x06\x08A\n\r\n\x05\x04N\x02\x14\x06\x12\
    \x04\xf8\x06\x08\x1f\n\r\n\x05\x04N\x02\x14\x01\x12\x04\xf8\x06\x20;\n\r\
    \n\x05\x04N\x02\x14\x03\x12\x04\xf8\x06>@\n\x0c\n\x04\x04N\x02\x15\x12\
    \x04\xf9\x06\x08@\n\r\n\x05\x04N\x02\x15\x06\x12\x04\xf9\x06\x08\x1f\n\r\
    \n\x05\x04N\x02\x15\x01\x12\x04\xf9\x06\x20:\n\r\n\x05\x04N\x02\x15\x03\
    \x12\x04\xf9\x06=?\n\x0c\n\x04\x04N\x02\x16\x12\x04\xfa\x06\x08<\n\r\n\
    \x05\x04N\x02\x16\x06\x12\x04\xfa\x06\x08\x1d\n\r\n\x05\x04N\x02\x16\x01\
    \x12\x04\xfa\x06\x1e6\n\r\n\x05\x04N\x02\x16\x03\x12\x04\xfa\x069;\n\x0c\
    \n\x04\x04N\x02\x17\x12\x04\xfb\x06\x08@\n\r\n\x05\x04N\x02\x17\x06\x12\
    \x04\xfb\x06\x08\x1f\n\r\n\x05\x04N\x02\x17\x01\x12\x04\xfb\x06\x20:\n\r\
    \n\x05\x04N\x02\x17\x03\x12\x04\xfb\x06=?\n\x0c\n\x04\x04N\x02\x18\x12\
    \x04\xfc\x06\x08F\n\r\n\x05\x04N\x02\x18\x06\x12\x04\xfc\x06\x08\"\n\r\n\
    \x05\x04N\x02\x18\x01\x12\x04\xfc\x06#@\n\r\n\x05\x04N\x02\x18\x03\x12\
    \x04\xfc\x06CE\n\x0c\n\x04\x04N\x02\x19\x12\x04\xfd\x06\x08Y\n\r\n\x05\
    \x04N\x02\x19\x06\x12\x04\xfd\x06\x08+\n\r\n\x05\x04N\x02\x19\x01\x12\
    \x04\xfd\x06,S\n\r\n\x05\x04N\x02\x19\x03\x12\x04\xfd\x06VX\n\x0c\n\x04\
    \x04N\x02\x1a\x12\x04\xfe\x06\x08@\n\r\n\x05\x04N\x02\x1a\x06\x12\x04\
    \xfe\x06\x08\x1f\n\r\n\x05\x04N\x02\x1a\x01\x12\x04\xfe\x06\x20:\n\r\n\
    \x05\x04N\x02\x1a\x03\x12\x04\xfe\x06=?\n\x0c\n\x04\x04N\x02\x1b\x12\x04\
    \x80\x07\x044\n\r\n\x05\x04N\x02\x1b\x06\x12\x04\x80\x07\x04\x17\n\r\n\
    \x05\x04N\x02\x1b\x01\x12\x04\x80\x07\x18.\n\r\n\x05\x04N\x02\x1b\x03\
    \x12\x04\x80\x0713\n\x0c\n\x02\x04O\x12\x06\x83\x07\0\x85\x07\x01\n\x0b\
    \n\x03\x04O\x01\x12\x04\x83\x07\x08\x1c\n\x0c\n\x04\x04O\x02\0\x12\x04\
    \x84\x07\x04\x1a\n\r\n\x05\x04O\x02\0\x05\x12\x04\x84\x07\x04\n\n\r\n\
    \x05\x04O\x02\0\x01\x12\x04\x84\x07\x0b\x15\n\r\n\x05\x04O\x02\0\x03\x12\
    \x04\x84\x07\x18\x19\n\x0c\n\x02\x04P\x12\x06\x87\x07\0\x89\x07\x01\n\
    \x0b\n\x03\x04P\x01\x12\x04\x87\x07\x08\x1f\n\x0c\n\x04\x04P\x02\0\x12\
    \x04\x88\x07\x04\x1a\n\r\n\x05\x04P\x02\0\x05\x12\x04\x88\x07\x04\n\n\r\
    \n\x05\x04P\x02\0\x01\x12\x04\x88\x07\x0b\x15\n\r\n\x05\x04P\x02\0\x03\
    \x12\x04\x88\x07\x18\x19\n\x0c\n\x02\x04Q\x12\x06\x8b\x07\0\x8e\x07\x01\
    \n\x0b\n\x03\x04Q\x01\x12\x04\x8b\x07\x08#\n\x0c\n\x04\x04Q\x02\0\x12\
    \x04\x8c\x07\x04\x15\n\r\n\x05\x04Q\x02\0\x05\x12\x04\x8c\x07\x04\n\n\r\
    \n\x05\x04Q\x02\0\x01\x12\x04\x8c\x07\x0b\x10\n\r\n\x05\x04Q\x02\0\x03\
    \x12\x04\x8c\x07\x13\x14\n\x0c\n\x04\x04Q\x02\x01\x12\x04\x8d\x07\x04\
    \x1b\n\r\n\x05\x04Q\x02\x01\x05\x12\x04\x8d\x07\x04\n\n\r\n\x05\x04Q\x02\
    \x01\x01\x12\x04\x8d\x07\x0b\x16\n\r\n\x05\x04Q\x02\x01\x03\x12\x04\x8d\
    \x07\x19\x1a\n\x0c\n\x02\x04R\x12\x06\x90\x07\0\x93\x07\x01\n\x0b\n\x03\
    \x04R\x01\x12\x04\x90\x07\x08\"\n\x0c\n\x04\x04R\x02\0\x12\x04\x91\x07\
    \x04\x1b\n\r\n\x05\x04R\x02\0\x05\x12\x04\x91\x07\x04\n\n\r\n\x05\x04R\
    \x02\0\x01\x12\x04\x91\x07\x0b\x16\n\r\n\x05\x04R\x02\0\x03\x12\x04\x91\
    \x07\x19\x1a\n\x0c\n\x04\x04R\x02\x01\x12\x04\x92\x07\x04\"\n\r\n\x05\
    \x04R\x02\x01\x05\x12\x04\x92\x07\x04\n\n\r\n\x05\x04R\x02\x01\x01\x12\
    \x04\x92\x07\x0b\x1d\n\r\n\x05\x04R\x02\x01\x03\x12\x04\x92\x07\x20!\n\
    \x0c\n\x02\x04S\x12\x06\x95\x07\0\x9f\x07\x01\n\x0b\n\x03\x04S\x01\x12\
    \x04\x95\x07\x08)\n\x0c\n\x04\x04S\x02\0\x12\x04\x96\x07\x04\x1b\n\r\n\
    \x05\x04S\x02\0\x05\x12\x04\x96\x07\x04\n\n\r\n\x05\x04S\x02\0\x01\x12\
    \x04\x96\x07\x0b\x16\n\r\n\x05\x04S\x02\0\x03\x12\x04\x96\x07\x19\x1a\n\
    \x0e\n\x04\x04S\x08\0\x12\x06\x97\x07\x04\x9e\x07\x05\n\r\n\x05\x04S\x08\
    \0\x01\x12\x04\x97\x07\n\x11\n\x0c\n\x04\x04S\x02\x01\x12\x04\x98\x07\
    \x084\n\r\n\x05\x04S\x02\x01\x06\x12\x04\x98\x07\x08\x1a\n\r\n\x05\x04S\
    \x02\x01\x01\x12\x04\x98\x07\x1b/\n\r\n\x05\x04S\x02\x01\x03\x12\x04\x98\
    \x0723\n\x0c\n\x04\x04S\x02\x02\x12\x04\x99\x07\x08C\n\r\n\x05\x04S\x02\
    \x02\x06\x12\x04\x99\x07\x08!\n\r\n\x05\x04S\x02\x02\x01\x12\x04\x99\x07\
    \">\n\r\n\x05\x04S\x02\x02\x03\x12\x04\x99\x07AB\n\x0c\n\x04\x04S\x02\
    \x03\x12\x04\x9a\x07\x084\n\r\n\x05\x04S\x02\x03\x06\x12\x04\x9a\x07\x08\
    \x1a\n\r\n\x05\x04S\x02\x03\x01\x12\x04\x9a\x07\x1b/\n\r\n\x05\x04S\x02\
    \x03\x03\x12\x04\x9a\x0723\n\x0c\n\x04\x04S\x02\x04\x12\x04\x9b\x07\x08E\
    \n\r\n\x05\x04S\x02\x04\x06\x12\x04\x9b\x07\x08\"\n\r\n\x05\x04S\x02\x04\
    \x01\x12\x04\x9b\x07#@\n\r\n\x05\x04S\x02\x04\x03\x12\x04\x9b\x07CD\n\
    \x0c\n\x04\x04S\x02\x05\x12\x04\x9c\x07\x08C\n\r\n\x05\x04S\x02\x05\x06\
    \x12\x04\x9c\x07\x08!\n\r\n\x05\x04S\x02\x05\x01\x12\x04\x9c\x07\">\n\r\
    \n\x05\x04S\x02\x05\x03\x12\x04\x9c\x07AB\n\x0c\n\x04\x04S\x02\x06\x12\
    \x04\x9d\x07\x082\n\r\n\x05\x04S\x02\x06\x06\x12\x04\x9d\x07\x08\x19\n\r\
    \n\x05\x04S\x02\x06\x01\x12\x04\x9d\x07\x1a-\n\r\n\x05\x04S\x02\x06\x03\
    \x12\x04\x9d\x0701\n\x0c\n\x02\x04T\x12\x06\xa1\x07\0\xb0\x07\x01\n\x0b\
    \n\x03\x04T\x01\x12\x04\xa1\x07\x08\x1a\n\x0c\n\x04\x04T\x02\0\x12\x04\
    \xa2\x07\x04\x1b\n\r\n\x05\x04T\x02\0\x05\x12\x04\xa2\x07\x04\n\n\r\n\
    \x05\x04T\x02\0\x01\x12\x04\xa2\x07\x0b\x16\n\r\n\x05\x04T\x02\0\x03\x12\
    \x04\xa2\x07\x19\x1a\n\x0c\n\x04\x04T\x02\x01\x12\x04\xa3\x07\x04\x19\n\
    \r\n\x05\x04T\x02\x01\x05\x12\x04\xa3\x07\x04\n\n\r\n\x05\x04T\x02\x01\
    \x01\x12\x04\xa3\x07\x0b\x14\n\r\n\x05\x04T\x02\x01\x03\x12\x04\xa3\x07\
    \x17\x18\n\x0c\n\x04\x04T\x02\x02\x12\x04\xa4\x07\x04\x17\n\r\n\x05\x04T\
    \x02\x02\x05\x12\x04\xa4\x07\x04\n\n\r\n\x05\x04T\x02\x02\x01\x12\x04\
    \xa4\x07\x0b\x12\n\r\n\x05\x04T\x02\x02\x03\x12\x04\xa4\x07\x15\x16\n\
    \x0c\n\x04\x04T\x02\x03\x12\x04\xa5\x07\x04\x19\n\r\n\x05\x04T\x02\x03\
    \x05\x12\x04\xa5\x07\x04\n\n\r\n\x05\x04T\x02\x03\x01\x12\x04\xa5\x07\
    \x0b\x14\n\r\n\x05\x04T\x02\x03\x03\x12\x04\xa5\x07\x17\x18\n\x0c\n\x04\
    \x04T\x02\x04\x12\x04\xa6\x07\x04\x1a\n\r\n\x05\x04T\x02\x04\x05\x12\x04\
    \xa6\x07\x04\n\n\r\n\x05\x04T\x02\x04\x01\x12\x04\xa6\x07\x0b\x15\n\r\n\
    \x05\x04T\x02\x04\x03\x12\x04\xa6\x07\x18\x19\n\x0c\n\x04\x04T\x02\x05\
    \x12\x04\xa7\x07\x04\x1c\n\r\n\x05\x04T\x02\x05\x05\x12\x04\xa7\x07\x04\
    \n\n\r\n\x05\x04T\x02\x05\x01\x12\x04\xa7\x07\x0b\x17\n\r\n\x05\x04T\x02\
    \x05\x03\x12\x04\xa7\x07\x1a\x1b\n\x0c\n\x04\x04T\x02\x06\x12\x04\xa8\
    \x07\x04\x1d\n\r\n\x05\x04T\x02\x06\x05\x12\x04\xa8\x07\x04\n\n\r\n\x05\
    \x04T\x02\x06\x01\x12\x04\xa8\x07\x0b\x18\n\r\n\x05\x04T\x02\x06\x03\x12\
    \x04\xa8\x07\x1b\x1c\n\x0c\n\x04\x04T\x02\x07\x12\x04\xa9\x07\x04)\n\r\n\
    \x05\x04T\x02\x07\x05\x12\x04\xa9\x07\x04\n\n\r\n\x05\x04T\x02\x07\x01\
    \x12\x04\xa9\x07\x0b\x10\n\r\n\x05\x04T\x02\x07\x03\x12\x04\xa9\x07\x13\
    \x14\n\r\n\x05\x04T\x02\x07\x08\x12\x04\xa9\x07\x15(\n\x0e\n\x06\x04T\
    \x02\x07\x08\x03\x12\x04\xa9\x07\x16'\n\x0e\n\x04\x04T\x08\0\x12\x06\xaa\
    \x07\x04\xae\x07\x05\n\r\n\x05\x04T\x08\0\x01\x12\x04\xaa\x07\n\x11\n\
    \x0c\n\x04\x04T\x02\x08\x12\x04\xab\x07\x08E\n\r\n\x05\x04T\x02\x08\x06\
    \x12\x04\xab\x07\x08\"\n\r\n\x05\x04T\x02\x08\x01\x12\x04\xab\x07#@\n\r\
    \n\x05\x04T\x02\x08\x03\x12\x04\xab\x07CD\n\x0c\n\x04\x04T\x02\t\x12\x04\
    \xac\x07\x08=\n\r\n\x05\x04T\x02\t\x06\x12\x04\xac\x07\x08\x1e\n\r\n\x05\
    \x04T\x02\t\x01\x12\x04\xac\x07\x1f7\n\r\n\x05\x04T\x02\t\x03\x12\x04\
    \xac\x07:<\n\x0c\n\x04\x04T\x02\n\x12\x04\xad\x07\x08H\n\r\n\x05\x04T\
    \x02\n\x06\x12\x04\xad\x07\x08#\n\r\n\x05\x04T\x02\n\x01\x12\x04\xad\x07\
    $B\n\r\n\x05\x04T\x02\n\x03\x12\x04\xad\x07EG\n\x0c\n\x04\x04T\x02\x0b\
    \x12\x04\xaf\x07\x04$\n\r\n\x05\x04T\x02\x0b\x05\x12\x04\xaf\x07\x04\n\n\
    \r\n\x05\x04T\x02\x0b\x01\x12\x04\xaf\x07\x0b\x1e\n\r\n\x05\x04T\x02\x0b\
    \x03\x12\x04\xaf\x07!#\n\x0c\n\x02\x04U\x12\x06\xb2\x07\0\xb3\x07\x01\n\
    \x0b\n\x03\x04U\x01\x12\x04\xb2\x07\x08\"\n\x0c\n\x02\x04V\x12\x06\xb5\
    \x07\0\xb6\x07\x01\n\x0b\n\x03\x04V\x01\x12\x04\xb5\x07\x08\x1e\n\x0c\n\
    \x02\x04W\x12\x06\xb8\x07\0\xc0\x07\x01\n\x0b\n\x03\x04W\x01\x12\x04\xb8\
    \x07\x08\x1f\n\x0c\n\x04\x04W\x02\0\x12\x04\xb9\x07\x04\x19\n\r\n\x05\
    \x04W\x02\0\x05\x12\x04\xb9\x07\x04\n\n\r\n\x05\x04W\x02\0\x01\x12\x04\
    \xb9\x07\x0b\x14\n\r\n\x05\x04W\x02\0\x03\x12\x04\xb9\x07\x17\x18\n\x0c\
    \n\x04\x04W\x02\x01\x12\x04\xba\x07\x04\x19\n\r\n\x05\x04W\x02\x01\x05\
    \x12\x04\xba\x07\x04\n\n\r\n\x05\x04W\x02\x01\x01\x12\x04\xba\x07\x0b\
    \x14\n\r\n\x05\x04W\x02\x01\x03\x12\x04\xba\x07\x17\x18\n\x0c\n\x04\x04W\
    \x02\x02\x12\x04\xbb\x07\x04\x20\n\r\n\x05\x04W\x02\x02\x05\x12\x04\xbb\
    \x07\x04\n\n\r\n\x05\x04W\x02\x02\x01\x12\x04\xbb\x07\x0b\x1b\n\r\n\x05\
    \x04W\x02\x02\x03\x12\x04\xbb\x07\x1e\x1f\n\x0c\n\x04\x04W\x02\x03\x12\
    \x04\xbc\x07\x04\x20\n\r\n\x05\x04W\x02\x03\x05\x12\x04\xbc\x07\x04\n\n\
    \r\n\x05\x04W\x02\x03\x01\x12\x04\xbc\x07\x0b\x1b\n\r\n\x05\x04W\x02\x03\
    \x03\x12\x04\xbc\x07\x1e\x1f\n\x0c\n\x04\x04W\x02\x04\x12\x04\xbd\x07\
    \x04!\n\r\n\x05\x04W\x02\x04\x05\x12\x04\xbd\x07\x04\n\n\r\n\x05\x04W\
    \x02\x04\x01\x12\x04\xbd\x07\x0b\x1c\n\r\n\x05\x04W\x02\x04\x03\x12\x04\
    \xbd\x07\x1f\x20\n\x0c\n\x04\x04W\x02\x05\x12\x04\xbe\x07\x04!\n\r\n\x05\
    \x04W\x02\x05\x05\x12\x04\xbe\x07\x04\n\n\r\n\x05\x04W\x02\x05\x01\x12\
    \x04\xbe\x07\x0b\x1c\n\r\n\x05\x04W\x02\x05\x03\x12\x04\xbe\x07\x1f\x20\
    \n\x0c\n\x04\x04W\x02\x06\x12\x04\xbf\x07\x04#\n\r\n\x05\x04W\x02\x06\
    \x05\x12\x04\xbf\x07\x04\n\n\r\n\x05\x04W\x02\x06\x01\x12\x04\xbf\x07\
    \x0b\x1e\n\r\n\x05\x04W\x02\x06\x03\x12\x04\xbf\x07!\"\n\x0c\n\x02\x04X\
    \x12\x06\xc2\x07\0\xc4\x07\x01\n\x0b\n\x03\x04X\x01\x12\x04\xc2\x07\x08#\
    \n\x0c\n\x04\x04X\x02\0\x12\x04\xc3\x07\x04'\n\r\n\x05\x04X\x02\0\x04\
    \x12\x04\xc3\x07\x04\x0c\n\r\n\x05\x04X\x02\0\x05\x12\x04\xc3\x07\r\x13\
    \n\r\n\x05\x04X\x02\0\x01\x12\x04\xc3\x07\x14\"\n\r\n\x05\x04X\x02\0\x03\
    \x12\x04\xc3\x07%&\n\x0c\n\x02\x04Y\x12\x06\xc6\x07\0\xd1\x07\x01\n\x0b\
    \n\x03\x04Y\x01\x12\x04\xc6\x07\x08!\n\x0c\n\x04\x04Y\x02\0\x12\x04\xc7\
    \x07\x04\x1b\n\r\n\x05\x04Y\x02\0\x05\x12\x04\xc7\x07\x04\n\n\r\n\x05\
    \x04Y\x02\0\x01\x12\x04\xc7\x07\x0b\x16\n\r\n\x05\x04Y\x02\0\x03\x12\x04\
    \xc7\x07\x19\x1a\n\x0c\n\x04\x04Y\x02\x01\x12\x04\xc8\x07\x04\x1c\n\r\n\
    \x05\x04Y\x02\x01\x05\x12\x04\xc8\x07\x04\n\n\r\n\x05\x04Y\x02\x01\x01\
    \x12\x04\xc8\x07\x0b\x17\n\r\n\x05\x04Y\x02\x01\x03\x12\x04\xc8\x07\x1a\
    \x1b\n\x0c\n\x04\x04Y\x02\x02\x12\x04\xc9\x07\x04\x19\n\r\n\x05\x04Y\x02\
    \x02\x05\x12\x04\xc9\x07\x04\n\n\r\n\x05\x04Y\x02\x02\x01\x12\x04\xc9\
    \x07\x0b\x14\n\r\n\x05\x04Y\x02\x02\x03\x12\x04\xc9\x07\x17\x18\n\x0c\n\
    \x04\x04Y\x02\x03\x12\x04\xca\x07\x04\x17\n\r\n\x05\x04Y\x02\x03\x05\x12\
    \x04\xca\x07\x04\n\n\r\n\x05\x04Y\x02\x03\x01\x12\x04\xca\x07\x0b\x12\n\
    \r\n\x05\x04Y\x02\x03\x03\x12\x04\xca\x07\x15\x16\n\x0c\n\x04\x04Y\x02\
    \x04\x12\x04\xcb\x07\x04\x19\n\r\n\x05\x04Y\x02\x04\x05\x12\x04\xcb\x07\
    \x04\n\n\r\n\x05\x04Y\x02\x04\x01\x12\x04\xcb\x07\x0b\x14\n\r\n\x05\x04Y\
    \x02\x04\x03\x12\x04\xcb\x07\x17\x18\n\x0c\n\x04\x04Y\x02\x05\x12\x04\
    \xcc\x07\x04\x1a\n\r\n\x05\x04Y\x02\x05\x05\x12\x04\xcc\x07\x04\n\n\r\n\
    \x05\x04Y\x02\x05\x01\x12\x04\xcc\x07\x0b\x15\n\r\n\x05\x04Y\x02\x05\x03\
    \x12\x04\xcc\x07\x18\x19\n\x0c\n\x04\x04Y\x02\x06\x12\x04\xcd\x07\x04\
    \x1c\n\r\n\x05\x04Y\x02\x06\x05\x12\x04\xcd\x07\x04\n\n\r\n\x05\x04Y\x02\
    \x06\x01\x12\x04\xcd\x07\x0b\x17\n\r\n\x05\x04Y\x02\x06\x03\x12\x04\xcd\
    \x07\x1a\x1b\n\x0c\n\x04\x04Y\x02\x07\x12\x04\xce\x07\x04\x1c\n\r\n\x05\
    \x04Y\x02\x07\x05\x12\x04\xce\x07\x04\n\n\r\n\x05\x04Y\x02\x07\x01\x12\
    \x04\xce\x07\x0b\x17\n\r\n\x05\x04Y\x02\x07\x03\x12\x04\xce\x07\x1a\x1b\
    \n\x0c\n\x04\x04Y\x02\x08\x12\x04\xcf\x07\x04\x1d\n\r\n\x05\x04Y\x02\x08\
    \x05\x12\x04\xcf\x07\x04\n\n\r\n\x05\x04Y\x02\x08\x01\x12\x04\xcf\x07\
    \x0b\x18\n\r\n\x05\x04Y\x02\x08\x03\x12\x04\xcf\x07\x1b\x1c\n\x0c\n\x04\
    \x04Y\x02\t\x12\x04\xd0\x07\x04$\n\r\n\x05\x04Y\x02\t\x05\x12\x04\xd0\
    \x07\x04\n\n\r\n\x05\x04Y\x02\t\x01\x12\x04\xd0\x07\x0b\x1e\n\r\n\x05\
    \x04Y\x02\t\x03\x12\x04\xd0\x07!#\n\x0c\n\x02\x04Z\x12\x06\xd3\x07\0\xd8\
    \x07\x01\n\x0b\n\x03\x04Z\x01\x12\x04\xd3\x07\x08\x1f\n\x0c\n\x04\x04Z\
    \x02\0\x12\x04\xd4\x07\x04\x1b\n\r\n\x05\x04Z\x02\0\x05\x12\x04\xd4\x07\
    \x04\n\n\r\n\x05\x04Z\x02\0\x01\x12\x04\xd4\x07\x0b\x16\n\r\n\x05\x04Z\
    \x02\0\x03\x12\x04\xd4\x07\x19\x1a\n\x0c\n\x04\x04Z\x02\x01\x12\x04\xd5\
    \x07\x04\x1c\n\r\n\x05\x04Z\x02\x01\x05\x12\x04\xd5\x07\x04\n\n\r\n\x05\
    \x04Z\x02\x01\x01\x12\x04\xd5\x07\x0b\x17\n\r\n\x05\x04Z\x02\x01\x03\x12\
    \x04\xd5\x07\x1a\x1b\n\x0c\n\x04\x04Z\x02\x02\x12\x04\xd6\x07\x04\x15\n\
    \r\n\x05\x04Z\x02\x02\x05\x12\x04\xd6\x07\x04\n\n\r\n\x05\x04Z\x02\x02\
    \x01\x12\x04\xd6\x07\x0b\x10\n\r\n\x05\x04Z\x02\x02\x03\x12\x04\xd6\x07\
    \x13\x14\n\x0c\n\x04\x04Z\x02\x03\x12\x04\xd7\x07\x04\x15\n\r\n\x05\x04Z\
    \x02\x03\x05\x12\x04\xd7\x07\x04\n\n\r\n\x05\x04Z\x02\x03\x01\x12\x04\
    \xd7\x07\x0b\x10\n\r\n\x05\x04Z\x02\x03\x03\x12\x04\xd7\x07\x13\x14\n\
    \x0c\n\x02\x04[\x12\x06\xda\x07\0\xdc\x07\x01\n\x0b\n\x03\x04[\x01\x12\
    \x04\xda\x07\x08\x1d\n\x0c\n\x04\x04[\x02\0\x12\x04\xdb\x07\x04\x19\n\r\
    \n\x05\x04[\x02\0\x05\x12\x04\xdb\x07\x04\n\n\r\n\x05\x04[\x02\0\x01\x12\
    \x04\xdb\x07\x0b\x14\n\r\n\x05\x04[\x02\0\x03\x12\x04\xdb\x07\x17\x18\n\
    \x0c\n\x02\x04\\\x12\x06\xde\x07\0\xe3\x07\x01\n\x0b\n\x03\x04\\\x01\x12\
    \x04\xde\x07\x08\"\n\x0c\n\x04\x04\\\x02\0\x12\x04\xdf\x07\x04\x1b\n\r\n\
    \x05\x04\\\x02\0\x05\x12\x04\xdf\x07\x04\n\n\r\n\x05\x04\\\x02\0\x01\x12\
    \x04\xdf\x07\x0b\x16\n\r\n\x05\x04\\\x02\0\x03\x12\x04\xdf\x07\x19\x1a\n\
    \x0c\n\x04\x04\\\x02\x01\x12\x04\xe0\x07\x04\x14\n\r\n\x05\x04\\\x02\x01\
    \x05\x12\x04\xe0\x07\x04\n\n\r\n\x05\x04\\\x02\x01\x01\x12\x04\xe0\x07\
    \x0b\x0f\n\r\n\x05\x04\\\x02\x01\x03\x12\x04\xe0\x07\x12\x13\n\x0c\n\x04\
    \x04\\\x02\x02\x12\x04\xe1\x07\x04\x15\n\r\n\x05\x04\\\x02\x02\x05\x12\
    \x04\xe1\x07\x04\n\n\r\n\x05\x04\\\x02\x02\x01\x12\x04\xe1\x07\x0b\x10\n\
    \r\n\x05\x04\\\x02\x02\x03\x12\x04\xe1\x07\x13\x14\n\x0c\n\x04\x04\\\x02\
    \x03\x12\x04\xe2\x07\x04\x15\n\r\n\x05\x04\\\x02\x03\x05\x12\x04\xe2\x07\
    \x04\n\n\r\n\x05\x04\\\x02\x03\x01\x12\x04\xe2\x07\x0b\x10\n\r\n\x05\x04\
    \\\x02\x03\x03\x12\x04\xe2\x07\x13\x14\n\x0c\n\x02\x04]\x12\x06\xe5\x07\
    \0\xeb\x07\x01\n\x0b\n\x03\x04]\x01\x12\x04\xe5\x07\x08\x1a\n\x0c\n\x04\
    \x04]\x02\0\x12\x04\xe6\x07\x04\x1b\n\r\n\x05\x04]\x02\0\x05\x12\x04\xe6\
    \x07\x04\n\n\r\n\x05\x04]\x02\0\x01\x12\x04\xe6\x07\x0b\x16\n\r\n\x05\
    \x04]\x02\0\x03\x12\x04\xe6\x07\x19\x1a\n\x0c\n\x04\x04]\x02\x01\x12\x04\
    \xe7\x07\x04\x14\n\r\n\x05\x04]\x02\x01\x05\x12\x04\xe7\x07\x04\n\n\r\n\
    \x05\x04]\x02\x01\x01\x12\x04\xe7\x07\x0b\x0f\n\r\n\x05\x04]\x02\x01\x03\
    \x12\x04\xe7\x07\x12\x13\n\x0c\n\x04\x04]\x02\x02\x12\x04\xe8\x07\x04\
    \x13\n\r\n\x05\x04]\x02\x02\x05\x12\x04\xe8\x07\x04\n\n\r\n\x05\x04]\x02\
    \x02\x01\x12\x04\xe8\x07\x0b\x0e\n\r\n\x05\x04]\x02\x02\x03\x12\x04\xe8\
    \x07\x11\x12\n\x0c\n\x04\x04]\x02\x03\x12\x04\xe9\x07\x04)\n\r\n\x05\x04\
    ]\x02\x03\x05\x12\x04\xe9\x07\x04\n\n\r\n\x05\x04]\x02\x03\x01\x12\x04\
    \xe9\x07\x0b\x10\n\r\n\x05\x04]\x02\x03\x03\x12\x04\xe9\x07\x13\x14\n\r\
    \n\x05\x04]\x02\x03\x08\x12\x04\xe9\x07\x15(\n\x0e\n\x06\x04]\x02\x03\
    \x08\x03\x12\x04\xe9\x07\x16'\n\x0c\n\x04\x04]\x02\x04\x12\x04\xea\x07\
    \x04/\n\r\n\x05\x04]\x02\x04\x04\x12\x04\xea\x07\x04\x0c\n\r\n\x05\x04]\
    \x02\x04\x05\x12\x04\xea\x07\r\x13\n\r\n\x05\x04]\x02\x04\x01\x12\x04\
    \xea\x07\x14*\n\r\n\x05\x04]\x02\x04\x03\x12\x04\xea\x07-.\n\x0c\n\x02\
    \x04^\x12\x06\xed\x07\0\xf2\x07\x01\n\x0b\n\x03\x04^\x01\x12\x04\xed\x07\
    \x08!\n\x0c\n\x04\x04^\x02\0\x12\x04\xee\x07\x04\x1b\n\r\n\x05\x04^\x02\
    \0\x05\x12\x04\xee\x07\x04\n\n\r\n\x05\x04^\x02\0\x01\x12\x04\xee\x07\
    \x0b\x16\n\r\n\x05\x04^\x02\0\x03\x12\x04\xee\x07\x19\x1a\n\x0c\n\x04\
    \x04^\x02\x01\x12\x04\xef\x07\x04\x14\n\r\n\x05\x04^\x02\x01\x05\x12\x04\
    \xef\x07\x04\n\n\r\n\x05\x04^\x02\x01\x01\x12\x04\xef\x07\x0b\x0f\n\r\n\
    \x05\x04^\x02\x01\x03\x12\x04\xef\x07\x12\x13\n\x0c\n\x04\x04^\x02\x02\
    \x12\x04\xf0\x07\x04\x13\n\r\n\x05\x04^\x02\x02\x05\x12\x04\xf0\x07\x04\
    \n\n\r\n\x05\x04^\x02\x02\x01\x12\x04\xf0\x07\x0b\x0e\n\r\n\x05\x04^\x02\
    \x02\x03\x12\x04\xf0\x07\x11\x12\n\x0c\n\x04\x04^\x02\x03\x12\x04\xf1\
    \x07\x04/\n\r\n\x05\x04^\x02\x03\x04\x12\x04\xf1\x07\x04\x0c\n\r\n\x05\
    \x04^\x02\x03\x05\x12\x04\xf1\x07\r\x13\n\r\n\x05\x04^\x02\x03\x01\x12\
    \x04\xf1\x07\x14*\n\r\n\x05\x04^\x02\x03\x03\x12\x04\xf1\x07-.\n\x0c\n\
    \x02\x04_\x12\x06\xf4\x07\0\xf6\x07\x01\n\x0b\n\x03\x04_\x01\x12\x04\xf4\
    \x07\x08$\n\x0c\n\x04\x04_\x02\0\x12\x04\xf5\x07\x04\x17\n\r\n\x05\x04_\
    \x02\0\x05\x12\x04\xf5\x07\x04\n\n\r\n\x05\x04_\x02\0\x01\x12\x04\xf5\
    \x07\x0b\x12\n\r\n\x05\x04_\x02\0\x03\x12\x04\xf5\x07\x15\x16\n\x0c\n\
    \x02\x04`\x12\x06\xf8\x07\0\xfa\x07\x01\n\x0b\n\x03\x04`\x01\x12\x04\xf8\
    \x07\x08+\n\x0c\n\x04\x04`\x02\0\x12\x04\xf9\x07\x04\x17\n\r\n\x05\x04`\
    \x02\0\x05\x12\x04\xf9\x07\x04\n\n\r\n\x05\x04`\x02\0\x01\x12\x04\xf9\
    \x07\x0b\x12\n\r\n\x05\x04`\x02\0\x03\x12\x04\xf9\x07\x15\x16\n\x0c\n\
    \x02\x04a\x12\x06\xfc\x07\0\x80\x08\x01\n\x0b\n\x03\x04a\x01\x12\x04\xfc\
    \x07\x08$\n\x0c\n\x04\x04a\x02\0\x12\x04\xfd\x07\x04\x19\n\r\n\x05\x04a\
    \x02\0\x05\x12\x04\xfd\x07\x04\n\n\r\n\x05\x04a\x02\0\x01\x12\x04\xfd\
    \x07\x0b\x14\n\r\n\x05\x04a\x02\0\x03\x12\x04\xfd\x07\x17\x18\n\x0c\n\
    \x04\x04a\x02\x01\x12\x04\xfe\x07\x04\x1a\n\r\n\x05\x04a\x02\x01\x05\x12\
    \x04\xfe\x07\x04\n\n\r\n\x05\x04a\x02\x01\x01\x12\x04\xfe\x07\x0b\x15\n\
    \r\n\x05\x04a\x02\x01\x03\x12\x04\xfe\x07\x18\x19\n\x0c\n\x04\x04a\x02\
    \x02\x12\x04\xff\x07\x04)\n\r\n\x05\x04a\x02\x02\x05\x12\x04\xff\x07\x04\
    \n\n\r\n\x05\x04a\x02\x02\x01\x12\x04\xff\x07\x0b\x10\n\r\n\x05\x04a\x02\
    \x02\x03\x12\x04\xff\x07\x13\x14\n\r\n\x05\x04a\x02\x02\x08\x12\x04\xff\
    \x07\x15(\n\x0e\n\x06\x04a\x02\x02\x08\x03\x12\x04\xff\x07\x16'\n\x0c\n\
    \x02\x04b\x12\x06\x82\x08\0\x87\x08\x01\n\x0b\n\x03\x04b\x01\x12\x04\x82\
    \x08\x08&\n\x0c\n\x04\x04b\x02\0\x12\x04\x83\x08\x04\x15\n\r\n\x05\x04b\
    \x02\0\x05\x12\x04\x83\x08\x04\n\n\r\n\x05\x04b\x02\0\x01\x12\x04\x83\
    \x08\x0b\x10\n\r\n\x05\x04b\x02\0\x03\x12\x04\x83\x08\x13\x14\n\x0c\n\
    \x04\x04b\x02\x01\x12\x04\x84\x08\x04\x1b\n\r\n\x05\x04b\x02\x01\x05\x12\
    \x04\x84\x08\x04\n\n\r\n\x05\x04b\x02\x01\x01\x12\x04\x84\x08\x0b\x16\n\
    \r\n\x05\x04b\x02\x01\x03\x12\x04\x84\x08\x19\x1a\n\x0c\n\x04\x04b\x02\
    \x02\x12\x04\x85\x08\x04\x18\n\r\n\x05\x04b\x02\x02\x05\x12\x04\x85\x08\
    \x04\n\n\r\n\x05\x04b\x02\x02\x01\x12\x04\x85\x08\x0b\x13\n\r\n\x05\x04b\
    \x02\x02\x03\x12\x04\x85\x08\x16\x17\n\x0c\n\x04\x04b\x02\x03\x12\x04\
    \x86\x08\x04\x16\n\r\n\x05\x04b\x02\x03\x05\x12\x04\x86\x08\x04\n\n\r\n\
    \x05\x04b\x02\x03\x01\x12\x04\x86\x08\x0b\x11\n\r\n\x05\x04b\x02\x03\x03\
    \x12\x04\x86\x08\x14\x15\n,\n\x02\x04c\x12\x06\x8a\x08\0\x8c\x08\x01\x1a\
    \x1e\x20Deprecated,\x20not\x20used\x20anymore\n\n\x0b\n\x03\x04c\x01\x12\
    \x04\x8a\x08\x08\x1b\n\x0c\n\x04\x04c\x02\0\x12\x04\x8b\x08\x04\x1a\n\r\
    \n\x05\x04c\x02\0\x05\x12\x04\x8b\x08\x04\n\n\r\n\x05\x04c\x02\0\x01\x12\
    \x04\x8b\x08\x0b\x15\n\r\n\x05\x04c\x02\0\x03\x12\x04\x8b\x08\x18\x19\n\
    \x0c\n\x02\x04d\x12\x06\x8e\x08\0\x90\x08\x01\n\x0b\n\x03\x04d\x01\x12\
    \x04\x8e\x08\x08\x1c\n\x0c\n\x04\x04d\x02\0\x12\x04\x8f\x08\x04\x1a\n\r\
    \n\x05\x04d\x02\0\x05\x12\x04\x8f\x08\x04\n\n\r\n\x05\x04d\x02\0\x01\x12\
    \x04\x8f\x08\x0b\x15\n\r\n\x05\x04d\x02\0\x03\x12\x04\x8f\x08\x18\x19\n,\
    \n\x02\x04e\x12\x06\x93\x08\0\x95\x08\x01\x1a\x1e\x20Deprecated,\x20not\
    \x20used\x20anymore\n\n\x0b\n\x03\x04e\x01\x12\x04\x93\x08\x08\x1d\n\x0c\
    \n\x04\x04e\x02\0\x12\x04\x94\x08\x04\x18\n\r\n\x05\x04e\x02\0\x05\x12\
    \x04\x94\x08\x04\n\n\r\n\x05\x04e\x02\0\x01\x12\x04\x94\x08\x0b\x13\n\r\
    \n\x05\x04e\x02\0\x03\x12\x04\x94\x08\x16\x17\n\x0c\n\x02\x04f\x12\x06\
    \x97\x08\0\x99\x08\x01\n\x0b\n\x03\x04f\x01\x12\x04\x97\x08\x08\x1f\n\
    \x0c\n\x04\x04f\x02\0\x12\x04\x98\x08\x04\x1a\n\r\n\x05\x04f\x02\0\x05\
    \x12\x04\x98\x08\x04\n\n\r\n\x05\x04f\x02\0\x01\x12\x04\x98\x08\x0b\x15\
    \n\r\n\x05\x04f\x02\0\x03\x12\x04\x98\x08\x18\x19\n,\n\x02\x04g\x12\x06\
    \x9c\x08\0\x9f\x08\x01\x1a\x1e\x20Deprecated,\x20not\x20used\x20anymore\
    \n\n\x0b\n\x03\x04g\x01\x12\x04\x9c\x08\x08\x1b\n\x0c\n\x04\x04g\x02\0\
    \x12\x04\x9d\x08\x04\x1f\n\r\n\x05\x04g\x02\0\x05\x12\x04\x9d\x08\x04\n\
    \n\r\n\x05\x04g\x02\0\x01\x12\x04\x9d\x08\x0b\x1a\n\r\n\x05\x04g\x02\0\
    \x03\x12\x04\x9d\x08\x1d\x1e\n\x0c\n\x04\x04g\x02\x01\x12\x04\x9e\x08\
    \x04\x1b\n\r\n\x05\x04g\x02\x01\x05\x12\x04\x9e\x08\x04\n\n\r\n\x05\x04g\
    \x02\x01\x01\x12\x04\x9e\x08\x0b\x16\n\r\n\x05\x04g\x02\x01\x03\x12\x04\
    \x9e\x08\x19\x1a\n\x0c\n\x02\x04h\x12\x06\xa1\x08\0\xa4\x08\x01\n\x0b\n\
    \x03\x04h\x01\x12\x04\xa1\x08\x08\x1e\n\x0c\n\x04\x04h\x02\0\x12\x04\xa2\
    \x08\x04\x1a\n\r\n\x05\x04h\x02\0\x05\x12\x04\xa2\x08\x04\n\n\r\n\x05\
    \x04h\x02\0\x01\x12\x04\xa2\x08\x0b\x15\n\r\n\x05\x04h\x02\0\x03\x12\x04\
    \xa2\x08\x18\x19\n\x0c\n\x04\x04h\x02\x01\x12\x04\xa3\x08\x04\x1b\n\r\n\
    \x05\x04h\x02\x01\x05\x12\x04\xa3\x08\x04\n\n\r\n\x05\x04h\x02\x01\x01\
    \x12\x04\xa3\x08\x0b\x16\n\r\n\x05\x04h\x02\x01\x03\x12\x04\xa3\x08\x19\
    \x1a\n\x0c\n\x02\x04i\x12\x06\xa6\x08\0\xa8\x08\x01\n\x0b\n\x03\x04i\x01\
    \x12\x04\xa6\x08\x08\x1d\n\x0c\n\x04\x04i\x02\0\x12\x04\xa7\x08\x04\x1a\
    \n\r\n\x05\x04i\x02\0\x05\x12\x04\xa7\x08\x04\n\n\r\n\x05\x04i\x02\0\x01\
    \x12\x04\xa7\x08\x0b\x15\n\r\n\x05\x04i\x02\0\x03\x12\x04\xa7\x08\x18\
    \x19\n\x0c\n\x02\x04j\x12\x06\xaa\x08\0\xac\x08\x01\n\x0b\n\x03\x04j\x01\
    \x12\x04\xaa\x08\x08\"\n\x0c\n\x04\x04j\x02\0\x12\x04\xab\x08\x04\x1a\n\
    \r\n\x05\x04j\x02\0\x05\x12\x04\xab\x08\x04\n\n\r\n\x05\x04j\x02\0\x01\
    \x12\x04\xab\x08\x0b\x15\n\r\n\x05\x04j\x02\0\x03\x12\x04\xab\x08\x18\
    \x19\n\x0c\n\x02\x04k\x12\x06\xae\x08\0\xb1\x08\x01\n\x0b\n\x03\x04k\x01\
    \x12\x04\xae\x08\x08\x1b\n\x0c\n\x04\x04k\x02\0\x12\x04\xaf\x08\x04\x19\
    \n\r\n\x05\x04k\x02\0\x05\x12\x04\xaf\x08\x04\n\n\r\n\x05\x04k\x02\0\x01\
    \x12\x04\xaf\x08\x0b\x14\n\r\n\x05\x04k\x02\0\x03\x12\x04\xaf\x08\x17\
    \x18\n\x0c\n\x04\x04k\x02\x01\x12\x04\xb0\x08\x04\x1b\n\r\n\x05\x04k\x02\
    \x01\x05\x12\x04\xb0\x08\x04\n\n\r\n\x05\x04k\x02\x01\x01\x12\x04\xb0\
    \x08\x0b\x16\n\r\n\x05\x04k\x02\x01\x03\x12\x04\xb0\x08\x19\x1a\n\x0c\n\
    \x02\x04l\x12\x06\xb3\x08\0\xb6\x08\x01\n\x0b\n\x03\x04l\x01\x12\x04\xb3\
    \x08\x08(\n\x0c\n\x04\x04l\x02\0\x12\x04\xb4\x08\x04\x1e\n\r\n\x05\x04l\
    \x02\0\x05\x12\x04\xb4\x08\x04\n\n\r\n\x05\x04l\x02\0\x01\x12\x04\xb4\
    \x08\x0b\x19\n\r\n\x05\x04l\x02\0\x03\x12\x04\xb4\x08\x1c\x1d\n\x0c\n\
    \x04\x04l\x02\x01\x12\x04\xb5\x08\x04\x1b\n\r\n\x05\x04l\x02\x01\x05\x12\
    \x04\xb5\x08\x04\n\n\r\n\x05\x04l\x02\x01\x01\x12\x04\xb5\x08\x0b\x16\n\
    \r\n\x05\x04l\x02\x01\x03\x12\x04\xb5\x08\x19\x1a\n\x0c\n\x02\x04m\x12\
    \x06\xb8\x08\0\xbc\x08\x01\n\x0b\n\x03\x04m\x01\x12\x04\xb8\x08\x08\x19\
    \n\x0c\n\x04\x04m\x02\0\x12\x04\xb9\x08\x04\x17\n\r\n\x05\x04m\x02\0\x05\
    \x12\x04\xb9\x08\x04\n\n\r\n\x05\x04m\x02\0\x01\x12\x04\xb9\x08\x0b\x12\
    \n\r\n\x05\x04m\x02\0\x03\x12\x04\xb9\x08\x15\x16\n\x0c\n\x04\x04m\x02\
    \x01\x12\x04\xba\x08\x04\x14\n\r\n\x05\x04m\x02\x01\x05\x12\x04\xba\x08\
    \x04\n\n\r\n\x05\x04m\x02\x01\x01\x12\x04\xba\x08\x0b\x0f\n\r\n\x05\x04m\
    \x02\x01\x03\x12\x04\xba\x08\x12\x13\n\x0c\n\x04\x04m\x02\x02\x12\x04\
    \xbb\x08\x04\x1a\n\r\n\x05\x04m\x02\x02\x05\x12\x04\xbb\x08\x04\n\n\r\n\
    \x05\x04m\x02\x02\x01\x12\x04\xbb\x08\x0b\x15\n\r\n\x05\x04m\x02\x02\x03\
    \x12\x04\xbb\x08\x18\x19\n\x0c\n\x02\x04n\x12\x06\xbe\x08\0\xc0\x08\x01\
    \n\x0b\n\x03\x04n\x01\x12\x04\xbe\x08\x08\x1f\n\x0c\n\x04\x04n\x02\0\x12\
    \x04\xbf\x08\x04\x1d\n\r\n\x05\x04n\x02\0\x05\x12\x04\xbf\x08\x04\n\n\r\
    \n\x05\x04n\x02\0\x01\x12\x04\xbf\x08\x0b\x18\n\r\n\x05\x04n\x02\0\x03\
    \x12\x04\xbf\x08\x1b\x1c\n\x0c\n\x02\x04o\x12\x06\xc2\x08\0\xc4\x08\x01\
    \n\x0b\n\x03\x04o\x01\x12\x04\xc2\x08\x08\"\n\x0c\n\x04\x04o\x02\0\x12\
    \x04\xc3\x08\x04\x1a\n\r\n\x05\x04o\x02\0\x05\x12\x04\xc3\x08\x04\n\n\r\
    \n\x05\x04o\x02\0\x01\x12\x04\xc3\x08\x0b\x15\n\r\n\x05\x04o\x02\0\x03\
    \x12\x04\xc3\x08\x18\x19\n\xf7\x01\n\x02\x04p\x12\x06\xcb\x08\0\xf6\x08\
    \x01\x1a\x1d\x20Those\x20are\x20persisted\x20to\x20disc\n2\xc9\x01//////\
    ////////////////////////////////////////////////////////////////////////\
    ///////////\n\x20PersistableEnvelope\n//////////////////////////////////\
    ///////////////////////////////////////////////////////\n\n\x0b\n\x03\
    \x04p\x01\x12\x04\xcb\x08\x08\x1b\n\x0e\n\x04\x04p\x08\0\x12\x06\xcc\x08\
    \x04\xf5\x08\x05\n\r\n\x05\x04p\x08\0\x01\x12\x04\xcc\x08\n\x11\n\x0c\n\
    \x04\x04p\x02\0\x12\x04\xcd\x08\x082\n\r\n\x05\x04p\x02\0\x06\x12\x04\
    \xcd\x08\x08\x19\n\r\n\x05\x04p\x02\0\x01\x12\x04\xcd\x08\x1a-\n\r\n\x05\
    \x04p\x02\0\x03\x12\x04\xcd\x0801\n\x0c\n\x04\x04p\x02\x01\x12\x04\xce\
    \x08\x08F\n\r\n\x05\x04p\x02\x01\x06\x12\x04\xce\x08\x08\x19\n\r\n\x05\
    \x04p\x02\x01\x01\x12\x04\xce\x08\x1a-\n\r\n\x05\x04p\x02\x01\x03\x12\
    \x04\xce\x0801\n\r\n\x05\x04p\x02\x01\x08\x12\x04\xce\x082E\n\x0e\n\x06\
    \x04p\x02\x01\x08\x03\x12\x04\xce\x083D\n\x0c\n\x04\x04p\x02\x02\x12\x04\
    \xcf\x08\x08\x1f\n\r\n\x05\x04p\x02\x02\x06\x12\x04\xcf\x08\x08\x10\n\r\
    \n\x05\x04p\x02\x02\x01\x12\x04\xcf\x08\x11\x1a\n\r\n\x05\x04p\x02\x02\
    \x03\x12\x04\xcf\x08\x1d\x1e\n\x0c\n\x04\x04p\x02\x03\x12\x04\xd0\x08\
    \x080\n\r\n\x05\x04p\x02\x03\x06\x12\x04\xd0\x08\x08\x18\n\r\n\x05\x04p\
    \x02\x03\x01\x12\x04\xd0\x08\x19+\n\r\n\x05\x04p\x02\x03\x03\x12\x04\xd0\
    \x08./\n\x0c\n\x04\x04p\x02\x04\x12\x04\xd1\x08\x08+\n\r\n\x05\x04p\x02\
    \x04\x06\x12\x04\xd1\x08\x08\x16\n\r\n\x05\x04p\x02\x04\x01\x12\x04\xd1\
    \x08\x17&\n\r\n\x05\x04p\x02\x04\x03\x12\x04\xd1\x08)*\n\x0c\n\x04\x04p\
    \x02\x05\x12\x04\xd3\x08\x08'\n\r\n\x05\x04p\x02\x05\x06\x12\x04\xd3\x08\
    \x08\x14\n\r\n\x05\x04p\x02\x05\x01\x12\x04\xd3\x08\x15\"\n\r\n\x05\x04p\
    \x02\x05\x03\x12\x04\xd3\x08%&\nA\n\x04\x04p\x02\x06\x12\x04\xd4\x08\x08\
    J\"3\x20Was\x20used\x20in\x20pre\x20v0.6.0\x20version.\x20Not\x20used\
    \x20anymore.\n\n\r\n\x05\x04p\x02\x06\x06\x12\x04\xd4\x08\x08\x1b\n\r\n\
    \x05\x04p\x02\x06\x01\x12\x04\xd4\x08\x1c1\n\r\n\x05\x04p\x02\x06\x03\
    \x12\x04\xd4\x0845\n\r\n\x05\x04p\x02\x06\x08\x12\x04\xd4\x086I\n\x0e\n\
    \x06\x04p\x02\x06\x08\x03\x12\x04\xd4\x087H\n\x0c\n\x04\x04p\x02\x07\x12\
    \x04\xd5\x08\x08<\n\r\n\x05\x04p\x02\x07\x06\x12\x04\xd5\x08\x08\x1e\n\r\
    \n\x05\x04p\x02\x07\x01\x12\x04\xd5\x08\x1f7\n\r\n\x05\x04p\x02\x07\x03\
    \x12\x04\xd5\x08:;\n\x0c\n\x04\x04p\x02\x08\x12\x04\xd7\x08\x083\n\r\n\
    \x05\x04p\x02\x08\x06\x12\x04\xd7\x08\x08\x1a\n\r\n\x05\x04p\x02\x08\x01\
    \x12\x04\xd7\x08\x1b.\n\r\n\x05\x04p\x02\x08\x03\x12\x04\xd7\x0812\n\x0c\
    \n\x04\x04p\x02\t\x12\x04\xd8\x08\x08&\n\r\n\x05\x04p\x02\t\x06\x12\x04\
    \xd8\x08\x08\x13\n\r\n\x05\x04p\x02\t\x01\x12\x04\xd8\x08\x14\x20\n\r\n\
    \x05\x04p\x02\t\x03\x12\x04\xd8\x08#%\n\x0c\n\x04\x04p\x02\n\x12\x04\xd9\
    \x08\x085\n\r\n\x05\x04p\x02\n\x06\x12\x04\xd9\x08\x08\x1a\n\r\n\x05\x04\
    p\x02\n\x01\x12\x04\xd9\x08\x1b/\n\r\n\x05\x04p\x02\n\x03\x12\x04\xd9\
    \x0824\n\xb8\x01\n\x04\x04p\x02\x0b\x12\x04\xde\x08\x08>2\xa9\x01\x20dep\
    recated\n\x20BsqState\x20bsq_state\x20=\x2012;\x20//\x20not\x20used\x20b\
    ut\x20as\x20other\x20non-dao\x20data\x20have\x20a\x20higher\x20index\x20\
    number\x20we\x20leave\x20it\x20to\x20make\x20clear\x20that\x20we\x20cann\
    ot\x20change\x20following\x20indexes\n\n\r\n\x05\x04p\x02\x0b\x06\x12\
    \x04\xde\x08\x08\x1e\n\r\n\x05\x04p\x02\x0b\x01\x12\x04\xde\x08\x1f8\n\r\
    \n\x05\x04p\x02\x0b\x03\x12\x04\xde\x08;=\n\x0c\n\x04\x04p\x02\x0c\x12\
    \x04\xdf\x08\x08;\n\r\n\x05\x04p\x02\x0c\x06\x12\x04\xdf\x08\x08\x1d\n\r\
    \n\x05\x04p\x02\x0c\x01\x12\x04\xdf\x08\x1e5\n\r\n\x05\x04p\x02\x0c\x03\
    \x12\x04\xdf\x088:\n\xe9\x01\n\x04\x04p\x02\r\x12\x04\xe4\x08\x08`\x1a\
    \xda\x01\x20we\x20need\x20to\x20keep\x20id\x2015\x20here\x20otherwise\
    \x20the\x20reading\x20of\x20the\x20old\x20data\x20structure\x20would\x20\
    not\x20work\x20anymore.\n\x20can\x20be\x20removed\x20after\x20most\x20pe\
    ople\x20have\x20updated\x20as\x20the\x20reading\x20of\x20the\x20Persista\
    bleNetworkPayloadList\n\x20is\x20not\x20mandatory.\n\n\r\n\x05\x04p\x02\
    \r\x06\x12\x04\xe4\x08\x08%\n\r\n\x05\x04p\x02\r\x01\x12\x04\xe4\x08&F\n\
    \r\n\x05\x04p\x02\r\x03\x12\x04\xe4\x08IK\n\r\n\x05\x04p\x02\r\x08\x12\
    \x04\xe4\x08L_\n\x0e\n\x06\x04p\x02\r\x08\x03\x12\x04\xe4\x08M^\n\x0c\n\
    \x04\x04p\x02\x0e\x12\x04\xe6\x08\x08*\n\r\n\x05\x04p\x02\x0e\x06\x12\
    \x04\xe6\x08\x08\x15\n\r\n\x05\x04p\x02\x0e\x01\x12\x04\xe6\x08\x16$\n\r\
    \n\x05\x04p\x02\x0e\x03\x12\x04\xe6\x08')\n\x0c\n\x04\x04p\x02\x0f\x12\
    \x04\xe7\x08\x083\n\r\n\x05\x04p\x02\x0f\x06\x12\x04\xe7\x08\x08\x19\n\r\
    \n\x05\x04p\x02\x0f\x01\x12\x04\xe7\x08\x1a-\n\r\n\x05\x04p\x02\x0f\x03\
    \x12\x04\xe7\x0802\n\x0c\n\x04\x04p\x02\x10\x12\x04\xe8\x08\x08-\n\r\n\
    \x05\x04p\x02\x10\x06\x12\x04\xe8\x08\x08\x16\n\r\n\x05\x04p\x02\x10\x01\
    \x12\x04\xe8\x08\x17'\n\r\n\x05\x04p\x02\x10\x03\x12\x04\xe8\x08*,\n\x0c\
    \n\x04\x04p\x02\x11\x12\x04\xe9\x08\x08-\n\r\n\x05\x04p\x02\x11\x06\x12\
    \x04\xe9\x08\x08\x16\n\r\n\x05\x04p\x02\x11\x01\x12\x04\xe9\x08\x17'\n\r\
    \n\x05\x04p\x02\x11\x03\x12\x04\xe9\x08*,\n\x0c\n\x04\x04p\x02\x12\x12\
    \x04\xea\x08\x08$\n\r\n\x05\x04p\x02\x12\x06\x12\x04\xea\x08\x08\x12\n\r\
    \n\x05\x04p\x02\x12\x01\x12\x04\xea\x08\x13\x1e\n\r\n\x05\x04p\x02\x12\
    \x03\x12\x04\xea\x08!#\n\x0c\n\x04\x04p\x02\x13\x12\x04\xeb\x08\x08%\n\r\
    \n\x05\x04p\x02\x13\x06\x12\x04\xeb\x08\x08\x12\n\r\n\x05\x04p\x02\x13\
    \x01\x12\x04\xeb\x08\x13\x1f\n\r\n\x05\x04p\x02\x13\x03\x12\x04\xeb\x08\
    \"$\n\x0c\n\x04\x04p\x02\x14\x12\x04\xec\x08\x080\n\r\n\x05\x04p\x02\x14\
    \x06\x12\x04\xec\x08\x08\x17\n\r\n\x05\x04p\x02\x14\x01\x12\x04\xec\x08\
    \x18*\n\r\n\x05\x04p\x02\x14\x03\x12\x04\xec\x08-/\n\x0c\n\x04\x04p\x02\
    \x15\x12\x04\xed\x08\x08\"\n\r\n\x05\x04p\x02\x15\x06\x12\x04\xed\x08\
    \x08\x11\n\r\n\x05\x04p\x02\x15\x01\x12\x04\xed\x08\x12\x1c\n\r\n\x05\
    \x04p\x02\x15\x03\x12\x04\xed\x08\x1f!\n\x0c\n\x04\x04p\x02\x16\x12\x04\
    \xee\x08\x08+\n\r\n\x05\x04p\x02\x16\x06\x12\x04\xee\x08\x08\x15\n\r\n\
    \x05\x04p\x02\x16\x01\x12\x04\xee\x08\x16%\n\r\n\x05\x04p\x02\x16\x03\
    \x12\x04\xee\x08(*\n\x0c\n\x04\x04p\x02\x17\x12\x04\xef\x08\x081\n\r\n\
    \x05\x04p\x02\x17\x06\x12\x04\xef\x08\x08\x18\n\r\n\x05\x04p\x02\x17\x01\
    \x12\x04\xef\x08\x19+\n\r\n\x05\x04p\x02\x17\x03\x12\x04\xef\x08.0\n\x0c\
    \n\x04\x04p\x02\x18\x12\x04\xf0\x08\x085\n\r\n\x05\x04p\x02\x18\x06\x12\
    \x04\xf0\x08\x08\x19\n\r\n\x05\x04p\x02\x18\x01\x12\x04\xf0\x08\x1a/\n\r\
    \n\x05\x04p\x02\x18\x03\x12\x04\xf0\x0824\n\x0c\n\x04\x04p\x02\x19\x12\
    \x04\xf1\x08\x08O\n\r\n\x05\x04p\x02\x19\x06\x12\x04\xf1\x08\x08&\n\r\n\
    \x05\x04p\x02\x19\x01\x12\x04\xf1\x08'I\n\r\n\x05\x04p\x02\x19\x03\x12\
    \x04\xf1\x08LN\n\x0c\n\x04\x04p\x02\x1a\x12\x04\xf2\x08\x085\n\r\n\x05\
    \x04p\x02\x1a\x06\x12\x04\xf2\x08\x08\x1a\n\r\n\x05\x04p\x02\x1a\x01\x12\
    \x04\xf2\x08\x1b/\n\r\n\x05\x04p\x02\x1a\x03\x12\x04\xf2\x0824\n\x0c\n\
    \x04\x04p\x02\x1b\x12\x04\xf3\x08\x089\n\r\n\x05\x04p\x02\x1b\x06\x12\
    \x04\xf3\x08\x08\x1c\n\r\n\x05\x04p\x02\x1b\x01\x12\x04\xf3\x08\x1d3\n\r\
    \n\x05\x04p\x02\x1b\x03\x12\x04\xf3\x0868\n\x0c\n\x04\x04p\x02\x1c\x12\
    \x04\xf4\x08\x083\n\r\n\x05\x04p\x02\x1c\x06\x12\x04\xf4\x08\x08\x19\n\r\
    \n\x05\x04p\x02\x1c\x01\x12\x04\xf4\x08\x1a-\n\r\n\x05\x04p\x02\x1c\x03\
    \x12\x04\xf4\x0802\n\xd0\x01\n\x02\x04q\x12\x06\xfc\x08\0\xfe\x08\x012\
    \xc1\x01////////////////////////////////////////////////////////////////\
    /////////////////////////\n\x20Collections\n////////////////////////////\
    /////////////////////////////////////////////////////////////\n\n\x0b\n\
    \x03\x04q\x01\x12\x04\xfc\x08\x08\x19\n\x0c\n\x04\x04q\x02\0\x12\x04\xfd\
    \x08\x04=\n\r\n\x05\x04q\x02\0\x04\x12\x04\xfd\x08\x04\x0c\n\r\n\x05\x04\
    q\x02\0\x06\x12\x04\xfd\x08\r\x20\n\r\n\x05\x04q\x02\0\x01\x12\x04\xfd\
    \x08!8\n\r\n\x05\x04q\x02\0\x03\x12\x04\xfd\x08;<\n\x0c\n\x02\x04r\x12\
    \x06\x80\t\0\x83\t\x01\n\x0b\n\x03\x04r\x01\x12\x04\x80\t\x08\x1b\n\x0c\
    \n\x04\x04r\x02\0\x12\x04\x81\t\x04\x18\n\r\n\x05\x04r\x02\0\x06\x12\x04\
    \x81\t\x04\r\n\r\n\x05\x04r\x02\0\x01\x12\x04\x81\t\x0e\x13\n\r\n\x05\
    \x04r\x02\0\x03\x12\x04\x81\t\x16\x17\n\x0c\n\x04\x04r\x02\x01\x12\x04\
    \x82\t\x04\x1b\n\r\n\x05\x04r\x02\x01\x06\x12\x04\x82\t\x04\x0c\n\r\n\
    \x05\x04r\x02\x01\x01\x12\x04\x82\t\r\x16\n\r\n\x05\x04r\x02\x01\x03\x12\
    \x04\x82\t\x19\x1a\n\x0c\n\x02\x04s\x12\x06\x85\t\0\x87\t\x01\n\x0b\n\
    \x03\x04s\x01\x12\x04\x85\t\x08\x11\n\x0c\n\x04\x04s\x02\0\x12\x04\x86\t\
    \x04\x14\n\r\n\x05\x04s\x02\0\x05\x12\x04\x86\t\x04\t\n\r\n\x05\x04s\x02\
    \0\x01\x12\x04\x86\t\n\x0f\n\r\n\x05\x04s\x02\0\x03\x12\x04\x86\t\x12\
    \x13\n\x0c\n\x02\x04t\x12\x06\x89\t\0\x8c\t\x01\n\x0b\n\x03\x04t\x01\x12\
    \x04\x89\t\x08\x10\n\x0c\n\x04\x04t\x02\0\x12\x04\x8a\t\x04\x1a\n\r\n\
    \x05\x04t\x02\0\x05\x12\x04\x8a\t\x04\t\n\r\n\x05\x04t\x02\0\x01\x12\x04\
    \x8a\t\n\x15\n\r\n\x05\x04t\x02\0\x03\x12\x04\x8a\t\x18\x19\n\x0c\n\x04\
    \x04t\x02\x01\x12\x04\x8b\t\x04\x19\n\r\n\x05\x04t\x02\x01\x05\x12\x04\
    \x8b\t\x04\t\n\r\n\x05\x04t\x02\x01\x01\x12\x04\x8b\t\n\x14\n\r\n\x05\
    \x04t\x02\x01\x03\x12\x04\x8b\t\x17\x18\n-\n\x02\x04u\x12\x06\x8f\t\0\
    \x91\t\x01\x1a\x1f\x20deprecated.\x20Not\x20used\x20anymore.\n\n\x0b\n\
    \x03\x04u\x01\x12\x04\x8f\t\x08\x19\n\x0c\n\x04\x04u\x02\0\x12\x04\x90\t\
    \x04?\n\r\n\x05\x04u\x02\0\x06\x12\x04\x90\t\x04&\n\r\n\x05\x04u\x02\0\
    \x01\x12\x04\x90\t':\n\r\n\x05\x04u\x02\0\x03\x12\x04\x90\t=>\n-\n\x02\
    \x04v\x12\x06\x94\t\0\x96\t\x01\x1a\x1f\x20deprecated.\x20Not\x20used\
    \x20anymore.\n\n\x0b\n\x03\x04v\x01\x12\x04\x94\t\x08%\n\x0c\n\x04\x04v\
    \x02\0\x12\x04\x95\t\x041\n\r\n\x05\x04v\x02\0\x04\x12\x04\x95\t\x04\x0c\
    \n\r\n\x05\x04v\x02\0\x06\x12\x04\x95\t\r&\n\r\n\x05\x04v\x02\0\x01\x12\
    \x04\x95\t',\n\r\n\x05\x04v\x02\0\x03\x12\x04\x95\t/0\ns\n\x02\x04w\x12\
    \x06\x99\t\0\x9b\t\x01\x1ae\x20We\x20use\x20a\x20list\x20not\x20a\x20has\
    h\x20map\x20to\x20save\x20disc\x20space.\x20The\x20hash\x20can\x20be\x20\
    calculated\x20from\x20the\x20payload\x20anyway\n\n\x0b\n\x03\x04w\x01\
    \x12\x04\x99\t\x08\x1e\n\x0c\n\x04\x04w\x02\0\x12\x04\x9a\t\x04)\n\r\n\
    \x05\x04w\x02\0\x04\x12\x04\x9a\t\x04\x0c\n\r\n\x05\x04w\x02\0\x06\x12\
    \x04\x9a\t\r\x1e\n\r\n\x05\x04w\x02\0\x01\x12\x04\x9a\t\x1f$\n\r\n\x05\
    \x04w\x02\0\x03\x12\x04\x9a\t'(\n\x0c\n\x02\x04x\x12\x06\x9d\t\0\x9f\t\
    \x01\n\x0b\n\x03\x04x\x01\x12\x04\x9d\t\x08\x1a\n\x0c\n\x04\x04x\x02\0\
    \x12\x04\x9e\t\x04%\n\r\n\x05\x04x\x02\0\x04\x12\x04\x9e\t\x04\x0c\n\r\n\
    \x05\x04x\x02\0\x06\x12\x04\x9e\t\r\x1a\n\r\n\x05\x04x\x02\0\x01\x12\x04\
    \x9e\t\x1b\x20\n\r\n\x05\x04x\x02\0\x03\x12\x04\x9e\t#$\ns\n\x02\x04y\
    \x12\x06\xa2\t\0\xa4\t\x01\x1ae\x20We\x20use\x20a\x20list\x20not\x20a\
    \x20hash\x20map\x20to\x20save\x20disc\x20space.\x20The\x20hash\x20can\
    \x20be\x20calculated\x20from\x20the\x20payload\x20anyway\n\n\x0b\n\x03\
    \x04y\x01\x12\x04\xa2\t\x08\x1d\n\x0c\n\x04\x04y\x02\0\x12\x04\xa3\t\x04\
    (\n\r\n\x05\x04y\x02\0\x04\x12\x04\xa3\t\x04\x0c\n\r\n\x05\x04y\x02\0\
    \x06\x12\x04\xa3\t\r\x1d\n\r\n\x05\x04y\x02\0\x01\x12\x04\xa3\t\x1e#\n\r\
    \n\x05\x04y\x02\0\x03\x12\x04\xa3\t&'\n\x0c\n\x02\x04z\x12\x06\xa6\t\0\
    \xa8\t\x01\n\x0b\n\x03\x04z\x01\x12\x04\xa6\t\x08\x10\n\x0c\n\x04\x04z\
    \x02\0\x12\x04\xa7\t\x04\x1b\n\r\n\x05\x04z\x02\0\x04\x12\x04\xa7\t\x04\
    \x0c\n\r\n\x05\x04z\x02\0\x06\x12\x04\xa7\t\r\x11\n\r\n\x05\x04z\x02\0\
    \x01\x12\x04\xa7\t\x12\x16\n\r\n\x05\x04z\x02\0\x03\x12\x04\xa7\t\x19\
    \x1a\n\x0c\n\x02\x04{\x12\x06\xaa\t\0\xac\t\x01\n\x0b\n\x03\x04{\x01\x12\
    \x04\xaa\t\x08\x18\n\x0c\n\x04\x04{\x02\0\x12\x04\xab\t\x04,\n\r\n\x05\
    \x04{\x02\0\x04\x12\x04\xab\t\x04\x0c\n\r\n\x05\x04{\x02\0\x06\x12\x04\
    \xab\t\r\x19\n\r\n\x05\x04{\x02\0\x01\x12\x04\xab\t\x1a'\n\r\n\x05\x04{\
    \x02\0\x03\x12\x04\xab\t*+\n\x0c\n\x02\x04|\x12\x06\xae\t\0\xbe\t\x01\n\
    \x0b\n\x03\x04|\x01\x12\x04\xae\t\x08\x14\n\x0e\n\x04\x04|\x04\0\x12\x06\
    \xaf\t\x04\xb7\t\x05\n\r\n\x05\x04|\x04\0\x01\x12\x04\xaf\t\t\x10\n\x0e\
    \n\x06\x04|\x04\0\x02\0\x12\x04\xb0\t\x08\x15\n\x0f\n\x07\x04|\x04\0\x02\
    \0\x01\x12\x04\xb0\t\x08\x10\n\x0f\n\x07\x04|\x04\0\x02\0\x02\x12\x04\
    \xb0\t\x13\x14\n\x0e\n\x06\x04|\x04\0\x02\x01\x12\x04\xb1\t\x08\x17\n\
    \x0f\n\x07\x04|\x04\0\x02\x01\x01\x12\x04\xb1\t\x08\x12\n\x0f\n\x07\x04|\
    \x04\0\x02\x01\x02\x12\x04\xb1\t\x15\x16\n\x0e\n\x06\x04|\x04\0\x02\x02\
    \x12\x04\xb2\t\x08\x16\n\x0f\n\x07\x04|\x04\0\x02\x02\x01\x12\x04\xb2\t\
    \x08\x11\n\x0f\n\x07\x04|\x04\0\x02\x02\x02\x12\x04\xb2\t\x14\x15\n\x0e\
    \n\x06\x04|\x04\0\x02\x03\x12\x04\xb3\t\x08\x1a\n\x0f\n\x07\x04|\x04\0\
    \x02\x03\x01\x12\x04\xb3\t\x08\x15\n\x0f\n\x07\x04|\x04\0\x02\x03\x02\
    \x12\x04\xb3\t\x18\x19\n\x0e\n\x06\x04|\x04\0\x02\x04\x12\x04\xb4\t\x08\
    \x1f\n\x0f\n\x07\x04|\x04\0\x02\x04\x01\x12\x04\xb4\t\x08\x1a\n\x0f\n\
    \x07\x04|\x04\0\x02\x04\x02\x12\x04\xb4\t\x1d\x1e\n\x0e\n\x06\x04|\x04\0\
    \x02\x05\x12\x04\xb5\t\x08\x16\n\x0f\n\x07\x04|\x04\0\x02\x05\x01\x12\
    \x04\xb5\t\x08\x11\n\x0f\n\x07\x04|\x04\0\x02\x05\x02\x12\x04\xb5\t\x14\
    \x15\n\x0e\n\x06\x04|\x04\0\x02\x06\x12\x04\xb6\t\x08\x19\n\x0f\n\x07\
    \x04|\x04\0\x02\x06\x01\x12\x04\xb6\t\x08\x14\n\x0f\n\x07\x04|\x04\0\x02\
    \x06\x02\x12\x04\xb6\t\x17\x18\n\x0c\n\x04\x04|\x02\0\x12\x04\xb9\t\x04\
    \x18\n\r\n\x05\x04|\x02\0\x05\x12\x04\xb9\t\x04\n\n\r\n\x05\x04|\x02\0\
    \x01\x12\x04\xb9\t\x0b\x13\n\r\n\x05\x04|\x02\0\x03\x12\x04\xb9\t\x16\
    \x17\n\x0c\n\x04\x04|\x02\x01\x12\x04\xba\t\x04\x18\n\r\n\x05\x04|\x02\
    \x01\x06\x12\x04\xba\t\x04\x0b\n\r\n\x05\x04|\x02\x01\x01\x12\x04\xba\t\
    \x0c\x13\n\r\n\x05\x04|\x02\x01\x03\x12\x04\xba\t\x16\x17\n\x0c\n\x04\
    \x04|\x02\x02\x12\x04\xbb\t\x04\x16\n\r\n\x05\x04|\x02\x02\x05\x12\x04\
    \xbb\t\x04\t\n\r\n\x05\x04|\x02\x02\x01\x12\x04\xbb\t\n\x11\n\r\n\x05\
    \x04|\x02\x02\x03\x12\x04\xbb\t\x14\x15\n\x0c\n\x04\x04|\x02\x03\x12\x04\
    \xbc\t\x04\x1c\n\r\n\x05\x04|\x02\x03\x05\x12\x04\xbc\t\x04\t\n\r\n\x05\
    \x04|\x02\x03\x01\x12\x04\xbc\t\n\x16\n\r\n\x05\x04|\x02\x03\x03\x12\x04\
    \xbc\t\x19\x1b\n\x0c\n\x04\x04|\x02\x04\x12\x04\xbd\t\x04(\n\r\n\x05\x04\
    |\x02\x04\x05\x12\x04\xbd\t\x04\t\n\r\n\x05\x04|\x02\x04\x01\x12\x04\xbd\
    \t\n\"\n\r\n\x05\x04|\x02\x04\x03\x12\x04\xbd\t%'\n\x0c\n\x02\x04}\x12\
    \x06\xc0\t\0\xc2\t\x01\n\x0b\n\x03\x04}\x01\x12\x04\xc0\t\x08\x16\n\x0c\
    \n\x04\x04}\x02\0\x12\x04\xc1\t\x04\x1d\n\r\n\x05\x04}\x02\0\x04\x12\x04\
    \xc1\t\x04\x0c\n\r\n\x05\x04}\x02\0\x05\x12\x04\xc1\t\r\x13\n\r\n\x05\
    \x04}\x02\0\x01\x12\x04\xc1\t\x14\x18\n\r\n\x05\x04}\x02\0\x03\x12\x04\
    \xc1\t\x1b\x1c\n\x0c\n\x02\x04~\x12\x06\xc4\t\0\xc6\t\x01\n\x0b\n\x03\
    \x04~\x01\x12\x04\xc4\t\x08\x1a\n\x0c\n\x04\x04~\x02\0\x12\x04\xc5\t\x04\
    0\n\r\n\x05\x04~\x02\0\x04\x12\x04\xc5\t\x04\x0c\n\r\n\x05\x04~\x02\0\
    \x06\x12\x04\xc5\t\r\x1b\n\r\n\x05\x04~\x02\0\x01\x12\x04\xc5\t\x1c+\n\r\
    \n\x05\x04~\x02\0\x03\x12\x04\xc5\t./\n\xd0\x01\n\x02\x04\x7f\x12\x06\
    \xcc\t\0\xce\t\x012\xc1\x01/////////////////////////////////////////////\
    ////////////////////////////////////////////\n\x20Offer/Trade\n/////////\
    ////////////////////////////////////////////////////////////////////////\
    ////////\n\n\x0b\n\x03\x04\x7f\x01\x12\x04\xcc\t\x08\x14\n\x0c\n\x04\x04\
    \x7f\x02\0\x12\x04\xcd\t\x04#\n\r\n\x05\x04\x7f\x02\0\x04\x12\x04\xcd\t\
    \x04\x0c\n\r\n\x05\x04\x7f\x02\0\x06\x12\x04\xcd\t\r\x15\n\r\n\x05\x04\
    \x7f\x02\0\x01\x12\x04\xcd\t\x16\x1e\n\r\n\x05\x04\x7f\x02\0\x03\x12\x04\
    \xcd\t!\"\n\x7f\n\x03\x04\x80\x01\x12\x06\xd1\t\0\xd3\t\x01\x1ap\x20depr\
    ecated\x20\x20Was\x20used\x20in\x20pre\x20v0.6.0\x20version.\x20Not\x20u\
    sed\x20anymore\x20but\x20leave\x20it\x20as\x20it\x20is\x20used\x20in\x20\
    PersistableEnvelope\n\n\x0c\n\x04\x04\x80\x01\x01\x12\x04\xd1\t\x08\x1b\
    \n\r\n\x05\x04\x80\x01\x02\0\x12\x04\xd2\t\x042\n\x0e\n\x06\x04\x80\x01\
    \x02\0\x04\x12\x04\xd2\t\x04\x0c\n\x0e\n\x06\x04\x80\x01\x02\0\x06\x12\
    \x04\xd2\t\r\x1c\n\x0e\n\x06\x04\x80\x01\x02\0\x01\x12\x04\xd2\t\x1d-\n\
    \x0e\n\x06\x04\x80\x01\x02\0\x03\x12\x04\xd2\t01\n\r\n\x03\x04\x81\x01\
    \x12\x06\xd5\t\0\xe1\t\x01\n\x0c\n\x04\x04\x81\x01\x01\x12\x04\xd5\t\x08\
    \r\n\x0f\n\x05\x04\x81\x01\x04\0\x12\x06\xd6\t\x04\xde\t\x05\n\x0e\n\x06\
    \x04\x81\x01\x04\0\x01\x12\x04\xd6\t\t\x0e\n\x0f\n\x07\x04\x81\x01\x04\0\
    \x02\0\x12\x04\xd7\t\x08\x15\n\x10\n\x08\x04\x81\x01\x04\0\x02\0\x01\x12\
    \x04\xd7\t\x08\x10\n\x10\n\x08\x04\x81\x01\x04\0\x02\0\x02\x12\x04\xd7\t\
    \x13\x14\n\x0f\n\x07\x04\x81\x01\x04\0\x02\x01\x12\x04\xd8\t\x08\x14\n\
    \x10\n\x08\x04\x81\x01\x04\0\x02\x01\x01\x12\x04\xd8\t\x08\x0f\n\x10\n\
    \x08\x04\x81\x01\x04\0\x02\x01\x02\x12\x04\xd8\t\x12\x13\n\x0f\n\x07\x04\
    \x81\x01\x04\0\x02\x02\x12\x04\xd9\t\x08\x1b\n\x10\n\x08\x04\x81\x01\x04\
    \0\x02\x02\x01\x12\x04\xd9\t\x08\x16\n\x10\n\x08\x04\x81\x01\x04\0\x02\
    \x02\x02\x12\x04\xd9\t\x19\x1a\n\x0f\n\x07\x04\x81\x01\x04\0\x02\x03\x12\
    \x04\xda\t\x08\x16\n\x10\n\x08\x04\x81\x01\x04\0\x02\x03\x01\x12\x04\xda\
    \t\x08\x11\n\x10\n\x08\x04\x81\x01\x04\0\x02\x03\x02\x12\x04\xda\t\x14\
    \x15\n\x0f\n\x07\x04\x81\x01\x04\0\x02\x04\x12\x04\xdb\t\x08\x1a\n\x10\n\
    \x08\x04\x81\x01\x04\0\x02\x04\x01\x12\x04\xdb\t\x08\x15\n\x10\n\x08\x04\
    \x81\x01\x04\0\x02\x04\x02\x12\x04\xdb\t\x18\x19\n\x0f\n\x07\x04\x81\x01\
    \x04\0\x02\x05\x12\x04\xdc\t\x08\x14\n\x10\n\x08\x04\x81\x01\x04\0\x02\
    \x05\x01\x12\x04\xdc\t\x08\x0f\n\x10\n\x08\x04\x81\x01\x04\0\x02\x05\x02\
    \x12\x04\xdc\t\x12\x13\n\x0f\n\x07\x04\x81\x01\x04\0\x02\x06\x12\x04\xdd\
    \t\x08\x1a\n\x10\n\x08\x04\x81\x01\x04\0\x02\x06\x01\x12\x04\xdd\t\x08\
    \x15\n\x10\n\x08\x04\x81\x01\x04\0\x02\x06\x02\x12\x04\xdd\t\x18\x19\n\r\
    \n\x05\x04\x81\x01\x02\0\x12\x04\xe0\t\x04#\n\x0e\n\x06\x04\x81\x01\x02\
    \0\x06\x12\x04\xe0\t\x04\x10\n\x0e\n\x06\x04\x81\x01\x02\0\x01\x12\x04\
    \xe0\t\x11\x1e\n\x0e\n\x06\x04\x81\x01\x02\0\x03\x12\x04\xe0\t!\"\n\r\n\
    \x03\x04\x82\x01\x12\x06\xe3\t\0\xf2\t\x01\n\x0c\n\x04\x04\x82\x01\x01\
    \x12\x04\xe3\t\x08\x11\n\x0f\n\x05\x04\x82\x01\x04\0\x12\x06\xe4\t\x04\
    \xeb\t\x05\n\x0e\n\x06\x04\x82\x01\x04\0\x01\x12\x04\xe4\t\t\x0e\n\x0f\n\
    \x07\x04\x82\x01\x04\0\x02\0\x12\x04\xe5\t\x08\x15\n\x10\n\x08\x04\x82\
    \x01\x04\0\x02\0\x01\x12\x04\xe5\t\x08\x10\n\x10\n\x08\x04\x82\x01\x04\0\
    \x02\0\x02\x12\x04\xe5\t\x13\x14\n\x0f\n\x07\x04\x82\x01\x04\0\x02\x01\
    \x12\x04\xe6\t\x08\x16\n\x10\n\x08\x04\x82\x01\x04\0\x02\x01\x01\x12\x04\
    \xe6\t\x08\x11\n\x10\n\x08\x04\x82\x01\x04\0\x02\x01\x02\x12\x04\xe6\t\
    \x14\x15\n\x0f\n\x07\x04\x82\x01\x04\0\x02\x02\x12\x04\xe7\t\x08\x15\n\
    \x10\n\x08\x04\x82\x01\x04\0\x02\x02\x01\x12\x04\xe7\t\x08\x10\n\x10\n\
    \x08\x04\x82\x01\x04\0\x02\x02\x02\x12\x04\xe7\t\x13\x14\n\x0f\n\x07\x04\
    \x82\x01\x04\0\x02\x03\x12\x04\xe8\t\x08\x13\n\x10\n\x08\x04\x82\x01\x04\
    \0\x02\x03\x01\x12\x04\xe8\t\x08\x0e\n\x10\n\x08\x04\x82\x01\x04\0\x02\
    \x03\x02\x12\x04\xe8\t\x11\x12\n\x0f\n\x07\x04\x82\x01\x04\0\x02\x04\x12\
    \x04\xe9\t\x08\x15\n\x10\n\x08\x04\x82\x01\x04\0\x02\x04\x01\x12\x04\xe9\
    \t\x08\x10\n\x10\n\x08\x04\x82\x01\x04\0\x02\x04\x02\x12\x04\xe9\t\x13\
    \x14\n\x0f\n\x07\x04\x82\x01\x04\0\x02\x05\x12\x04\xea\t\x08\x18\n\x10\n\
    \x08\x04\x82\x01\x04\0\x02\x05\x01\x12\x04\xea\t\x08\x13\n\x10\n\x08\x04\
    \x82\x01\x04\0\x02\x05\x02\x12\x04\xea\t\x16\x17\n\r\n\x05\x04\x82\x01\
    \x02\0\x12\x04\xed\t\x04\x14\n\x0e\n\x06\x04\x82\x01\x02\0\x06\x12\x04\
    \xed\t\x04\t\n\x0e\n\x06\x04\x82\x01\x02\0\x01\x12\x04\xed\t\n\x0f\n\x0e\
    \n\x06\x04\x82\x01\x02\0\x03\x12\x04\xed\t\x12\x13\n\r\n\x05\x04\x82\x01\
    \x02\x01\x12\x04\xee\t\x04\x14\n\x0e\n\x06\x04\x82\x01\x02\x01\x06\x12\
    \x04\xee\t\x04\t\n\x0e\n\x06\x04\x82\x01\x02\x01\x01\x12\x04\xee\t\n\x0f\
    \n\x0e\n\x06\x04\x82\x01\x02\x01\x03\x12\x04\xee\t\x12\x13\n\r\n\x05\x04\
    \x82\x01\x02\x02\x12\x04\xef\t\x04,\n\x0e\n\x06\x04\x82\x01\x02\x02\x06\
    \x12\x04\xef\t\x04\x0f\n\x0e\n\x06\x04\x82\x01\x02\x02\x01\x12\x04\xef\t\
    \x10'\n\x0e\n\x06\x04\x82\x01\x02\x02\x03\x12\x04\xef\t*+\n\r\n\x05\x04\
    \x82\x01\x02\x03\x12\x04\xf0\t\x04*\n\x0e\n\x06\x04\x82\x01\x02\x03\x06\
    \x12\x04\xf0\t\x04\x0f\n\x0e\n\x06\x04\x82\x01\x02\x03\x01\x12\x04\xf0\t\
    \x10%\n\x0e\n\x06\x04\x82\x01\x02\x03\x03\x12\x04\xf0\t()\n\r\n\x05\x04\
    \x82\x01\x02\x04\x12\x04\xf1\t\x04.\n\x0e\n\x06\x04\x82\x01\x02\x04\x06\
    \x12\x04\xf1\t\x04\x0f\n\x0e\n\x06\x04\x82\x01\x02\x04\x01\x12\x04\xf1\t\
    \x10)\n\x0e\n\x06\x04\x82\x01\x02\x04\x03\x12\x04\xf1\t,-\n\r\n\x03\x04\
    \x83\x01\x12\x06\xf4\t\0\xfc\t\x01\n\x0c\n\x04\x04\x83\x01\x01\x12\x04\
    \xf4\t\x08\x10\n\x0f\n\x05\x04\x83\x01\x08\0\x12\x06\xf5\t\x04\xfb\t\x05\
    \n\x0e\n\x06\x04\x83\x01\x08\0\x01\x12\x04\xf5\t\n\x11\n\r\n\x05\x04\x83\
    \x01\x02\0\x12\x04\xf6\t\x08!\n\x0e\n\x06\x04\x83\x01\x02\0\x06\x12\x04\
    \xf6\t\x08\x11\n\x0e\n\x06\x04\x83\x01\x02\0\x01\x12\x04\xf6\t\x12\x1c\n\
    \x0e\n\x06\x04\x83\x01\x02\0\x03\x12\x04\xf6\t\x1f\x20\n\r\n\x05\x04\x83\
    \x01\x02\x01\x12\x04\xf7\t\x083\n\x0e\n\x06\x04\x83\x01\x02\x01\x06\x12\
    \x04\xf7\t\x08\x19\n\x0e\n\x06\x04\x83\x01\x02\x01\x01\x12\x04\xf7\t\x1a\
    .\n\x0e\n\x06\x04\x83\x01\x02\x01\x03\x12\x04\xf7\t12\n\r\n\x05\x04\x83\
    \x01\x02\x02\x12\x04\xf8\t\x083\n\x0e\n\x06\x04\x83\x01\x02\x02\x06\x12\
    \x04\xf8\t\x08\x19\n\x0e\n\x06\x04\x83\x01\x02\x02\x01\x12\x04\xf8\t\x1a\
    .\n\x0e\n\x06\x04\x83\x01\x02\x02\x03\x12\x04\xf8\t12\n\r\n\x05\x04\x83\
    \x01\x02\x03\x12\x04\xf9\t\x085\n\x0e\n\x06\x04\x83\x01\x02\x03\x06\x12\
    \x04\xf9\t\x08\x1a\n\x0e\n\x06\x04\x83\x01\x02\x03\x01\x12\x04\xf9\t\x1b\
    0\n\x0e\n\x06\x04\x83\x01\x02\x03\x03\x12\x04\xf9\t34\n\r\n\x05\x04\x83\
    \x01\x02\x04\x12\x04\xfa\t\x085\n\x0e\n\x06\x04\x83\x01\x02\x04\x06\x12\
    \x04\xfa\t\x08\x1a\n\x0e\n\x06\x04\x83\x01\x02\x04\x01\x12\x04\xfa\t\x1b\
    0\n\x0e\n\x06\x04\x83\x01\x02\x04\x03\x12\x04\xfa\t34\n\r\n\x03\x04\x84\
    \x01\x12\x06\xfe\t\0\xe5\n\x01\n\x0c\n\x04\x04\x84\x01\x01\x12\x04\xfe\t\
    \x08\r\n\x0f\n\x05\x04\x84\x01\x04\0\x12\x06\xff\t\x04\x9f\n\x05\n\x0e\n\
    \x06\x04\x84\x01\x04\0\x01\x12\x04\xff\t\t\x0e\n\x0f\n\x07\x04\x84\x01\
    \x04\0\x02\0\x12\x04\x80\n\x08\x1b\n\x10\n\x08\x04\x84\x01\x04\0\x02\0\
    \x01\x12\x04\x80\n\x08\x16\n\x10\n\x08\x04\x84\x01\x04\0\x02\0\x02\x12\
    \x04\x80\n\x19\x1a\n\x0f\n\x07\x04\x84\x01\x04\0\x02\x01\x12\x04\x81\n\
    \x08\x18\n\x10\n\x08\x04\x84\x01\x04\0\x02\x01\x01\x12\x04\x81\n\x08\x13\
    \n\x10\n\x08\x04\x84\x01\x04\0\x02\x01\x02\x12\x04\x81\n\x16\x17\n\x0f\n\
    \x07\x04\x84\x01\x04\0\x02\x02\x12\x04\x82\n\x08)\n\x10\n\x08\x04\x84\
    \x01\x04\0\x02\x02\x01\x12\x04\x82\n\x08$\n\x10\n\x08\x04\x84\x01\x04\0\
    \x02\x02\x02\x12\x04\x82\n'(\n\x0f\n\x07\x04\x84\x01\x04\0\x02\x03\x12\
    \x04\x83\n\x082\n\x10\n\x08\x04\x84\x01\x04\0\x02\x03\x01\x12\x04\x83\n\
    \x08-\n\x10\n\x08\x04\x84\x01\x04\0\x02\x03\x02\x12\x04\x83\n01\n\x0f\n\
    \x07\x04\x84\x01\x04\0\x02\x04\x12\x04\x84\n\x089\n\x10\n\x08\x04\x84\
    \x01\x04\0\x02\x04\x01\x12\x04\x84\n\x084\n\x10\n\x08\x04\x84\x01\x04\0\
    \x02\x04\x02\x12\x04\x84\n78\n\x0f\n\x07\x04\x84\x01\x04\0\x02\x05\x12\
    \x04\x85\n\x08?\n\x10\n\x08\x04\x84\x01\x04\0\x02\x05\x01\x12\x04\x85\n\
    \x08:\n\x10\n\x08\x04\x84\x01\x04\0\x02\x05\x02\x12\x04\x85\n=>\n\x0f\n\
    \x07\x04\x84\x01\x04\0\x02\x06\x12\x04\x86\n\x089\n\x10\n\x08\x04\x84\
    \x01\x04\0\x02\x06\x01\x12\x04\x86\n\x084\n\x10\n\x08\x04\x84\x01\x04\0\
    \x02\x06\x02\x12\x04\x86\n78\n\x0f\n\x07\x04\x84\x01\x04\0\x02\x07\x12\
    \x04\x87\n\x086\n\x10\n\x08\x04\x84\x01\x04\0\x02\x07\x01\x12\x04\x87\n\
    \x081\n\x10\n\x08\x04\x84\x01\x04\0\x02\x07\x02\x12\x04\x87\n45\n\x0f\n\
    \x07\x04\x84\x01\x04\0\x02\x08\x12\x04\x88\n\x08(\n\x10\n\x08\x04\x84\
    \x01\x04\0\x02\x08\x01\x12\x04\x88\n\x08#\n\x10\n\x08\x04\x84\x01\x04\0\
    \x02\x08\x02\x12\x04\x88\n&'\n\x0f\n\x07\x04\x84\x01\x04\0\x02\t\x12\x04\
    \x89\n\x081\n\x10\n\x08\x04\x84\x01\x04\0\x02\t\x01\x12\x04\x89\n\x08,\n\
    \x10\n\x08\x04\x84\x01\x04\0\x02\t\x02\x12\x04\x89\n/0\n\x0f\n\x07\x04\
    \x84\x01\x04\0\x02\n\x12\x04\x8a\n\x089\n\x10\n\x08\x04\x84\x01\x04\0\
    \x02\n\x01\x12\x04\x8a\n\x083\n\x10\n\x08\x04\x84\x01\x04\0\x02\n\x02\
    \x12\x04\x8a\n68\n\x0f\n\x07\x04\x84\x01\x04\0\x02\x0b\x12\x04\x8b\n\x08\
    ?\n\x10\n\x08\x04\x84\x01\x04\0\x02\x0b\x01\x12\x04\x8b\n\x089\n\x10\n\
    \x08\x04\x84\x01\x04\0\x02\x0b\x02\x12\x04\x8b\n<>\n\x0f\n\x07\x04\x84\
    \x01\x04\0\x02\x0c\x12\x04\x8c\n\x089\n\x10\n\x08\x04\x84\x01\x04\0\x02\
    \x0c\x01\x12\x04\x8c\n\x083\n\x10\n\x08\x04\x84\x01\x04\0\x02\x0c\x02\
    \x12\x04\x8c\n68\n\x0f\n\x07\x04\x84\x01\x04\0\x02\r\x12\x04\x8d\n\x085\
    \n\x10\n\x08\x04\x84\x01\x04\0\x02\r\x01\x12\x04\x8d\n\x08/\n\x10\n\x08\
    \x04\x84\x01\x04\0\x02\r\x02\x12\x04\x8d\n24\n\x0f\n\x07\x04\x84\x01\x04\
    \0\x02\x0e\x12\x04\x8e\n\x08-\n\x10\n\x08\x04\x84\x01\x04\0\x02\x0e\x01\
    \x12\x04\x8e\n\x08'\n\x10\n\x08\x04\x84\x01\x04\0\x02\x0e\x02\x12\x04\
    \x8e\n*,\n\x0f\n\x07\x04\x84\x01\x04\0\x02\x0f\x12\x04\x8f\n\x08.\n\x10\
    \n\x08\x04\x84\x01\x04\0\x02\x0f\x01\x12\x04\x8f\n\x08(\n\x10\n\x08\x04\
    \x84\x01\x04\0\x02\x0f\x02\x12\x04\x8f\n+-\n\x0f\n\x07\x04\x84\x01\x04\0\
    \x02\x10\x12\x04\x90\n\x08:\n\x10\n\x08\x04\x84\x01\x04\0\x02\x10\x01\
    \x12\x04\x90\n\x084\n\x10\n\x08\x04\x84\x01\x04\0\x02\x10\x02\x12\x04\
    \x90\n79\n\x0f\n\x07\x04\x84\x01\x04\0\x02\x11\x12\x04\x91\n\x083\n\x10\
    \n\x08\x04\x84\x01\x04\0\x02\x11\x01\x12\x04\x91\n\x08-\n\x10\n\x08\x04\
    \x84\x01\x04\0\x02\x11\x02\x12\x04\x91\n02\n\x0f\n\x07\x04\x84\x01\x04\0\
    \x02\x12\x12\x04\x92\n\x08:\n\x10\n\x08\x04\x84\x01\x04\0\x02\x12\x01\
    \x12\x04\x92\n\x084\n\x10\n\x08\x04\x84\x01\x04\0\x02\x12\x02\x12\x04\
    \x92\n79\n\x0f\n\x07\x04\x84\x01\x04\0\x02\x13\x12\x04\x93\n\x08@\n\x10\
    \n\x08\x04\x84\x01\x04\0\x02\x13\x01\x12\x04\x93\n\x08:\n\x10\n\x08\x04\
    \x84\x01\x04\0\x02\x13\x02\x12\x04\x93\n=?\n\x0f\n\x07\x04\x84\x01\x04\0\
    \x02\x14\x12\x04\x94\n\x08:\n\x10\n\x08\x04\x84\x01\x04\0\x02\x14\x01\
    \x12\x04\x94\n\x084\n\x10\n\x08\x04\x84\x01\x04\0\x02\x14\x02\x12\x04\
    \x94\n79\n\x0f\n\x07\x04\x84\x01\x04\0\x02\x15\x12\x04\x95\n\x088\n\x10\
    \n\x08\x04\x84\x01\x04\0\x02\x15\x01\x12\x04\x95\n\x082\n\x10\n\x08\x04\
    \x84\x01\x04\0\x02\x15\x02\x12\x04\x95\n57\n\x0f\n\x07\x04\x84\x01\x04\0\
    \x02\x16\x12\x04\x96\n\x089\n\x10\n\x08\x04\x84\x01\x04\0\x02\x16\x01\
    \x12\x04\x96\n\x083\n\x10\n\x08\x04\x84\x01\x04\0\x02\x16\x02\x12\x04\
    \x96\n68\n\x0f\n\x07\x04\x84\x01\x04\0\x02\x17\x12\x04\x97\n\x08(\n\x10\
    \n\x08\x04\x84\x01\x04\0\x02\x17\x01\x12\x04\x97\n\x08\"\n\x10\n\x08\x04\
    \x84\x01\x04\0\x02\x17\x02\x12\x04\x97\n%'\n\x0f\n\x07\x04\x84\x01\x04\0\
    \x02\x18\x12\x04\x98\n\x081\n\x10\n\x08\x04\x84\x01\x04\0\x02\x18\x01\
    \x12\x04\x98\n\x08+\n\x10\n\x08\x04\x84\x01\x04\0\x02\x18\x02\x12\x04\
    \x98\n.0\n\x0f\n\x07\x04\x84\x01\x04\0\x02\x19\x12\x04\x99\n\x088\n\x10\
    \n\x08\x04\x84\x01\x04\0\x02\x19\x01\x12\x04\x99\n\x082\n\x10\n\x08\x04\
    \x84\x01\x04\0\x02\x19\x02\x12\x04\x99\n57\n\x0f\n\x07\x04\x84\x01\x04\0\
    \x02\x1a\x12\x04\x9a\n\x08>\n\x10\n\x08\x04\x84\x01\x04\0\x02\x1a\x01\
    \x12\x04\x9a\n\x088\n\x10\n\x08\x04\x84\x01\x04\0\x02\x1a\x02\x12\x04\
    \x9a\n;=\n\x0f\n\x07\x04\x84\x01\x04\0\x02\x1b\x12\x04\x9b\n\x088\n\x10\
    \n\x08\x04\x84\x01\x04\0\x02\x1b\x01\x12\x04\x9b\n\x082\n\x10\n\x08\x04\
    \x84\x01\x04\0\x02\x1b\x02\x12\x04\x9b\n57\n\x0f\n\x07\x04\x84\x01\x04\0\
    \x02\x1c\x12\x04\x9c\n\x084\n\x10\n\x08\x04\x84\x01\x04\0\x02\x1c\x01\
    \x12\x04\x9c\n\x08.\n\x10\n\x08\x04\x84\x01\x04\0\x02\x1c\x02\x12\x04\
    \x9c\n13\n\x0f\n\x07\x04\x84\x01\x04\0\x02\x1d\x12\x04\x9d\n\x08,\n\x10\
    \n\x08\x04\x84\x01\x04\0\x02\x1d\x01\x12\x04\x9d\n\x08&\n\x10\n\x08\x04\
    \x84\x01\x04\0\x02\x1d\x02\x12\x04\x9d\n)+\n\x0f\n\x07\x04\x84\x01\x04\0\
    \x02\x1e\x12\x04\x9e\n\x08\x20\n\x10\n\x08\x04\x84\x01\x04\0\x02\x1e\x01\
    \x12\x04\x9e\n\x08\x1a\n\x10\n\x08\x04\x84\x01\x04\0\x02\x1e\x02\x12\x04\
    \x9e\n\x1d\x1f\n\x0f\n\x05\x04\x84\x01\x04\x01\x12\x06\xa1\n\x04\xab\n\
    \x05\n\x0e\n\x06\x04\x84\x01\x04\x01\x01\x12\x04\xa1\n\t\x0e\n\x0f\n\x07\
    \x04\x84\x01\x04\x01\x02\0\x12\x04\xa2\n\x08\x1b\n\x10\n\x08\x04\x84\x01\
    \x04\x01\x02\0\x01\x12\x04\xa2\n\x08\x16\n\x10\n\x08\x04\x84\x01\x04\x01\
    \x02\0\x02\x12\x04\xa2\n\x19\x1a\n\x0f\n\x07\x04\x84\x01\x04\x01\x02\x01\
    \x12\x04\xa3\n\x08\x11\n\x10\n\x08\x04\x84\x01\x04\x01\x02\x01\x01\x12\
    \x04\xa3\n\x08\x0c\n\x10\n\x08\x04\x84\x01\x04\x01\x02\x01\x02\x12\x04\
    \xa3\n\x0f\x10\n\x0f\n\x07\x04\x84\x01\x04\x01\x02\x02\x12\x04\xa4\n\x08\
    \x20\n\x10\n\x08\x04\x84\x01\x04\x01\x02\x02\x01\x12\x04\xa4\n\x08\x1b\n\
    \x10\n\x08\x04\x84\x01\x04\x01\x02\x02\x02\x12\x04\xa4\n\x1e\x1f\n\x0f\n\
    \x07\x04\x84\x01\x04\x01\x02\x03\x12\x04\xa5\n\x08\x1e\n\x10\n\x08\x04\
    \x84\x01\x04\x01\x02\x03\x01\x12\x04\xa5\n\x08\x19\n\x10\n\x08\x04\x84\
    \x01\x04\x01\x02\x03\x02\x12\x04\xa5\n\x1c\x1d\n\x0f\n\x07\x04\x84\x01\
    \x04\x01\x02\x04\x12\x04\xa6\n\x08\x1e\n\x10\n\x08\x04\x84\x01\x04\x01\
    \x02\x04\x01\x12\x04\xa6\n\x08\x19\n\x10\n\x08\x04\x84\x01\x04\x01\x02\
    \x04\x02\x12\x04\xa6\n\x1c\x1d\n\x0f\n\x07\x04\x84\x01\x04\x01\x02\x05\
    \x12\x04\xa7\n\x08\x16\n\x10\n\x08\x04\x84\x01\x04\x01\x02\x05\x01\x12\
    \x04\xa7\n\x08\x11\n\x10\n\x08\x04\x84\x01\x04\x01\x02\x05\x02\x12\x04\
    \xa7\n\x14\x15\n\x0f\n\x07\x04\x84\x01\x04\x01\x02\x06\x12\x04\xa8\n\x08\
    \x1a\n\x10\n\x08\x04\x84\x01\x04\x01\x02\x06\x01\x12\x04\xa8\n\x08\x15\n\
    \x10\n\x08\x04\x84\x01\x04\x01\x02\x06\x02\x12\x04\xa8\n\x18\x19\n\x0f\n\
    \x07\x04\x84\x01\x04\x01\x02\x07\x12\x04\xa9\n\x08\x1d\n\x10\n\x08\x04\
    \x84\x01\x04\x01\x02\x07\x01\x12\x04\xa9\n\x08\x18\n\x10\n\x08\x04\x84\
    \x01\x04\x01\x02\x07\x02\x12\x04\xa9\n\x1b\x1c\n\x0f\n\x07\x04\x84\x01\
    \x04\x01\x02\x08\x12\x04\xaa\n\x08\x16\n\x10\n\x08\x04\x84\x01\x04\x01\
    \x02\x08\x01\x12\x04\xaa\n\x08\x11\n\x10\n\x08\x04\x84\x01\x04\x01\x02\
    \x08\x02\x12\x04\xaa\n\x14\x15\n\x0f\n\x05\x04\x84\x01\x04\x02\x12\x06\
    \xad\n\x04\xb9\n\x05\n\x0e\n\x06\x04\x84\x01\x04\x02\x01\x12\x04\xad\n\t\
    \x15\n\x0f\n\x07\x04\x84\x01\x04\x02\x02\0\x12\x04\xae\n\x08#\n\x10\n\
    \x08\x04\x84\x01\x04\x02\x02\0\x01\x12\x04\xae\n\x08\x1e\n\x10\n\x08\x04\
    \x84\x01\x04\x02\x02\0\x02\x12\x04\xae\n!\"\n\x0f\n\x07\x04\x84\x01\x04\
    \x02\x02\x01\x12\x04\xaf\n\x08\x17\n\x10\n\x08\x04\x84\x01\x04\x02\x02\
    \x01\x01\x12\x04\xaf\n\x08\x12\n\x10\n\x08\x04\x84\x01\x04\x02\x02\x01\
    \x02\x12\x04\xaf\n\x15\x16\n`\n\x07\x04\x84\x01\x04\x02\x02\x02\x12\x04\
    \xb0\n\x08\x1e\"O\x20arbitration\x20\x20We\x20use\x20the\x20enum\x20name\
    \x20for\x20resolving\x20enums\x20so\x20it\x20cannot\x20be\x20renamed\n\n\
    \x10\n\x08\x04\x84\x01\x04\x02\x02\x02\x01\x12\x04\xb0\n\x08\x19\n\x10\n\
    \x08\x04\x84\x01\x04\x02\x02\x02\x02\x12\x04\xb0\n\x1c\x1d\n`\n\x07\x04\
    \x84\x01\x04\x02\x02\x03\x12\x04\xb1\n\x08$\"O\x20arbitration\x20\x20We\
    \x20use\x20the\x20enum\x20name\x20for\x20resolving\x20enums\x20so\x20it\
    \x20cannot\x20be\x20renamed\n\n\x10\n\x08\x04\x84\x01\x04\x02\x02\x03\
    \x01\x12\x04\xb1\n\x08\x1f\n\x10\n\x08\x04\x84\x01\x04\x02\x02\x03\x02\
    \x12\x04\xb1\n\"#\n`\n\x07\x04\x84\x01\x04\x02\x02\x04\x12\x04\xb2\n\x08\
    \x1b\"O\x20arbitration\x20\x20We\x20use\x20the\x20enum\x20name\x20for\
    \x20resolving\x20enums\x20so\x20it\x20cannot\x20be\x20renamed\n\n\x10\n\
    \x08\x04\x84\x01\x04\x02\x02\x04\x01\x12\x04\xb2\n\x08\x16\n\x10\n\x08\
    \x04\x84\x01\x04\x02\x02\x04\x02\x12\x04\xb2\n\x19\x1a\n\x0f\n\x07\x04\
    \x84\x01\x04\x02\x02\x05\x12\x04\xb3\n\x08\x20\n\x10\n\x08\x04\x84\x01\
    \x04\x02\x02\x05\x01\x12\x04\xb3\n\x08\x1b\n\x10\n\x08\x04\x84\x01\x04\
    \x02\x02\x05\x02\x12\x04\xb3\n\x1e\x1f\n\x0f\n\x07\x04\x84\x01\x04\x02\
    \x02\x06\x12\x04\xb4\n\x08&\n\x10\n\x08\x04\x84\x01\x04\x02\x02\x06\x01\
    \x12\x04\xb4\n\x08!\n\x10\n\x08\x04\x84\x01\x04\x02\x02\x06\x02\x12\x04\
    \xb4\n$%\n\x0f\n\x07\x04\x84\x01\x04\x02\x02\x07\x12\x04\xb5\n\x08\x1d\n\
    \x10\n\x08\x04\x84\x01\x04\x02\x02\x07\x01\x12\x04\xb5\n\x08\x18\n\x10\n\
    \x08\x04\x84\x01\x04\x02\x02\x07\x02\x12\x04\xb5\n\x1b\x1c\n\x0f\n\x07\
    \x04\x84\x01\x04\x02\x02\x08\x12\x04\xb6\n\x08\x1d\n\x10\n\x08\x04\x84\
    \x01\x04\x02\x02\x08\x01\x12\x04\xb6\n\x08\x18\n\x10\n\x08\x04\x84\x01\
    \x04\x02\x02\x08\x02\x12\x04\xb6\n\x1b\x1c\n\x0f\n\x07\x04\x84\x01\x04\
    \x02\x02\t\x12\x04\xb7\n\x08+\n\x10\n\x08\x04\x84\x01\x04\x02\x02\t\x01\
    \x12\x04\xb7\n\x08&\n\x10\n\x08\x04\x84\x01\x04\x02\x02\t\x02\x12\x04\
    \xb7\n)*\n\x0f\n\x07\x04\x84\x01\x04\x02\x02\n\x12\x04\xb8\n\x08#\n\x10\
    \n\x08\x04\x84\x01\x04\x02\x02\n\x01\x12\x04\xb8\n\x08\x1d\n\x10\n\x08\
    \x04\x84\x01\x04\x02\x02\n\x02\x12\x04\xb8\n\x20\"\n\x0f\n\x05\x04\x84\
    \x01\x04\x03\x12\x06\xbb\n\x04\xc0\n\x05\n\x0e\n\x06\x04\x84\x01\x04\x03\
    \x01\x12\x04\xbb\n\t\x19\n\x0f\n\x07\x04\x84\x01\x04\x03\x02\0\x12\x04\
    \xbc\n\x08(\n\x10\n\x08\x04\x84\x01\x04\x03\x02\0\x01\x12\x04\xbc\n\x08#\
    \n\x10\n\x08\x04\x84\x01\x04\x03\x02\0\x02\x12\x04\xbc\n&'\n\x0f\n\x07\
    \x04\x84\x01\x04\x03\x02\x01\x12\x04\xbd\n\x08\x17\n\x10\n\x08\x04\x84\
    \x01\x04\x03\x02\x01\x01\x12\x04\xbd\n\x08\x12\n\x10\n\x08\x04\x84\x01\
    \x04\x03\x02\x01\x02\x12\x04\xbd\n\x15\x16\n\x0f\n\x07\x04\x84\x01\x04\
    \x03\x02\x02\x12\x04\xbe\n\x08\x18\n\x10\n\x08\x04\x84\x01\x04\x03\x02\
    \x02\x01\x12\x04\xbe\n\x08\x13\n\x10\n\x08\x04\x84\x01\x04\x03\x02\x02\
    \x02\x12\x04\xbe\n\x16\x17\n\x0f\n\x07\x04\x84\x01\x04\x03\x02\x03\x12\
    \x04\xbf\n\x08\x1e\n\x10\n\x08\x04\x84\x01\x04\x03\x02\x03\x01\x12\x04\
    \xbf\n\x08\x19\n\x10\n\x08\x04\x84\x01\x04\x03\x02\x03\x02\x12\x04\xbf\n\
    \x1c\x1d\n\r\n\x05\x04\x84\x01\x02\0\x12\x04\xc2\n\x04\x14\n\x0e\n\x06\
    \x04\x84\x01\x02\0\x06\x12\x04\xc2\n\x04\t\n\x0e\n\x06\x04\x84\x01\x02\0\
    \x01\x12\x04\xc2\n\n\x0f\n\x0e\n\x06\x04\x84\x01\x02\0\x03\x12\x04\xc2\n\
    \x12\x13\n\r\n\x05\x04\x84\x01\x02\x01\x12\x04\xc3\n\x04#\n\x0e\n\x06\
    \x04\x84\x01\x02\x01\x06\x12\x04\xc3\n\x04\x10\n\x0e\n\x06\x04\x84\x01\
    \x02\x01\x01\x12\x04\xc3\n\x11\x1e\n\x0e\n\x06\x04\x84\x01\x02\x01\x03\
    \x12\x04\xc3\n!\"\n\r\n\x05\x04\x84\x01\x02\x02\x12\x04\xc4\n\x04\x1f\n\
    \x0e\n\x06\x04\x84\x01\x02\x02\x05\x12\x04\xc4\n\x04\n\n\x0e\n\x06\x04\
    \x84\x01\x02\x02\x01\x12\x04\xc4\n\x0b\x1a\n\x0e\n\x06\x04\x84\x01\x02\
    \x02\x03\x12\x04\xc4\n\x1d\x1e\n\r\n\x05\x04\x84\x01\x02\x03\x12\x04\xc5\
    \n\x04\x1d\n\x0e\n\x06\x04\x84\x01\x02\x03\x05\x12\x04\xc5\n\x04\n\n\x0e\
    \n\x06\x04\x84\x01\x02\x03\x01\x12\x04\xc5\n\x0b\x18\n\x0e\n\x06\x04\x84\
    \x01\x02\x03\x03\x12\x04\xc5\n\x1b\x1c\n\r\n\x05\x04\x84\x01\x02\x04\x12\
    \x04\xc6\n\x04\x1c\n\x0e\n\x06\x04\x84\x01\x02\x04\x05\x12\x04\xc6\n\x04\
    \n\n\x0e\n\x06\x04\x84\x01\x02\x04\x01\x12\x04\xc6\n\x0b\x17\n\x0e\n\x06\
    \x04\x84\x01\x02\x04\x03\x12\x04\xc6\n\x1a\x1b\n\r\n\x05\x04\x84\x01\x02\
    \x05\x12\x04\xc7\n\x04#\n\x0e\n\x06\x04\x84\x01\x02\x05\x05\x12\x04\xc7\
    \n\x04\t\n\x0e\n\x06\x04\x84\x01\x02\x05\x01\x12\x04\xc7\n\n\x1e\n\x0e\n\
    \x06\x04\x84\x01\x02\x05\x03\x12\x04\xc7\n!\"\n\r\n\x05\x04\x84\x01\x02\
    \x06\x12\x04\xc8\n\x04\x1d\n\x0e\n\x06\x04\x84\x01\x02\x06\x05\x12\x04\
    \xc8\n\x04\t\n\x0e\n\x06\x04\x84\x01\x02\x06\x01\x12\x04\xc8\n\n\x18\n\
    \x0e\n\x06\x04\x84\x01\x02\x06\x03\x12\x04\xc8\n\x1b\x1c\n\r\n\x05\x04\
    \x84\x01\x02\x07\x12\x04\xc9\n\x04\x20\n\x0e\n\x06\x04\x84\x01\x02\x07\
    \x05\x12\x04\xc9\n\x04\t\n\x0e\n\x06\x04\x84\x01\x02\x07\x01\x12\x04\xc9\
    \n\n\x1b\n\x0e\n\x06\x04\x84\x01\x02\x07\x03\x12\x04\xc9\n\x1e\x1f\n\r\n\
    \x05\x04\x84\x01\x02\x08\x12\x04\xca\n\x04\x1e\n\x0e\n\x06\x04\x84\x01\
    \x02\x08\x05\x12\x04\xca\n\x04\t\n\x0e\n\x06\x04\x84\x01\x02\x08\x01\x12\
    \x04\xca\n\n\x19\n\x0e\n\x06\x04\x84\x01\x02\x08\x03\x12\x04\xca\n\x1c\
    \x1d\n\r\n\x05\x04\x84\x01\x02\t\x12\x04\xcb\n\x04,\n\x0e\n\x06\x04\x84\
    \x01\x02\t\x05\x12\x04\xcb\n\x04\x08\n\x0e\n\x06\x04\x84\x01\x02\t\x01\
    \x12\x04\xcb\n\t&\n\x0e\n\x06\x04\x84\x01\x02\t\x03\x12\x04\xcb\n)+\n\r\
    \n\x05\x04\x84\x01\x02\n\x12\x04\xcc\n\x04\x1b\n\x0e\n\x06\x04\x84\x01\
    \x02\n\x05\x12\x04\xcc\n\x04\t\n\x0e\n\x06\x04\x84\x01\x02\n\x01\x12\x04\
    \xcc\n\n\x15\n\x0e\n\x06\x04\x84\x01\x02\n\x03\x12\x04\xcc\n\x18\x1a\n\r\
    \n\x05\x04\x84\x01\x02\x0b\x12\x04\xcd\n\x04/\n\x0e\n\x06\x04\x84\x01\
    \x02\x0b\x06\x12\x04\xcd\n\x04\x0f\n\x0e\n\x06\x04\x84\x01\x02\x0b\x01\
    \x12\x04\xcd\n\x10)\n\x0e\n\x06\x04\x84\x01\x02\x0b\x03\x12\x04\xcd\n,.\
    \n\r\n\x05\x04\x84\x01\x02\x0c\x12\x04\xce\n\x04\x15\n\x0e\n\x06\x04\x84\
    \x01\x02\x0c\x06\x12\x04\xce\n\x04\t\n\x0e\n\x06\x04\x84\x01\x02\x0c\x01\
    \x12\x04\xce\n\n\x0f\n\x0e\n\x06\x04\x84\x01\x02\x0c\x03\x12\x04\xce\n\
    \x12\x14\n\r\n\x05\x04\x84\x01\x02\r\x12\x04\xcf\n\x04$\n\x0e\n\x06\x04\
    \x84\x01\x02\r\x06\x12\x04\xcf\n\x04\x10\n\x0e\n\x06\x04\x84\x01\x02\r\
    \x01\x12\x04\xcf\n\x11\x1e\n\x0e\n\x06\x04\x84\x01\x02\r\x03\x12\x04\xcf\
    \n!#\n\r\n\x05\x04\x84\x01\x02\x0e\x12\x04\xd0\n\x04-\n\x0e\n\x06\x04\
    \x84\x01\x02\x0e\x06\x12\x04\xd0\n\x04\x14\n\x0e\n\x06\x04\x84\x01\x02\
    \x0e\x01\x12\x04\xd0\n\x15'\n\x0e\n\x06\x04\x84\x01\x02\x0e\x03\x12\x04\
    \xd0\n*,\n\r\n\x05\x04\x84\x01\x02\x0f\x12\x04\xd1\n\x04\x1b\n\x0e\n\x06\
    \x04\x84\x01\x02\x0f\x06\x12\x04\xd1\n\x04\x0c\n\x0e\n\x06\x04\x84\x01\
    \x02\x0f\x01\x12\x04\xd1\n\r\x15\n\x0e\n\x06\x04\x84\x01\x02\x0f\x03\x12\
    \x04\xd1\n\x18\x1a\n\r\n\x05\x04\x84\x01\x02\x10\x12\x04\xd2\n\x04!\n\
    \x0e\n\x06\x04\x84\x01\x02\x10\x05\x12\x04\xd2\n\x04\n\n\x0e\n\x06\x04\
    \x84\x01\x02\x10\x01\x12\x04\xd2\n\x0b\x1b\n\x0e\n\x06\x04\x84\x01\x02\
    \x10\x03\x12\x04\xd2\n\x1e\x20\n\r\n\x05\x04\x84\x01\x02\x11\x12\x04\xd3\
    \n\x04\x1d\n\x0e\n\x06\x04\x84\x01\x02\x11\x05\x12\x04\xd3\n\x04\t\n\x0e\
    \n\x06\x04\x84\x01\x02\x11\x01\x12\x04\xd3\n\n\x17\n\x0e\n\x06\x04\x84\
    \x01\x02\x11\x03\x12\x04\xd3\n\x1a\x1c\n\r\n\x05\x04\x84\x01\x02\x12\x12\
    \x04\xd4\n\x04)\n\x0e\n\x06\x04\x84\x01\x02\x12\x05\x12\x04\xd4\n\x04\n\
    \n\x0e\n\x06\x04\x84\x01\x02\x12\x01\x12\x04\xd4\n\x0b#\n\x0e\n\x06\x04\
    \x84\x01\x02\x12\x03\x12\x04\xd4\n&(\n\r\n\x05\x04\x84\x01\x02\x13\x12\
    \x04\xd5\n\x04)\n\x0e\n\x06\x04\x84\x01\x02\x13\x05\x12\x04\xd5\n\x04\n\
    \n\x0e\n\x06\x04\x84\x01\x02\x13\x01\x12\x04\xd5\n\x0b#\n\x0e\n\x06\x04\
    \x84\x01\x02\x13\x03\x12\x04\xd5\n&(\n\r\n\x05\x04\x84\x01\x02\x14\x12\
    \x04\xd6\n\x04-\n\x0e\n\x06\x04\x84\x01\x02\x14\x06\x12\x04\xd6\n\x04\
    \x0f\n\x0e\n\x06\x04\x84\x01\x02\x14\x01\x12\x04\xd6\n\x10'\n\x0e\n\x06\
    \x04\x84\x01\x02\x14\x03\x12\x04\xd6\n*,\n\r\n\x05\x04\x84\x01\x02\x15\
    \x12\x04\xd7\n\x04+\n\x0e\n\x06\x04\x84\x01\x02\x15\x06\x12\x04\xd7\n\
    \x04\x0f\n\x0e\n\x06\x04\x84\x01\x02\x15\x01\x12\x04\xd7\n\x10%\n\x0e\n\
    \x06\x04\x84\x01\x02\x15\x03\x12\x04\xd7\n(*\n\r\n\x05\x04\x84\x01\x02\
    \x16\x12\x04\xd8\n\x04&\n\x0e\n\x06\x04\x84\x01\x02\x16\x05\x12\x04\xd8\
    \n\x04\t\n\x0e\n\x06\x04\x84\x01\x02\x16\x01\x12\x04\xd8\n\n\x20\n\x0e\n\
    \x06\x04\x84\x01\x02\x16\x03\x12\x04\xd8\n#%\n\r\n\x05\x04\x84\x01\x02\
    \x17\x12\x04\xd9\n\x04)\n\x0e\n\x06\x04\x84\x01\x02\x17\x05\x12\x04\xd9\
    \n\x04\n\n\x0e\n\x06\x04\x84\x01\x02\x17\x01\x12\x04\xd9\n\x0b#\n\x0e\n\
    \x06\x04\x84\x01\x02\x17\x03\x12\x04\xd9\n&(\n\r\n\x05\x04\x84\x01\x02\
    \x18\x12\x04\xda\n\x04\x1e\n\x0e\n\x06\x04\x84\x01\x02\x18\x05\x12\x04\
    \xda\n\x04\n\n\x0e\n\x06\x04\x84\x01\x02\x18\x01\x12\x04\xda\n\x0b\x18\n\
    \x0e\n\x06\x04\x84\x01\x02\x18\x03\x12\x04\xda\n\x1b\x1d\n\r\n\x05\x04\
    \x84\x01\x02\x19\x12\x04\xdb\n\x04,\n\x0e\n\x06\x04\x84\x01\x02\x19\x06\
    \x12\x04\xdb\n\x04\x0e\n\x0e\n\x06\x04\x84\x01\x02\x19\x01\x12\x04\xdb\n\
    \x0f&\n\x0e\n\x06\x04\x84\x01\x02\x19\x03\x12\x04\xdb\n)+\n\r\n\x05\x04\
    \x84\x01\x02\x1a\x12\x04\xdc\n\x04*\n\x0e\n\x06\x04\x84\x01\x02\x1a\x06\
    \x12\x04\xdc\n\x04\x0e\n\x0e\n\x06\x04\x84\x01\x02\x1a\x01\x12\x04\xdc\n\
    \x0f$\n\x0e\n\x06\x04\x84\x01\x02\x1a\x03\x12\x04\xdc\n')\n\r\n\x05\x04\
    \x84\x01\x02\x1b\x12\x04\xdd\n\x04'\n\x0e\n\x06\x04\x84\x01\x02\x1b\x05\
    \x12\x04\xdd\n\x04\n\n\x0e\n\x06\x04\x84\x01\x02\x1b\x01\x12\x04\xdd\n\
    \x0b!\n\x0e\n\x06\x04\x84\x01\x02\x1b\x03\x12\x04\xdd\n$&\n\r\n\x05\x04\
    \x84\x01\x02\x1c\x12\x04\xde\n\x04+\n\x0e\n\x06\x04\x84\x01\x02\x1c\x04\
    \x12\x04\xde\n\x04\x0c\n\x0e\n\x06\x04\x84\x01\x02\x1c\x06\x12\x04\xde\n\
    \r\x18\n\x0e\n\x06\x04\x84\x01\x02\x1c\x01\x12\x04\xde\n\x19%\n\x0e\n\
    \x06\x04\x84\x01\x02\x1c\x03\x12\x04\xde\n(*\n\r\n\x05\x04\x84\x01\x02\
    \x1d\x12\x04\xdf\n\x045\n\x0e\n\x06\x04\x84\x01\x02\x1d\x06\x12\x04\xdf\
    \n\x04\x18\n\x0e\n\x06\x04\x84\x01\x02\x1d\x01\x12\x04\xdf\n\x19/\n\x0e\
    \n\x06\x04\x84\x01\x02\x1d\x03\x12\x04\xdf\n24\n\r\n\x05\x04\x84\x01\x02\
    \x1e\x12\x04\xe0\n\x04\x19\n\x0e\n\x06\x04\x84\x01\x02\x1e\x05\x12\x04\
    \xe0\n\x04\t\n\x0e\n\x06\x04\x84\x01\x02\x1e\x01\x12\x04\xe0\n\n\x13\n\
    \x0e\n\x06\x04\x84\x01\x02\x1e\x03\x12\x04\xe0\n\x16\x18\n\r\n\x05\x04\
    \x84\x01\x02\x1f\x12\x04\xe1\n\x04'\n\x0e\n\x06\x04\x84\x01\x02\x1f\x05\
    \x12\x04\xe1\n\x04\t\n\x0e\n\x06\x04\x84\x01\x02\x1f\x01\x12\x04\xe1\n\n\
    !\n\x0e\n\x06\x04\x84\x01\x02\x1f\x03\x12\x04\xe1\n$&\n\r\n\x05\x04\x84\
    \x01\x02\x20\x12\x04\xe2\n\x04/\n\x0e\n\x06\x04\x84\x01\x02\x20\x06\x12\
    \x04\xe2\n\x04\x0f\n\x0e\n\x06\x04\x84\x01\x02\x20\x01\x12\x04\xe2\n\x10\
    )\n\x0e\n\x06\x04\x84\x01\x02\x20\x03\x12\x04\xe2\n,.\n\r\n\x05\x04\x84\
    \x01\x02!\x12\x04\xe3\n\x04.\n\x0e\n\x06\x04\x84\x01\x02!\x06\x12\x04\
    \xe3\n\x04\x0e\n\x0e\n\x06\x04\x84\x01\x02!\x01\x12\x04\xe3\n\x0f(\n\x0e\
    \n\x06\x04\x84\x01\x02!\x03\x12\x04\xe3\n+-\n\r\n\x05\x04\x84\x01\x02\"\
    \x12\x04\xe4\n\x04/\n\x0e\n\x06\x04\x84\x01\x02\"\x06\x12\x04\xe4\n\x04\
    \x15\n\x0e\n\x06\x04\x84\x01\x02\"\x01\x12\x04\xe4\n\x16)\n\x0e\n\x06\
    \x04\x84\x01\x02\"\x03\x12\x04\xe4\n,.\n\r\n\x03\x04\x85\x01\x12\x06\xe7\
    \n\0\xe9\n\x01\n\x0c\n\x04\x04\x85\x01\x01\x12\x04\xe7\n\x08\x19\n\r\n\
    \x05\x04\x85\x01\x02\0\x12\x04\xe8\n\x04\x14\n\x0e\n\x06\x04\x85\x01\x02\
    \0\x06\x12\x04\xe8\n\x04\t\n\x0e\n\x06\x04\x85\x01\x02\0\x01\x12\x04\xe8\
    \n\n\x0f\n\x0e\n\x06\x04\x85\x01\x02\0\x03\x12\x04\xe8\n\x12\x13\n\r\n\
    \x03\x04\x86\x01\x12\x06\xeb\n\0\xed\n\x01\n\x0c\n\x04\x04\x86\x01\x01\
    \x12\x04\xeb\n\x08\x19\n\r\n\x05\x04\x86\x01\x02\0\x12\x04\xec\n\x04\x14\
    \n\x0e\n\x06\x04\x86\x01\x02\0\x06\x12\x04\xec\n\x04\t\n\x0e\n\x06\x04\
    \x86\x01\x02\0\x01\x12\x04\xec\n\n\x0f\n\x0e\n\x06\x04\x86\x01\x02\0\x03\
    \x12\x04\xec\n\x12\x13\n\r\n\x03\x04\x87\x01\x12\x06\xef\n\0\xf1\n\x01\n\
    \x0c\n\x04\x04\x87\x01\x01\x12\x04\xef\n\x08\x1a\n\r\n\x05\x04\x87\x01\
    \x02\0\x12\x04\xf0\n\x04\x14\n\x0e\n\x06\x04\x87\x01\x02\0\x06\x12\x04\
    \xf0\n\x04\t\n\x0e\n\x06\x04\x87\x01\x02\0\x01\x12\x04\xf0\n\n\x0f\n\x0e\
    \n\x06\x04\x87\x01\x02\0\x03\x12\x04\xf0\n\x12\x13\n\r\n\x03\x04\x88\x01\
    \x12\x06\xf3\n\0\xf5\n\x01\n\x0c\n\x04\x04\x88\x01\x01\x12\x04\xf3\n\x08\
    \x1a\n\r\n\x05\x04\x88\x01\x02\0\x12\x04\xf4\n\x04\x14\n\x0e\n\x06\x04\
    \x88\x01\x02\0\x06\x12\x04\xf4\n\x04\t\n\x0e\n\x06\x04\x88\x01\x02\0\x01\
    \x12\x04\xf4\n\n\x0f\n\x0e\n\x06\x04\x88\x01\x02\0\x03\x12\x04\xf4\n\x12\
    \x13\n\r\n\x03\x04\x89\x01\x12\x06\xf7\n\0\x8c\x0b\x01\n\x0c\n\x04\x04\
    \x89\x01\x01\x12\x04\xf7\n\x08\x14\n\r\n\x05\x04\x89\x01\x02\0\x12\x04\
    \xf8\n\x04!\n\x0e\n\x06\x04\x89\x01\x02\0\x06\x12\x04\xf8\n\x04\x0f\n\
    \x0e\n\x06\x04\x89\x01\x02\0\x01\x12\x04\xf8\n\x10\x1c\n\x0e\n\x06\x04\
    \x89\x01\x02\0\x03\x12\x04\xf8\n\x1f\x20\n\r\n\x05\x04\x89\x01\x02\x01\
    \x12\x04\xf9\n\x04\x18\n\x0e\n\x06\x04\x89\x01\x02\x01\x05\x12\x04\xf9\n\
    \x04\n\n\x0e\n\x06\x04\x89\x01\x02\x01\x01\x12\x04\xf9\n\x0b\x13\n\x0e\n\
    \x06\x04\x89\x01\x02\x01\x03\x12\x04\xf9\n\x16\x17\n\r\n\x05\x04\x89\x01\
    \x02\x02\x12\x04\xfa\n\x04\x1a\n\x0e\n\x06\x04\x89\x01\x02\x02\x05\x12\
    \x04\xfa\n\x04\n\n\x0e\n\x06\x04\x89\x01\x02\x02\x01\x12\x04\xfa\n\x0b\
    \x15\n\x0e\n\x06\x04\x89\x01\x02\x02\x03\x12\x04\xfa\n\x18\x19\n\r\n\x05\
    \x04\x89\x01\x02\x03\x12\x04\xfb\n\x04\x20\n\x0e\n\x06\x04\x89\x01\x02\
    \x03\x06\x12\x04\xfb\n\x04\x0e\n\x0e\n\x06\x04\x89\x01\x02\x03\x01\x12\
    \x04\xfb\n\x0f\x1b\n\x0e\n\x06\x04\x89\x01\x02\x03\x03\x12\x04\xfb\n\x1e\
    \x1f\n\r\n\x05\x04\x89\x01\x02\x04\x12\x04\xfc\n\x04$\n\x0e\n\x06\x04\
    \x89\x01\x02\x04\x05\x12\x04\xfc\n\x04\n\n\x0e\n\x06\x04\x89\x01\x02\x04\
    \x01\x12\x04\xfc\n\x0b\x1f\n\x0e\n\x06\x04\x89\x01\x02\x04\x03\x12\x04\
    \xfc\n\"#\n\r\n\x05\x04\x89\x01\x02\x05\x12\x04\xfd\n\x04\"\n\x0e\n\x06\
    \x04\x89\x01\x02\x05\x05\x12\x04\xfd\n\x04\t\n\x0e\n\x06\x04\x89\x01\x02\
    \x05\x01\x12\x04\xfd\n\n\x1d\n\x0e\n\x06\x04\x89\x01\x02\x05\x03\x12\x04\
    \xfd\n\x20!\n\x20\n\x04\x04\x89\x01\t\x12\x04\xfe\n\x04\x0f\"\x12\x20Not\
    \x20used\x20anymore\n\n\r\n\x05\x04\x89\x01\t\0\x12\x04\xfe\n\r\x0e\n\
    \x0e\n\x06\x04\x89\x01\t\0\x01\x12\x04\xfe\n\r\x0e\n\x0e\n\x06\x04\x89\
    \x01\t\0\x02\x12\x04\xfe\n\r\x0e\n\x20\n\x04\x04\x89\x01\t\x12\x04\xff\n\
    \x04\x0f\"\x12\x20Not\x20used\x20anymore\n\n\r\n\x05\x04\x89\x01\t\x01\
    \x12\x04\xff\n\r\x0e\n\x0e\n\x06\x04\x89\x01\t\x01\x01\x12\x04\xff\n\r\
    \x0e\n\x0e\n\x06\x04\x89\x01\t\x01\x02\x12\x04\xff\n\r\x0e\n\r\n\x05\x04\
    \x89\x01\x02\x06\x12\x04\x80\x0b\x04\"\n\x0e\n\x06\x04\x89\x01\x02\x06\
    \x05\x12\x04\x80\x0b\x04\t\n\x0e\n\x06\x04\x89\x01\x02\x06\x01\x12\x04\
    \x80\x0b\n\x1d\n\x0e\n\x06\x04\x89\x01\x02\x06\x03\x12\x04\x80\x0b\x20!\
    \n\r\n\x05\x04\x89\x01\x02\x07\x12\x04\x81\x0b\x04=\n\x0e\n\x06\x04\x89\
    \x01\x02\x07\x04\x12\x04\x81\x0b\x04\x0c\n\x0e\n\x06\x04\x89\x01\x02\x07\
    \x06\x12\x04\x81\x0b\r\x20\n\x0e\n\x06\x04\x89\x01\x02\x07\x01\x12\x04\
    \x81\x0b!7\n\x0e\n\x06\x04\x89\x01\x02\x07\x03\x12\x04\x81\x0b:<\n\r\n\
    \x05\x04\x89\x01\x02\x08\x12\x04\x82\x0b\x04#\n\x0e\n\x06\x04\x89\x01\
    \x02\x08\x05\x12\x04\x82\x0b\x04\t\n\x0e\n\x06\x04\x89\x01\x02\x08\x01\
    \x12\x04\x82\x0b\n\x1d\n\x0e\n\x06\x04\x89\x01\x02\x08\x03\x12\x04\x82\
    \x0b\x20\"\n\r\n\x05\x04\x89\x01\x02\t\x12\x04\x83\x0b\x04&\n\x0e\n\x06\
    \x04\x89\x01\x02\t\x05\x12\x04\x83\x0b\x04\n\n\x0e\n\x06\x04\x89\x01\x02\
    \t\x01\x12\x04\x83\x0b\x0b\x20\n\x0e\n\x06\x04\x89\x01\x02\t\x03\x12\x04\
    \x83\x0b#%\n\r\n\x05\x04\x89\x01\x02\n\x12\x04\x84\x0b\x04!\n\x0e\n\x06\
    \x04\x89\x01\x02\n\x05\x12\x04\x84\x0b\x04\x08\n\x0e\n\x06\x04\x89\x01\
    \x02\n\x01\x12\x04\x84\x0b\t\x1b\n\x0e\n\x06\x04\x89\x01\x02\n\x03\x12\
    \x04\x84\x0b\x1e\x20\n\r\n\x05\x04\x89\x01\x02\x0b\x12\x04\x85\x0b\x04.\
    \n\x0e\n\x06\x04\x89\x01\x02\x0b\x05\x12\x04\x85\x0b\x04\t\n\x0e\n\x06\
    \x04\x89\x01\x02\x0b\x01\x12\x04\x85\x0b\n(\n\x0e\n\x06\x04\x89\x01\x02\
    \x0b\x03\x12\x04\x85\x0b+-\n\r\n\x05\x04\x89\x01\x02\x0c\x12\x04\x86\x0b\
    \x04$\n\x0e\n\x06\x04\x89\x01\x02\x0c\x05\x12\x04\x86\x0b\x04\t\n\x0e\n\
    \x06\x04\x89\x01\x02\x0c\x01\x12\x04\x86\x0b\n\x1e\n\x0e\n\x06\x04\x89\
    \x01\x02\x0c\x03\x12\x04\x86\x0b!#\n\r\n\x05\x04\x89\x01\x02\r\x12\x04\
    \x87\x0b\x044\n\x0e\n\x06\x04\x89\x01\x02\r\x06\x12\x04\x87\x0b\x04\x0f\
    \n\x0e\n\x06\x04\x89\x01\x02\r\x01\x12\x04\x87\x0b\x10.\n\x0e\n\x06\x04\
    \x89\x01\x02\r\x03\x12\x04\x87\x0b13\n\r\n\x05\x04\x89\x01\x02\x0e\x12\
    \x04\x88\x0b\x04.\n\x0e\n\x06\x04\x89\x01\x02\x0e\x05\x12\x04\x88\x0b\
    \x04\n\n\x0e\n\x06\x04\x89\x01\x02\x0e\x01\x12\x04\x88\x0b\x0b(\n\x0e\n\
    \x06\x04\x89\x01\x02\x0e\x03\x12\x04\x88\x0b+-\n\r\n\x05\x04\x89\x01\x02\
    \x0f\x12\x04\x89\x0b\x04,\n\x0e\n\x06\x04\x89\x01\x02\x0f\x05\x12\x04\
    \x89\x0b\x04\t\n\x0e\n\x06\x04\x89\x01\x02\x0f\x01\x12\x04\x89\x0b\n&\n\
    \x0e\n\x06\x04\x89\x01\x02\x0f\x03\x12\x04\x89\x0b)+\n\r\n\x05\x04\x89\
    \x01\x02\x10\x12\x04\x8a\x0b\x042\n\x0e\n\x06\x04\x89\x01\x02\x10\x05\
    \x12\x04\x8a\x0b\x04\t\n\x0e\n\x06\x04\x89\x01\x02\x10\x01\x12\x04\x8a\
    \x0b\n,\n\x0e\n\x06\x04\x89\x01\x02\x10\x03\x12\x04\x8a\x0b/1\n\r\n\x05\
    \x04\x89\x01\x02\x11\x12\x04\x8b\x0b\x043\n\x0e\n\x06\x04\x89\x01\x02\
    \x11\x05\x12\x04\x8b\x0b\x04\t\n\x0e\n\x06\x04\x89\x01\x02\x11\x01\x12\
    \x04\x8b\x0b\n-\n\x0e\n\x06\x04\x89\x01\x02\x11\x03\x12\x04\x8b\x0b02\n\
    \r\n\x03\x04\x8a\x01\x12\x06\x8e\x0b\0\x9e\x0b\x01\n\x0c\n\x04\x04\x8a\
    \x01\x01\x12\x04\x8e\x0b\x08\x13\n\r\n\x05\x04\x8a\x01\x02\0\x12\x04\x8f\
    \x0b\x04\x1a\n\x0e\n\x06\x04\x8a\x01\x02\0\x05\x12\x04\x8f\x0b\x04\n\n\
    \x0e\n\x06\x04\x8a\x01\x02\0\x01\x12\x04\x8f\x0b\x0b\x15\n\x0e\n\x06\x04\
    \x8a\x01\x02\0\x03\x12\x04\x8f\x0b\x18\x19\n\r\n\x05\x04\x8a\x01\x02\x01\
    \x12\x04\x90\x0b\x046\n\x0e\n\x06\x04\x8a\x01\x02\x01\x06\x12\x04\x90\
    \x0b\x04\x19\n\x0e\n\x06\x04\x8a\x01\x02\x01\x01\x12\x04\x90\x0b\x1a1\n\
    \x0e\n\x06\x04\x8a\x01\x02\x01\x03\x12\x04\x90\x0b45\n\r\n\x05\x04\x8a\
    \x01\x02\x02\x12\x04\x91\x0b\x04%\n\x0e\n\x06\x04\x8a\x01\x02\x02\x05\
    \x12\x04\x91\x0b\x04\n\n\x0e\n\x06\x04\x8a\x01\x02\x02\x01\x12\x04\x91\
    \x0b\x0b\x20\n\x0e\n\x06\x04\x8a\x01\x02\x02\x03\x12\x04\x91\x0b#$\n\r\n\
    \x05\x04\x8a\x01\x02\x03\x12\x04\x92\x0b\x04\x20\n\x0e\n\x06\x04\x8a\x01\
    \x02\x03\x05\x12\x04\x92\x0b\x04\n\n\x0e\n\x06\x04\x8a\x01\x02\x03\x01\
    \x12\x04\x92\x0b\x0b\x1b\n\x0e\n\x06\x04\x8a\x01\x02\x03\x03\x12\x04\x92\
    \x0b\x1e\x1f\n\r\n\x05\x04\x8a\x01\x02\x04\x12\x04\x93\x0b\x04\"\n\x0e\n\
    \x06\x04\x8a\x01\x02\x04\x05\x12\x04\x93\x0b\x04\n\n\x0e\n\x06\x04\x8a\
    \x01\x02\x04\x01\x12\x04\x93\x0b\x0b\x1d\n\x0e\n\x06\x04\x8a\x01\x02\x04\
    \x03\x12\x04\x93\x0b\x20!\n\r\n\x05\x04\x8a\x01\x02\x05\x12\x04\x94\x0b\
    \x04\x18\n\x0e\n\x06\x04\x8a\x01\x02\x05\x05\x12\x04\x94\x0b\x04\t\n\x0e\
    \n\x06\x04\x8a\x01\x02\x05\x01\x12\x04\x94\x0b\n\x13\n\x0e\n\x06\x04\x8a\
    \x01\x02\x05\x03\x12\x04\x94\x0b\x16\x17\n\r\n\x05\x04\x8a\x01\x02\x06\
    \x12\x04\x95\x0b\x04\x20\n\x0e\n\x06\x04\x8a\x01\x02\x06\x06\x12\x04\x95\
    \x0b\x04\x0e\n\x0e\n\x06\x04\x8a\x01\x02\x06\x01\x12\x04\x95\x0b\x0f\x1b\
    \n\x0e\n\x06\x04\x8a\x01\x02\x06\x03\x12\x04\x95\x0b\x1e\x1f\n\r\n\x05\
    \x04\x8a\x01\x02\x07\x12\x04\x96\x0b\x04\x20\n\x0e\n\x06\x04\x8a\x01\x02\
    \x07\x05\x12\x04\x96\x0b\x04\t\n\x0e\n\x06\x04\x8a\x01\x02\x07\x01\x12\
    \x04\x96\x0b\n\x1b\n\x0e\n\x06\x04\x8a\x01\x02\x07\x03\x12\x04\x96\x0b\
    \x1e\x1f\n\r\n\x05\x04\x8a\x01\x02\x08\x12\x04\x97\x0b\x04<\n\x0e\n\x06\
    \x04\x8a\x01\x02\x08\x04\x12\x04\x97\x0b\x04\x0c\n\x0e\n\x06\x04\x8a\x01\
    \x02\x08\x06\x12\x04\x97\x0b\r\x20\n\x0e\n\x06\x04\x8a\x01\x02\x08\x01\
    \x12\x04\x97\x0b!7\n\x0e\n\x06\x04\x8a\x01\x02\x08\x03\x12\x04\x97\x0b:;\
    \n\r\n\x05\x04\x8a\x01\x02\t\x12\x04\x98\x0b\x04#\n\x0e\n\x06\x04\x8a\
    \x01\x02\t\x05\x12\x04\x98\x0b\x04\t\n\x0e\n\x06\x04\x8a\x01\x02\t\x01\
    \x12\x04\x98\x0b\n\x1d\n\x0e\n\x06\x04\x8a\x01\x02\t\x03\x12\x04\x98\x0b\
    \x20\"\n\r\n\x05\x04\x8a\x01\x02\n\x12\x04\x99\x0b\x04&\n\x0e\n\x06\x04\
    \x8a\x01\x02\n\x05\x12\x04\x99\x0b\x04\n\n\x0e\n\x06\x04\x8a\x01\x02\n\
    \x01\x12\x04\x99\x0b\x0b\x20\n\x0e\n\x06\x04\x8a\x01\x02\n\x03\x12\x04\
    \x99\x0b#%\n\r\n\x05\x04\x8a\x01\x02\x0b\x12\x04\x9a\x0b\x04)\n\x0e\n\
    \x06\x04\x8a\x01\x02\x0b\x05\x12\x04\x9a\x0b\x04\t\n\x0e\n\x06\x04\x8a\
    \x01\x02\x0b\x01\x12\x04\x9a\x0b\n#\n\x0e\n\x06\x04\x8a\x01\x02\x0b\x03\
    \x12\x04\x9a\x0b&(\n\r\n\x05\x04\x8a\x01\x02\x0c\x12\x04\x9b\x0b\x04-\n\
    \x0e\n\x06\x04\x8a\x01\x02\x0c\x05\x12\x04\x9b\x0b\x04\t\n\x0e\n\x06\x04\
    \x8a\x01\x02\x0c\x01\x12\x04\x9b\x0b\n'\n\x0e\n\x06\x04\x8a\x01\x02\x0c\
    \x03\x12\x04\x9b\x0b*,\n\r\n\x05\x04\x8a\x01\x02\r\x12\x04\x9c\x0b\x04\
    \x1c\n\x0e\n\x06\x04\x8a\x01\x02\r\x05\x12\x04\x9c\x0b\x04\t\n\x0e\n\x06\
    \x04\x8a\x01\x02\r\x01\x12\x04\x9c\x0b\n\x16\n\x0e\n\x06\x04\x8a\x01\x02\
    \r\x03\x12\x04\x9c\x0b\x19\x1b\n\r\n\x05\x04\x8a\x01\x02\x0e\x12\x04\x9d\
    \x0b\x04,\n\x0e\n\x06\x04\x8a\x01\x02\x0e\x05\x12\x04\x9d\x0b\x04\t\n\
    \x0e\n\x06\x04\x8a\x01\x02\x0e\x01\x12\x04\x9d\x0b\n&\n\x0e\n\x06\x04\
    \x8a\x01\x02\x0e\x03\x12\x04\x9d\x0b)+\n\xcd\x01\n\x03\x04\x8b\x01\x12\
    \x06\xa4\x0b\0\xa6\x0b\x012\xbd\x01/////////////////////////////////////\
    ////////////////////////////////////////////////////\n\x20Dispute\n/////\
    ////////////////////////////////////////////////////////////////////////\
    ////////////\n\n\x0c\n\x04\x04\x8b\x01\x01\x12\x04\xa4\x0b\x08\x1e\n\r\n\
    \x05\x04\x8b\x01\x02\0\x12\x04\xa5\x0b\x04!\n\x0e\n\x06\x04\x8b\x01\x02\
    \0\x04\x12\x04\xa5\x0b\x04\x0c\n\x0e\n\x06\x04\x8b\x01\x02\0\x06\x12\x04\
    \xa5\x0b\r\x14\n\x0e\n\x06\x04\x8b\x01\x02\0\x01\x12\x04\xa5\x0b\x15\x1c\
    \n\x0e\n\x06\x04\x8b\x01\x02\0\x03\x12\x04\xa5\x0b\x1f\x20\n\r\n\x03\x04\
    \x8c\x01\x12\x06\xa8\x0b\0\xaa\x0b\x01\n\x0c\n\x04\x04\x8c\x01\x01\x12\
    \x04\xa8\x0b\x08\x1c\n\r\n\x05\x04\x8c\x01\x02\0\x12\x04\xa9\x0b\x04!\n\
    \x0e\n\x06\x04\x8c\x01\x02\0\x04\x12\x04\xa9\x0b\x04\x0c\n\x0e\n\x06\x04\
    \x8c\x01\x02\0\x06\x12\x04\xa9\x0b\r\x14\n\x0e\n\x06\x04\x8c\x01\x02\0\
    \x01\x12\x04\xa9\x0b\x15\x1c\n\x0e\n\x06\x04\x8c\x01\x02\0\x03\x12\x04\
    \xa9\x0b\x1f\x20\n\r\n\x03\x04\x8d\x01\x12\x06\xac\x0b\0\xae\x0b\x01\n\
    \x0c\n\x04\x04\x8d\x01\x01\x12\x04\xac\x0b\x08\x19\n\r\n\x05\x04\x8d\x01\
    \x02\0\x12\x04\xad\x0b\x04!\n\x0e\n\x06\x04\x8d\x01\x02\0\x04\x12\x04\
    \xad\x0b\x04\x0c\n\x0e\n\x06\x04\x8d\x01\x02\0\x06\x12\x04\xad\x0b\r\x14\
    \n\x0e\n\x06\x04\x8d\x01\x02\0\x01\x12\x04\xad\x0b\x15\x1c\n\x0e\n\x06\
    \x04\x8d\x01\x02\0\x03\x12\x04\xad\x0b\x1f\x20\n\x0c\n\x02\x05\x02\x12\
    \x06\xb0\x0b\0\xc1\x0b\x01\n\x0b\n\x03\x05\x02\x01\x12\x04\xb0\x0b\x05\
    \x19\n\x0c\n\x04\x05\x02\x02\0\x12\x04\xb1\x0b\x04\"\n\r\n\x05\x05\x02\
    \x02\0\x01\x12\x04\xb1\x0b\x04\x1d\n\r\n\x05\x05\x02\x02\0\x02\x12\x04\
    \xb1\x0b\x20!\n\x0c\n\x04\x05\x02\x02\x01\x12\x04\xb2\x0b\x04#\n\r\n\x05\
    \x05\x02\x02\x01\x01\x12\x04\xb2\x0b\x04\x1e\n\r\n\x05\x05\x02\x02\x01\
    \x02\x12\x04\xb2\x0b!\"\n\x0c\n\x04\x05\x02\x02\x02\x12\x04\xb3\x0b\x04\
    \"\n\r\n\x05\x05\x02\x02\x02\x01\x12\x04\xb3\x0b\x04\x1d\n\r\n\x05\x05\
    \x02\x02\x02\x02\x12\x04\xb3\x0b\x20!\n\x0c\n\x04\x05\x02\x02\x03\x12\
    \x04\xb4\x0b\x04\"\n\r\n\x05\x05\x02\x02\x03\x01\x12\x04\xb4\x0b\x04\x1d\
    \n\r\n\x05\x05\x02\x02\x03\x02\x12\x04\xb4\x0b\x20!\n\x0c\n\x04\x05\x02\
    \x02\x04\x12\x04\xb5\x0b\x04\x15\n\r\n\x05\x05\x02\x02\x04\x01\x12\x04\
    \xb5\x0b\x04\x10\n\r\n\x05\x05\x02\x02\x04\x02\x12\x04\xb5\x0b\x13\x14\n\
    \x0c\n\x04\x05\x02\x02\x05\x12\x04\xb6\x0b\x04\x18\n\r\n\x05\x05\x02\x02\
    \x05\x01\x12\x04\xb6\x0b\x04\x13\n\r\n\x05\x05\x02\x02\x05\x02\x12\x04\
    \xb6\x0b\x16\x17\n\x0c\n\x04\x05\x02\x02\x06\x12\x04\xb7\x0b\x04\x1b\n\r\
    \n\x05\x05\x02\x02\x06\x01\x12\x04\xb7\x0b\x04\x16\n\r\n\x05\x05\x02\x02\
    \x06\x02\x12\x04\xb7\x0b\x19\x1a\n\x0c\n\x04\x05\x02\x02\x07\x12\x04\xb8\
    \x0b\x04\x1c\n\r\n\x05\x05\x02\x02\x07\x01\x12\x04\xb8\x0b\x04\x17\n\r\n\
    \x05\x05\x02\x02\x07\x02\x12\x04\xb8\x0b\x1a\x1b\n\x0c\n\x04\x05\x02\x02\
    \x08\x12\x04\xb9\x0b\x04\x19\n\r\n\x05\x05\x02\x02\x08\x01\x12\x04\xb9\
    \x0b\x04\x14\n\r\n\x05\x05\x02\x02\x08\x02\x12\x04\xb9\x0b\x17\x18\n\x0c\
    \n\x04\x05\x02\x02\t\x12\x04\xba\x0b\x04\x1c\n\r\n\x05\x05\x02\x02\t\x01\
    \x12\x04\xba\x0b\x04\x17\n\r\n\x05\x05\x02\x02\t\x02\x12\x04\xba\x0b\x1a\
    \x1b\n\x0c\n\x04\x05\x02\x02\n\x12\x04\xbb\x0b\x04&\n\r\n\x05\x05\x02\
    \x02\n\x01\x12\x04\xbb\x0b\x04\x20\n\r\n\x05\x05\x02\x02\n\x02\x12\x04\
    \xbb\x0b#%\n\x0c\n\x04\x05\x02\x02\x0b\x12\x04\xbc\x0b\x04)\n\r\n\x05\
    \x05\x02\x02\x0b\x01\x12\x04\xbc\x0b\x04#\n\r\n\x05\x05\x02\x02\x0b\x02\
    \x12\x04\xbc\x0b&(\n\x0c\n\x04\x05\x02\x02\x0c\x12\x04\xbd\x0b\x04,\n\r\
    \n\x05\x05\x02\x02\x0c\x01\x12\x04\xbd\x0b\x04&\n\r\n\x05\x05\x02\x02\
    \x0c\x02\x12\x04\xbd\x0b)+\n\x0c\n\x04\x05\x02\x02\r\x12\x04\xbe\x0b\x04\
    -\n\r\n\x05\x05\x02\x02\r\x01\x12\x04\xbe\x0b\x04'\n\r\n\x05\x05\x02\x02\
    \r\x02\x12\x04\xbe\x0b*,\n\x0c\n\x04\x05\x02\x02\x0e\x12\x04\xbf\x0b\x04\
    *\n\r\n\x05\x05\x02\x02\x0e\x01\x12\x04\xbf\x0b\x04$\n\r\n\x05\x05\x02\
    \x02\x0e\x02\x12\x04\xbf\x0b')\n\x0c\n\x04\x05\x02\x02\x0f\x12\x04\xc0\
    \x0b\x04#\n\r\n\x05\x05\x02\x02\x0f\x01\x12\x04\xc0\x0b\x04\x1d\n\r\n\
    \x05\x05\x02\x02\x0f\x02\x12\x04\xc0\x0b\x20\"\n\x13\n\x02\x05\x03\x12\
    \x06\xc4\x0b\0\xc7\x0b\x01\x1a\x05todo\n\n\x0b\n\x03\x05\x03\x01\x12\x04\
    \xc4\x0b\x05\x16\n\x0c\n\x04\x05\x03\x02\0\x12\x04\xc5\x0b\x04\x1f\n\r\n\
    \x05\x05\x03\x02\0\x01\x12\x04\xc5\x0b\x04\x1a\n\r\n\x05\x05\x03\x02\0\
    \x02\x12\x04\xc5\x0b\x1d\x1e\n\x0c\n\x04\x05\x03\x02\x01\x12\x04\xc6\x0b\
    \x04\x20\n\r\n\x05\x05\x03\x02\x01\x01\x12\x04\xc6\x0b\x04\x1b\n\r\n\x05\
    \x05\x03\x02\x01\x02\x12\x04\xc6\x0b\x1e\x1f\n\xd1\x01\n\x03\x04\x8e\x01\
    \x12\x06\xcd\x0b\0\x85\x0c\x012\xc1\x01/////////////////////////////////\
    ////////////////////////////////////////////////////////\n\x20Preference\
    s\n/////////////////////////////////////////////////////////////////////\
    ////////////////////\n\n\x0c\n\x04\x04\x8e\x01\x01\x12\x04\xcd\x0b\x08\
    \x1a\n\r\n\x05\x04\x8e\x01\x02\0\x12\x04\xce\x0b\x04\x1d\n\x0e\n\x06\x04\
    \x8e\x01\x02\0\x05\x12\x04\xce\x0b\x04\n\n\x0e\n\x06\x04\x8e\x01\x02\0\
    \x01\x12\x04\xce\x0b\x0b\x18\n\x0e\n\x06\x04\x8e\x01\x02\0\x03\x12\x04\
    \xce\x0b\x1b\x1c\n\r\n\x05\x04\x8e\x01\x02\x01\x12\x04\xcf\x0b\x04\x1d\n\
    \x0e\n\x06\x04\x8e\x01\x02\x01\x06\x12\x04\xcf\x0b\x04\x0b\n\x0e\n\x06\
    \x04\x8e\x01\x02\x01\x01\x12\x04\xcf\x0b\x0c\x18\n\x0e\n\x06\x04\x8e\x01\
    \x02\x01\x03\x12\x04\xcf\x0b\x1b\x1c\n\r\n\x05\x04\x8e\x01\x02\x02\x12\
    \x04\xd0\x0b\x04/\n\x0e\n\x06\x04\x8e\x01\x02\x02\x04\x12\x04\xd0\x0b\
    \x04\x0c\n\x0e\n\x06\x04\x8e\x01\x02\x02\x06\x12\x04\xd0\x0b\r\x1a\n\x0e\
    \n\x06\x04\x8e\x01\x02\x02\x01\x12\x04\xd0\x0b\x1b*\n\x0e\n\x06\x04\x8e\
    \x01\x02\x02\x03\x12\x04\xd0\x0b-.\n\r\n\x05\x04\x8e\x01\x02\x03\x12\x04\
    \xd1\x0b\x041\n\x0e\n\x06\x04\x8e\x01\x02\x03\x04\x12\x04\xd1\x0b\x04\
    \x0c\n\x0e\n\x06\x04\x8e\x01\x02\x03\x06\x12\x04\xd1\x0b\r\x1a\n\x0e\n\
    \x06\x04\x8e\x01\x02\x03\x01\x12\x04\xd1\x0b\x1b,\n\x0e\n\x06\x04\x8e\
    \x01\x02\x03\x03\x12\x04\xd1\x0b/0\n\r\n\x05\x04\x8e\x01\x02\x04\x12\x04\
    \xd2\x0b\x049\n\x0e\n\x06\x04\x8e\x01\x02\x04\x06\x12\x04\xd2\x0b\x04\
    \x16\n\x0e\n\x06\x04\x8e\x01\x02\x04\x01\x12\x04\xd2\x0b\x174\n\x0e\n\
    \x06\x04\x8e\x01\x02\x04\x03\x12\x04\xd2\x0b78\n\r\n\x05\x04\x8e\x01\x02\
    \x05\x12\x04\xd3\x0b\x049\n\x0e\n\x06\x04\x8e\x01\x02\x05\x06\x12\x04\
    \xd3\x0b\x04\x16\n\x0e\n\x06\x04\x8e\x01\x02\x05\x01\x12\x04\xd3\x0b\x17\
    4\n\x0e\n\x06\x04\x8e\x01\x02\x05\x03\x12\x04\xd3\x0b78\n\r\n\x05\x04\
    \x8e\x01\x02\x06\x12\x04\xd4\x0b\x044\n\x0e\n\x06\x04\x8e\x01\x02\x06\
    \x06\x12\x04\xd4\x0b\x04\x16\n\x0e\n\x06\x04\x8e\x01\x02\x06\x01\x12\x04\
    \xd4\x0b\x17/\n\x0e\n\x06\x04\x8e\x01\x02\x06\x03\x12\x04\xd4\x0b23\n\r\
    \n\x05\x04\x8e\x01\x02\x07\x12\x04\xd5\x0b\x04\x20\n\x0e\n\x06\x04\x8e\
    \x01\x02\x07\x05\x12\x04\xd5\x0b\x04\n\n\x0e\n\x06\x04\x8e\x01\x02\x07\
    \x01\x12\x04\xd5\x0b\x0b\x1b\n\x0e\n\x06\x04\x8e\x01\x02\x07\x03\x12\x04\
    \xd5\x0b\x1e\x1f\n\r\n\x05\x04\x8e\x01\x02\x08\x12\x04\xd6\x0b\x04%\n\
    \x0e\n\x06\x04\x8e\x01\x02\x08\x05\x12\x04\xd6\x0b\x04\x08\n\x0e\n\x06\
    \x04\x8e\x01\x02\x08\x01\x12\x04\xd6\x0b\t\x20\n\x0e\n\x06\x04\x8e\x01\
    \x02\x08\x03\x12\x04\xd6\x0b#$\n\r\n\x05\x04\x8e\x01\x02\t\x12\x04\xd7\
    \x0b\x04/\n\x0e\n\x06\x04\x8e\x01\x02\t\x06\x12\x04\xd7\x0b\x04\x15\n\
    \x0e\n\x06\x04\x8e\x01\x02\t\x01\x12\x04\xd7\x0b\x16)\n\x0e\n\x06\x04\
    \x8e\x01\x02\t\x03\x12\x04\xd7\x0b,.\n\r\n\x05\x04\x8e\x01\x02\n\x12\x04\
    \xd8\x0b\x04\x1b\n\x0e\n\x06\x04\x8e\x01\x02\n\x05\x12\x04\xd8\x0b\x04\
    \x08\n\x0e\n\x06\x04\x8e\x01\x02\n\x01\x12\x04\xd8\x0b\t\x15\n\x0e\n\x06\
    \x04\x8e\x01\x02\n\x03\x12\x04\xd8\x0b\x18\x1a\n\r\n\x05\x04\x8e\x01\x02\
    \x0b\x12\x04\xd9\x0b\x04$\n\x0e\n\x06\x04\x8e\x01\x02\x0b\x05\x12\x04\
    \xd9\x0b\x04\x08\n\x0e\n\x06\x04\x8e\x01\x02\x0b\x01\x12\x04\xd9\x0b\t\
    \x1e\n\x0e\n\x06\x04\x8e\x01\x02\x0b\x03\x12\x04\xd9\x0b!#\n\r\n\x05\x04\
    \x8e\x01\x02\x0c\x12\x04\xda\x0b\x04,\n\x0e\n\x06\x04\x8e\x01\x02\x0c\
    \x05\x12\x04\xda\x0b\x04\x08\n\x0e\n\x06\x04\x8e\x01\x02\x0c\x01\x12\x04\
    \xda\x0b\t&\n\x0e\n\x06\x04\x8e\x01\x02\x0c\x03\x12\x04\xda\x0b)+\n\r\n\
    \x05\x04\x8e\x01\x02\r\x12\x04\xdb\x0b\x040\n\x0e\n\x06\x04\x8e\x01\x02\
    \r\x06\x12\x04\xdb\x0b\x04\x11\n\x0e\n\x06\x04\x8e\x01\x02\r\x01\x12\x04\
    \xdb\x0b\x12*\n\x0e\n\x06\x04\x8e\x01\x02\r\x03\x12\x04\xdb\x0b-/\n\r\n\
    \x05\x04\x8e\x01\x02\x0e\x12\x04\xdc\x0b\x04*\n\x0e\n\x06\x04\x8e\x01\
    \x02\x0e\x05\x12\x04\xdc\x0b\x04\t\n\x0e\n\x06\x04\x8e\x01\x02\x0e\x01\
    \x12\x04\xdc\x0b\n$\n\x0e\n\x06\x04\x8e\x01\x02\x0e\x03\x12\x04\xdc\x0b'\
    )\n\r\n\x05\x04\x8e\x01\x02\x0f\x12\x04\xdd\x0b\x04+\n\x0e\n\x06\x04\x8e\
    \x01\x02\x0f\x05\x12\x04\xdd\x0b\x04\x08\n\x0e\n\x06\x04\x8e\x01\x02\x0f\
    \x01\x12\x04\xdd\x0b\t%\n\x0e\n\x06\x04\x8e\x01\x02\x0f\x03\x12\x04\xdd\
    \x0b(*\n\r\n\x05\x04\x8e\x01\x02\x10\x12\x04\xde\x0b\x04.\n\x0e\n\x06\
    \x04\x8e\x01\x02\x10\x05\x12\x04\xde\x0b\x04\n\n\x0e\n\x06\x04\x8e\x01\
    \x02\x10\x01\x12\x04\xde\x0b\x0b(\n\x0e\n\x06\x04\x8e\x01\x02\x10\x03\
    \x12\x04\xde\x0b+-\n\r\n\x05\x04\x8e\x01\x02\x11\x12\x04\xdf\x0b\x046\n\
    \x0e\n\x06\x04\x8e\x01\x02\x11\x05\x12\x04\xdf\x0b\x04\n\n\x0e\n\x06\x04\
    \x8e\x01\x02\x11\x01\x12\x04\xdf\x0b\x0b0\n\x0e\n\x06\x04\x8e\x01\x02\
    \x11\x03\x12\x04\xdf\x0b35\n\r\n\x05\x04\x8e\x01\x02\x12\x12\x04\xe0\x0b\
    \x042\n\x0e\n\x06\x04\x8e\x01\x02\x12\x05\x12\x04\xe0\x0b\x04\n\n\x0e\n\
    \x06\x04\x8e\x01\x02\x12\x01\x12\x04\xe0\x0b\x0b,\n\x0e\n\x06\x04\x8e\
    \x01\x02\x12\x03\x12\x04\xe0\x0b/1\n\r\n\x05\x04\x8e\x01\x02\x13\x12\x04\
    \xe1\x0b\x04)\n\x0e\n\x06\x04\x8e\x01\x02\x13\x05\x12\x04\xe1\x0b\x04\n\
    \n\x0e\n\x06\x04\x8e\x01\x02\x13\x01\x12\x04\xe1\x0b\x0b#\n\x0e\n\x06\
    \x04\x8e\x01\x02\x13\x03\x12\x04\xe1\x0b&(\n\r\n\x05\x04\x8e\x01\x02\x14\
    \x12\x04\xe2\x0b\x04*\n\x0e\n\x06\x04\x8e\x01\x02\x14\x05\x12\x04\xe2\
    \x0b\x04\n\n\x0e\n\x06\x04\x8e\x01\x02\x14\x01\x12\x04\xe2\x0b\x0b$\n\
    \x0e\n\x06\x04\x8e\x01\x02\x14\x03\x12\x04\xe2\x0b')\n\r\n\x05\x04\x8e\
    \x01\x02\x15\x12\x04\xe3\x0b\x040\n\x0e\n\x06\x04\x8e\x01\x02\x15\x05\
    \x12\x04\xe3\x0b\x04\t\n\x0e\n\x06\x04\x8e\x01\x02\x15\x01\x12\x04\xe3\
    \x0b\n*\n\x0e\n\x06\x04\x8e\x01\x02\x15\x03\x12\x04\xe3\x0b-/\n\r\n\x05\
    \x04\x8e\x01\x02\x16\x12\x04\xe4\x0b\x04#\n\x0e\n\x06\x04\x8e\x01\x02\
    \x16\x05\x12\x04\xe4\x0b\x04\x08\n\x0e\n\x06\x04\x8e\x01\x02\x16\x01\x12\
    \x04\xe4\x0b\t\x1d\n\x0e\n\x06\x04\x8e\x01\x02\x16\x03\x12\x04\xe4\x0b\
    \x20\"\n\r\n\x05\x04\x8e\x01\x02\x17\x12\x04\xe5\x0b\x041\n\x0e\n\x06\
    \x04\x8e\x01\x02\x17\x05\x12\x04\xe5\x0b\x04\x08\n\x0e\n\x06\x04\x8e\x01\
    \x02\x17\x01\x12\x04\xe5\x0b\t+\n\x0e\n\x06\x04\x8e\x01\x02\x17\x03\x12\
    \x04\xe5\x0b.0\n\r\n\x05\x04\x8e\x01\x02\x18\x12\x04\xe6\x0b\x04)\n\x0e\
    \n\x06\x04\x8e\x01\x02\x18\x05\x12\x04\xe6\x0b\x04\x08\n\x0e\n\x06\x04\
    \x8e\x01\x02\x18\x01\x12\x04\xe6\x0b\t#\n\x0e\n\x06\x04\x8e\x01\x02\x18\
    \x03\x12\x04\xe6\x0b&(\n\r\n\x05\x04\x8e\x01\x02\x19\x12\x04\xe7\x0b\x04\
    *\n\x0e\n\x06\x04\x8e\x01\x02\x19\x06\x12\x04\xe7\x0b\x04\x17\n\x0e\n\
    \x06\x04\x8e\x01\x02\x19\x01\x12\x04\xe7\x0b\x18$\n\x0e\n\x06\x04\x8e\
    \x01\x02\x19\x03\x12\x04\xe7\x0b')\n\r\n\x05\x04\x8e\x01\x02\x1a\x12\x04\
    \xe8\x0b\x04\x1e\n\x0e\n\x06\x04\x8e\x01\x02\x1a\x05\x12\x04\xe8\x0b\x04\
    \n\n\x0e\n\x06\x04\x8e\x01\x02\x1a\x01\x12\x04\xe8\x0b\x0b\x18\n\x0e\n\
    \x06\x04\x8e\x01\x02\x1a\x03\x12\x04\xe8\x0b\x1b\x1d\n\r\n\x05\x04\x8e\
    \x01\x02\x1b\x12\x04\xe9\x0b\x04-\n\x0e\n\x06\x04\x8e\x01\x02\x1b\x04\
    \x12\x04\xe9\x0b\x04\x0c\n\x0e\n\x06\x04\x8e\x01\x02\x1b\x05\x12\x04\xe9\
    \x0b\r\x13\n\x0e\n\x06\x04\x8e\x01\x02\x1b\x01\x12\x04\xe9\x0b\x14'\n\
    \x0e\n\x06\x04\x8e\x01\x02\x1b\x03\x12\x04\xe9\x0b*,\n\r\n\x05\x04\x8e\
    \x01\x02\x1c\x12\x04\xea\x0b\x04'\n\x0e\n\x06\x04\x8e\x01\x02\x1c\x05\
    \x12\x04\xea\x0b\x04\n\n\x0e\n\x06\x04\x8e\x01\x02\x1c\x01\x12\x04\xea\
    \x0b\x0b!\n\x0e\n\x06\x04\x8e\x01\x02\x1c\x03\x12\x04\xea\x0b$&\n<\n\x05\
    \x04\x8e\x01\x02\x1d\x12\x04\xeb\x0b\x04B\"-\x20Superseded\x20by\x20buye\
    rSecurityDepositAsPercent\n\n\x0e\n\x06\x04\x8e\x01\x02\x1d\x05\x12\x04\
    \xeb\x0b\x04\t\n\x0e\n\x06\x04\x8e\x01\x02\x1d\x01\x12\x04\xeb\x0b\n(\n\
    \x0e\n\x06\x04\x8e\x01\x02\x1d\x03\x12\x04\xeb\x0b+-\n\x0e\n\x06\x04\x8e\
    \x01\x02\x1d\x08\x12\x04\xeb\x0b.A\n\x0f\n\x07\x04\x8e\x01\x02\x1d\x08\
    \x03\x12\x04\xeb\x0b/@\n\r\n\x05\x04\x8e\x01\x02\x1e\x12\x04\xec\x0b\x04\
    \x1d\n\x0e\n\x06\x04\x8e\x01\x02\x1e\x05\x12\x04\xec\x0b\x04\x08\n\x0e\n\
    \x06\x04\x8e\x01\x02\x1e\x01\x12\x04\xec\x0b\t\x17\n\x0e\n\x06\x04\x8e\
    \x01\x02\x1e\x03\x12\x04\xec\x0b\x1a\x1c\n\r\n\x05\x04\x8e\x01\x02\x1f\
    \x12\x04\xed\x0b\x04@\n\x0e\n\x06\x04\x8e\x01\x02\x1f\x06\x12\x04\xed\
    \x0b\x04\x12\n\x0e\n\x06\x04\x8e\x01\x02\x1f\x01\x12\x04\xed\x0b\x13:\n\
    \x0e\n\x06\x04\x8e\x01\x02\x1f\x03\x12\x04\xed\x0b=?\n\r\n\x05\x04\x8e\
    \x01\x02\x20\x12\x04\xee\x0b\x04\x1d\n\x0e\n\x06\x04\x8e\x01\x02\x20\x05\
    \x12\x04\xee\x0b\x04\x08\n\x0e\n\x06\x04\x8e\x01\x02\x20\x01\x12\x04\xee\
    \x0b\t\x17\n\x0e\n\x06\x04\x8e\x01\x02\x20\x03\x12\x04\xee\x0b\x1a\x1c\n\
    \r\n\x05\x04\x8e\x01\x02!\x12\x04\xef\x0b\x04*\n\x0e\n\x06\x04\x8e\x01\
    \x02!\x04\x12\x04\xef\x0b\x04\x0c\n\x0e\n\x06\x04\x8e\x01\x02!\x05\x12\
    \x04\xef\x0b\r\x13\n\x0e\n\x06\x04\x8e\x01\x02!\x01\x12\x04\xef\x0b\x14$\
    \n\x0e\n\x06\x04\x8e\x01\x02!\x03\x12\x04\xef\x0b')\n\r\n\x05\x04\x8e\
    \x01\x02\"\x12\x04\xf0\x0b\x04%\n\x0e\n\x06\x04\x8e\x01\x02\"\x05\x12\
    \x04\xf0\x0b\x04\t\n\x0e\n\x06\x04\x8e\x01\x02\"\x01\x12\x04\xf0\x0b\n\
    \x1f\n\x0e\n\x06\x04\x8e\x01\x02\"\x03\x12\x04\xf0\x0b\"$\n\r\n\x05\x04\
    \x8e\x01\x02#\x12\x04\xf1\x0b\x04%\n\x0e\n\x06\x04\x8e\x01\x02#\x05\x12\
    \x04\xf1\x0b\x04\t\n\x0e\n\x06\x04\x8e\x01\x02#\x01\x12\x04\xf1\x0b\n\
    \x1f\n\x0e\n\x06\x04\x8e\x01\x02#\x03\x12\x04\xf1\x0b\"$\n\r\n\x05\x04\
    \x8e\x01\x02$\x12\x04\xf2\x0b\x04\x1f\n\x0e\n\x06\x04\x8e\x01\x02$\x05\
    \x12\x04\xf2\x0b\x04\n\n\x0e\n\x06\x04\x8e\x01\x02$\x01\x12\x04\xf2\x0b\
    \x0b\x19\n\x0e\n\x06\x04\x8e\x01\x02$\x03\x12\x04\xf2\x0b\x1c\x1e\n\r\n\
    \x05\x04\x8e\x01\x02%\x12\x04\xf3\x0b\x04,\n\x0e\n\x06\x04\x8e\x01\x02%\
    \x05\x12\x04\xf3\x0b\x04\t\n\x0e\n\x06\x04\x8e\x01\x02%\x01\x12\x04\xf3\
    \x0b\n&\n\x0e\n\x06\x04\x8e\x01\x02%\x03\x12\x04\xf3\x0b)+\n\r\n\x05\x04\
    \x8e\x01\x02&\x12\x04\xf4\x0b\x04\x1c\n\x0e\n\x06\x04\x8e\x01\x02&\x05\
    \x12\x04\xf4\x0b\x04\n\n\x0e\n\x06\x04\x8e\x01\x02&\x01\x12\x04\xf4\x0b\
    \x0b\x16\n\x0e\n\x06\x04\x8e\x01\x02&\x03\x12\x04\xf4\x0b\x19\x1b\n\r\n\
    \x05\x04\x8e\x01\x02'\x12\x04\xf5\x0b\x04$\n\x0e\n\x06\x04\x8e\x01\x02'\
    \x05\x12\x04\xf5\x0b\x04\n\n\x0e\n\x06\x04\x8e\x01\x02'\x01\x12\x04\xf5\
    \x0b\x0b\x1e\n\x0e\n\x06\x04\x8e\x01\x02'\x03\x12\x04\xf5\x0b!#\n\r\n\
    \x05\x04\x8e\x01\x02(\x12\x04\xf6\x0b\x041\n\x0e\n\x06\x04\x8e\x01\x02(\
    \x05\x12\x04\xf6\x0b\x04\x08\n\x0e\n\x06\x04\x8e\x01\x02(\x01\x12\x04\
    \xf6\x0b\t+\n\x0e\n\x06\x04\x8e\x01\x02(\x03\x12\x04\xf6\x0b.0\n\r\n\x05\
    \x04\x8e\x01\x02)\x12\x04\xf7\x0b\x04&\n\x0e\n\x06\x04\x8e\x01\x02)\x05\
    \x12\x04\xf7\x0b\x04\x08\n\x0e\n\x06\x04\x8e\x01\x02)\x01\x12\x04\xf7\
    \x0b\t\x20\n\x0e\n\x06\x04\x8e\x01\x02)\x03\x12\x04\xf7\x0b#%\n\r\n\x05\
    \x04\x8e\x01\x02*\x12\x04\xf8\x0b\x04'\n\x0e\n\x06\x04\x8e\x01\x02*\x05\
    \x12\x04\xf8\x0b\x04\x08\n\x0e\n\x06\x04\x8e\x01\x02*\x01\x12\x04\xf8\
    \x0b\t!\n\x0e\n\x06\x04\x8e\x01\x02*\x03\x12\x04\xf8\x0b$&\n\r\n\x05\x04\
    \x8e\x01\x02+\x12\x04\xf9\x0b\x04&\n\x0e\n\x06\x04\x8e\x01\x02+\x05\x12\
    \x04\xf9\x0b\x04\x08\n\x0e\n\x06\x04\x8e\x01\x02+\x01\x12\x04\xf9\x0b\t\
    \x20\n\x0e\n\x06\x04\x8e\x01\x02+\x03\x12\x04\xf9\x0b#%\n\r\n\x05\x04\
    \x8e\x01\x02,\x12\x04\xfa\x0b\x04\x1f\n\x0e\n\x06\x04\x8e\x01\x02,\x05\
    \x12\x04\xfa\x0b\x04\x08\n\x0e\n\x06\x04\x8e\x01\x02,\x01\x12\x04\xfa\
    \x0b\t\x19\n\x0e\n\x06\x04\x8e\x01\x02,\x03\x12\x04\xfa\x0b\x1c\x1e\n\r\
    \n\x05\x04\x8e\x01\x02-\x12\x04\xfb\x0b\x04\x1f\n\x0e\n\x06\x04\x8e\x01\
    \x02-\x05\x12\x04\xfb\x0b\x04\x08\n\x0e\n\x06\x04\x8e\x01\x02-\x01\x12\
    \x04\xfb\x0b\t\x19\n\x0e\n\x06\x04\x8e\x01\x02-\x03\x12\x04\xfb\x0b\x1c\
    \x1e\n\r\n\x05\x04\x8e\x01\x02.\x12\x04\xfc\x0b\x04\x19\n\x0e\n\x06\x04\
    \x8e\x01\x02.\x05\x12\x04\xfc\x0b\x04\n\n\x0e\n\x06\x04\x8e\x01\x02.\x01\
    \x12\x04\xfc\x0b\x0b\x13\n\x0e\n\x06\x04\x8e\x01\x02.\x03\x12\x04\xfc\
    \x0b\x16\x18\n\r\n\x05\x04\x8e\x01\x02/\x12\x04\xfd\x0b\x04\x17\n\x0e\n\
    \x06\x04\x8e\x01\x02/\x05\x12\x04\xfd\x0b\x04\n\n\x0e\n\x06\x04\x8e\x01\
    \x02/\x01\x12\x04\xfd\x0b\x0b\x11\n\x0e\n\x06\x04\x8e\x01\x02/\x03\x12\
    \x04\xfd\x0b\x14\x16\n\r\n\x05\x04\x8e\x01\x020\x12\x04\xfe\x0b\x047\n\
    \x0e\n\x06\x04\x8e\x01\x020\x05\x12\x04\xfe\x0b\x04\n\n\x0e\n\x06\x04\
    \x8e\x01\x020\x01\x12\x04\xfe\x0b\x0b1\n\x0e\n\x06\x04\x8e\x01\x020\x03\
    \x12\x04\xfe\x0b46\n\r\n\x05\x04\x8e\x01\x021\x12\x04\xff\x0b\x042\n\x0e\
    \n\x06\x04\x8e\x01\x021\x05\x12\x04\xff\x0b\x04\n\n\x0e\n\x06\x04\x8e\
    \x01\x021\x01\x12\x04\xff\x0b\x0b,\n\x0e\n\x06\x04\x8e\x01\x021\x03\x12\
    \x04\xff\x0b/1\n\r\n\x05\x04\x8e\x01\x022\x12\x04\x80\x0c\x04%\n\x0e\n\
    \x06\x04\x8e\x01\x022\x05\x12\x04\x80\x0c\x04\t\n\x0e\n\x06\x04\x8e\x01\
    \x022\x01\x12\x04\x80\x0c\n\x1f\n\x0e\n\x06\x04\x8e\x01\x022\x03\x12\x04\
    \x80\x0c\"$\n\r\n\x05\x04\x8e\x01\x023\x12\x04\x81\x0c\x04=\n\x0e\n\x06\
    \x04\x8e\x01\x023\x05\x12\x04\x81\x0c\x04\n\n\x0e\n\x06\x04\x8e\x01\x023\
    \x01\x12\x04\x81\x0c\x0b7\n\x0e\n\x06\x04\x8e\x01\x023\x03\x12\x04\x81\
    \x0c:<\n\r\n\x05\x04\x8e\x01\x024\x12\x04\x82\x0c\x04!\n\x0e\n\x06\x04\
    \x8e\x01\x024\x05\x12\x04\x82\x0c\x04\t\n\x0e\n\x06\x04\x8e\x01\x024\x01\
    \x12\x04\x82\x0c\n\x1b\n\x0e\n\x06\x04\x8e\x01\x024\x03\x12\x04\x82\x0c\
    \x1e\x20\n\r\n\x05\x04\x8e\x01\x025\x12\x04\x83\x0c\x04\x19\n\x0e\n\x06\
    \x04\x8e\x01\x025\x05\x12\x04\x83\x0c\x04\t\n\x0e\n\x06\x04\x8e\x01\x025\
    \x01\x12\x04\x83\x0c\n\x13\n\x0e\n\x06\x04\x8e\x01\x025\x03\x12\x04\x83\
    \x0c\x16\x18\n\r\n\x05\x04\x8e\x01\x026\x12\x04\x84\x0c\x04\x20\n\x0e\n\
    \x06\x04\x8e\x01\x026\x05\x12\x04\x84\x0c\x04\x08\n\x0e\n\x06\x04\x8e\
    \x01\x026\x01\x12\x04\x84\x0c\t\x1a\n\x0e\n\x06\x04\x8e\x01\x026\x03\x12\
    \x04\x84\x0c\x1d\x1f\n\xd1\x01\n\x03\x04\x8f\x01\x12\x06\x8b\x0c\0\x9b\
    \x0c\x012\xc1\x01///////////////////////////////////////////////////////\
    //////////////////////////////////\n\x20UserPayload\n///////////////////\
    //////////////////////////////////////////////////////////////////////\n\
    \n\x0c\n\x04\x04\x8f\x01\x01\x12\x04\x8b\x0c\x08\x13\n\r\n\x05\x04\x8f\
    \x01\x02\0\x12\x04\x8c\x0c\x04\x1a\n\x0e\n\x06\x04\x8f\x01\x02\0\x05\x12\
    \x04\x8c\x0c\x04\n\n\x0e\n\x06\x04\x8f\x01\x02\0\x01\x12\x04\x8c\x0c\x0b\
    \x15\n\x0e\n\x06\x04\x8f\x01\x02\0\x03\x12\x04\x8c\x0c\x18\x19\n\r\n\x05\
    \x04\x8f\x01\x02\x01\x12\x04\x8d\x0c\x041\n\x0e\n\x06\x04\x8f\x01\x02\
    \x01\x04\x12\x04\x8d\x0c\x04\x0c\n\x0e\n\x06\x04\x8f\x01\x02\x01\x06\x12\
    \x04\x8d\x0c\r\x1b\n\x0e\n\x06\x04\x8f\x01\x02\x01\x01\x12\x04\x8d\x0c\
    \x1c,\n\x0e\n\x06\x04\x8f\x01\x02\x01\x03\x12\x04\x8d\x0c/0\n\r\n\x05\
    \x04\x8f\x01\x02\x02\x12\x04\x8e\x0c\x04/\n\x0e\n\x06\x04\x8f\x01\x02\
    \x02\x06\x12\x04\x8e\x0c\x04\x12\n\x0e\n\x06\x04\x8f\x01\x02\x02\x01\x12\
    \x04\x8e\x0c\x13*\n\x0e\n\x06\x04\x8f\x01\x02\x02\x03\x12\x04\x8e\x0c-.\
    \n\r\n\x05\x04\x8f\x01\x02\x03\x12\x04\x8f\x0c\x047\n\x0e\n\x06\x04\x8f\
    \x01\x02\x03\x04\x12\x04\x8f\x0c\x04\x0c\n\x0e\n\x06\x04\x8f\x01\x02\x03\
    \x05\x12\x04\x8f\x0c\r\x13\n\x0e\n\x06\x04\x8f\x01\x02\x03\x01\x12\x04\
    \x8f\x0c\x142\n\x0e\n\x06\x04\x8f\x01\x02\x03\x03\x12\x04\x8f\x0c56\n\r\
    \n\x05\x04\x8f\x01\x02\x04\x12\x04\x90\x0c\x04\x1f\n\x0e\n\x06\x04\x8f\
    \x01\x02\x04\x06\x12\x04\x90\x0c\x04\t\n\x0e\n\x06\x04\x8f\x01\x02\x04\
    \x01\x12\x04\x90\x0c\n\x1a\n\x0e\n\x06\x04\x8f\x01\x02\x04\x03\x12\x04\
    \x90\x0c\x1d\x1e\n\r\n\x05\x04\x8f\x01\x02\x05\x12\x04\x91\x0c\x04\x1e\n\
    \x0e\n\x06\x04\x8f\x01\x02\x05\x06\x12\x04\x91\x0c\x04\t\n\x0e\n\x06\x04\
    \x8f\x01\x02\x05\x01\x12\x04\x91\x0c\n\x19\n\x0e\n\x06\x04\x8f\x01\x02\
    \x05\x03\x12\x04\x91\x0c\x1c\x1d\n\r\n\x05\x04\x8f\x01\x02\x06\x12\x04\
    \x92\x0c\x04!\n\x0e\n\x06\x04\x8f\x01\x02\x06\x06\x12\x04\x92\x0c\x04\n\
    \n\x0e\n\x06\x04\x8f\x01\x02\x06\x01\x12\x04\x92\x0c\x0b\x1c\n\x0e\n\x06\
    \x04\x8f\x01\x02\x06\x03\x12\x04\x92\x0c\x1f\x20\n\r\n\x05\x04\x8f\x01\
    \x02\x07\x12\x04\x93\x0c\x041\n\x0e\n\x06\x04\x8f\x01\x02\x07\x04\x12\
    \x04\x93\x0c\x04\x0c\n\x0e\n\x06\x04\x8f\x01\x02\x07\x06\x12\x04\x93\x0c\
    \r\x17\n\x0e\n\x06\x04\x8f\x01\x02\x07\x01\x12\x04\x93\x0c\x18,\n\x0e\n\
    \x06\x04\x8f\x01\x02\x07\x03\x12\x04\x93\x0c/0\n\r\n\x05\x04\x8f\x01\x02\
    \x08\x12\x04\x94\x0c\x04-\n\x0e\n\x06\x04\x8f\x01\x02\x08\x04\x12\x04\
    \x94\x0c\x04\x0c\n\x0e\n\x06\x04\x8f\x01\x02\x08\x06\x12\x04\x94\x0c\r\
    \x15\n\x0e\n\x06\x04\x8f\x01\x02\x08\x01\x12\x04\x94\x0c\x16(\n\x0e\n\
    \x06\x04\x8f\x01\x02\x08\x03\x12\x04\x94\x0c+,\n\r\n\x05\x04\x8f\x01\x02\
    \t\x12\x04\x95\x0c\x04*\n\x0e\n\x06\x04\x8f\x01\x02\t\x06\x12\x04\x95\
    \x0c\x04\x0e\n\x0e\n\x06\x04\x8f\x01\x02\t\x01\x12\x04\x95\x0c\x0f$\n\
    \x0e\n\x06\x04\x8f\x01\x02\t\x03\x12\x04\x95\x0c')\n\r\n\x05\x04\x8f\x01\
    \x02\n\x12\x04\x96\x0c\x04&\n\x0e\n\x06\x04\x8f\x01\x02\n\x06\x12\x04\
    \x96\x0c\x04\x0c\n\x0e\n\x06\x04\x8f\x01\x02\n\x01\x12\x04\x96\x0c\r\x20\
    \n\x0e\n\x06\x04\x8f\x01\x02\n\x03\x12\x04\x96\x0c#%\n\r\n\x05\x04\x8f\
    \x01\x02\x0b\x12\x04\x97\x0c\x04-\n\x0e\n\x06\x04\x8f\x01\x02\x0b\x06\
    \x12\x04\x97\x0c\x04\x14\n\x0e\n\x06\x04\x8f\x01\x02\x0b\x01\x12\x04\x97\
    \x0c\x15'\n\x0e\n\x06\x04\x8f\x01\x02\x0b\x03\x12\x04\x97\x0c*,\n\r\n\
    \x05\x04\x8f\x01\x02\x0c\x12\x04\x98\x0c\x049\n\x0e\n\x06\x04\x8f\x01\
    \x02\x0c\x04\x12\x04\x98\x0c\x04\x0c\n\x0e\n\x06\x04\x8f\x01\x02\x0c\x06\
    \x12\x04\x98\x0c\r\x1e\n\x0e\n\x06\x04\x8f\x01\x02\x0c\x01\x12\x04\x98\
    \x0c\x1f3\n\x0e\n\x06\x04\x8f\x01\x02\x0c\x03\x12\x04\x98\x0c68\n\r\n\
    \x05\x04\x8f\x01\x02\r\x12\x04\x99\x0c\x045\n\x0e\n\x06\x04\x8f\x01\x02\
    \r\x04\x12\x04\x99\x0c\x04\x0c\n\x0e\n\x06\x04\x8f\x01\x02\r\x06\x12\x04\
    \x99\x0c\r\x18\n\x0e\n\x06\x04\x8f\x01\x02\r\x01\x12\x04\x99\x0c\x19/\n\
    \x0e\n\x06\x04\x8f\x01\x02\r\x03\x12\x04\x99\x0c24\n\r\n\x05\x04\x8f\x01\
    \x02\x0e\x12\x04\x9a\x0c\x04-\n\x0e\n\x06\x04\x8f\x01\x02\x0e\x06\x12\
    \x04\x9a\x0c\x04\x0f\n\x0e\n\x06\x04\x8f\x01\x02\x0e\x01\x12\x04\x9a\x0c\
    \x10'\n\x0e\n\x06\x04\x8f\x01\x02\x0e\x03\x12\x04\x9a\x0c*,\n\xd7\x01\n\
    \x03\x04\x90\x01\x12\x06\xa3\x0c\0\xac\x0c\x012\xb9\x01/////////////////\
    ////////////////////////////////////////////////////////////////////////\
    \n\x20DAO\n/////////////////////////////////////////////////////////////\
    ////////////////////////////\n2\x0c\x20blockchain\n\n\x0c\n\x04\x04\x90\
    \x01\x01\x12\x04\xa3\x0c\x08\x11\n\r\n\x05\x04\x90\x01\x02\0\x12\x04\xa4\
    \x0c\x04\x15\n\x0e\n\x06\x04\x90\x01\x02\0\x05\x12\x04\xa4\x0c\x04\t\n\
    \x0e\n\x06\x04\x90\x01\x02\0\x01\x12\x04\xa4\x0c\n\x10\n\x0e\n\x06\x04\
    \x90\x01\x02\0\x03\x12\x04\xa4\x0c\x13\x14\n\r\n\x05\x04\x90\x01\x02\x01\
    \x12\x04\xa5\x0c\x04\x13\n\x0e\n\x06\x04\x90\x01\x02\x01\x05\x12\x04\xa5\
    \x0c\x04\t\n\x0e\n\x06\x04\x90\x01\x02\x01\x01\x12\x04\xa5\x0c\n\x0e\n\
    \x0e\n\x06\x04\x90\x01\x02\x01\x03\x12\x04\xa5\x0c\x11\x12\n\r\n\x05\x04\
    \x90\x01\x02\x02\x12\x04\xa6\x0c\x04\x14\n\x0e\n\x06\x04\x90\x01\x02\x02\
    \x05\x12\x04\xa6\x0c\x04\n\n\x0e\n\x06\x04\x90\x01\x02\x02\x01\x12\x04\
    \xa6\x0c\x0b\x0f\n\x0e\n\x06\x04\x90\x01\x02\x02\x03\x12\x04\xa6\x0c\x12\
    \x13\n\r\n\x05\x04\x90\x01\x02\x03\x12\x04\xa7\x0c\x04#\n\x0e\n\x06\x04\
    \x90\x01\x02\x03\x05\x12\x04\xa7\x0c\x04\n\n\x0e\n\x06\x04\x90\x01\x02\
    \x03\x01\x12\x04\xa7\x0c\x0b\x1e\n\x0e\n\x06\x04\x90\x01\x02\x03\x03\x12\
    \x04\xa7\x0c!\"\n\x0f\n\x05\x04\x90\x01\x08\0\x12\x06\xa8\x0c\x04\xab\
    \x0c\x05\n\x0e\n\x06\x04\x90\x01\x08\0\x01\x12\x04\xa8\x0c\n\x11\n\r\n\
    \x05\x04\x90\x01\x02\x04\x12\x04\xa9\x0c\x08\x1f\n\x0e\n\x06\x04\x90\x01\
    \x02\x04\x06\x12\x04\xa9\x0c\x08\x10\n\x0e\n\x06\x04\x90\x01\x02\x04\x01\
    \x12\x04\xa9\x0c\x11\x1a\n\x0e\n\x06\x04\x90\x01\x02\x04\x03\x12\x04\xa9\
    \x0c\x1d\x1e\n\r\n\x05\x04\x90\x01\x02\x05\x12\x04\xaa\x0c\x08\x18\n\x0e\
    \n\x06\x04\x90\x01\x02\x05\x06\x12\x04\xaa\x0c\x08\r\n\x0e\n\x06\x04\x90\
    \x01\x02\x05\x01\x12\x04\xaa\x0c\x0e\x13\n\x0e\n\x06\x04\x90\x01\x02\x05\
    \x03\x12\x04\xaa\x0c\x16\x17\n\r\n\x03\x04\x91\x01\x12\x06\xae\x0c\0\xb1\
    \x0c\x01\n\x0c\n\x04\x04\x91\x01\x01\x12\x04\xae\x0c\x08\x10\nh\n\x05\
    \x04\x91\x01\x02\0\x12\x04\xb0\x0c\x04\x20\x1aY\x20Because\x20of\x20the\
    \x20way\x20how\x20PB\x20implements\x20inheritance\x20we\x20need\x20to\
    \x20use\x20the\x20super\x20class\x20as\x20type\n\n\x0e\n\x06\x04\x91\x01\
    \x02\0\x04\x12\x04\xb0\x0c\x04\x0c\n\x0e\n\x06\x04\x91\x01\x02\0\x06\x12\
    \x04\xb0\x0c\r\x13\n\x0e\n\x06\x04\x91\x01\x02\0\x01\x12\x04\xb0\x0c\x14\
    \x1b\n\x0e\n\x06\x04\x91\x01\x02\0\x03\x12\x04\xb0\x0c\x1e\x1f\n\r\n\x03\
    \x04\x92\x01\x12\x06\xb3\x0c\0\xb6\x0c\x01\n\x0c\n\x04\x04\x92\x01\x01\
    \x12\x04\xb3\x0c\x08\r\nh\n\x05\x04\x92\x01\x02\0\x12\x04\xb5\x0c\x04\
    \x1c\x1aY\x20Because\x20of\x20the\x20way\x20how\x20PB\x20implements\x20i\
    nheritance\x20we\x20need\x20to\x20use\x20the\x20super\x20class\x20as\x20\
    type\n\n\x0e\n\x06\x04\x92\x01\x02\0\x04\x12\x04\xb5\x0c\x04\x0c\n\x0e\n\
    \x06\x04\x92\x01\x02\0\x06\x12\x04\xb5\x0c\r\x13\n\x0e\n\x06\x04\x92\x01\
    \x02\0\x01\x12\x04\xb5\x0c\x14\x17\n\x0e\n\x06\x04\x92\x01\x02\0\x03\x12\
    \x04\xb5\x0c\x1a\x1b\n\r\n\x03\x04\x93\x01\x12\x06\xb8\x0c\0\xc3\x0c\x01\
    \n\x0c\n\x04\x04\x93\x01\x01\x12\x04\xb8\x0c\x08\x0e\n\r\n\x05\x04\x93\
    \x01\x02\0\x12\x04\xb9\x0c\x04\x1a\n\x0e\n\x06\x04\x93\x01\x02\0\x05\x12\
    \x04\xb9\x0c\x04\n\n\x0e\n\x06\x04\x93\x01\x02\0\x01\x12\x04\xb9\x0c\x0b\
    \x15\n\x0e\n\x06\x04\x93\x01\x02\0\x03\x12\x04\xb9\x0c\x18\x19\n\r\n\x05\
    \x04\x93\x01\x02\x01\x12\x04\xba\x0c\x04\x12\n\x0e\n\x06\x04\x93\x01\x02\
    \x01\x05\x12\x04\xba\x0c\x04\n\n\x0e\n\x06\x04\x93\x01\x02\x01\x01\x12\
    \x04\xba\x0c\x0b\r\n\x0e\n\x06\x04\x93\x01\x02\x01\x03\x12\x04\xba\x0c\
    \x10\x11\n\r\n\x05\x04\x93\x01\x02\x02\x12\x04\xbb\x0c\x04\x1b\n\x0e\n\
    \x06\x04\x93\x01\x02\x02\x05\x12\x04\xbb\x0c\x04\t\n\x0e\n\x06\x04\x93\
    \x01\x02\x02\x01\x12\x04\xbb\x0c\n\x16\n\x0e\n\x06\x04\x93\x01\x02\x02\
    \x03\x12\x04\xbb\x0c\x19\x1a\n\r\n\x05\x04\x93\x01\x02\x03\x12\x04\xbc\
    \x0c\x04\x1a\n\x0e\n\x06\x04\x93\x01\x02\x03\x05\x12\x04\xbc\x0c\x04\n\n\
    \x0e\n\x06\x04\x93\x01\x02\x03\x01\x12\x04\xbc\x0c\x0b\x15\n\x0e\n\x06\
    \x04\x93\x01\x02\x03\x03\x12\x04\xbc\x0c\x18\x19\n\r\n\x05\x04\x93\x01\
    \x02\x04\x12\x04\xbd\x0c\x04\x13\n\x0e\n\x06\x04\x93\x01\x02\x04\x05\x12\
    \x04\xbd\x0c\x04\t\n\x0e\n\x06\x04\x93\x01\x02\x04\x01\x12\x04\xbd\x0c\n\
    \x0e\n\x0e\n\x06\x04\x93\x01\x02\x04\x03\x12\x04\xbd\x0c\x11\x12\n\r\n\
    \x05\x04\x93\x01\x02\x05\x12\x04\xbe\x0c\x04#\n\x0e\n\x06\x04\x93\x01\
    \x02\x05\x04\x12\x04\xbe\x0c\x04\x0c\n\x0e\n\x06\x04\x93\x01\x02\x05\x06\
    \x12\x04\xbe\x0c\r\x14\n\x0e\n\x06\x04\x93\x01\x02\x05\x01\x12\x04\xbe\
    \x0c\x15\x1e\n\x0e\n\x06\x04\x93\x01\x02\x05\x03\x12\x04\xbe\x0c!\"\n\
    \x0f\n\x05\x04\x93\x01\x08\0\x12\x06\xbf\x0c\x04\xc2\x0c\x05\n\x0e\n\x06\
    \x04\x93\x01\x08\0\x01\x12\x04\xbf\x0c\n\x11\n\r\n\x05\x04\x93\x01\x02\
    \x06\x12\x04\xc0\x0c\x08\x19\n\x0e\n\x06\x04\x93\x01\x02\x06\x06\x12\x04\
    \xc0\x0c\x08\r\n\x0e\n\x06\x04\x93\x01\x02\x06\x01\x12\x04\xc0\x0c\x0e\
    \x14\n\x0e\n\x06\x04\x93\x01\x02\x06\x03\x12\x04\xc0\x0c\x17\x18\n\r\n\
    \x05\x04\x93\x01\x02\x07\x12\x04\xc1\x0c\x08\x12\n\x0e\n\x06\x04\x93\x01\
    \x02\x07\x06\x12\x04\xc1\x0c\x08\n\n\x0e\n\x06\x04\x93\x01\x02\x07\x01\
    \x12\x04\xc1\x0c\x0b\r\n\x0e\n\x06\x04\x93\x01\x02\x07\x03\x12\x04\xc1\
    \x0c\x10\x11\n\r\n\x03\x04\x94\x01\x12\x06\xc5\x0c\0\xc8\x0c\x01\n\x0c\n\
    \x04\x04\x94\x01\x01\x12\x04\xc5\x0c\x08\r\nh\n\x05\x04\x94\x01\x02\0\
    \x12\x04\xc7\x0c\x04-\x1aY\x20Because\x20of\x20the\x20way\x20how\x20PB\
    \x20implements\x20inheritance\x20we\x20need\x20to\x20use\x20the\x20super\
    \x20class\x20as\x20type\n\n\x0e\n\x06\x04\x94\x01\x02\0\x04\x12\x04\xc7\
    \x0c\x04\x0c\n\x0e\n\x06\x04\x94\x01\x02\0\x06\x12\x04\xc7\x0c\r\x19\n\
    \x0e\n\x06\x04\x94\x01\x02\0\x01\x12\x04\xc7\x0c\x1a(\n\x0e\n\x06\x04\
    \x94\x01\x02\0\x03\x12\x04\xc7\x0c+,\n\r\n\x03\x04\x95\x01\x12\x06\xca\
    \x0c\0\xcf\x0c\x01\n\x0c\n\x04\x04\x95\x01\x01\x12\x04\xca\x0c\x08\n\nh\
    \n\x05\x04\x95\x01\x02\0\x12\x04\xcc\x0c\x04)\x1aY\x20Because\x20of\x20t\
    he\x20way\x20how\x20PB\x20implements\x20inheritance\x20we\x20need\x20to\
    \x20use\x20the\x20super\x20class\x20as\x20type\n\n\x0e\n\x06\x04\x95\x01\
    \x02\0\x04\x12\x04\xcc\x0c\x04\x0c\n\x0e\n\x06\x04\x95\x01\x02\0\x06\x12\
    \x04\xcc\x0c\r\x19\n\x0e\n\x06\x04\x95\x01\x02\0\x01\x12\x04\xcc\x0c\x1a\
    $\n\x0e\n\x06\x04\x95\x01\x02\0\x03\x12\x04\xcc\x0c'(\n\r\n\x05\x04\x95\
    \x01\x02\x01\x12\x04\xcd\x0c\x04\x16\n\x0e\n\x06\x04\x95\x01\x02\x01\x06\
    \x12\x04\xcd\x0c\x04\n\n\x0e\n\x06\x04\x95\x01\x02\x01\x01\x12\x04\xcd\
    \x0c\x0b\x11\n\x0e\n\x06\x04\x95\x01\x02\x01\x03\x12\x04\xcd\x0c\x14\x15\
    \n\r\n\x05\x04\x95\x01\x02\x02\x12\x04\xce\x0c\x04\x18\n\x0e\n\x06\x04\
    \x95\x01\x02\x02\x05\x12\x04\xce\x0c\x04\t\n\x0e\n\x06\x04\x95\x01\x02\
    \x02\x01\x12\x04\xce\x0c\n\x13\n\x0e\n\x06\x04\x95\x01\x02\x02\x03\x12\
    \x04\xce\x0c\x16\x17\n\x0c\n\x02\x05\x04\x12\x06\xd1\x0c\0\xe3\x0c\x01\n\
    \x0b\n\x03\x05\x04\x01\x12\x04\xd1\x0c\x05\x0b\n\x0c\n\x04\x05\x04\x02\0\
    \x12\x04\xd2\x0c\x04\x19\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\xd2\x0c\x04\
    \x14\n\r\n\x05\x05\x04\x02\0\x02\x12\x04\xd2\x0c\x17\x18\n\x0c\n\x04\x05\
    \x04\x02\x01\x12\x04\xd3\x0c\x04\x1a\n\r\n\x05\x05\x04\x02\x01\x01\x12\
    \x04\xd3\x0c\x04\x15\n\r\n\x05\x05\x04\x02\x01\x02\x12\x04\xd3\x0c\x18\
    \x19\n\x0c\n\x04\x05\x04\x02\x02\x12\x04\xd4\x0c\x04\x13\n\r\n\x05\x05\
    \x04\x02\x02\x01\x12\x04\xd4\x0c\x04\x0e\n\r\n\x05\x05\x04\x02\x02\x02\
    \x12\x04\xd4\x0c\x11\x12\n\x0c\n\x04\x05\x04\x02\x03\x12\x04\xd5\x0c\x04\
    \x10\n\r\n\x05\x05\x04\x02\x03\x01\x12\x04\xd5\x0c\x04\x0b\n\r\n\x05\x05\
    \x04\x02\x03\x02\x12\x04\xd5\x0c\x0e\x0f\n\x0c\n\x04\x05\x04\x02\x04\x12\
    \x04\xd6\x0c\x04\x10\n\r\n\x05\x05\x04\x02\x04\x01\x12\x04\xd6\x0c\x04\
    \x0b\n\r\n\x05\x05\x04\x02\x04\x02\x12\x04\xd6\x0c\x0e\x0f\n\x0c\n\x04\
    \x05\x04\x02\x05\x12\x04\xd7\x0c\x04\x15\n\r\n\x05\x05\x04\x02\x05\x01\
    \x12\x04\xd7\x0c\x04\x10\n\r\n\x05\x05\x04\x02\x05\x02\x12\x04\xd7\x0c\
    \x13\x14\n\x0c\n\x04\x05\x04\x02\x06\x12\x04\xd8\x0c\x04\x16\n\r\n\x05\
    \x05\x04\x02\x06\x01\x12\x04\xd8\x0c\x04\x11\n\r\n\x05\x05\x04\x02\x06\
    \x02\x12\x04\xd8\x0c\x14\x15\n\x0c\n\x04\x05\x04\x02\x07\x12\x04\xd9\x0c\
    \x04\x11\n\r\n\x05\x05\x04\x02\x07\x01\x12\x04\xd9\x0c\x04\x0c\n\r\n\x05\
    \x05\x04\x02\x07\x02\x12\x04\xd9\x0c\x0f\x10\n\x0c\n\x04\x05\x04\x02\x08\
    \x12\x04\xda\x0c\x04\x1d\n\r\n\x05\x05\x04\x02\x08\x01\x12\x04\xda\x0c\
    \x04\x18\n\r\n\x05\x05\x04\x02\x08\x02\x12\x04\xda\x0c\x1b\x1c\n\x0c\n\
    \x04\x05\x04\x02\t\x12\x04\xdb\x0c\x04\x1e\n\r\n\x05\x05\x04\x02\t\x01\
    \x12\x04\xdb\x0c\x04\x19\n\r\n\x05\x05\x04\x02\t\x02\x12\x04\xdb\x0c\x1c\
    \x1d\n\x0c\n\x04\x05\x04\x02\n\x12\x04\xdc\x0c\x04\x14\n\r\n\x05\x05\x04\
    \x02\n\x01\x12\x04\xdc\x0c\x04\x0e\n\r\n\x05\x05\x04\x02\n\x02\x12\x04\
    \xdc\x0c\x11\x13\n\x0c\n\x04\x05\x04\x02\x0b\x12\x04\xdd\x0c\x04\x15\n\r\
    \n\x05\x05\x04\x02\x0b\x01\x12\x04\xdd\x0c\x04\x0f\n\r\n\x05\x05\x04\x02\
    \x0b\x02\x12\x04\xdd\x0c\x12\x14\n\x0c\n\x04\x05\x04\x02\x0c\x12\x04\xde\
    \x0c\x04\x10\n\r\n\x05\x05\x04\x02\x0c\x01\x12\x04\xde\x0c\x04\n\n\r\n\
    \x05\x05\x04\x02\x0c\x02\x12\x04\xde\x0c\r\x0f\n\x0c\n\x04\x05\x04\x02\r\
    \x12\x04\xdf\x0c\x04\x10\n\r\n\x05\x05\x04\x02\r\x01\x12\x04\xdf\x0c\x04\
    \n\n\r\n\x05\x05\x04\x02\r\x02\x12\x04\xdf\x0c\r\x0f\n\x0c\n\x04\x05\x04\
    \x02\x0e\x12\x04\xe0\x0c\x04\x1b\n\r\n\x05\x05\x04\x02\x0e\x01\x12\x04\
    \xe0\x0c\x04\x15\n\r\n\x05\x05\x04\x02\x0e\x02\x12\x04\xe0\x0c\x18\x1a\n\
    \x0c\n\x04\x05\x04\x02\x0f\x12\x04\xe1\x0c\x04\x17\n\r\n\x05\x05\x04\x02\
    \x0f\x01\x12\x04\xe1\x0c\x04\x11\n\r\n\x05\x05\x04\x02\x0f\x02\x12\x04\
    \xe1\x0c\x14\x16\n\x0c\n\x04\x05\x04\x02\x10\x12\x04\xe2\x0c\x04\x13\n\r\
    \n\x05\x05\x04\x02\x10\x01\x12\x04\xe2\x0c\x04\r\n\r\n\x05\x05\x04\x02\
    \x10\x02\x12\x04\xe2\x0c\x10\x12\n\r\n\x03\x04\x96\x01\x12\x06\xe5\x0c\0\
    \xe9\x0c\x01\n\x0c\n\x04\x04\x96\x01\x01\x12\x04\xe5\x0c\x08\x0f\n\r\n\
    \x05\x04\x96\x01\x02\0\x12\x04\xe6\x0c\x04)\n\x0e\n\x06\x04\x96\x01\x02\
    \0\x05\x12\x04\xe6\x0c\x04\n\n\x0e\n\x06\x04\x96\x01\x02\0\x01\x12\x04\
    \xe6\x0c\x0b$\n\x0e\n\x06\x04\x96\x01\x02\0\x03\x12\x04\xe6\x0c'(\n\r\n\
    \x05\x04\x96\x01\x02\x01\x12\x04\xe7\x0c\x04(\n\x0e\n\x06\x04\x96\x01\
    \x02\x01\x05\x12\x04\xe7\x0c\x04\t\n\x0e\n\x06\x04\x96\x01\x02\x01\x01\
    \x12\x04\xe7\x0c\n#\n\x0e\n\x06\x04\x96\x01\x02\x01\x03\x12\x04\xe7\x0c&\
    '\n\r\n\x05\x04\x96\x01\x02\x02\x12\x04\xe8\x0c\x04\x17\n\x0e\n\x06\x04\
    \x96\x01\x02\x02\x05\x12\x04\xe8\x0c\x04\n\n\x0e\n\x06\x04\x96\x01\x02\
    \x02\x01\x12\x04\xe8\x0c\x0b\x12\n\x0e\n\x06\x04\x96\x01\x02\x02\x03\x12\
    \x04\xe8\x0c\x15\x16\n\r\n\x03\x04\x97\x01\x12\x06\xeb\x0c\0\xf7\x0c\x01\
    \n\x0c\n\x04\x04\x97\x01\x01\x12\x04\xeb\x0c\x08\x14\n\r\n\x05\x04\x97\
    \x01\x02\0\x12\x04\xec\x0c\x04\x14\n\x0e\n\x06\x04\x97\x01\x02\0\x05\x12\
    \x04\xec\x0c\x04\t\n\x0e\n\x06\x04\x97\x01\x02\0\x01\x12\x04\xec\x0c\n\
    \x0f\n\x0e\n\x06\x04\x97\x01\x02\0\x03\x12\x04\xec\x0c\x12\x13\n\r\n\x05\
    \x04\x97\x01\x02\x01\x12\x04\xed\x0c\x04\x14\n\x0e\n\x06\x04\x97\x01\x02\
    \x01\x05\x12\x04\xed\x0c\x04\t\n\x0e\n\x06\x04\x97\x01\x02\x01\x01\x12\
    \x04\xed\x0c\n\x0f\n\x0e\n\x06\x04\x97\x01\x02\x01\x03\x12\x04\xed\x0c\
    \x12\x13\n\r\n\x05\x04\x97\x01\x02\x02\x12\x04\xee\x0c\x04\x15\n\x0e\n\
    \x06\x04\x97\x01\x02\x02\x05\x12\x04\xee\x0c\x04\n\n\x0e\n\x06\x04\x97\
    \x01\x02\x02\x01\x12\x04\xee\x0c\x0b\x10\n\x0e\n\x06\x04\x97\x01\x02\x02\
    \x03\x12\x04\xee\x0c\x13\x14\n\r\n\x05\x04\x97\x01\x02\x03\x12\x04\xef\
    \x0c\x04$\n\x0e\n\x06\x04\x97\x01\x02\x03\x06\x12\x04\xef\x0c\x04\x10\n\
    \x0e\n\x06\x04\x97\x01\x02\x03\x01\x12\x04\xef\x0c\x11\x1f\n\x0e\n\x06\
    \x04\x97\x01\x02\x03\x03\x12\x04\xef\x0c\"#\n\r\n\x05\x04\x97\x01\x02\
    \x04\x12\x04\xf0\x0c\x04\x17\n\x0e\n\x06\x04\x97\x01\x02\x04\x05\x12\x04\
    \xf0\x0c\x04\n\n\x0e\n\x06\x04\x97\x01\x02\x04\x01\x12\x04\xf0\x0c\x0b\
    \x12\n\x0e\n\x06\x04\x97\x01\x02\x04\x03\x12\x04\xf0\x0c\x15\x16\n\r\n\
    \x05\x04\x97\x01\x02\x05\x12\x04\xf1\x0c\x04\x1d\n\x0e\n\x06\x04\x97\x01\
    \x02\x05\x05\x12\x04\xf1\x0c\x04\t\n\x0e\n\x06\x04\x97\x01\x02\x05\x01\
    \x12\x04\xf1\x0c\n\x18\n\x0e\n\x06\x04\x97\x01\x02\x05\x03\x12\x04\xf1\
    \x0c\x1b\x1c\n\r\n\x05\x04\x97\x01\x02\x06\x12\x04\xf2\x0c\x04\x1b\n\x0e\
    \n\x06\x04\x97\x01\x02\x06\x05\x12\x04\xf2\x0c\x04\t\n\x0e\n\x06\x04\x97\
    \x01\x02\x06\x01\x12\x04\xf2\x0c\n\x16\n\x0e\n\x06\x04\x97\x01\x02\x06\
    \x03\x12\x04\xf2\x0c\x19\x1a\n\x0f\n\x05\x04\x97\x01\x08\0\x12\x06\xf3\
    \x0c\x04\xf6\x0c\x05\n\x0e\n\x06\x04\x97\x01\x08\0\x01\x12\x04\xf3\x0c\n\
    \x11\n\r\n\x05\x04\x97\x01\x02\x07\x12\x04\xf4\x0c\x08&\n\x0e\n\x06\x04\
    \x97\x01\x02\x07\x06\x12\x04\xf4\x0c\x08\x13\n\x0e\n\x06\x04\x97\x01\x02\
    \x07\x01\x12\x04\xf4\x0c\x14!\n\x0e\n\x06\x04\x97\x01\x02\x07\x03\x12\
    \x04\xf4\x0c$%\n\r\n\x05\x04\x97\x01\x02\x08\x12\x04\xf5\x0c\x08\x1f\n\
    \x0e\n\x06\x04\x97\x01\x02\x08\x06\x12\x04\xf5\x0c\x08\x10\n\x0e\n\x06\
    \x04\x97\x01\x02\x08\x01\x12\x04\xf5\x0c\x11\x1a\n\x0e\n\x06\x04\x97\x01\
    \x02\x08\x03\x12\x04\xf5\x0c\x1d\x1e\n\r\n\x03\x04\x98\x01\x12\x06\xf9\
    \x0c\0\xfd\x0c\x01\n\x0c\n\x04\x04\x98\x01\x01\x12\x04\xf9\x0c\x08\x1b\n\
    \r\n\x05\x04\x98\x01\x02\0\x12\x04\xfa\x0c\x04\x14\n\x0e\n\x06\x04\x98\
    \x01\x02\0\x05\x12\x04\xfa\x0c\x04\t\n\x0e\n\x06\x04\x98\x01\x02\0\x01\
    \x12\x04\xfa\x0c\n\x0f\n\x0e\n\x06\x04\x98\x01\x02\0\x03\x12\x04\xfa\x0c\
    \x12\x13\n\r\n\x05\x04\x98\x01\x02\x01\x12\x04\xfb\x0c\x04\x14\n\x0e\n\
    \x06\x04\x98\x01\x02\x01\x05\x12\x04\xfb\x0c\x04\t\n\x0e\n\x06\x04\x98\
    \x01\x02\x01\x01\x12\x04\xfb\x0c\n\x0f\n\x0e\n\x06\x04\x98\x01\x02\x01\
    \x03\x12\x04\xfb\x0c\x12\x13\n\r\n\x05\x04\x98\x01\x02\x02\x12\x04\xfc\
    \x0c\x04\x15\n\x0e\n\x06\x04\x98\x01\x02\x02\x05\x12\x04\xfc\x0c\x04\n\n\
    \x0e\n\x06\x04\x98\x01\x02\x02\x01\x12\x04\xfc\x0c\x0b\x10\n\x0e\n\x06\
    \x04\x98\x01\x02\x02\x03\x12\x04\xfc\x0c\x13\x14\n\r\n\x03\x04\x99\x01\
    \x12\x06\xff\x0c\0\x80\r\x01\n\x0c\n\x04\x04\x99\x01\x01\x12\x04\xff\x0c\
    \x08\x13\n\r\n\x03\x04\x9a\x01\x12\x06\x82\r\0\x86\r\x01\n\x0c\n\x04\x04\
    \x9a\x01\x01\x12\x04\x82\r\x08\x10\n\r\n\x05\x04\x9a\x01\x02\0\x12\x04\
    \x83\r\x04$\n\x0e\n\x06\x04\x9a\x01\x02\0\x06\x12\x04\x83\r\x04\x10\n\
    \x0e\n\x06\x04\x9a\x01\x02\0\x01\x12\x04\x83\r\x11\x1f\n\x0e\n\x06\x04\
    \x9a\x01\x02\0\x03\x12\x04\x83\r\"#\n\r\n\x05\x04\x9a\x01\x02\x01\x12\
    \x04\x84\r\x04\x18\n\x0e\n\x06\x04\x9a\x01\x02\x01\x05\x12\x04\x84\r\x04\
    \t\n\x0e\n\x06\x04\x9a\x01\x02\x01\x01\x12\x04\x84\r\n\x13\n\x0e\n\x06\
    \x04\x9a\x01\x02\x01\x03\x12\x04\x84\r\x16\x17\n\r\n\x05\x04\x9a\x01\x02\
    \x02\x12\x04\x85\r\x04\"\n\x0e\n\x06\x04\x9a\x01\x02\x02\x05\x12\x04\x85\
    \r\x04\t\n\x0e\n\x06\x04\x9a\x01\x02\x02\x01\x12\x04\x85\r\n\x1d\n\x0e\n\
    \x06\x04\x9a\x01\x02\x02\x03\x12\x04\x85\r\x20!\n\x0c\n\x02\x05\x05\x12\
    \x06\x88\r\0\x9d\r\x01\n\x0b\n\x03\x05\x05\x01\x12\x04\x88\r\x05\x11\n\
    \x0c\n\x04\x05\x05\x02\0\x12\x04\x89\r\x04\x20\n\r\n\x05\x05\x05\x02\0\
    \x01\x12\x04\x89\r\x04\x1b\n\r\n\x05\x05\x05\x02\0\x02\x12\x04\x89\r\x1e\
    \x1f\n\x0c\n\x04\x05\x05\x02\x01\x12\x04\x8a\r\x04\x19\n\r\n\x05\x05\x05\
    \x02\x01\x01\x12\x04\x8a\r\x04\x14\n\r\n\x05\x05\x05\x02\x01\x02\x12\x04\
    \x8a\r\x17\x18\n\x0c\n\x04\x05\x05\x02\x02\x12\x04\x8b\r\x04\x17\n\r\n\
    \x05\x05\x05\x02\x02\x01\x12\x04\x8b\r\x04\x12\n\r\n\x05\x05\x05\x02\x02\
    \x02\x12\x04\x8b\r\x15\x16\n\x0c\n\x04\x05\x05\x02\x03\x12\x04\x8c\r\x04\
    \x13\n\r\n\x05\x05\x05\x02\x03\x01\x12\x04\x8c\r\x04\x0e\n\r\n\x05\x05\
    \x05\x02\x03\x02\x12\x04\x8c\r\x11\x12\n\x0c\n\x04\x05\x05\x02\x04\x12\
    \x04\x8d\r\x04\x13\n\r\n\x05\x05\x05\x02\x04\x01\x12\x04\x8d\r\x04\x0e\n\
    \r\n\x05\x05\x05\x02\x04\x02\x12\x04\x8d\r\x11\x12\n\x0c\n\x04\x05\x05\
    \x02\x05\x12\x04\x8e\r\x04\"\n\r\n\x05\x05\x05\x02\x05\x01\x12\x04\x8e\r\
    \x04\x1d\n\r\n\x05\x05\x05\x02\x05\x02\x12\x04\x8e\r\x20!\n\x0c\n\x04\
    \x05\x05\x02\x06\x12\x04\x8f\r\x04\"\n\r\n\x05\x05\x05\x02\x06\x01\x12\
    \x04\x8f\r\x04\x1d\n\r\n\x05\x05\x05\x02\x06\x02\x12\x04\x8f\r\x20!\n\
    \x0c\n\x04\x05\x05\x02\x07\x12\x04\x90\r\x04'\n\r\n\x05\x05\x05\x02\x07\
    \x01\x12\x04\x90\r\x04\"\n\r\n\x05\x05\x05\x02\x07\x02\x12\x04\x90\r%&\n\
    \x0c\n\x04\x05\x05\x02\x08\x12\x04\x91\r\x04)\n\r\n\x05\x05\x05\x02\x08\
    \x01\x12\x04\x91\r\x04$\n\r\n\x05\x05\x05\x02\x08\x02\x12\x04\x91\r'(\n\
    \x0c\n\x04\x05\x05\x02\t\x12\x04\x92\r\x04\"\n\r\n\x05\x05\x05\x02\t\x01\
    \x12\x04\x92\r\x04\x1d\n\r\n\x05\x05\x05\x02\t\x02\x12\x04\x92\r\x20!\n\
    \x0c\n\x04\x05\x05\x02\n\x12\x04\x93\r\x04&\n\r\n\x05\x05\x05\x02\n\x01\
    \x12\x04\x93\r\x04\x20\n\r\n\x05\x05\x05\x02\n\x02\x12\x04\x93\r#%\n\x0c\
    \n\x04\x05\x05\x02\x0b\x12\x04\x94\r\x04%\n\r\n\x05\x05\x05\x02\x0b\x01\
    \x12\x04\x94\r\x04\x1f\n\r\n\x05\x05\x05\x02\x0b\x02\x12\x04\x94\r\"$\n\
    \x0c\n\x04\x05\x05\x02\x0c\x12\x04\x95\r\x04)\n\r\n\x05\x05\x05\x02\x0c\
    \x01\x12\x04\x95\r\x04#\n\r\n\x05\x05\x05\x02\x0c\x02\x12\x04\x95\r&(\n\
    \x0c\n\x04\x05\x05\x02\r\x12\x04\x96\r\x04&\n\r\n\x05\x05\x05\x02\r\x01\
    \x12\x04\x96\r\x04\x20\n\r\n\x05\x05\x05\x02\r\x02\x12\x04\x96\r#%\n\x0c\
    \n\x04\x05\x05\x02\x0e\x12\x04\x97\r\x04,\n\r\n\x05\x05\x05\x02\x0e\x01\
    \x12\x04\x97\r\x04&\n\r\n\x05\x05\x05\x02\x0e\x02\x12\x04\x97\r)+\n\x0c\
    \n\x04\x05\x05\x02\x0f\x12\x04\x98\r\x04(\n\r\n\x05\x05\x05\x02\x0f\x01\
    \x12\x04\x98\r\x04\"\n\r\n\x05\x05\x05\x02\x0f\x02\x12\x04\x98\r%'\n\x0c\
    \n\x04\x05\x05\x02\x10\x12\x04\x99\r\x04\x17\n\r\n\x05\x05\x05\x02\x10\
    \x01\x12\x04\x99\r\x04\x11\n\r\n\x05\x05\x05\x02\x10\x02\x12\x04\x99\r\
    \x14\x16\n\x0c\n\x04\x05\x05\x02\x11\x12\x04\x9a\r\x04!\n\r\n\x05\x05\
    \x05\x02\x11\x01\x12\x04\x9a\r\x04\x1b\n\r\n\x05\x05\x05\x02\x11\x02\x12\
    \x04\x9a\r\x1e\x20\n\x0c\n\x04\x05\x05\x02\x12\x12\x04\x9b\r\x04\x17\n\r\
    \n\x05\x05\x05\x02\x12\x01\x12\x04\x9b\r\x04\x11\n\r\n\x05\x05\x05\x02\
    \x12\x02\x12\x04\x9b\r\x14\x16\n\x0c\n\x04\x05\x05\x02\x13\x12\x04\x9c\r\
    \x04\x18\n\r\n\x05\x05\x05\x02\x13\x01\x12\x04\x9c\r\x04\x12\n\r\n\x05\
    \x05\x05\x02\x13\x02\x12\x04\x9c\r\x15\x17\n\r\n\x03\x04\x9b\x01\x12\x06\
    \x9f\r\0\xa3\r\x01\n\x0c\n\x04\x04\x9b\x01\x01\x12\x04\x9f\r\x08\x11\n\r\
    \n\x05\x04\x9b\x01\x02\0\x12\x04\xa0\r\x04\x1b\n\x0e\n\x06\x04\x9b\x01\
    \x02\0\x05\x12\x04\xa0\r\x04\t\n\x0e\n\x06\x04\x9b\x01\x02\0\x01\x12\x04\
    \xa0\r\n\x16\n\x0e\n\x06\x04\x9b\x01\x02\0\x03\x12\x04\xa0\r\x19\x1a\n\r\
    \n\x05\x04\x9b\x01\x02\x01\x12\x04\xa1\r\x04\x15\n\x0e\n\x06\x04\x9b\x01\
    \x02\x01\x05\x12\x04\xa1\r\x04\n\n\x0e\n\x06\x04\x9b\x01\x02\x01\x01\x12\
    \x04\xa1\r\x0b\x10\n\x0e\n\x06\x04\x9b\x01\x02\x01\x03\x12\x04\xa1\r\x13\
    \x14\n\r\n\x05\x04\x9b\x01\x02\x02\x12\x04\xa2\r\x04\x1a\n\x0e\n\x06\x04\
    \x9b\x01\x02\x02\x05\x12\x04\xa2\r\x04\t\n\x0e\n\x06\x04\x9b\x01\x02\x02\
    \x01\x12\x04\xa2\r\n\x15\n\x0e\n\x06\x04\x9b\x01\x02\x02\x03\x12\x04\xa2\
    \r\x18\x19\n\x0c\n\x02\x05\x06\x12\x06\xa5\r\0\xaf\r\x01\n\x0b\n\x03\x05\
    \x06\x01\x12\x04\xa5\r\x05\x0f\n\x0c\n\x04\x05\x06\x02\0\x12\x04\xa6\r\
    \x04\x1e\n\r\n\x05\x05\x06\x02\0\x01\x12\x04\xa6\r\x04\x19\n\r\n\x05\x05\
    \x06\x02\0\x02\x12\x04\xa6\r\x1c\x1d\n\x0c\n\x04\x05\x06\x02\x01\x12\x04\
    \xa7\r\x04\x10\n\r\n\x05\x05\x06\x02\x01\x01\x12\x04\xa7\r\x04\x0b\n\r\n\
    \x05\x05\x06\x02\x01\x02\x12\x04\xa7\r\x0e\x0f\n\x0c\n\x04\x05\x06\x02\
    \x02\x12\x04\xa8\r\x04\x15\n\r\n\x05\x05\x06\x02\x02\x01\x12\x04\xa8\r\
    \x04\x10\n\r\n\x05\x05\x06\x02\x02\x02\x12\x04\xa8\r\x13\x14\n\x0c\n\x04\
    \x05\x06\x02\x03\x12\x04\xa9\r\x04\x14\n\r\n\x05\x05\x06\x02\x03\x01\x12\
    \x04\xa9\r\x04\x0f\n\r\n\x05\x05\x06\x02\x03\x02\x12\x04\xa9\r\x12\x13\n\
    \x0c\n\x04\x05\x06\x02\x04\x12\x04\xaa\r\x04\x11\n\r\n\x05\x05\x06\x02\
    \x04\x01\x12\x04\xaa\r\x04\x0c\n\r\n\x05\x05\x06\x02\x04\x02\x12\x04\xaa\
    \r\x0f\x10\n\x0c\n\x04\x05\x06\x02\x05\x12\x04\xab\r\x04\x12\n\r\n\x05\
    \x05\x06\x02\x05\x01\x12\x04\xab\r\x04\r\n\r\n\x05\x05\x06\x02\x05\x02\
    \x12\x04\xab\r\x10\x11\n\x0c\n\x04\x05\x06\x02\x06\x12\x04\xac\r\x04\x1b\
    \n\r\n\x05\x05\x06\x02\x06\x01\x12\x04\xac\r\x04\x16\n\r\n\x05\x05\x06\
    \x02\x06\x02\x12\x04\xac\r\x19\x1a\n\x0c\n\x04\x05\x06\x02\x07\x12\x04\
    \xad\r\x04\x1e\n\r\n\x05\x05\x06\x02\x07\x01\x12\x04\xad\r\x04\x19\n\r\n\
    \x05\x05\x06\x02\x07\x02\x12\x04\xad\r\x1c\x1d\n\x0c\n\x04\x05\x06\x02\
    \x08\x12\x04\xae\r\x04\x14\n\r\n\x05\x05\x06\x02\x08\x01\x12\x04\xae\r\
    \x04\x0f\n\r\n\x05\x05\x06\x02\x08\x02\x12\x04\xae\r\x12\x13\n\r\n\x03\
    \x04\x9c\x01\x12\x06\xb1\r\0\xb7\r\x01\n\x0c\n\x04\x04\x9c\x01\x01\x12\
    \x04\xb1\r\x08\x14\n\r\n\x05\x04\x9c\x01\x02\0\x12\x04\xb2\r\x04\x17\n\
    \x0e\n\x06\x04\x9c\x01\x02\0\x05\x12\x04\xb2\r\x04\t\n\x0e\n\x06\x04\x9c\
    \x01\x02\0\x01\x12\x04\xb2\r\n\x12\n\x0e\n\x06\x04\x9c\x01\x02\0\x03\x12\
    \x04\xb2\r\x15\x16\n\r\n\x05\x04\x9c\x01\x02\x01\x12\x04\xb3\r\x04\x1f\n\
    \x0e\n\x06\x04\x9c\x01\x02\x01\x06\x12\x04\xb3\r\x04\x0e\n\x0e\n\x06\x04\
    \x9c\x01\x02\x01\x01\x12\x04\xb3\r\x0f\x1a\n\x0e\n\x06\x04\x9c\x01\x02\
    \x01\x03\x12\x04\xb3\r\x1d\x1e\n\r\n\x05\x04\x9c\x01\x02\x02\x12\x04\xb4\
    \r\x04\"\n\x0e\n\x06\x04\x9c\x01\x02\x02\x04\x12\x04\xb4\r\x04\x0c\n\x0e\
    \n\x06\x04\x9c\x01\x02\x02\x05\x12\x04\xb4\r\r\x13\n\x0e\n\x06\x04\x9c\
    \x01\x02\x02\x01\x12\x04\xb4\r\x14\x1d\n\x0e\n\x06\x04\x9c\x01\x02\x02\
    \x03\x12\x04\xb4\r\x20!\n\r\n\x05\x04\x9c\x01\x02\x03\x12\x04\xb5\r\x04\
    \x13\n\x0e\n\x06\x04\x9c\x01\x02\x03\x05\x12\x04\xb5\r\x04\n\n\x0e\n\x06\
    \x04\x9c\x01\x02\x03\x01\x12\x04\xb5\r\x0b\x0e\n\x0e\n\x06\x04\x9c\x01\
    \x02\x03\x03\x12\x04\xb5\r\x11\x12\n\r\n\x05\x04\x9c\x01\x02\x04\x12\x04\
    \xb6\r\x04\x13\n\x0e\n\x06\x04\x9c\x01\x02\x04\x05\x12\x04\xb6\r\x04\n\n\
    \x0e\n\x06\x04\x9c\x01\x02\x04\x01\x12\x04\xb6\r\x0b\x0e\n\x0e\n\x06\x04\
    \x9c\x01\x02\x04\x03\x12\x04\xb6\r\x11\x12\n\x19\n\x03\x04\x9d\x01\x12\
    \x06\xbb\r\0\xbe\r\x012\n\x20dao\x20data\n\n\x0c\n\x04\x04\x9d\x01\x01\
    \x12\x04\xbb\r\x08\x10\n\r\n\x05\x04\x9d\x01\x02\0\x12\x04\xbc\r\x04\x1c\
    \n\x0e\n\x06\x04\x9d\x01\x02\0\x05\x12\x04\xbc\r\x04\t\n\x0e\n\x06\x04\
    \x9d\x01\x02\0\x01\x12\x04\xbc\r\n\x17\n\x0e\n\x06\x04\x9d\x01\x02\0\x03\
    \x12\x04\xbc\r\x1a\x1b\n\r\n\x05\x04\x9d\x01\x02\x01\x12\x04\xbd\r\x04\
    \x17\n\x0e\n\x06\x04\x9d\x01\x02\x01\x05\x12\x04\xbd\r\x04\t\n\x0e\n\x06\
    \x04\x9d\x01\x02\x01\x01\x12\x04\xbd\r\n\x12\n\x0e\n\x06\x04\x9d\x01\x02\
    \x01\x03\x12\x04\xbd\r\x15\x16\n\r\n\x03\x04\x9e\x01\x12\x06\xc0\r\0\xc3\
    \r\x01\n\x0c\n\x04\x04\x9e\x01\x01\x12\x04\xc0\r\x08\r\n\r\n\x05\x04\x9e\
    \x01\x02\0\x12\x04\xc1\r\x04#\n\x0e\n\x06\x04\x9e\x01\x02\0\x05\x12\x04\
    \xc1\r\x04\t\n\x0e\n\x06\x04\x9e\x01\x02\0\x01\x12\x04\xc1\r\n\x1e\n\x0e\
    \n\x06\x04\x9e\x01\x02\0\x03\x12\x04\xc1\r!\"\n\r\n\x05\x04\x9e\x01\x02\
    \x01\x12\x04\xc2\r\x04$\n\x0e\n\x06\x04\x9e\x01\x02\x01\x04\x12\x04\xc2\
    \r\x04\x0c\n\x0e\n\x06\x04\x9e\x01\x02\x01\x06\x12\x04\xc2\r\r\x15\n\x0e\
    \n\x06\x04\x9e\x01\x02\x01\x01\x12\x04\xc2\r\x16\x1f\n\x0e\n\x06\x04\x9e\
    \x01\x02\x01\x03\x12\x04\xc2\r\"#\n\r\n\x03\x04\x9f\x01\x12\x06\xc5\r\0\
    \xd2\r\x01\n\x0c\n\x04\x04\x9f\x01\x01\x12\x04\xc5\r\x08\x10\n\r\n\x05\
    \x04\x9f\x01\x02\0\x12\x04\xc6\r\x04\x1b\n\x0e\n\x06\x04\x9f\x01\x02\0\
    \x05\x12\x04\xc6\r\x04\t\n\x0e\n\x06\x04\x9f\x01\x02\0\x01\x12\x04\xc6\r\
    \n\x16\n\x0e\n\x06\x04\x9f\x01\x02\0\x03\x12\x04\xc6\r\x19\x1a\nh\n\x05\
    \x04\x9f\x01\x02\x01\x12\x04\xc8\r\x04\"\x1aY\x20Because\x20of\x20the\
    \x20way\x20how\x20PB\x20implements\x20inheritance\x20we\x20need\x20to\
    \x20use\x20the\x20super\x20class\x20as\x20type\n\n\x0e\n\x06\x04\x9f\x01\
    \x02\x01\x04\x12\x04\xc8\r\x04\x0c\n\x0e\n\x06\x04\x9f\x01\x02\x01\x06\
    \x12\x04\xc8\r\r\x16\n\x0e\n\x06\x04\x9f\x01\x02\x01\x01\x12\x04\xc8\r\
    \x17\x1d\n\x0e\n\x06\x04\x9f\x01\x02\x01\x03\x12\x04\xc8\r\x20!\n\r\n\
    \x05\x04\x9f\x01\x02\x02\x12\x04\xc9\r\x04\x1e\n\x0e\n\x06\x04\x9f\x01\
    \x02\x02\x04\x12\x04\xc9\r\x04\x0c\n\x0e\n\x06\x04\x9f\x01\x02\x02\x06\
    \x12\x04\xc9\r\r\x12\n\x0e\n\x06\x04\x9f\x01\x02\x02\x01\x12\x04\xc9\r\
    \x13\x19\n\x0e\n\x06\x04\x9f\x01\x02\x02\x03\x12\x04\xc9\r\x1c\x1d\nh\n\
    \x05\x04\x9f\x01\x02\x03\x12\x04\xcb\r\x048\x1aY\x20Because\x20of\x20the\
    \x20way\x20how\x20PB\x20implements\x20inheritance\x20we\x20need\x20to\
    \x20use\x20the\x20super\x20class\x20as\x20type\n\n\x0e\n\x06\x04\x9f\x01\
    \x02\x03\x06\x12\x04\xcb\r\x04\x1d\n\x0e\n\x06\x04\x9f\x01\x02\x03\x01\
    \x12\x04\xcb\r\x1e3\n\x0e\n\x06\x04\x9f\x01\x02\x03\x03\x12\x04\xcb\r67\
    \n\r\n\x05\x04\x9f\x01\x02\x04\x12\x04\xcc\r\x04+\n\x0e\n\x06\x04\x9f\
    \x01\x02\x04\x06\x12\x04\xcc\r\x04\x19\n\x0e\n\x06\x04\x9f\x01\x02\x04\
    \x01\x12\x04\xcc\r\x1a&\n\x0e\n\x06\x04\x9f\x01\x02\x04\x03\x12\x04\xcc\
    \r)*\n\r\n\x05\x04\x9f\x01\x02\x05\x12\x04\xcd\r\x043\n\x0e\n\x06\x04\
    \x9f\x01\x02\x05\x04\x12\x04\xcd\r\x04\x0c\n\x0e\n\x06\x04\x9f\x01\x02\
    \x05\x05\x12\x04\xcd\r\r\x13\n\x0e\n\x06\x04\x9f\x01\x02\x05\x01\x12\x04\
    \xcd\r\x14.\n\x0e\n\x06\x04\x9f\x01\x02\x05\x03\x12\x04\xcd\r12\n\r\n\
    \x05\x04\x9f\x01\x02\x06\x12\x04\xce\r\x04.\n\x0e\n\x06\x04\x9f\x01\x02\
    \x06\x06\x12\x04\xce\r\x04\x1a\n\x0e\n\x06\x04\x9f\x01\x02\x06\x01\x12\
    \x04\xce\r\x1b)\n\x0e\n\x06\x04\x9f\x01\x02\x06\x03\x12\x04\xce\r,-\n\r\
    \n\x05\x04\x9f\x01\x02\x07\x12\x04\xcf\r\x04/\n\x0e\n\x06\x04\x9f\x01\
    \x02\x07\x04\x12\x04\xcf\r\x04\x0c\n\x0e\n\x06\x04\x9f\x01\x02\x07\x06\
    \x12\x04\xcf\r\r\x18\n\x0e\n\x06\x04\x9f\x01\x02\x07\x01\x12\x04\xcf\r\
    \x19*\n\x0e\n\x06\x04\x9f\x01\x02\x07\x03\x12\x04\xcf\r-.\n\r\n\x05\x04\
    \x9f\x01\x02\x08\x12\x04\xd0\r\x04;\n\x0e\n\x06\x04\x9f\x01\x02\x08\x04\
    \x12\x04\xd0\r\x04\x0c\n\x0e\n\x06\x04\x9f\x01\x02\x08\x06\x12\x04\xd0\r\
    \r\x1e\n\x0e\n\x06\x04\x9f\x01\x02\x08\x01\x12\x04\xd0\r\x1f6\n\x0e\n\
    \x06\x04\x9f\x01\x02\x08\x03\x12\x04\xd0\r9:\n\r\n\x05\x04\x9f\x01\x02\t\
    \x12\x04\xd1\r\x04P\n\x0e\n\x06\x04\x9f\x01\x02\t\x04\x12\x04\xd1\r\x04\
    \x0c\n\x0e\n\x06\x04\x9f\x01\x02\t\x06\x12\x04\xd1\r\r'\n\x0e\n\x06\x04\
    \x9f\x01\x02\t\x01\x12\x04\xd1\r(J\n\x0e\n\x06\x04\x9f\x01\x02\t\x03\x12\
    \x04\xd1\rMO\n\r\n\x03\x04\xa0\x01\x12\x06\xd4\r\0\xda\r\x01\n\x0c\n\x04\
    \x04\xa0\x01\x01\x12\x04\xd4\r\x08\x10\n\r\n\x05\x04\xa0\x01\x02\0\x12\
    \x04\xd5\r\x04\x15\n\x0e\n\x06\x04\xa0\x01\x02\0\x05\x12\x04\xd5\r\x04\n\
    \n\x0e\n\x06\x04\xa0\x01\x02\0\x01\x12\x04\xd5\r\x0b\x10\n\x0e\n\x06\x04\
    \xa0\x01\x02\0\x03\x12\x04\xd5\r\x13\x14\n\r\n\x05\x04\xa0\x01\x02\x01\
    \x12\x04\xd6\r\x04\x1b\n\x0e\n\x06\x04\xa0\x01\x02\x01\x05\x12\x04\xd6\r\
    \x04\t\n\x0e\n\x06\x04\xa0\x01\x02\x01\x01\x12\x04\xd6\r\n\x16\n\x0e\n\
    \x06\x04\xa0\x01\x02\x01\x03\x12\x04\xd6\r\x19\x1a\n\r\n\x05\x04\xa0\x01\
    \x02\x02\x12\x04\xd7\r\x04\x15\n\x0e\n\x06\x04\xa0\x01\x02\x02\x05\x12\
    \x04\xd7\r\x04\t\n\x0e\n\x06\x04\xa0\x01\x02\x02\x01\x12\x04\xd7\r\n\x10\
    \n\x0e\n\x06\x04\xa0\x01\x02\x02\x03\x12\x04\xd7\r\x13\x14\n\r\n\x05\x04\
    \xa0\x01\x02\x03\x12\x04\xd8\r\x04\x17\n\x0e\n\x06\x04\xa0\x01\x02\x03\
    \x05\x12\x04\xd8\r\x04\n\n\x0e\n\x06\x04\xa0\x01\x02\x03\x01\x12\x04\xd8\
    \r\x0b\x12\n\x0e\n\x06\x04\xa0\x01\x02\x03\x03\x12\x04\xd8\r\x15\x16\n\r\
    \n\x05\x04\xa0\x01\x02\x04\x12\x04\xd9\r\x04\x1d\n\x0e\n\x06\x04\xa0\x01\
    \x02\x04\x05\x12\x04\xd9\r\x04\n\n\x0e\n\x06\x04\xa0\x01\x02\x04\x01\x12\
    \x04\xd9\r\x0b\x18\n\x0e\n\x06\x04\xa0\x01\x02\x04\x03\x12\x04\xd9\r\x1b\
    \x1c\n\r\n\x03\x04\xa1\x01\x12\x06\xdc\r\0\xed\r\x01\n\x0c\n\x04\x04\xa1\
    \x01\x01\x12\x04\xdc\r\x08\x10\n\r\n\x05\x04\xa1\x01\x02\0\x12\x04\xdd\r\
    \x04\x14\n\x0e\n\x06\x04\xa1\x01\x02\0\x05\x12\x04\xdd\r\x04\n\n\x0e\n\
    \x06\x04\xa1\x01\x02\0\x01\x12\x04\xdd\r\x0b\x0f\n\x0e\n\x06\x04\xa1\x01\
    \x02\0\x03\x12\x04\xdd\r\x12\x13\n\r\n\x05\x04\xa1\x01\x02\x01\x12\x04\
    \xde\r\x04\x14\n\x0e\n\x06\x04\xa1\x01\x02\x01\x05\x12\x04\xde\r\x04\n\n\
    \x0e\n\x06\x04\xa1\x01\x02\x01\x01\x12\x04\xde\r\x0b\x0f\n\x0e\n\x06\x04\
    \xa1\x01\x02\x01\x03\x12\x04\xde\r\x12\x13\n\r\n\x05\x04\xa1\x01\x02\x02\
    \x12\x04\xdf\r\x04\x17\n\x0e\n\x06\x04\xa1\x01\x02\x02\x05\x12\x04\xdf\r\
    \x04\n\n\x0e\n\x06\x04\xa1\x01\x02\x02\x01\x12\x04\xdf\r\x0b\x12\n\x0e\n\
    \x06\x04\xa1\x01\x02\x02\x03\x12\x04\xdf\r\x15\x16\n\r\n\x05\x04\xa1\x01\
    \x02\x03\x12\x04\xe0\r\x04\x1c\n\x0e\n\x06\x04\xa1\x01\x02\x03\x05\x12\
    \x04\xe0\r\x04\t\n\x0e\n\x06\x04\xa1\x01\x02\x03\x01\x12\x04\xe0\r\n\x17\
    \n\x0e\n\x06\x04\xa1\x01\x02\x03\x03\x12\x04\xe0\r\x1a\x1b\n\r\n\x05\x04\
    \xa1\x01\x02\x04\x12\x04\xe1\r\x04\x15\n\x0e\n\x06\x04\xa1\x01\x02\x04\
    \x05\x12\x04\xe1\r\x04\n\n\x0e\n\x06\x04\xa1\x01\x02\x04\x01\x12\x04\xe1\
    \r\x0b\x10\n\x0e\n\x06\x04\xa1\x01\x02\x04\x03\x12\x04\xe1\r\x13\x14\n\
    \x0f\n\x05\x04\xa1\x01\x08\0\x12\x06\xe2\r\x04\xea\r\x05\n\x0e\n\x06\x04\
    \xa1\x01\x08\0\x01\x12\x04\xe2\r\n\x11\n\r\n\x05\x04\xa1\x01\x02\x05\x12\
    \x04\xe3\r\x087\n\x0e\n\x06\x04\xa1\x01\x02\x05\x06\x12\x04\xe3\r\x08\
    \x1c\n\x0e\n\x06\x04\xa1\x01\x02\x05\x01\x12\x04\xe3\r\x1d2\n\x0e\n\x06\
    \x04\xa1\x01\x02\x05\x03\x12\x04\xe3\r56\n\r\n\x05\x04\xa1\x01\x02\x06\
    \x12\x04\xe4\r\x089\n\x0e\n\x06\x04\xa1\x01\x02\x06\x06\x12\x04\xe4\r\
    \x08\x1d\n\x0e\n\x06\x04\xa1\x01\x02\x06\x01\x12\x04\xe4\r\x1e4\n\x0e\n\
    \x06\x04\xa1\x01\x02\x06\x03\x12\x04\xe4\r78\n\r\n\x05\x04\xa1\x01\x02\
    \x07\x12\x04\xe5\r\x086\n\x0e\n\x06\x04\xa1\x01\x02\x07\x06\x12\x04\xe5\
    \r\x08\x1b\n\x0e\n\x06\x04\xa1\x01\x02\x07\x01\x12\x04\xe5\r\x1c1\n\x0e\
    \n\x06\x04\xa1\x01\x02\x07\x03\x12\x04\xe5\r45\n\r\n\x05\x04\xa1\x01\x02\
    \x08\x12\x04\xe6\r\x08'\n\x0e\n\x06\x04\xa1\x01\x02\x08\x06\x12\x04\xe6\
    \r\x08\x14\n\x0e\n\x06\x04\xa1\x01\x02\x08\x01\x12\x04\xe6\r\x15\"\n\x0e\
    \n\x06\x04\xa1\x01\x02\x08\x03\x12\x04\xe6\r%&\n\r\n\x05\x04\xa1\x01\x02\
    \t\x12\x04\xe7\r\x08=\n\x0e\n\x06\x04\xa1\x01\x02\t\x06\x12\x04\xe7\r\
    \x08\x1e\n\x0e\n\x06\x04\xa1\x01\x02\t\x01\x12\x04\xe7\r\x1f7\n\x0e\n\
    \x06\x04\xa1\x01\x02\t\x03\x12\x04\xe7\r:<\n\r\n\x05\x04\xa1\x01\x02\n\
    \x12\x04\xe8\r\x08.\n\x0e\n\x06\x04\xa1\x01\x02\n\x06\x12\x04\xe8\r\x08\
    \x17\n\x0e\n\x06\x04\xa1\x01\x02\n\x01\x12\x04\xe8\r\x18(\n\x0e\n\x06\
    \x04\xa1\x01\x02\n\x03\x12\x04\xe8\r+-\n\r\n\x05\x04\xa1\x01\x02\x0b\x12\
    \x04\xe9\r\x087\n\x0e\n\x06\x04\xa1\x01\x02\x0b\x06\x12\x04\xe9\r\x08\
    \x1b\n\x0e\n\x06\x04\xa1\x01\x02\x0b\x01\x12\x04\xe9\r\x1c1\n\x0e\n\x06\
    \x04\xa1\x01\x02\x0b\x03\x12\x04\xe9\r46\nN\n\x05\x04\xa1\x01\x02\x0c\
    \x12\x04\xec\r\x04(\x1a?\x20We\x20leave\x20some\x20index\x20space\x20her\
    e\x20in\x20case\x20we\x20add\x20more\x20subclasses\n\n\x0e\n\x06\x04\xa1\
    \x01\x02\x0c\x06\x12\x04\xec\r\x04\x17\n\x0e\n\x06\x04\xa1\x01\x02\x0c\
    \x01\x12\x04\xec\r\x18\"\n\x0e\n\x06\x04\xa1\x01\x02\x0c\x03\x12\x04\xec\
    \r%'\n\r\n\x03\x04\xa2\x01\x12\x06\xef\r\0\xf2\r\x01\n\x0c\n\x04\x04\xa2\
    \x01\x01\x12\x04\xef\r\x08\x1c\n\r\n\x05\x04\xa2\x01\x02\0\x12\x04\xf0\r\
    \x04\x1c\n\x0e\n\x06\x04\xa2\x01\x02\0\x05\x12\x04\xf0\r\x04\t\n\x0e\n\
    \x06\x04\xa2\x01\x02\0\x01\x12\x04\xf0\r\n\x17\n\x0e\n\x06\x04\xa2\x01\
    \x02\0\x03\x12\x04\xf0\r\x1a\x1b\n\r\n\x05\x04\xa2\x01\x02\x01\x12\x04\
    \xf1\r\x04\x1b\n\x0e\n\x06\x04\xa2\x01\x02\x01\x05\x12\x04\xf1\r\x04\n\n\
    \x0e\n\x06\x04\xa2\x01\x02\x01\x01\x12\x04\xf1\r\x0b\x16\n\x0e\n\x06\x04\
    \xa2\x01\x02\x01\x03\x12\x04\xf1\r\x19\x1a\n\r\n\x03\x04\xa3\x01\x12\x06\
    \xf4\r\0\xf7\r\x01\n\x0c\n\x04\x04\xa3\x01\x01\x12\x04\xf4\r\x08\x1d\n\r\
    \n\x05\x04\xa3\x01\x02\0\x12\x04\xf5\r\x04\x1c\n\x0e\n\x06\x04\xa3\x01\
    \x02\0\x05\x12\x04\xf5\r\x04\t\n\x0e\n\x06\x04\xa3\x01\x02\0\x01\x12\x04\
    \xf5\r\n\x17\n\x0e\n\x06\x04\xa3\x01\x02\0\x03\x12\x04\xf5\r\x1a\x1b\n\r\
    \n\x05\x04\xa3\x01\x02\x01\x12\x04\xf6\r\x04\x1b\n\x0e\n\x06\x04\xa3\x01\
    \x02\x01\x05\x12\x04\xf6\r\x04\n\n\x0e\n\x06\x04\xa3\x01\x02\x01\x01\x12\
    \x04\xf6\r\x0b\x16\n\x0e\n\x06\x04\xa3\x01\x02\x01\x03\x12\x04\xf6\r\x19\
    \x1a\n\r\n\x03\x04\xa4\x01\x12\x06\xf9\r\0\xfc\r\x01\n\x0c\n\x04\x04\xa4\
    \x01\x01\x12\x04\xf9\r\x08\x1b\n\x1d\n\x05\x04\xa4\x01\x02\0\x12\x04\xfa\
    \r\x04\x15\"\x0e\x20name\x20of\x20enum\n\n\x0e\n\x06\x04\xa4\x01\x02\0\
    \x05\x12\x04\xfa\r\x04\n\n\x0e\n\x06\x04\xa4\x01\x02\0\x01\x12\x04\xfa\r\
    \x0b\x10\n\x0e\n\x06\x04\xa4\x01\x02\0\x03\x12\x04\xfa\r\x13\x14\n\r\n\
    \x05\x04\xa4\x01\x02\x01\x12\x04\xfb\r\x04\x1b\n\x0e\n\x06\x04\xa4\x01\
    \x02\x01\x05\x12\x04\xfb\r\x04\n\n\x0e\n\x06\x04\xa4\x01\x02\x01\x01\x12\
    \x04\xfb\r\x0b\x16\n\x0e\n\x06\x04\xa4\x01\x02\x01\x03\x12\x04\xfb\r\x19\
    \x1a\n\r\n\x03\x04\xa5\x01\x12\x06\xfe\r\0\x82\x0e\x01\n\x0c\n\x04\x04\
    \xa5\x01\x01\x12\x04\xfe\r\x08\x14\n\r\n\x05\x04\xa5\x01\x02\0\x12\x04\
    \xff\r\x04\x12\n\x0e\n\x06\x04\xa5\x01\x02\0\x06\x12\x04\xff\r\x04\x08\n\
    \x0e\n\x06\x04\xa5\x01\x02\0\x01\x12\x04\xff\r\t\r\n\x0e\n\x06\x04\xa5\
    \x01\x02\0\x03\x12\x04\xff\r\x10\x11\n\r\n\x05\x04\xa5\x01\x02\x01\x12\
    \x04\x80\x0e\x04!\n\x0e\n\x06\x04\xa5\x01\x02\x01\x05\x12\x04\x80\x0e\
    \x04\t\n\x0e\n\x06\x04\xa5\x01\x02\x01\x01\x12\x04\x80\x0e\n\x1c\n\x0e\n\
    \x06\x04\xa5\x01\x02\x01\x03\x12\x04\x80\x0e\x1f\x20\n\r\n\x05\x04\xa5\
    \x01\x02\x02\x12\x04\x81\x0e\x04\x1a\n\x0e\n\x06\x04\xa5\x01\x02\x02\x05\
    \x12\x04\x81\x0e\x04\t\n\x0e\n\x06\x04\xa5\x01\x02\x02\x01\x12\x04\x81\
    \x0e\n\x15\n\x0e\n\x06\x04\xa5\x01\x02\x02\x03\x12\x04\x81\x0e\x18\x19\n\
    \r\n\x03\x04\xa6\x01\x12\x06\x84\x0e\0\x86\x0e\x01\n\x0c\n\x04\x04\xa6\
    \x01\x01\x12\x04\x84\x0e\x08\x1e\n\r\n\x05\x04\xa6\x01\x02\0\x12\x04\x85\
    \x0e\x04\x1c\n\x0e\n\x06\x04\xa6\x01\x02\0\x05\x12\x04\x85\x0e\x04\n\n\
    \x0e\n\x06\x04\xa6\x01\x02\0\x01\x12\x04\x85\x0e\x0b\x17\n\x0e\n\x06\x04\
    \xa6\x01\x02\0\x03\x12\x04\x85\x0e\x1a\x1b\n\r\n\x03\x04\xa7\x01\x12\x06\
    \x88\x0e\0\x89\x0e\x01\n\x0c\n\x04\x04\xa7\x01\x01\x12\x04\x88\x0e\x08\
    \x17\n\r\n\x03\x04\xa8\x01\x12\x06\x8b\x0e\0\x8d\x0e\x01\n\x0c\n\x04\x04\
    \xa8\x01\x01\x12\x04\x8b\x0e\x08\x1b\n\r\n\x05\x04\xa8\x01\x02\0\x12\x04\
    \x8c\x0e\x04\x1d\n\x0e\n\x06\x04\xa8\x01\x02\0\x05\x12\x04\x8c\x0e\x04\n\
    \n\x0e\n\x06\x04\xa8\x01\x02\0\x01\x12\x04\x8c\x0e\x0b\x18\n\x0e\n\x06\
    \x04\xa8\x01\x02\0\x03\x12\x04\x8c\x0e\x1b\x1c\n\r\n\x03\x04\xa9\x01\x12\
    \x06\x8f\x0e\0\x94\x0e\x01\n\x0c\n\x04\x04\xa9\x01\x01\x12\x04\x8f\x0e\
    \x08\x0c\n\r\n\x05\x04\xa9\x01\x02\0\x12\x04\x90\x0e\x04\x13\n\x0e\n\x06\
    \x04\xa9\x01\x02\0\x05\x12\x04\x90\x0e\x04\n\n\x0e\n\x06\x04\xa9\x01\x02\
    \0\x01\x12\x04\x90\x0e\x0b\x0e\n\x0e\n\x06\x04\xa9\x01\x02\0\x03\x12\x04\
    \x90\x0e\x11\x12\n\r\n\x05\x04\xa9\x01\x02\x01\x12\x04\x91\x0e\x04\x14\n\
    \x0e\n\x06\x04\xa9\x01\x02\x01\x05\x12\x04\x91\x0e\x04\n\n\x0e\n\x06\x04\
    \xa9\x01\x02\x01\x01\x12\x04\x91\x0e\x0b\x0f\n\x0e\n\x06\x04\xa9\x01\x02\
    \x01\x03\x12\x04\x91\x0e\x12\x13\n\r\n\x05\x04\xa9\x01\x02\x02\x12\x04\
    \x92\x0e\x04\x14\n\x0e\n\x06\x04\xa9\x01\x02\x02\x05\x12\x04\x92\x0e\x04\
    \n\n\x0e\n\x06\x04\xa9\x01\x02\x02\x01\x12\x04\x92\x0e\x0b\x0f\n\x0e\n\
    \x06\x04\xa9\x01\x02\x02\x03\x12\x04\x92\x0e\x12\x13\n,\n\x05\x04\xa9\
    \x01\x02\x03\x12\x04\x93\x0e\x04\x20\"\x1d\x20name\x20of\x20BondedRoleTy\
    pe\x20enum\n\n\x0e\n\x06\x04\xa9\x01\x02\x03\x05\x12\x04\x93\x0e\x04\n\n\
    \x0e\n\x06\x04\xa9\x01\x02\x03\x01\x12\x04\x93\x0e\x0b\x1b\n\x0e\n\x06\
    \x04\xa9\x01\x02\x03\x03\x12\x04\x93\x0e\x1e\x1f\n\r\n\x03\x04\xaa\x01\
    \x12\x06\x96\x0e\0\x99\x0e\x01\n\x0c\n\x04\x04\xaa\x01\x01\x12\x04\x96\
    \x0e\x08\x14\n\r\n\x05\x04\xaa\x01\x02\0\x12\x04\x97\x0e\x04\x13\n\x0e\n\
    \x06\x04\xaa\x01\x02\0\x05\x12\x04\x97\x0e\x04\n\n\x0e\n\x06\x04\xaa\x01\
    \x02\0\x01\x12\x04\x97\x0e\x0b\x0e\n\x0e\n\x06\x04\xaa\x01\x02\0\x03\x12\
    \x04\x97\x0e\x11\x12\n\r\n\x05\x04\xaa\x01\x02\x01\x12\x04\x98\x0e\x04\
    \x13\n\x0e\n\x06\x04\xaa\x01\x02\x01\x05\x12\x04\x98\x0e\x04\t\n\x0e\n\
    \x06\x04\xaa\x01\x02\x01\x01\x12\x04\x98\x0e\n\x0e\n\x0e\n\x06\x04\xaa\
    \x01\x02\x01\x03\x12\x04\x98\x0e\x11\x12\n\r\n\x03\x04\xab\x01\x12\x06\
    \x9b\x0e\0\x9d\x0e\x01\n\x0c\n\x04\x04\xab\x01\x01\x12\x04\x9b\x0e\x08\
    \x18\n\r\n\x05\x04\xab\x01\x02\0\x12\x04\x9c\x0e\x04,\n\x0e\n\x06\x04\
    \xab\x01\x02\0\x04\x12\x04\x9c\x0e\x04\x0c\n\x0e\n\x06\x04\xab\x01\x02\0\
    \x06\x12\x04\x9c\x0e\r\x19\n\x0e\n\x06\x04\xab\x01\x02\0\x01\x12\x04\x9c\
    \x0e\x1a'\n\x0e\n\x06\x04\xab\x01\x02\0\x03\x12\x04\x9c\x0e*+\n\r\n\x03\
    \x04\xac\x01\x12\x06\x9f\x0e\0\xa2\x0e\x01\n\x0c\n\x04\x04\xac\x01\x01\
    \x12\x04\x9f\x0e\x08\x15\n\r\n\x05\x04\xac\x01\x02\0\x12\x04\xa0\x0e\x04\
    \x15\n\x0e\n\x06\x04\xac\x01\x02\0\x05\x12\x04\xa0\x0e\x04\n\n\x0e\n\x06\
    \x04\xac\x01\x02\0\x01\x12\x04\xa0\x0e\x0b\x10\n\x0e\n\x06\x04\xac\x01\
    \x02\0\x03\x12\x04\xa0\x0e\x13\x14\n\r\n\x05\x04\xac\x01\x02\x01\x12\x04\
    \xa1\x0e\x04\x19\n\x0e\n\x06\x04\xac\x01\x02\x01\x05\x12\x04\xa1\x0e\x04\
    \n\n\x0e\n\x06\x04\xac\x01\x02\x01\x01\x12\x04\xa1\x0e\x0b\x14\n\x0e\n\
    \x06\x04\xac\x01\x02\x01\x03\x12\x04\xa1\x0e\x17\x18\n\r\n\x03\x04\xad\
    \x01\x12\x06\xa4\x0e\0\xa6\x0e\x01\n\x0c\n\x04\x04\xad\x01\x01\x12\x04\
    \xa4\x0e\x08\x19\n\r\n\x05\x04\xad\x01\x02\0\x12\x04\xa5\x0e\x040\n\x0e\
    \n\x06\x04\xad\x01\x02\0\x04\x12\x04\xa5\x0e\x04\x0c\n\x0e\n\x06\x04\xad\
    \x01\x02\0\x06\x12\x04\xa5\x0e\r\x1a\n\x0e\n\x06\x04\xad\x01\x02\0\x01\
    \x12\x04\xa5\x0e\x1b+\n\x0e\n\x06\x04\xad\x01\x02\0\x03\x12\x04\xa5\x0e.\
    /\n\r\n\x03\x04\xae\x01\x12\x06\xa8\x0e\0\xaa\x0e\x01\n\x0c\n\x04\x04\
    \xae\x01\x01\x12\x04\xa8\x0e\x08&\n\r\n\x05\x04\xae\x01\x02\0\x12\x04\
    \xa9\x0e\x04;\n\x0e\n\x06\x04\xae\x01\x02\0\x04\x12\x04\xa9\x0e\x04\x0c\
    \n\x0e\n\x06\x04\xae\x01\x02\0\x06\x12\x04\xa9\x0e\r\x20\n\x0e\n\x06\x04\
    \xae\x01\x02\0\x01\x12\x04\xa9\x0e!6\n\x0e\n\x06\x04\xae\x01\x02\0\x03\
    \x12\x04\xa9\x0e9:\n\r\n\x03\x04\xaf\x01\x12\x06\xac\x0e\0\xb0\x0e\x01\n\
    \x0c\n\x04\x04\xaf\x01\x01\x12\x04\xac\x0e\x08\x1b\n\r\n\x05\x04\xaf\x01\
    \x02\0\x12\x04\xad\x0e\x04\x1a\n\x0e\n\x06\x04\xaf\x01\x02\0\x06\x12\x04\
    \xad\x0e\x04\x0c\n\x0e\n\x06\x04\xaf\x01\x02\0\x01\x12\x04\xad\x0e\r\x15\
    \n\x0e\n\x06\x04\xaf\x01\x02\0\x03\x12\x04\xad\x0e\x18\x19\n\r\n\x05\x04\
    \xaf\x01\x02\x01\x12\x04\xae\x0e\x04$\n\x0e\n\x06\x04\xaf\x01\x02\x01\
    \x05\x12\x04\xae\x0e\x04\t\n\x0e\n\x06\x04\xaf\x01\x02\x01\x01\x12\x04\
    \xae\x0e\n\x1f\n\x0e\n\x06\x04\xaf\x01\x02\x01\x03\x12\x04\xae\x0e\"#\n\
    \r\n\x05\x04\xaf\x01\x02\x02\x12\x04\xaf\x0e\x04'\n\x0e\n\x06\x04\xaf\
    \x01\x02\x02\x06\x12\x04\xaf\x0e\x04\x17\n\x0e\n\x06\x04\xaf\x01\x02\x02\
    \x01\x12\x04\xaf\x0e\x18\"\n\x0e\n\x06\x04\xaf\x01\x02\x02\x03\x12\x04\
    \xaf\x0e%&\n\r\n\x03\x04\xb0\x01\x12\x06\xb2\x0e\0\xb5\x0e\x01\n\x0c\n\
    \x04\x04\xb0\x01\x01\x12\x04\xb2\x0e\x08\x17\n\r\n\x05\x04\xb0\x01\x02\0\
    \x12\x04\xb3\x0e\x04\x1a\n\x0e\n\x06\x04\xb0\x01\x02\0\x06\x12\x04\xb3\
    \x0e\x04\x0c\n\x0e\n\x06\x04\xb0\x01\x02\0\x01\x12\x04\xb3\x0e\r\x15\n\
    \x0e\n\x06\x04\xb0\x01\x02\0\x03\x12\x04\xb3\x0e\x18\x19\n\r\n\x05\x04\
    \xb0\x01\x02\x01\x12\x04\xb4\x0e\x04\x13\n\x0e\n\x06\x04\xb0\x01\x02\x01\
    \x05\x12\x04\xb4\x0e\x04\t\n\x0e\n\x06\x04\xb0\x01\x02\x01\x01\x12\x04\
    \xb4\x0e\n\x0e\n\x0e\n\x06\x04\xb0\x01\x02\x01\x03\x12\x04\xb4\x0e\x11\
    \x12\n\r\n\x03\x04\xb1\x01\x12\x06\xb7\x0e\0\xb9\x0e\x01\n\x0c\n\x04\x04\
    \xb1\x01\x01\x12\x04\xb7\x0e\x08\x15\n\r\n\x05\x04\xb1\x01\x02\0\x12\x04\
    \xb8\x0e\x04'\n\x0e\n\x06\x04\xb1\x01\x02\0\x04\x12\x04\xb8\x0e\x04\x0c\
    \n\x0e\n\x06\x04\xb1\x01\x02\0\x06\x12\x04\xb8\x0e\r\x1c\n\x0e\n\x06\x04\
    \xb1\x01\x02\0\x01\x12\x04\xb8\x0e\x1d\"\n\x0e\n\x06\x04\xb1\x01\x02\0\
    \x03\x12\x04\xb8\x0e%&\n\r\n\x03\x04\xb2\x01\x12\x06\xbb\x0e\0\xbd\x0e\
    \x01\n\x0c\n\x04\x04\xb2\x01\x01\x12\x04\xbb\x0e\x08\x19\n\r\n\x05\x04\
    \xb2\x01\x02\0\x12\x04\xbc\x0e\x04-\n\x0e\n\x06\x04\xb2\x01\x02\0\x04\
    \x12\x04\xbc\x0e\x04\x0c\n\x0e\n\x06\x04\xb2\x01\x02\0\x06\x12\x04\xbc\
    \x0e\r\"\n\x0e\n\x06\x04\xb2\x01\x02\0\x01\x12\x04\xbc\x0e#(\n\x0e\n\x06\
    \x04\xb2\x01\x02\0\x03\x12\x04\xbc\x0e+,\n\r\n\x03\x04\xb3\x01\x12\x06\
    \xbf\x0e\0\xc2\x0e\x01\n\x0c\n\x04\x04\xb3\x01\x01\x12\x04\xbf\x0e\x08\
    \x0e\n\r\n\x05\x04\xb3\x01\x02\0\x12\x04\xc0\x0e\x04\x1a\n\x0e\n\x06\x04\
    \xb3\x01\x02\0\x06\x12\x04\xc0\x0e\x04\x0c\n\x0e\n\x06\x04\xb3\x01\x02\0\
    \x01\x12\x04\xc0\x0e\r\x15\n\x0e\n\x06\x04\xb3\x01\x02\0\x03\x12\x04\xc0\
    \x0e\x18\x19\n\r\n\x05\x04\xb3\x01\x02\x01\x12\x04\xc1\x0e\x04\x12\n\x0e\
    \n\x06\x04\xb3\x01\x02\x01\x06\x12\x04\xc1\x0e\x04\x08\n\x0e\n\x06\x04\
    \xb3\x01\x02\x01\x01\x12\x04\xc1\x0e\t\r\n\x0e\n\x06\x04\xb3\x01\x02\x01\
    \x03\x12\x04\xc1\x0e\x10\x11\n\r\n\x03\x04\xb4\x01\x12\x06\xc4\x0e\0\xc6\
    \x0e\x01\n\x0c\n\x04\x04\xb4\x01\x01\x12\x04\xc4\x0e\x08\x16\n\r\n\x05\
    \x04\xb4\x01\x02\0\x12\x04\xc5\x0e\x04#\n\x0e\n\x06\x04\xb4\x01\x02\0\
    \x04\x12\x04\xc5\x0e\x04\x0c\n\x0e\n\x06\x04\xb4\x01\x02\0\x06\x12\x04\
    \xc5\x0e\r\x15\n\x0e\n\x06\x04\xb4\x01\x02\0\x01\x12\x04\xc5\x0e\x16\x1e\
    \n\x0e\n\x06\x04\xb4\x01\x02\0\x03\x12\x04\xc5\x0e!\"\n\r\n\x03\x04\xb5\
    \x01\x12\x06\xc8\x0e\0\xca\x0e\x01\n\x0c\n\x04\x04\xb5\x01\x01\x12\x04\
    \xc8\x0e\x08\x12\n\r\n\x05\x04\xb5\x01\x02\0\x12\x04\xc9\x0e\x04\x1f\n\
    \x0e\n\x06\x04\xb5\x01\x02\0\x04\x12\x04\xc9\x0e\x04\x0c\n\x0e\n\x06\x04\
    \xb5\x01\x02\0\x06\x12\x04\xc9\x0e\r\x13\n\x0e\n\x06\x04\xb5\x01\x02\0\
    \x01\x12\x04\xc9\x0e\x14\x1a\n\x0e\n\x06\x04\xb5\x01\x02\0\x03\x12\x04\
    \xc9\x0e\x1d\x1e\n\r\n\x03\x04\xb6\x01\x12\x06\xcc\x0e\0\xd0\x0e\x01\n\
    \x0c\n\x04\x04\xb6\x01\x01\x12\x04\xcc\x0e\x08\x13\n\r\n\x05\x04\xb6\x01\
    \x02\0\x12\x04\xcd\x0e\x04\x1a\n\x0e\n\x06\x04\xb6\x01\x02\0\x05\x12\x04\
    \xcd\x0e\x04\n\n\x0e\n\x06\x04\xb6\x01\x02\0\x01\x12\x04\xcd\x0e\x0b\x15\
    \n\x0e\n\x06\x04\xb6\x01\x02\0\x03\x12\x04\xcd\x0e\x18\x19\n\r\n\x05\x04\
    \xb6\x01\x02\x01\x12\x04\xce\x0e\x04\x1b\n\x0e\n\x06\x04\xb6\x01\x02\x01\
    \x05\x12\x04\xce\x0e\x04\n\n\x0e\n\x06\x04\xb6\x01\x02\x01\x01\x12\x04\
    \xce\x0e\x0b\x16\n\x0e\n\x06\x04\xb6\x01\x02\x01\x03\x12\x04\xce\x0e\x19\
    \x1a\n\r\n\x05\x04\xb6\x01\x02\x02\x12\x04\xcf\x0e\x04\x20\n\x0e\n\x06\
    \x04\xb6\x01\x02\x02\x05\x12\x04\xcf\x0e\x04\t\n\x0e\n\x06\x04\xb6\x01\
    \x02\x02\x01\x12\x04\xcf\x0e\n\x1b\n\x0e\n\x06\x04\xb6\x01\x02\x02\x03\
    \x12\x04\xcf\x0e\x1e\x1f\n\r\n\x03\x04\xb7\x01\x12\x06\xd2\x0e\0\xd4\x0e\
    \x01\n\x0c\n\x04\x04\xb7\x01\x01\x12\x04\xd2\x0e\x08\x16\n\r\n\x05\x04\
    \xb7\x01\x02\0\x12\x04\xd3\x0e\x04\x1c\n\x0e\n\x06\x04\xb7\x01\x02\0\x05\
    \x12\x04\xd3\x0e\x04\n\n\x0e\n\x06\x04\xb7\x01\x02\0\x01\x12\x04\xd3\x0e\
    \x0b\x17\n\x0e\n\x06\x04\xb7\x01\x02\0\x03\x12\x04\xd3\x0e\x1a\x1b\n\r\n\
    \x03\x04\xb8\x01\x12\x06\xd6\x0e\0\xdd\x0e\x01\n\x0c\n\x04\x04\xb8\x01\
    \x01\x12\x04\xd6\x0e\x08\x0e\n\r\n\x05\x04\xb8\x01\x02\0\x12\x04\xd7\x0e\
    \x04\x15\n\x0e\n\x06\x04\xb8\x01\x02\0\x05\x12\x04\xd7\x0e\x04\t\n\x0e\n\
    \x06\x04\xb8\x01\x02\0\x01\x12\x04\xd7\x0e\n\x10\n\x0e\n\x06\x04\xb8\x01\
    \x02\0\x03\x12\x04\xd7\x0e\x13\x14\n\r\n\x05\x04\xb8\x01\x02\x01\x12\x04\
    \xd8\x0e\x04\x1f\n\x0e\n\x06\x04\xb8\x01\x02\x01\x06\x12\x04\xd8\x0e\x04\
    \x0e\n\x0e\n\x06\x04\xb8\x01\x02\x01\x01\x12\x04\xd8\x0e\x0f\x1a\n\x0e\n\
    \x06\x04\xb8\x01\x02\x01\x03\x12\x04\xd8\x0e\x1d\x1e\n\r\n\x05\x04\xb8\
    \x01\x02\x02\x12\x04\xd9\x0e\x04!\n\x0e\n\x06\x04\xb8\x01\x02\x02\x05\
    \x12\x04\xd9\x0e\x04\t\n\x0e\n\x06\x04\xb8\x01\x02\x02\x01\x12\x04\xd9\
    \x0e\n\x1c\n\x0e\n\x06\x04\xb8\x01\x02\x02\x03\x12\x04\xd9\x0e\x1f\x20\n\
    \r\n\x05\x04\xb8\x01\x02\x03\x12\x04\xda\x0e\x04\x1d\n\x0e\n\x06\x04\xb8\
    \x01\x02\x03\x06\x12\x04\xda\x0e\x04\r\n\x0e\n\x06\x04\xb8\x01\x02\x03\
    \x01\x12\x04\xda\x0e\x0e\x18\n\x0e\n\x06\x04\xb8\x01\x02\x03\x03\x12\x04\
    \xda\x0e\x1b\x1c\n\r\n\x05\x04\xb8\x01\x02\x04\x12\x04\xdb\x0e\x04\x13\n\
    \x0e\n\x06\x04\xb8\x01\x02\x04\x05\x12\x04\xdb\x0e\x04\t\n\x0e\n\x06\x04\
    \xb8\x01\x02\x04\x01\x12\x04\xdb\x0e\n\x0e\n\x0e\n\x06\x04\xb8\x01\x02\
    \x04\x03\x12\x04\xdb\x0e\x11\x12\n\r\n\x05\x04\xb8\x01\x02\x05\x12\x04\
    \xdc\x0e\x04\x1c\n\x0e\n\x06\x04\xb8\x01\x02\x05\x05\x12\x04\xdc\x0e\x04\
    \n\n\x0e\n\x06\x04\xb8\x01\x02\x05\x01\x12\x04\xdc\x0e\x0b\x17\n\x0e\n\
    \x06\x04\xb8\x01\x02\x05\x03\x12\x04\xdc\x0e\x1a\x1b\n\r\n\x03\x04\xb9\
    \x01\x12\x06\xdf\x0e\0\xe1\x0e\x01\n\x0c\n\x04\x04\xb9\x01\x01\x12\x04\
    \xdf\x0e\x08\x12\n\r\n\x05\x04\xb9\x01\x02\0\x12\x04\xe0\x0e\x04\x20\n\
    \x0e\n\x06\x04\xb9\x01\x02\0\x04\x12\x04\xe0\x0e\x04\x0c\n\x0e\n\x06\x04\
    \xb9\x01\x02\0\x06\x12\x04\xe0\x0e\r\x13\n\x0e\n\x06\x04\xb9\x01\x02\0\
    \x01\x12\x04\xe0\x0e\x14\x1b\n\x0e\n\x06\x04\xb9\x01\x02\0\x03\x12\x04\
    \xe0\x0e\x1e\x1f\n\r\n\x03\x04\xba\x01\x12\x06\xe3\x0e\0\xe6\x0e\x01\n\
    \x0c\n\x04\x04\xba\x01\x01\x12\x04\xe3\x0e\x08\x1c\n\r\n\x05\x04\xba\x01\
    \x02\0\x12\x04\xe4\x0e\x04\x1e\n\x0e\n\x06\x04\xba\x01\x02\0\x05\x12\x04\
    \xe4\x0e\x04\n\n\x0e\n\x06\x04\xba\x01\x02\0\x01\x12\x04\xe4\x0e\x0b\x19\
    \n\x0e\n\x06\x04\xba\x01\x02\0\x03\x12\x04\xe4\x0e\x1c\x1d\n\r\n\x05\x04\
    \xba\x01\x02\x01\x12\x04\xe5\x0e\x04\x12\n\x0e\n\x06\x04\xba\x01\x02\x01\
    \x06\x12\x04\xe5\x0e\x04\x08\n\x0e\n\x06\x04\xba\x01\x02\x01\x01\x12\x04\
    \xe5\x0e\t\r\n\x0e\n\x06\x04\xba\x01\x02\x01\x03\x12\x04\xe5\x0e\x10\x11\
    \n\r\n\x03\x04\xbb\x01\x12\x06\xe8\x0e\0\xea\x0e\x01\n\x0c\n\x04\x04\xbb\
    \x01\x01\x12\x04\xe8\x0e\x08\x20\n\r\n\x05\x04\xbb\x01\x02\0\x12\x04\xe9\
    \x0e\x04+\n\x0e\n\x06\x04\xbb\x01\x02\0\x04\x12\x04\xe9\x0e\x04\x0c\n\
    \x0e\n\x06\x04\xbb\x01\x02\0\x06\x12\x04\xe9\x0e\r!\n\x0e\n\x06\x04\xbb\
    \x01\x02\0\x01\x12\x04\xe9\x0e\"&\n\x0e\n\x06\x04\xbb\x01\x02\0\x03\x12\
    \x04\xe9\x0e)*\n\r\n\x03\x04\xbc\x01\x12\x06\xec\x0e\0\xf3\x0e\x01\n\x0c\
    \n\x04\x04\xbc\x01\x01\x12\x04\xec\x0e\x08\x11\n\r\n\x05\x04\xbc\x01\x02\
    \0\x12\x04\xed\x0e\x04\x1e\n\x0e\n\x06\x04\xbc\x01\x02\0\x05\x12\x04\xed\
    \x0e\x04\t\n\x0e\n\x06\x04\xbc\x01\x02\0\x01\x12\x04\xed\x0e\n\x19\n\x0e\
    \n\x06\x04\xbc\x01\x02\0\x03\x12\x04\xed\x0e\x1c\x1d\n\r\n\x05\x04\xbc\
    \x01\x02\x01\x12\x04\xee\x0e\x04\x15\n\x0e\n\x06\x04\xbc\x01\x02\x01\x05\
    \x12\x04\xee\x0e\x04\n\n\x0e\n\x06\x04\xbc\x01\x02\x01\x01\x12\x04\xee\
    \x0e\x0b\x10\n\x0e\n\x06\x04\xbc\x01\x02\x01\x03\x12\x04\xee\x0e\x13\x14\
    \n\r\n\x05\x04\xbc\x01\x02\x02\x12\x04\xef\x0e\x04\x14\n\x0e\n\x06\x04\
    \xbc\x01\x02\x02\x05\x12\x04\xef\x0e\x04\t\n\x0e\n\x06\x04\xbc\x01\x02\
    \x02\x01\x12\x04\xef\x0e\n\x0f\n\x0e\n\x06\x04\xbc\x01\x02\x02\x03\x12\
    \x04\xef\x0e\x12\x13\n\r\n\x05\x04\xbc\x01\x02\x03\x12\x04\xf0\x0e\x04#\
    \n\x0e\n\x06\x04\xbc\x01\x02\x03\x05\x12\x04\xf0\x0e\x04\t\n\x0e\n\x06\
    \x04\xbc\x01\x02\x03\x01\x12\x04\xf0\x0e\n\x1e\n\x0e\n\x06\x04\xbc\x01\
    \x02\x03\x03\x12\x04\xf0\x0e!\"\n\r\n\x05\x04\xbc\x01\x02\x04\x12\x04\
    \xf1\x0e\x04\x13\n\x0e\n\x06\x04\xbc\x01\x02\x04\x05\x12\x04\xf1\x0e\x04\
    \t\n\x0e\n\x06\x04\xbc\x01\x02\x04\x01\x12\x04\xf1\x0e\n\x0e\n\x0e\n\x06\
    \x04\xbc\x01\x02\x04\x03\x12\x04\xf1\x0e\x11\x12\n\r\n\x05\x04\xbc\x01\
    \x02\x05\x12\x04\xf2\x0e\x04'\n\x0e\n\x06\x04\xbc\x01\x02\x05\x06\x12\
    \x04\xf2\x0e\x04\x17\n\x0e\n\x06\x04\xbc\x01\x02\x05\x01\x12\x04\xf2\x0e\
    \x18\"\n\x0e\n\x06\x04\xbc\x01\x02\x05\x03\x12\x04\xf2\x0e%&\n\r\n\x03\
    \x04\xbd\x01\x12\x06\xf5\x0e\0\xf7\x0e\x01\n\x0c\n\x04\x04\xbd\x01\x01\
    \x12\x04\xf5\x0e\x08\x17\n\r\n\x05\x04\xbd\x01\x02\0\x12\x04\xf6\x0e\x04\
    &\n\x0e\n\x06\x04\xbd\x01\x02\0\x04\x12\x04\xf6\x0e\x04\x0c\n\x0e\n\x06\
    \x04\xbd\x01\x02\0\x06\x12\x04\xf6\x0e\r\x16\n\x0e\n\x06\x04\xbd\x01\x02\
    \0\x01\x12\x04\xf6\x0e\x17!\n\x0e\n\x06\x04\xbd\x01\x02\0\x03\x12\x04\
    \xf6\x0e$%\n\r\n\x03\x04\xbe\x01\x12\x06\xf9\x0e\0\xfb\x0e\x01\n\x0c\n\
    \x04\x04\xbe\x01\x01\x12\x04\xf9\x0e\x08\x16\n\r\n\x05\x04\xbe\x01\x02\0\
    \x12\x04\xfa\x0e\x04(\n\x0e\n\x06\x04\xbe\x01\x02\0\x04\x12\x04\xfa\x0e\
    \x04\x0c\n\x0e\n\x06\x04\xbe\x01\x02\0\x06\x12\x04\xfa\x0e\r\x1d\n\x0e\n\
    \x06\x04\xbe\x01\x02\0\x01\x12\x04\xfa\x0e\x1e#\n\x0e\n\x06\x04\xbe\x01\
    \x02\0\x03\x12\x04\xfa\x0e&'\n\r\n\x03\x04\xbf\x01\x12\x06\xfd\x0e\0\x80\
    \x0f\x01\n\x0c\n\x04\x04\xbf\x01\x01\x12\x04\xfd\x0e\x08\x18\n\r\n\x05\
    \x04\xbf\x01\x02\0\x12\x04\xfe\x0e\x04\x1d\n\x0e\n\x06\x04\xbf\x01\x02\0\
    \x06\x12\x04\xfe\x0e\x04\r\n\x0e\n\x06\x04\xbf\x01\x02\0\x01\x12\x04\xfe\
    \x0e\x0e\x18\n\x0e\n\x06\x04\xbf\x01\x02\0\x03\x12\x04\xfe\x0e\x1b\x1c\n\
    \r\n\x05\x04\xbf\x01\x02\x01\x12\x04\xff\x0e\x04\x13\n\x0e\n\x06\x04\xbf\
    \x01\x02\x01\x05\x12\x04\xff\x0e\x04\t\n\x0e\n\x06\x04\xbf\x01\x02\x01\
    \x01\x12\x04\xff\x0e\n\x0e\n\x0e\n\x06\x04\xbf\x01\x02\x01\x03\x12\x04\
    \xff\x0e\x11\x12\n\r\n\x03\x04\xc0\x01\x12\x06\x82\x0f\0\x84\x0f\x01\n\
    \x0c\n\x04\x04\xc0\x01\x01\x12\x04\x82\x0f\x08\x0c\n\r\n\x05\x04\xc0\x01\
    \x02\0\x12\x04\x83\x0f\x04\x16\n\x0e\n\x06\x04\xc0\x01\x02\0\x05\x12\x04\
    \x83\x0f\x04\x08\n\x0e\n\x06\x04\xc0\x01\x02\0\x01\x12\x04\x83\x0f\t\x11\
    \n\x0e\n\x06\x04\xc0\x01\x02\0\x03\x12\x04\x83\x0f\x14\x15\n\r\n\x03\x04\
    \xc1\x01\x12\x06\x86\x0f\0\x89\x0f\x01\n\x0c\n\x04\x04\xc1\x01\x01\x12\
    \x04\x86\x0f\x08\r\n\r\n\x05\x04\xc1\x01\x02\0\x12\x04\x87\x0f\x04\x1a\n\
    \x0e\n\x06\x04\xc1\x01\x02\0\x06\x12\x04\x87\x0f\x04\x0c\n\x0e\n\x06\x04\
    \xc1\x01\x02\0\x01\x12\x04\x87\x0f\r\x15\n\x0e\n\x06\x04\xc1\x01\x02\0\
    \x03\x12\x04\x87\x0f\x18\x19\n\r\n\x05\x04\xc1\x01\x02\x01\x12\x04\x88\
    \x0f\x04\x18\n\x0e\n\x06\x04\xc1\x01\x02\x01\x05\x12\x04\x88\x0f\x04\t\n\
    \x0e\n\x06\x04\xc1\x01\x02\x01\x01\x12\x04\x88\x0f\n\x13\n\x0e\n\x06\x04\
    \xc1\x01\x02\x01\x03\x12\x04\x88\x0f\x16\x17\n\r\n\x03\x04\xc2\x01\x12\
    \x06\x8b\x0f\0\x8d\x0f\x01\n\x0c\n\x04\x04\xc2\x01\x01\x12\x04\x8b\x0f\
    \x08\x11\n\r\n\x05\x04\xc2\x01\x02\0\x12\x04\x8c\x0f\x04\x1d\n\x0e\n\x06\
    \x04\xc2\x01\x02\0\x04\x12\x04\x8c\x0f\x04\x0c\n\x0e\n\x06\x04\xc2\x01\
    \x02\0\x06\x12\x04\x8c\x0f\r\x12\n\x0e\n\x06\x04\xc2\x01\x02\0\x01\x12\
    \x04\x8c\x0f\x13\x18\n\x0e\n\x06\x04\xc2\x01\x02\0\x03\x12\x04\x8c\x0f\
    \x1b\x1c\n\r\n\x03\x04\xc3\x01\x12\x06\x8f\x0f\0\x96\x0f\x01\n\x0c\n\x04\
    \x04\xc3\x01\x01\x12\x04\x8f\x0f\x08\x1a\n\r\n\x05\x04\xc3\x01\x02\0\x12\
    \x04\x90\x0f\x04\x1a\n\x0e\n\x06\x04\xc3\x01\x02\0\x06\x12\x04\x90\x0f\
    \x04\x0c\n\x0e\n\x06\x04\xc3\x01\x02\0\x01\x12\x04\x90\x0f\r\x15\n\x0e\n\
    \x06\x04\xc3\x01\x02\0\x03\x12\x04\x90\x0f\x18\x19\n\r\n\x05\x04\xc3\x01\
    \x02\x01\x12\x04\x91\x0f\x04&\n\x0e\n\x06\x04\xc3\x01\x02\x01\x05\x12\
    \x04\x91\x0f\x04\t\n\x0e\n\x06\x04\xc3\x01\x02\x01\x01\x12\x04\x91\x0f\n\
    !\n\x0e\n\x06\x04\xc3\x01\x02\x01\x03\x12\x04\x91\x0f$%\n\r\n\x05\x04\
    \xc3\x01\x02\x02\x12\x04\x92\x0f\x04&\n\x0e\n\x06\x04\xc3\x01\x02\x02\
    \x05\x12\x04\x92\x0f\x04\t\n\x0e\n\x06\x04\xc3\x01\x02\x02\x01\x12\x04\
    \x92\x0f\n!\n\x0e\n\x06\x04\xc3\x01\x02\x02\x03\x12\x04\x92\x0f$%\n\r\n\
    \x05\x04\xc3\x01\x02\x03\x12\x04\x93\x0f\x04!\n\x0e\n\x06\x04\xc3\x01\
    \x02\x03\x05\x12\x04\x93\x0f\x04\t\n\x0e\n\x06\x04\xc3\x01\x02\x03\x01\
    \x12\x04\x93\x0f\n\x1c\n\x0e\n\x06\x04\xc3\x01\x02\x03\x03\x12\x04\x93\
    \x0f\x1f\x20\n\r\n\x05\x04\xc3\x01\x02\x04\x12\x04\x94\x0f\x04!\n\x0e\n\
    \x06\x04\xc3\x01\x02\x04\x05\x12\x04\x94\x0f\x04\t\n\x0e\n\x06\x04\xc3\
    \x01\x02\x04\x01\x12\x04\x94\x0f\n\x1c\n\x0e\n\x06\x04\xc3\x01\x02\x04\
    \x03\x12\x04\x94\x0f\x1f\x20\n\r\n\x05\x04\xc3\x01\x02\x05\x12\x04\x95\
    \x0f\x04\x20\n\x0e\n\x06\x04\xc3\x01\x02\x05\x05\x12\x04\x95\x0f\x04\t\n\
    \x0e\n\x06\x04\xc3\x01\x02\x05\x01\x12\x04\x95\x0f\n\x1b\n\x0e\n\x06\x04\
    \xc3\x01\x02\x05\x03\x12\x04\x95\x0f\x1e\x1f\n\r\n\x03\x04\xc4\x01\x12\
    \x06\x98\x0f\0\x9b\x0f\x01\n\x0c\n\x04\x04\xc4\x01\x01\x12\x04\x98\x0f\
    \x08\x19\n\r\n\x05\x04\xc4\x01\x02\0\x12\x04\x99\x0f\x04\x19\n\x0e\n\x06\
    \x04\xc4\x01\x02\0\x05\x12\x04\x99\x0f\x04\x08\n\x0e\n\x06\x04\xc4\x01\
    \x02\0\x01\x12\x04\x99\x0f\t\x14\n\x0e\n\x06\x04\xc4\x01\x02\0\x03\x12\
    \x04\x99\x0f\x17\x18\n\r\n\x05\x04\xc4\x01\x02\x01\x12\x04\x9a\x0f\x040\
    \n\x0e\n\x06\x04\xc4\x01\x02\x01\x06\x12\x04\x9a\x0f\x04\x16\n\x0e\n\x06\
    \x04\xc4\x01\x02\x01\x01\x12\x04\x9a\x0f\x17+\n\x0e\n\x06\x04\xc4\x01\
    \x02\x01\x03\x12\x04\x9a\x0f./\n\r\n\x03\x04\xc5\x01\x12\x06\x9d\x0f\0\
    \xa4\x0f\x01\n\x0c\n\x04\x04\xc5\x01\x01\x12\x04\x9d\x0f\x08\"\n\r\n\x05\
    \x04\xc5\x01\x02\0\x12\x04\x9e\x0f\x04&\n\x0e\n\x06\x04\xc5\x01\x02\0\
    \x05\x12\x04\x9e\x0f\x04\t\n\x0e\n\x06\x04\xc5\x01\x02\0\x01\x12\x04\x9e\
    \x0f\n!\n\x0e\n\x06\x04\xc5\x01\x02\0\x03\x12\x04\x9e\x0f$%\n\r\n\x05\
    \x04\xc5\x01\x02\x01\x12\x04\x9f\x0f\x04\x20\n\x0e\n\x06\x04\xc5\x01\x02\
    \x01\x05\x12\x04\x9f\x0f\x04\n\n\x0e\n\x06\x04\xc5\x01\x02\x01\x01\x12\
    \x04\x9f\x0f\x0b\x1b\n\x0e\n\x06\x04\xc5\x01\x02\x01\x03\x12\x04\x9f\x0f\
    \x1e\x1f\n\r\n\x05\x04\xc5\x01\x02\x02\x12\x04\xa0\x0f\x04!\n\x0e\n\x06\
    \x04\xc5\x01\x02\x02\x05\x12\x04\xa0\x0f\x04\n\n\x0e\n\x06\x04\xc5\x01\
    \x02\x02\x01\x12\x04\xa0\x0f\x0b\x1c\n\x0e\n\x06\x04\xc5\x01\x02\x02\x03\
    \x12\x04\xa0\x0f\x1f\x20\n\r\n\x05\x04\xc5\x01\x02\x03\x12\x04\xa1\x0f\
    \x04\x14\n\x0e\n\x06\x04\xc5\x01\x02\x03\x05\x12\x04\xa1\x0f\x04\t\n\x0e\
    \n\x06\x04\xc5\x01\x02\x03\x01\x12\x04\xa1\x0f\n\x0f\n\x0e\n\x06\x04\xc5\
    \x01\x02\x03\x03\x12\x04\xa1\x0f\x12\x13\n\r\n\x05\x04\xc5\x01\x02\x04\
    \x12\x04\xa2\x0f\x04\x1f\n\x0e\n\x06\x04\xc5\x01\x02\x04\x06\x12\x04\xa2\
    \x0f\x04\x0e\n\x0e\n\x06\x04\xc5\x01\x02\x04\x01\x12\x04\xa2\x0f\x0f\x1a\
    \n\x0e\n\x06\x04\xc5\x01\x02\x04\x03\x12\x04\xa2\x0f\x1d\x1e\n\r\n\x05\
    \x04\xc5\x01\x02\x05\x12\x04\xa3\x0f\x04\x1d\n\x0e\n\x06\x04\xc5\x01\x02\
    \x05\x06\x12\x04\xa3\x0f\x04\r\n\x0e\n\x06\x04\xc5\x01\x02\x05\x01\x12\
    \x04\xa3\x0f\x0e\x18\n\x0e\n\x06\x04\xc5\x01\x02\x05\x03\x12\x04\xa3\x0f\
    \x1b\x1c\n\r\n\x03\x04\xc6\x01\x12\x06\xa6\x0f\0\xa9\x0f\x01\n\x0c\n\x04\
    \x04\xc6\x01\x01\x12\x04\xa6\x0f\x08\x15\n\r\n\x05\x04\xc6\x01\x02\0\x12\
    \x04\xa7\x0f\x04\x1b\n\x0e\n\x06\x04\xc6\x01\x02\0\x06\x12\x04\xa7\x0f\
    \x04\x0c\n\x0e\n\x06\x04\xc6\x01\x02\0\x01\x12\x04\xa7\x0f\r\x16\n\x0e\n\
    \x06\x04\xc6\x01\x02\0\x03\x12\x04\xa7\x0f\x19\x1a\n\r\n\x05\x04\xc6\x01\
    \x02\x01\x12\x04\xa8\x0f\x04-\n\x0e\n\x06\x04\xc6\x01\x02\x01\x04\x12\
    \x04\xa8\x0f\x04\x0c\n\x0e\n\x06\x04\xc6\x01\x02\x01\x06\x12\x04\xa8\x0f\
    \r\x19\n\x0e\n\x06\x04\xc6\x01\x02\x01\x01\x12\x04\xa8\x0f\x1a(\n\x0e\n\
    \x06\x04\xc6\x01\x02\x01\x03\x12\x04\xa8\x0f+,\n\r\n\x03\x04\xc7\x01\x12\
    \x06\xab\x0f\0\xaf\x0f\x01\n\x0c\n\x04\x04\xc7\x01\x01\x12\x04\xab\x0f\
    \x08\x14\n\r\n\x05\x04\xc7\x01\x02\0\x12\x04\xac\x0f\x04\x15\n\x0e\n\x06\
    \x04\xc7\x01\x02\0\x05\x12\x04\xac\x0f\x04\t\n\x0e\n\x06\x04\xc7\x01\x02\
    \0\x01\x12\x04\xac\x0f\n\x10\n\x0e\n\x06\x04\xc7\x01\x02\0\x03\x12\x04\
    \xac\x0f\x13\x14\n\r\n\x05\x04\xc7\x01\x02\x01\x12\x04\xad\x0f\x04\x13\n\
    \x0e\n\x06\x04\xc7\x01\x02\x01\x05\x12\x04\xad\x0f\x04\t\n\x0e\n\x06\x04\
    \xc7\x01\x02\x01\x01\x12\x04\xad\x0f\n\x0e\n\x0e\n\x06\x04\xc7\x01\x02\
    \x01\x03\x12\x04\xad\x0f\x11\x12\n\r\n\x05\x04\xc7\x01\x02\x02\x12\x04\
    \xae\x0f\x04\x18\n\x0e\n\x06\x04\xc7\x01\x02\x02\x05\x12\x04\xae\x0f\x04\
    \t\n\x0e\n\x06\x04\xc7\x01\x02\x02\x01\x12\x04\xae\x0f\n\x13\n\x0e\n\x06\
    \x04\xc7\x01\x02\x02\x03\x12\x04\xae\x0f\x16\x17\n\r\n\x03\x04\xc8\x01\
    \x12\x06\xb1\x0f\0\xb6\x0f\x01\n\x0c\n\x04\x04\xc8\x01\x01\x12\x04\xb1\
    \x0f\x08\x19\n\r\n\x05\x04\xc8\x01\x02\0\x12\x04\xb2\x0f\x04\x15\n\x0e\n\
    \x06\x04\xc8\x01\x02\0\x05\x12\x04\xb2\x0f\x04\t\n\x0e\n\x06\x04\xc8\x01\
    \x02\0\x01\x12\x04\xb2\x0f\n\x10\n\x0e\n\x06\x04\xc8\x01\x02\0\x03\x12\
    \x04\xb2\x0f\x13\x14\n\r\n\x05\x04\xc8\x01\x02\x01\x12\x04\xb3\x0f\x04\
    \x13\n\x0e\n\x06\x04\xc8\x01\x02\x01\x05\x12\x04\xb3\x0f\x04\t\n\x0e\n\
    \x06\x04\xc8\x01\x02\x01\x01\x12\x04\xb3\x0f\n\x0e\n\x0e\n\x06\x04\xc8\
    \x01\x02\x01\x03\x12\x04\xb3\x0f\x11\x12\n\r\n\x05\x04\xc8\x01\x02\x02\
    \x12\x04\xb4\x0f\x04\x18\n\x0e\n\x06\x04\xc8\x01\x02\x02\x05\x12\x04\xb4\
    \x0f\x04\t\n\x0e\n\x06\x04\xc8\x01\x02\x02\x01\x12\x04\xb4\x0f\n\x13\n\
    \x0e\n\x06\x04\xc8\x01\x02\x02\x03\x12\x04\xb4\x0f\x16\x17\n\r\n\x05\x04\
    \xc8\x01\x02\x03\x12\x04\xb5\x0f\x04\x1c\n\x0e\n\x06\x04\xc8\x01\x02\x03\
    \x05\x12\x04\xb5\x0f\x04\t\n\x0e\n\x06\x04\xc8\x01\x02\x03\x01\x12\x04\
    \xb5\x0f\n\x17\n\x0e\n\x06\x04\xc8\x01\x02\x03\x03\x12\x04\xb5\x0f\x1a\
    \x1b\n\r\n\x03\x04\xc9\x01\x12\x06\xb8\x0f\0\xbd\x0f\x01\n\x0c\n\x04\x04\
    \xc9\x01\x01\x12\x04\xb8\x0f\x08\x1a\n\r\n\x05\x04\xc9\x01\x02\0\x12\x04\
    \xb9\x0f\x04\x15\n\x0e\n\x06\x04\xc9\x01\x02\0\x05\x12\x04\xb9\x0f\x04\t\
    \n\x0e\n\x06\x04\xc9\x01\x02\0\x01\x12\x04\xb9\x0f\n\x10\n\x0e\n\x06\x04\
    \xc9\x01\x02\0\x03\x12\x04\xb9\x0f\x13\x14\n\r\n\x05\x04\xc9\x01\x02\x01\
    \x12\x04\xba\x0f\x04\x13\n\x0e\n\x06\x04\xc9\x01\x02\x01\x05\x12\x04\xba\
    \x0f\x04\t\n\x0e\n\x06\x04\xc9\x01\x02\x01\x01\x12\x04\xba\x0f\n\x0e\n\
    \x0e\n\x06\x04\xc9\x01\x02\x01\x03\x12\x04\xba\x0f\x11\x12\n\r\n\x05\x04\
    \xc9\x01\x02\x02\x12\x04\xbb\x0f\x04\x18\n\x0e\n\x06\x04\xc9\x01\x02\x02\
    \x05\x12\x04\xbb\x0f\x04\t\n\x0e\n\x06\x04\xc9\x01\x02\x02\x01\x12\x04\
    \xbb\x0f\n\x13\n\x0e\n\x06\x04\xc9\x01\x02\x02\x03\x12\x04\xbb\x0f\x16\
    \x17\n\r\n\x05\x04\xc9\x01\x02\x03\x12\x04\xbc\x0f\x04\x1e\n\x0e\n\x06\
    \x04\xc9\x01\x02\x03\x05\x12\x04\xbc\x0f\x04\t\n\x0e\n\x06\x04\xc9\x01\
    \x02\x03\x01\x12\x04\xbc\x0f\n\x19\n\x0e\n\x06\x04\xc9\x01\x02\x03\x03\
    \x12\x04\xbc\x0f\x1c\x1d\n\xca\x01\n\x03\x04\xca\x01\x12\x06\xc3\x0f\0\
    \xc7\x0f\x012\xba\x01///////////////////////////////////////////////////\
    //////////////////////////////////////\n\x20Misc\n//////////////////////\
    ///////////////////////////////////////////////////////////////////\n\n\
    \x0c\n\x04\x04\xca\x01\x01\x12\x04\xc3\x0f\x08\x1a\n\r\n\x05\x04\xca\x01\
    \x02\0\x12\x04\xc4\x0f\x04\x14\n\x0e\n\x06\x04\xca\x01\x02\0\x05\x12\x04\
    \xc4\x0f\x04\n\n\x0e\n\x06\x04\xca\x01\x02\0\x01\x12\x04\xc4\x0f\x0b\x0f\
    \n\x0e\n\x06\x04\xca\x01\x02\0\x03\x12\x04\xc4\x0f\x12\x13\n\r\n\x05\x04\
    \xca\x01\x02\x01\x12\x04\xc5\x0f\x04\x16\n\x0e\n\x06\x04\xca\x01\x02\x01\
    \x05\x12\x04\xc5\x0f\x04\n\n\x0e\n\x06\x04\xca\x01\x02\x01\x01\x12\x04\
    \xc5\x0f\x0b\x11\n\x0e\n\x06\x04\xca\x01\x02\x01\x03\x12\x04\xc5\x0f\x14\
    \x15\n\r\n\x05\x04\xca\x01\x02\x02\x12\x04\xc6\x0f\x04\x1b\n\x0e\n\x06\
    \x04\xca\x01\x02\x02\x05\x12\x04\xc6\x0f\x04\n\n\x0e\n\x06\x04\xca\x01\
    \x02\x02\x01\x12\x04\xc6\x0f\x0b\x16\n\x0e\n\x06\x04\xca\x01\x02\x02\x03\
    \x12\x04\xc6\x0f\x19\x1a\n\r\n\x03\x04\xcb\x01\x12\x06\xc9\x0f\0\xd1\x0f\
    \x01\n\x0c\n\x04\x04\xcb\x01\x01\x12\x04\xc9\x0f\x08\x16\n\r\n\x05\x04\
    \xcb\x01\x02\0\x12\x04\xca\x0f\x04\x12\n\x0e\n\x06\x04\xcb\x01\x02\0\x05\
    \x12\x04\xca\x0f\x04\n\n\x0e\n\x06\x04\xcb\x01\x02\0\x01\x12\x04\xca\x0f\
    \x0b\r\n\x0e\n\x06\x04\xcb\x01\x02\0\x03\x12\x04\xca\x0f\x10\x11\n\r\n\
    \x05\x04\xcb\x01\x02\x01\x12\x04\xcb\x0f\x04\x1c\n\x0e\n\x06\x04\xcb\x01\
    \x02\x01\x05\x12\x04\xcb\x0f\x04\t\n\x0e\n\x06\x04\xcb\x01\x02\x01\x01\
    \x12\x04\xcb\x0f\n\x17\n\x0e\n\x06\x04\xcb\x01\x02\x01\x03\x12\x04\xcb\
    \x0f\x1a\x1b\n\r\n\x05\x04\xcb\x01\x02\x02\x12\x04\xcc\x0f\x04%\n\x0e\n\
    \x06\x04\xcb\x01\x02\x02\x06\x12\x04\xcc\x0f\x04\x11\n\x0e\n\x06\x04\xcb\
    \x01\x02\x02\x01\x12\x04\xcc\x0f\x12\x20\n\x0e\n\x06\x04\xcb\x01\x02\x02\
    \x03\x12\x04\xcc\x0f#$\n\r\n\x05\x04\xcb\x01\x02\x03\x12\x04\xcd\x0f\x04\
    \x1c\n\x0e\n\x06\x04\xcb\x01\x02\x03\x05\x12\x04\xcd\x0f\x04\n\n\x0e\n\
    \x06\x04\xcb\x01\x02\x03\x01\x12\x04\xcd\x0f\x0b\x17\n\x0e\n\x06\x04\xcb\
    \x01\x02\x03\x03\x12\x04\xcd\x0f\x1a\x1b\n\r\n\x05\x04\xcb\x01\x02\x04\
    \x12\x04\xce\x0f\x040\n\x0e\n\x06\x04\xcb\x01\x02\x04\x04\x12\x04\xce\
    \x0f\x04\x0c\n\x0e\n\x06\x04\xcb\x01\x02\x04\x06\x12\x04\xce\x0f\r\x1a\n\
    \x0e\n\x06\x04\xcb\x01\x02\x04\x01\x12\x04\xce\x0f\x1b+\n\x0e\n\x06\x04\
    \xcb\x01\x02\x04\x03\x12\x04\xce\x0f./\n\r\n\x05\x04\xcb\x01\x02\x05\x12\
    \x04\xcf\x0f\x04.\n\x0e\n\x06\x04\xcb\x01\x02\x05\x06\x12\x04\xcf\x0f\
    \x04\x11\n\x0e\n\x06\x04\xcb\x01\x02\x05\x01\x12\x04\xcf\x0f\x12)\n\x0e\
    \n\x06\x04\xcb\x01\x02\x05\x03\x12\x04\xcf\x0f,-\n\r\n\x05\x04\xcb\x01\
    \x02\x06\x12\x04\xd0\x0f\x046\n\x0e\n\x06\x04\xcb\x01\x02\x06\x06\x12\
    \x04\xd0\x0f\x04\x19\n\x0e\n\x06\x04\xcb\x01\x02\x06\x01\x12\x04\xd0\x0f\
    \x1a1\n\x0e\n\x06\x04\xcb\x01\x02\x06\x03\x12\x04\xd0\x0f45\n\r\n\x03\
    \x04\xcc\x01\x12\x06\xd3\x0f\0\xd7\x0f\x01\n\x0c\n\x04\x04\xcc\x01\x01\
    \x12\x04\xd3\x0f\x08\x15\n\r\n\x05\x04\xcc\x01\x02\0\x12\x04\xd4\x0f\x04\
    \x12\n\x0e\n\x06\x04\xcc\x01\x02\0\x05\x12\x04\xd4\x0f\x04\n\n\x0e\n\x06\
    \x04\xcc\x01\x02\0\x01\x12\x04\xd4\x0f\x0b\r\n\x0e\n\x06\x04\xcc\x01\x02\
    \0\x03\x12\x04\xd4\x0f\x10\x11\n\r\n\x05\x04\xcc\x01\x02\x01\x12\x04\xd5\
    \x0f\x04\x1f\n\x0e\n\x06\x04\xcc\x01\x02\x01\x05\x12\x04\xd5\x0f\x04\t\n\
    \x0e\n\x06\x04\xcc\x01\x02\x01\x01\x12\x04\xd5\x0f\n\x1a\n\x0e\n\x06\x04\
    \xcc\x01\x02\x01\x03\x12\x04\xd5\x0f\x1d\x1e\n\r\n\x05\x04\xcc\x01\x02\
    \x02\x12\x04\xd6\x0f\x04\x1e\n\x0e\n\x06\x04\xcc\x01\x02\x02\x05\x12\x04\
    \xd6\x0f\x04\t\n\x0e\n\x06\x04\xcc\x01\x02\x02\x01\x12\x04\xd6\x0f\n\x19\
    \n\x0e\n\x06\x04\xcc\x01\x02\x02\x03\x12\x04\xd6\x0f\x1c\x1d\n\x19\n\x03\
    \x04\xcd\x01\x12\x06\xdb\x0f\0\xdd\x0f\x012\n\x20Currency\n\n\x0c\n\x04\
    \x04\xcd\x01\x01\x12\x04\xdb\x0f\x08\x10\n\r\n\x05\x04\xcd\x01\x02\0\x12\
    \x04\xdc\x0f\x04\x1d\n\x0e\n\x06\x04\xcd\x01\x02\0\x05\x12\x04\xdc\x0f\
    \x04\n\n\x0e\n\x06\x04\xcd\x01\x02\0\x01\x12\x04\xdc\x0f\x0b\x18\n\x0e\n\
    \x06\x04\xcd\x01\x02\0\x03\x12\x04\xdc\x0f\x1b\x1c\n\r\n\x03\x04\xce\x01\
    \x12\x06\xdf\x0f\0\xe6\x0f\x01\n\x0c\n\x04\x04\xce\x01\x01\x12\x04\xdf\
    \x0f\x08\x15\n\r\n\x05\x04\xce\x01\x02\0\x12\x04\xe0\x0f\x04\x14\n\x0e\n\
    \x06\x04\xce\x01\x02\0\x05\x12\x04\xe0\x0f\x04\n\n\x0e\n\x06\x04\xce\x01\
    \x02\0\x01\x12\x04\xe0\x0f\x0b\x0f\n\x0e\n\x06\x04\xce\x01\x02\0\x03\x12\
    \x04\xe0\x0f\x12\x13\n\r\n\x05\x04\xce\x01\x02\x01\x12\x04\xe1\x0f\x04\
    \x14\n\x0e\n\x06\x04\xce\x01\x02\x01\x05\x12\x04\xe1\x0f\x04\n\n\x0e\n\
    \x06\x04\xce\x01\x02\x01\x01\x12\x04\xe1\x0f\x0b\x0f\n\x0e\n\x06\x04\xce\
    \x01\x02\x01\x03\x12\x04\xe1\x0f\x12\x13\n\x0f\n\x05\x04\xce\x01\x08\0\
    \x12\x06\xe2\x0f\x04\xe5\x0f\x05\n\x0e\n\x06\x04\xce\x01\x08\0\x01\x12\
    \x04\xe2\x0f\n\x11\n\r\n\x05\x04\xce\x01\x02\x02\x12\x04\xe3\x0f\x08+\n\
    \x0e\n\x06\x04\xce\x01\x02\x02\x06\x12\x04\xe3\x0f\x08\x16\n\x0e\n\x06\
    \x04\xce\x01\x02\x02\x01\x12\x04\xe3\x0f\x17&\n\x0e\n\x06\x04\xce\x01\
    \x02\x02\x03\x12\x04\xe3\x0f)*\n\r\n\x05\x04\xce\x01\x02\x03\x12\x04\xe4\
    \x0f\x08'\n\x0e\n\x06\x04\xce\x01\x02\x03\x06\x12\x04\xe4\x0f\x08\x14\n\
    \x0e\n\x06\x04\xce\x01\x02\x03\x01\x12\x04\xe4\x0f\x15\"\n\x0e\n\x06\x04\
    \xce\x01\x02\x03\x03\x12\x04\xe4\x0f%&\n\r\n\x03\x04\xcf\x01\x12\x06\xe8\
    \x0f\0\xea\x0f\x01\n\x0c\n\x04\x04\xcf\x01\x01\x12\x04\xe8\x0f\x08\x16\n\
    \r\n\x05\x04\xcf\x01\x02\0\x12\x04\xe9\x0f\x04\x16\n\x0e\n\x06\x04\xcf\
    \x01\x02\0\x05\x12\x04\xe9\x0f\x04\x08\n\x0e\n\x06\x04\xcf\x01\x02\0\x01\
    \x12\x04\xe9\x0f\t\x11\n\x0e\n\x06\x04\xcf\x01\x02\0\x03\x12\x04\xe9\x0f\
    \x14\x15\n\r\n\x03\x04\xd0\x01\x12\x06\xec\x0f\0\xee\x0f\x01\n\x0c\n\x04\
    \x04\xd0\x01\x01\x12\x04\xec\x0f\x08\x14\n\r\n\x05\x04\xd0\x01\x02\0\x12\
    \x04\xed\x0f\x04\x1a\n\x0e\n\x06\x04\xd0\x01\x02\0\x06\x12\x04\xed\x0f\
    \x04\x0c\n\x0e\n\x06\x04\xd0\x01\x02\0\x01\x12\x04\xed\x0f\r\x15\n\x0e\n\
    \x06\x04\xd0\x01\x02\0\x03\x12\x04\xed\x0f\x18\x19\n\r\n\x03\x04\xd1\x01\
    \x12\x06\xf0\x0f\0\xf4\x0f\x01\n\x0c\n\x04\x04\xd1\x01\x01\x12\x04\xf0\
    \x0f\x08\x0f\n\r\n\x05\x04\xd1\x01\x02\0\x12\x04\xf1\x0f\x04\x14\n\x0e\n\
    \x06\x04\xd1\x01\x02\0\x05\x12\x04\xf1\x0f\x04\n\n\x0e\n\x06\x04\xd1\x01\
    \x02\0\x01\x12\x04\xf1\x0f\x0b\x0f\n\x0e\n\x06\x04\xd1\x01\x02\0\x03\x12\
    \x04\xf1\x0f\x12\x13\n\r\n\x05\x04\xd1\x01\x02\x01\x12\x04\xf2\x0f\x04\
    \x14\n\x0e\n\x06\x04\xd1\x01\x02\x01\x05\x12\x04\xf2\x0f\x04\n\n\x0e\n\
    \x06\x04\xd1\x01\x02\x01\x01\x12\x04\xf2\x0f\x0b\x0f\n\x0e\n\x06\x04\xd1\
    \x01\x02\x01\x03\x12\x04\xf2\x0f\x12\x13\n\r\n\x05\x04\xd1\x01\x02\x02\
    \x12\x04\xf3\x0f\x04\x16\n\x0e\n\x06\x04\xd1\x01\x02\x02\x06\x12\x04\xf3\
    \x0f\x04\n\n\x0e\n\x06\x04\xd1\x01\x02\x02\x01\x12\x04\xf3\x0f\x0b\x11\n\
    \x0e\n\x06\x04\xd1\x01\x02\x02\x03\x12\x04\xf3\x0f\x14\x15\n\r\n\x03\x04\
    \xd2\x01\x12\x06\xf6\x0f\0\xf9\x0f\x01\n\x0c\n\x04\x04\xd2\x01\x01\x12\
    \x04\xf6\x0f\x08\x0e\n\r\n\x05\x04\xd2\x01\x02\0\x12\x04\xf7\x0f\x04\x14\
    \n\x0e\n\x06\x04\xd2\x01\x02\0\x05\x12\x04\xf7\x0f\x04\n\n\x0e\n\x06\x04\
    \xd2\x01\x02\0\x01\x12\x04\xf7\x0f\x0b\x0f\n\x0e\n\x06\x04\xd2\x01\x02\0\
    \x03\x12\x04\xf7\x0f\x12\x13\n\r\n\x05\x04\xd2\x01\x02\x01\x12\x04\xf8\
    \x0f\x04\x14\n\x0e\n\x06\x04\xd2\x01\x02\x01\x05\x12\x04\xf8\x0f\x04\n\n\
    \x0e\n\x06\x04\xd2\x01\x02\x01\x01\x12\x04\xf8\x0f\x0b\x0f\n\x0e\n\x06\
    \x04\xd2\x01\x02\x01\x03\x12\x04\xf8\x0f\x12\x13\n\xd3\x01\n\x03\x04\xd3\
    \x01\x12\x06\xff\x0f\0\x83\x10\x012\xc3\x01/////////////////////////////\
    ////////////////////////////////////////////////////////////\n\x20Notifi\
    cations\n///////////////////////////////////////////////////////////////\
    //////////////////////////\n\n\x0c\n\x04\x04\xd3\x01\x01\x12\x04\xff\x0f\
    \x08\x18\n\r\n\x05\x04\xd3\x01\x02\0\x12\x04\x80\x10\x04\x1c\n\x0e\n\x06\
    \x04\xd3\x01\x02\0\x05\x12\x04\x80\x10\x04\n\n\x0e\n\x06\x04\xd3\x01\x02\
    \0\x01\x12\x04\x80\x10\x0b\x17\n\x0e\n\x06\x04\xd3\x01\x02\0\x03\x12\x04\
    \x80\x10\x1a\x1b\n\r\n\x05\x04\xd3\x01\x02\x01\x12\x04\x81\x10\x04\x13\n\
    \x0e\n\x06\x04\xd3\x01\x02\x01\x05\x12\x04\x81\x10\x04\t\n\x0e\n\x06\x04\
    \xd3\x01\x02\x01\x01\x12\x04\x81\x10\n\x0e\n\x0e\n\x06\x04\xd3\x01\x02\
    \x01\x03\x12\x04\x81\x10\x11\x12\n\r\n\x05\x04\xd3\x01\x02\x02\x12\x04\
    \x82\x10\x04\x12\n\x0e\n\x06\x04\xd3\x01\x02\x02\x05\x12\x04\x82\x10\x04\
    \t\n\x0e\n\x06\x04\xd3\x01\x02\x02\x01\x12\x04\x82\x10\n\r\n\x0e\n\x06\
    \x04\xd3\x01\x02\x02\x03\x12\x04\x82\x10\x10\x11\n\r\n\x03\x04\xd4\x01\
    \x12\x06\x85\x10\0\x8a\x10\x01\n\x0c\n\x04\x04\xd4\x01\x01\x12\x04\x85\
    \x10\x08\x19\n\r\n\x05\x04\xd4\x01\x02\0\x12\x04\x86\x10\x04'\n\x0e\n\
    \x06\x04\xd4\x01\x02\0\x06\x12\x04\x86\x10\x04\x12\n\x0e\n\x06\x04\xd4\
    \x01\x02\0\x01\x12\x04\x86\x10\x13\"\n\x0e\n\x06\x04\xd4\x01\x02\0\x03\
    \x12\x04\x86\x10%&\n\r\n\x05\x04\xd4\x01\x02\x01\x12\x04\x87\x10\x04\x1c\
    \n\x0e\n\x06\x04\xd4\x01\x02\x01\x05\x12\x04\x87\x10\x04\t\n\x0e\n\x06\
    \x04\xd4\x01\x02\x01\x01\x12\x04\x87\x10\n\x17\n\x0e\n\x06\x04\xd4\x01\
    \x02\x01\x03\x12\x04\x87\x10\x1a\x1b\n\r\n\x05\x04\xd4\x01\x02\x02\x12\
    \x04\x88\x10\x04\x1a\n\x0e\n\x06\x04\xd4\x01\x02\x02\x05\x12\x04\x88\x10\
    \x04\x08\n\x0e\n\x06\x04\xd4\x01\x02\x02\x01\x12\x04\x88\x10\t\x15\n\x0e\
    \n\x06\x04\xd4\x01\x02\x02\x03\x12\x04\x88\x10\x18\x19\n\r\n\x05\x04\xd4\
    \x01\x02\x03\x12\x04\x89\x10\x04\"\n\x0e\n\x06\x04\xd4\x01\x02\x03\x04\
    \x12\x04\x89\x10\x04\x0c\n\x0e\n\x06\x04\xd4\x01\x02\x03\x05\x12\x04\x89\
    \x10\r\x13\n\x0e\n\x06\x04\xd4\x01\x02\x03\x01\x12\x04\x89\x10\x14\x1d\n\
    \x0e\n\x06\x04\xd4\x01\x02\x03\x03\x12\x04\x89\x10\x20!\n\xca\x01\n\x03\
    \x04\xd5\x01\x12\x06\x90\x10\0\x94\x10\x012\xba\x01/////////////////////\
    ////////////////////////////////////////////////////////////////////\n\
    \x20Mock\n//////////////////////////////////////////////////////////////\
    ///////////////////////////\n\n\x0c\n\x04\x04\xd5\x01\x01\x12\x04\x90\
    \x10\x08\x1a\n\r\n\x05\x04\xd5\x01\x02\0\x12\x04\x91\x10\x04\x17\n\x0e\n\
    \x06\x04\xd5\x01\x02\0\x05\x12\x04\x91\x10\x04\n\n\x0e\n\x06\x04\xd5\x01\
    \x02\0\x01\x12\x04\x91\x10\x0b\x12\n\x0e\n\x06\x04\xd5\x01\x02\0\x03\x12\
    \x04\x91\x10\x15\x16\n\r\n\x05\x04\xd5\x01\x02\x01\x12\x04\x92\x10\x04(\
    \n\x0e\n\x06\x04\xd5\x01\x02\x01\x06\x12\x04\x92\x10\x04\x0f\n\x0e\n\x06\
    \x04\xd5\x01\x02\x01\x01\x12\x04\x92\x10\x10#\n\x0e\n\x06\x04\xd5\x01\
    \x02\x01\x03\x12\x04\x92\x10&'\n\r\n\x05\x04\xd5\x01\x02\x02\x12\x04\x93\
    \x10\x04\x13\n\x0e\n\x06\x04\xd5\x01\x02\x02\x05\x12\x04\x93\x10\x04\n\n\
    \x0e\n\x06\x04\xd5\x01\x02\x02\x01\x12\x04\x93\x10\x0b\x0e\n\x0e\n\x06\
    \x04\xd5\x01\x02\x02\x03\x12\x04\x93\x10\x11\x12\n\r\n\x03\x04\xd6\x01\
    \x12\x06\x96\x10\0\x99\x10\x01\n\x0c\n\x04\x04\xd6\x01\x01\x12\x04\x96\
    \x10\x08\x13\n\r\n\x05\x04\xd6\x01\x02\0\x12\x04\x97\x10\x04\x1f\n\x0e\n\
    \x06\x04\xd6\x01\x02\0\x05\x12\x04\x97\x10\x04\n\n\x0e\n\x06\x04\xd6\x01\
    \x02\0\x01\x12\x04\x97\x10\x0b\x1a\n\x0e\n\x06\x04\xd6\x01\x02\0\x03\x12\
    \x04\x97\x10\x1d\x1e\n\r\n\x05\x04\xd6\x01\x02\x01\x12\x04\x98\x10\x04\
    \x17\n\x0e\n\x06\x04\xd6\x01\x02\x01\x05\x12\x04\x98\x10\x04\n\n\x0e\n\
    \x06\x04\xd6\x01\x02\x01\x01\x12\x04\x98\x10\x0b\x12\n\x0e\n\x06\x04\xd6\
    \x01\x02\x01\x03\x12\x04\x98\x10\x15\x16b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<
    ::protobuf::descriptor::FileDescriptorProto,
> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe { file_descriptor_proto_lazy.get(|| parse_descriptor_proto()) }
}
